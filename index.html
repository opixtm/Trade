 <!DOCTYPE html>
<html lang="id" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate CEX_DEX</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF7;
            color: #342d27;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .card {
            background-color: #FFFFFF;
            border: 1px solid #EAE5E0;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            transition: all 0.3s ease-in-out;
        }
        .btn-primary {
            background-color: #c97c00;
            color: #2b2a28;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary:hover { background-color: #eb9413 }
        .btn-primary:disabled { background-color: #333333; cursor: not-allowed; }
        .input-primary {
            background-color: #F8F5F1;
            border: 1px solid #DCD6CF;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #3D352E;
        }
        .input-primary:focus {
            outline: none;
            border-color: #747462;
            box-shadow: 0 0 0 2px rgba(34, 55, 40, 0.2);
        }
        .tag { padding: 0.25rem 0.625rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; }
        .tag-green { background-color: #E6F4EA; color: #4A7C59; }
        .tag-red { background-color: #FCE8E8; color: #A83A3A; }
        .tag-yellow { background-color: #FFF8E1; color: #B5840F; }
        .tag-gray { background-color: #F1F3F4; color: #5F6368; }

        /* Dark Mode Styles */
        .dark body { background-color: #000000; color: #E0E0E0; }
        .dark .card { background-color: #151414; border-color: #333; }
        .dark .input-primary { background-color: #1c1b1b; border-color: #444; color: #E0E0E0; }
        .dark .input-primary:focus { border-color: #2b2d2b; box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.3); }
        .dark .tag-green { background-color: rgba(74, 124, 89, 0.2); color: #69b37f; }
        .dark .tag-red { background-color: rgba(168, 58, 58, 0.2); color: #d17474; }
        .dark .tag-yellow { background-color: rgba(181, 132, 15, 0.2); color: #e0c273; }
        .dark .tag-gray { background-color: rgba(95, 99, 104, 0.2); color: #9aa0a6; }
        .dark .text-gray-800 { color: #E0E0E0; }
        .dark .text-gray-500 { color: #d8d2d2; }
        .dark .text-gray-600 { color: #dddddd; }
        .dark .text-gray-700 { color: #e0e0e0; }
        .dark hr { border-color: #3e4946; }
        .dark .positive { color: #69b37f; }
        .dark .negative { color: #d17474; }

        /* Chart Container Styles */
        .chart-container { position: relative; width: 100%; }
        #main-chart-container { height: 450px; }
        .pane-chart-container { height: 150px; margin-top: 8px; border-top: 1px solid rgba(128, 128, 128, 0.2); padding-top: 8px;}
        .pane-title { position: absolute; top: 15px; left: 15px; z-index: 10; font-size: 12px; font-weight: bold; color: #dddddd; }
        .dark .pane-title { color: #d9d5d5; }

        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px; 
        }

        .dot {
            width: 14px;
            height: 14px;
            background-color: #e1e1e1; 
            border-radius: 50%;
            animation: bounce 1.0s infinite ease-in-out both;
        }

        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1.5);
            }
        }
        
        .positive { color: #16a34a; }
        .dark .positive { color: #4ade80; }
        .negative { color: #dc2626; }
        .dark .negative { color: #f87171; }
        .blinking-text-animation { animation: blinking-text 1.0s infinite; }
        @keyframes blinking-text { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        #button-loader .dot {
            width: 8px;
            height: 8px;
        }

        /* Style untuk tombol toggle indikator */
        .toggle-btn {
            background-color: #E7A13B;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #d1d5db;
        }
        .toggle-btn:hover {
            background-color: #d1d5db;
        }
        .toggle-btn.active {
            background-color: #1755c6;
            color: #121010;
            border-color: #1c295c;
        }
        .dark .toggle-btn {
            background-color: #1c1b1b;
            color: #d1d5db;
            border-color: #444;
        }
        .dark .toggle-btn:hover {
            background-color: #444;
        }
        .dark .toggle-btn.active {
            background-color: #4f3e01;
            color: #ffffff;
            border-color: #4A7C59;
        }
        .projection-results-container .card {
            background-color: #1c1b1b;
            border-color: #444;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .projection-results-container h4 {
            font-size: 1rem;
            color: #008c38;
        }
        .projection-results-container p {
            color: #e0e0e0;
        }
        .btn-yellow {
            background-color: #f59e0b; 
            color: #1f2937; 
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-yellow:hover {
            background-color: #d97706;
        }
        .dark .btn-yellow {
            color: #120f0f;
        }
        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }
        #trade-link:hover {
            text-decoration: none;
        }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (MULAI) === */
        .status-uptrend { color: #34d399; }
        .dark .status-uptrend { color: #4ade80; }
        .status-downtrend { color: #ef4444; }
        .dark .status-downtrend { color: #f87171; }
        .status-chop { color: #fbbf24; }
        .dark .status-chop { color: #fcd34d; }

        .confluence-bar-container {
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            height: 30px;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .dark .confluence-bar-container { background-color: #374151; }

        .confluence-bar {
            height: 100%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
            color: #111827;
        }

        .confluence-bar-bullish { background: linear-gradient(to right, #22c55e, #86efac); }
        .confluence-bar-bearish { background: linear-gradient(to right, #ef4444, #fca5a5); }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (SELESAI) === */
        .dark .btn-yellow {
            color: #120f0f;
        }
        /* === TAMBAHKAN BLOK CSS DI BAWAH INI === */
        .btn-secondary {
            background-color: #ff1869; /* gray-500 */
            color: #070707;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-secondary:hover {
            background-color: #ff0a0a; /* gray-600 */
        }
        .dark .btn-secondary {
            background-color: #bb3103; /* gray-600 */
        }
        .dark .btn-secondary:hover {
            background-color: #a21000; /* gray-700 */
        }
     /* === CSS BARU UNTUK SINKRONISASI LEBAR SUMBU HARGA (MULAI) === */
        .chart-container table td:last-child {
            /* Memaksa kolom terakhir (sumbu harga) memiliki lebar 80px */
            width: 80px !important; 
        }
        .chart-container table td:first-child {
            /* Memastikan kolom utama (area chart) mengisi sisa ruang */
            width: calc(100% - 80px) !important;
        }
        
        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dashed rgba(128, 128, 128, 0.5);
        }

        #custom-tooltip {
            position: absolute;
            background-color: #141517; /* dark:bg-gray-800 */
            color: #e2e8f0; /* dark:text-gray-200 */
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #e48005; /* dark:border-gray-600 */
            font-size: 0.875rem;
            line-height: 1.5;
            z-index: 100;
            max-width: 320px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }

        #custom-tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: #2d3748 transparent transparent transparent;
        }

        #custom-tooltip strong {
            color: #63b3ed; /* dark:text-blue-400 */
            display: block;
            margin-bottom: 4px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 4px;
        }

        #ai-narrative-content .prose h3 {
            margin-top: 1.25rem; /* Beri jarak di atas setiap judul (###) */
            margin-bottom: 0.5rem;
        }

        #ai-narrative-content .prose ul {
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        #ai-narrative-content .prose li {
            margin-bottom: 0.5rem; /* Beri jarak antar poin-poin (*) */
        }
        .vwap-mode-btn {
            background-color: #4a5568; /* gray-600 */
            color: #e2e8f0; /* gray-200 */
            border: 1px solid #718096; /* gray-500 */
            opacity: 0.6;
        }
        .vwap-mode-btn.active {
            background-color: #f59e0b; /* yellow-500 */
            color: #1f2937; /* gray-800 */
            opacity: 1;
            font-weight: bold;
        }
        .hybrid-bar {
            background-color: #2d3748;
            border-radius: 4px;
            height: 12px;
            width: 100px;
            position: relative;
            overflow: hidden;
            border: 1px solid #4a5568;
        }
        .pump-strength {
            background-color: #48bb78;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }
        .dump-risk {
            background-color: #f56565;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }
        /* === CSS BARU UNTUK SKOR TENSI (MULAI) === */
        .tension-bar-bg {
            background-color: #374151; /* dark:bg-gray-700 */
            border-radius: 9999px;
            height: 8px;
            width: 100%;
            margin: 4px auto 0;
            overflow: hidden;
            border: 1px solid #4b5563;
        }
        .tension-bar-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
            background: linear-gradient(to right, #fcd34d, #f59e0b, #ef4444); /* yellow to orange to red */
        }
        /* === CSS BARU UNTUK SKOR TENSI (SELESAI) === */
    </style>
</head>
<body class="antialiased">

    <div id="sticky-nav-wrapper" class="sticky top-0 z-50 bg-[#FDFBF7]/80 dark:bg-[#121212]/80 backdrop-blur-lg border-b border-gray-200/50 dark:border-gray-700/50 shadow-sm">
        <div class="flex items-center justify-between py-2 px-4 sm:px-6 lg:px-8">
            <div class="flex items-center gap-3">
                <a href="https://copilot.page.gd/" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-lg transition-colors duration-300 text-sm">🏠</a>               
                <div id="nav-info-container" class="items-center gap-2 hidden md:flex">
                    <div class="flex flex-col">
                        <span id="nav-symbol" class="text-base font-bold text-yellow-500 dark:text-yellow-500"></span>
                        <div class="font-mono text-[10px]">
                            <span class="text-gray-400">VOL 24H:</span>
                            <span id="nav-volume-24h" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                    </div>
                    <div class="flex flex-col text-left text-xs">
                        <span id="nav-change-24h" class="font-semibold positive">-</span>
                        <span id="nav-change-1h" class="font-semibold positive">-</span>
                    </div>
                </div>
            </div>

            <div id="nav-stats-container" class="items-center gap-4 font-mono text-[10px] hidden md:flex">
                <div class="flex flex-col text-left">
                    <div>
                        <span class="text-gray-400">ATH:</span>
                        <span id="nav-ath" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                    </div>
                    <div>
                        <span class="text-gray-400">ATL:</span>
                        <span id="nav-atl" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                    </div>
                </div>
            </div>
            
            <a href="#" id="trade-link" class="text-right no-underline hidden">
                <span id="nav-price" class="text-yellow-500 text-lg">-</span>
                <span id="nav-price-idr" class="block text-[10px] text-gray-400"></span>
            </a>
        </div>
    </div>

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <header class="py-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-gray-800">ULTIMATE 🤑 FINAL</h1>
                <p class="text-yellow-500 font-mono mt-1 text-sm">PATTERN FORMULA</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none">
                <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8 0 1010.586 10.586z"></path></svg>
                <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414 1.414zM-.707 7.072l.707-.707a1 1 0 10-1.414-1.414l-.707.707a1 1 0 001.414 1.414zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z"></path></svg>
            </button>
        </header>
        <main>
            <div class="space-y-6 mb-8">
                <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                    <div>
                        <input type="password" id="gemini-api-key" class="input-primary" placeholder="Tempel API Key dari Google AI Studio...">
                        <p class="text-sm text-gray-400 mt-1">API 🔑 <a href="https://aistudio.google.com/app/apikey" target="_blank" class="underline hover:text-blue-500">GET KEY 👆🏻</a>.</p>
                    </div>
                    
                </section>
                <section id="settings-card" class="card p-4">
                    <button id="toggle-settings-btn" class="w-full flex justify-between items-center text-left">
                        <h2 class="text-lg font-bold">Indicators Settings</h2>
                        <svg id="toggle-settings-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>                                
                    </button>
                    <div id="settings-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Parameter Indikator</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between"><label for="setting-rsi-period" class="text-gray-500">Periode RSI</label><input type="number" id="setting-rsi-period" class="input-primary !w-20 text-center" value="14"></div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-stoch-rsi-period" class="text-gray-500">Stoch RSI (RSI/Stoch/K/D)</label>
                                            <div class="flex gap-1">
                                                <input type="number" id="setting-stoch-rsi-period" class="input-primary !w-12 text-center" value="14">
                                                <input type="number" id="setting-stoch-stoch-period" class="input-primary !w-12 text-center" value="14">
                                                <input type="number" id="setting-stoch-k-smooth" class="input-primary !w-12 text-center" value="3">
                                                <input type="number" id="setting-stoch-d-smooth" class="input-primary !w-12 text-center" value="3">
                                            </div>
                                        </div>
                                        <div class="flex items-center justify-between"><label for="setting-macd-fast" class="text-gray-500">MACD Fast/Slow/Signal</label><div class="flex gap-1"><input type="number" id="setting-macd-fast" class="input-primary !w-16 text-center" value="12"><input type="number" id="setting-macd-slow" class="input-primary !w-16 text-center" value="26"><input type="number" id="setting-macd-signal" class="input-primary !w-16 text-center" value="9"></div></div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-weight-obv-divergence" class="text-gray-500">Bobot Divergensi OBV</label>
                                            <input type="number" step="0.1" id="setting-weight-obv-divergence" class="input-primary !w-20 text-center" value="3.0">
                                        </div>
                                    </div>
                                </div>
                                
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Bobot Skor Konfluensi</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between"><label for="setting-weight-divergence" class="text-gray-500">Bobot Divergensi RSI</label><input type="number" step="0.1" id="setting-weight-divergence" class="input-primary !w-20 text-center" value="2.5"></div>
                                        <div class="flex items-center justify-between"><label for="setting-weight-macd" class="text-gray-500">Bobot MACD Cross</label><input type="number" step="0.1" id="setting-weight-macd" class="input-primary !w-20 text-center" value="2.0"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                                <div class="flex items-center justify-between">
                                    <label for="preset-select" class="font-semibold text-gray-700 dark:text-gray-300">📈 Preset Trader</label>
                                    <select id="preset-select" class="input-primary !w-auto text-sm">
                                        <option value="default">Default</option>
                                        <option value="scalper">Scalper</option>
                                        <option value="dayTrader">Day Trader</option>
                                        <option value="swingTrader">Swing Trader</option>
                                    </select>
                                </div>
                            </div>
                            <div class="text-right mt-4"><button id="save-settings-btn" class="btn-primary">💾 Simpan</button></div>
                            <p id="settings-saved-msg" class="text-green-500 text-sm mt-2 text-center hidden">Pengaturan disimpan!</p>
                        </div>
                    </div>
                </section>
                <section id="watchlist-section" class="card p-6">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
                        <h2 class="text-base font-senibold">📈 Watchlist</h2>
                        <div class="w-full sm:w-auto flex items-center gap-2">
                            <input type="text" id="watchlist-input" class="input-primary text-sm flex-grow uppercase" placeholder="BTCUSDT, ETHUSDT, SOLUSDT...">
                            <button id="save-watchlist-btn" class="btn-primary !p-2" title="Simpan Watchlist">💾</button>
                        </div>
                    </div>
                    <button id="scan-watchlist-btn" class="btn-yellow w-full mb-4">
                        <span>🔍 Watchlist</span>
                        <div class="loader w-5 h-5 hidden"></div>
                    </button>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                            <thead class="bg-gray-50 dark:bg-gray-800">
                                <tr>
                                    <th scope="col" ...>Aset</th>
                                    <th scope="col" ...>Harga</th>
                                    <th scope="col" ...>𝌡 24J </th>
                                </tr>
                            </thead>
                            <tbody id="watchlist-results-body" ...>
                                <tr>
                                    <td colspan="3" ...>Jalankan pemindaian untuk melihat hasil.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>
                
                
                <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                    <div>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <input type="text" id="asset-input" list="asset-list" class="input-primary text-sm flex-grow uppercase" placeholder="Ketik Simbol Aset (cth: BTCUSDT)" value="BTCUSDT">
                            <datalist id="asset-list"></datalist>
                            <select id="market-type-select" class="input-primary text-sm !w-auto">
                                <option value="spot">Spot</option>
                                <option value="futures" selected>Perp</option>
                            </select>
                            <select id="timeframe-select" class="input-primary text-sm !w-auto">
                                <option value="1m">1m</option><option value="3m">3m</option><option value="5m"selected>5m</option><option value="15m">15m</option><option value="30m">30m</option><option value="1h">1h</option><option value="2h">2h</option><option value="4h">4h</option><option value="1d">1d</option><option value="1w">W</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="md:col-span-2 flex gap-4">
                         <button id="analyze-asset-btn" class="btn-primary w-full font-bold text-xl">
                            <span id="button-text">GET DATA</span>
                            <div id="button-loader" class="loader hidden">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                        </button>
                        <p id="asset-error" class="text-red-600 text-sm mt-2 text-center hidden"></p>
                        <button id="reset-btn" class="btn-secondary !w-auto">REFRESH</button>
                    </div>
                </section>
                <section id="top-movers-section" class="card p-6">
                    <div class="flex justify-between items-center mb-4">
                    <h2 class="text-base font-semibold">Pump & Dump Strength</h2>
                    <div id="top-movers-controls" class="flex gap-4 items-center">
                    <div id="top-movers-timeframe-selector" class="flex gap-2">
                    <button data-timeframe="5m" class="top-movers-tf-btn px-2 py-1 text-xs font-mono rounded-md">5m</button>
                    <button data-timeframe="15m" class="top-movers-tf-btn px-2 py-1 text-xs font-mono rounded-md">15m</button>
                    <button data-timeframe="1h" class="top-movers-tf-btn px-2 py-1 text-xs font-mono rounded-md active">1H</button>
                </div>
                <div class="flex gap-2 items-center">
                    <select id="refresh-interval-select" class="input-primary text-xs !w-auto !p-1">
                        <option value="5000">5s</option>
                        <option value="10000">10s</option>
                        <option value="30000">30s</option>
                        <option value="60000">60s</option>
                        <option value="120000" selected>120s</option>
                    </select>
                    <span id="refresh-countdown" class="text-xs text-gray-500 w-24 text-center"></span>
                </div>
            </div>
        </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h3 class="text-sm font-semibold text-gray-400 mb-2">🟢 Gainers</h3>
                            <div id="gainers-list" class="space-y-2"></div>
                        </div>
                        <div>
                            <h3 class="text-sm font-semibold text-gray-400 mb-2">🔴 Losers</h3>
                            <div id="losers-list" class="space-y-2"></div>
                        </div>
                    </div>
                </section>
            </div>

            <div id="dashboard-content" class="hidden">
                <div class="space-y-8">
                    <button id="toggle-charts-btn" class="btn-yellow w-full">SHOW CHART</button>
                    <section id="charts-wrapper" class="card p-6" style="display: none;">
                        <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                        <div class="chart-container relative"><div class="pane-title">Price</div><div id="main-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">Volume</div>
                            <div id="volume-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">RSI (14)</div><div id="rsi-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">Stochastic RSI</div><div id="stoch-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">MACD</div>
                            <div id="macd-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">Rate of Change (ROC)</div><div id="roc-chart-container"></div></div>
                    </section>
                    
                    
<div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:items-start">
    <div class="flex flex-col gap-4">
        <section id="scalping-setup-section" class="card p-6">
            <button id="toggle-scalping-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-xl font-bold">⚡ Setup Scalping Cepat (<span id="scalping-timeframe-display"></span>)</h2>
                <svg id="toggle-scalping-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
            </button>
            <div id="hybrid-breakdown-module" class="mb-4">
                <div class="flex items-center justify-between text-xs text-gray-400">
                    <span>Kekuatan Pump</span>
                    <span>Potensi Dump</span>
                </div>
                <div class="confluence-bar-container w-full h-8 mt-1">
                    <div id="main-pump-bar" class="confluence-bar confluence-bar-bullish" style="width: 0%;"></div>
                    <div id="main-dump-bar" class="confluence-bar confluence-bar-bearish" style="width: 0%;"></div>
                </div>
                <div class="flex items-center justify-between text-sm mt-1">
                    <span id="main-pump-score" class="positive font-bold">0%</span>
                    <span id="main-dump-score" class="negative font-bold">0/10</span>
                </div>
                <details class="mt-3">
                    <summary class="cursor-pointer text-sm text-gray-400 hover:text-white transition-colors">
                        Lihat Rincian Trigger Potensi Dump ▾
                    </summary>
                    <div id="trigger-breakdown-list" class="mt-2 pt-2 border-t border-gray-700/50 text-sm space-y-1">
                        <p class="text-xs text-center text-gray-600">Memuat rincian...</p>
                    </div>
                </details>
            </div>
            <div id="scalping-content-wrapper" class="collapsible-content">
                <div>
                    <div id="futures-data-container" class="hidden space-y-1 text-sm">
                        <div class="flex justify-between items-center"><span class="text-gray-500">Open Interest</span><span id="open-interest">-</span></div>
                        <div class="flex justify-between items-center"><span class="text-yellow-500">Funding Rate</span><span id="funding-rate" class="font-mono text-yellow-500">-</span></div>
                        <div class="flex justify-between items-center"><span class="text-gray-500">Funding Interval</span><span id="funding-rate-interval" class="font-mono">-</span></div>
                    </div>
                    <div id="ls-umum-container" class="flex justify-between items-center text-sm"><span class="text-gray-500">L/S Ratio (Umum)</span><span id="ls-ratio-umum" class="font-mono">-</span></div>
                    <div id="ls-top-container" class="flex justify-between items-center text-sm"><span class="text-gray-500">L/S Ratio (Top Trader)</span><span id="ls-ratio-top" class="font-mono">-</span></div>
                    <div class="flex justify-between items-start text-sm mt-1">
                        <div>
                            <span class="text-gray-500 text-sm">Average True Range</span>
                            <span id="atr-status-badge" class="tag tag-gray ml-2">...</span>
                        </div>
                        <div class="text-right">
                            <p id="atr-percent-value" class="font-mono text-blue-500 font-semibold">-</p>
                            <p id="atr-absolute-value" class="font-mono text-xs text-gray-400">-</p>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500 text-sm" data-tooltip="Kekuatan Tren (ADX)|Mengukur KEKUATAN sebuah tren, bukan arahnya.<br><br><b>Kondisi:</b><br>• <b>0-25:</b> Tren Lemah / Sideways.<br>• <b>25-50:</b> Tren Kuat.<br>• <b>50-75:</b> Tren Sangat Kuat.<br>• <b>75-100:</b> Tren Ekstrem.">Kekuatan Tren (ADX 14)</span>
                        <div>
                            <span id="adx-value" class="font-mono font-semibold text-sm">-</span>
                            <span class="text-xs positive" id="plus-di-value"></span> /
                            <span class="text-xs negative" id="minus-di-value"></span>
                        </div>
                    </div>
                    
                    <div id="scalping-resistance-info" class="flex justify-between items-center text-sm pt-2 mt-2 border-t border-dashed border-gray-700/50">
                        <span class="text-gray-500">Resistance Terdekat</span>
                        <span class="font-mono font-semibold text-red-400">-</span>
                    </div>
                    <div id="scalping-wall-info" class="text-center text-xs pt-2 text-gray-400">
                        </div>
                    
                    <div id="scalping-setup-content" class="text-center mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                        <p class="text-sm text-gray-500">Menunggu data...</p>
                    </div>
                </div>
            </div>
        </section>
        <section id="current-state-section" class="card p-6">
            <button id="toggle-market-state-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 id="current-state-title" class="text-xl font-semibold">Kondisi Pasar (CEX)</h2>
                                    <svg id="toggle-market-state-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="current-state-content-wrapper" class="collapsible-content expanded">
                                    <div class="space-y-6">
                                        <h2 class="text-lg font-semibold text-center">Timeframe <span id="quick-confluence-timeframe">15m</span></h2>
                                        <div class="flex items-center gap-4 my-2">
                                            <div id="quick-finalBearishScore" class="text-2xl font-bold status-downtrend text-right w-1/5">🐻 0%</div>
                                            <div class="confluence-bar-container w-3/5">
                                                <div id="quick-confluenceBarBearish" class="confluence-bar confluence-bar-bearish" style="width: 50%;"></div>
                                                <div id="quick-confluenceBarBullish" class="confluence-bar confluence-bar-bullish" style="width: 50%;"></div>
                                            </div>
                                            <div id="quick-finalBullishScore" class="text-2xl font-bold status-uptrend text-left w-1/5">0% 🐂</div>
                                        </div>
                                        <div id="verdict-container" class="text-center">
                                            <p id="quick-finalVerdict" class="font-semibold"></p>
                                            <div id="tension-score-container" class="mt-3 text-xs">
                                                </div>
                                        </div>

                                        <div id="confluence-breakdown-container" class="mt-4 text-xs text-center space-y-2 hidden">
                                            <div class="grid grid-cols-2 gap-2 text-left">
                                                <div id="top-bullish-contributors"></div>
                                                <div id="top-bearish-contributors"></div>
                                            </div>
                                            <div id="tf-alignment-summary" class="pt-2 border-t border-gray-200 dark:border-gray-700">
                                            </div>
                                        </div>
                                        <div class="space-y-2 pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                                <p class="text-sm text-gray-500">Pola Candlestick</p>
                                                <p id="candlestick-pattern" class="font-semibold">BELUM ADA</p>
                                            </div>
                                            <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                                <p id="chart-pattern-label" class="text-xs text-gray-500">Pola Chart</p>
                                                <p id="chart-pattern" class="font-semibold">BELUM ADA</p>
                                            </div>
                                        </div>
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h2 class="text-xl font-bold mb-4">Live Order Book</h2>
                                            <div id="full-order-book-container" class="space-y-2 text-sm"><p class="text-center text-gray-500">Menunggu data order book...</p></div>
                                            <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                <span class="text-gray-500">Order Book Bias</span><span id="order-book-bias" class="font-mono">-</span>
                                            </div>
                                        </div>
                                        
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h3 class="text-lg font-bold mb-4">CVD Order Flow</h3>
                                            <div class="chart-container" style="height: 150px;"><canvas id="cvdChart"></canvas></div>
                                        </div>
                                    </div>
                                </div>
            </section>
        <section id="sentiment-display-container" class="card p-6">
            <button id="toggle-sentiment-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 class="text-xl font-bold">🌡️ Sentimen Pasar BITCOIN (via AI)</h2>
                                    <svg id="toggle-sentiment-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="sentiment-content-wrapper" class="collapsible-content">
                                    <p class="text-center text-gray-500">Data Tambahan Sentimen via "AI" belum dimuat.</p>
                                </div>
            </section>
        <section id="risk-management-section" class="card p-6">
            <button id="toggle-risk-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 class="text-xl font-bold">📐 Manajemen Risiko</h2>
                                    <svg id="toggle-risk-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="risk-content-wrapper" class="collapsible-content">
                                    <div class="space-y-4 text-sm">
                                        <div class="grid grid-cols-2 gap-4">
                                            <div>
                                                <label for="risk-amount-input" class="text-gray-400">Risiko per Trade ($)</label>
                                                <input type="number" id="risk-amount-input" class="input-primary w-full text-center mt-1" value="100">
                                            </div>
                                            <div>
                                                <label for="leverage-input" class="text-gray-400">Leverage</label>
                                                <div class="relative">
                                                    <input type="number" id="leverage-input" class="input-primary w-full text-center mt-1 pr-6" value="10">
                                                    <span class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 text-xs">x</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-400">Rasio Risk/Reward (ke TP1)</span>
                                            <span id="rr-ratio-display" class="font-mono font-semibold text-yellow-400">-</span>
                                        </div>
                                        <div class="p-4 rounded-lg bg-gray-100 dark:bg-gray-800/50 text-center">
                                            <p class="text-xs text-gray-500">Saran Ukuran Posisi (Notional)</p>
                                            <p id="position-size-display" class="text-2xl font-bold text-gray-800 dark:text-gray-200">-</p>
                                            <p id="position-size-usd-display" class="text-xs font-mono text-gray-400">-</p>
                                        </div>
                                        <div class="p-4 rounded-lg bg-blue-100 dark:bg-blue-900/30 text-center border border-dashed border-blue-400/50">
                                            <p class="text-xs text-blue-400">Margin yang Dibutuhkan</p>
                                            <p id="margin-required-display" class="text-2xl font-bold text-blue-300">-</p>
                                        </div>
                                    </div>
                                </div>
            </section>
    </div>

    <div class="flex flex-col gap-3">
        <section id="confluence-details-section" class="card p-6">
            <button id="toggle-confluence-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 class="text-lg font-bold">📊 Data Timeframe <span id="confluence-timeframe-display">1H</span></h2>
                                    <svg id="toggle-confluence-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="confluence-content-wrapper" class="collapsible-content">
                                    <div>
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">🌍 Konteks Pasar & Tren Utama</h3>
                                            <div class="space-y-1 text-sm">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500">Korelasi vs. BTC (30 Hari)</span>
                                                    <div>
                                                        <span id="correlation-value" class="font-mono font-semibold text-gray-300">-</span>
                                                        <span id="correlation-text" class="text-xs text-gray-500 ml-1">...</span>
                                                    </div>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500">Dominasi BTC</span>
                                                    <span id="btc-dominance" class="font-mono">-</span>
                                                </div>
                                                <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                    <span class="text-gray-500">Market Cap</span>
                                                    <span id="market-cap" class="font-mono">-</span>
                                                </div>

                                                <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500">Tren (EMA 21/50)</span>
                                                        <span id="ma-status" class="font-mono font-semibold">-</span>
                                                    </div>
                                                    <div class="text-right text-xs text-gray-400 font-mono">
                                                        <span id="ema-21-value">-</span> / 
                                                        <span id="ema-50-value">-</span>
                                                    </div>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500" data-tooltip="Ichimoku Bias|Sistem tren komprehensif yang melihat momentum dan level S/R dinamis.<br><br><b>Kondisi:</b><br>• <b>Bullish:</b> Harga di atas Awan (Kumo).<br>• <b>Bearish:</b> Harga di bawah Awan (Kumo).<br>• <b>Netral:</b> Harga di dalam Awan (Kumo).">Ichimoku Bias</span>
                                                    <span id="ichimoku-bias" class="font-mono font-semibold">-</span>
                                                </div>
                                                
                                            </div>
                                        </div>

                                    <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">🎯 Area Penting & Level Kunci</h3>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between"><span class="text-red-500">Value Area High</span><span id="vpvr-vah" class="font-mono">-</span></div>
                                            <div class="flex justify-between"><span class="font-bold text-blue-500" data-tooltip="Point of Control (POC)|Level harga dengan volume trading tertinggi pada periode terlihat. Bertindak sebagai magnet harga.<br><br><b>Kondisi:</b><br>• <b>Harga > POC:</b> Dianggap sebagai area support.<br>• <b>Harga < POC:</b> Dianggap sebagai area resistance.">Point of Control (POC)</span><span id="vpvr-poc" class="font-mono font-bold">-</span></div>
                                            <div class="flex justify-between"><span class="text-green-500">Value Area Low</span><span id="vpvr-val" class="font-mono">-</span></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500">Rentang 24 Jam</span><span id="range-24h" class="font-mono font-semibold">-</span></div>
                                            <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                <span class="text-gray-500" data-tooltip="Pivot Harian (P)|Level acuan sentral yang dihitung dari High, Low, Close hari sebelumnya.<br><br><b>Kondisi:</b><br>• <b>Harga > Pivot:</b> Sentimen Bullish Intraday.<br>• <b>Harga < Pivot:</b> Sentimen Bearish Intraday.">Pivot Harian (P)</span><span id="pivot-p" class="font-mono font-bold text-blue-500">-</span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500" data-tooltip="VWAP (Volume-Weighted Average Price)|Harga rata-rata tertimbang volume. Acuan penting bagi trader institusional.<br><br><b>Mode:</b><br>• <b>Rolling:</b> Rata-rata 20 candle terakhir.<br>• <b>Session:</b> Direset setiap hari (00:00 UTC).<br>• <b>Anchored:</b> Dimulai dari titik terendah 200 candle terakhir.">VWAP</span>
                                                <div class="flex items-center gap-2">
                                                    <div id="vwap-mode-buttons" class="flex text-xs">
                                                        <button data-mode="rolling" class="vwap-mode-btn active px-2 py-0.5 rounded-l-md" data-tooltip="Rolling VWAP|Menghitung VWAP berdasarkan 20 candle terakhir. Berguna untuk melihat nilai wajar jangka pendek yang terus bergerak.">R</button>
                                                        <button data-mode="session" class="vwap-mode-btn px-2 py-0.5" data-tooltip="Session VWAP|VWAP direset setiap hari pada pukul 00:00 UTC. Sangat umum digunakan oleh day trader untuk menentukan bias intraday.">S</button>
                                                        <button data-mode="anchored" class="vwap-mode-btn px-2 py-0.5 rounded-r-md" data-tooltip="Anchored VWAP|VWAP dimulai dari titik terendah dalam 200 candle terakhir. Berguna untuk melihat harga rata-rata sejak titik pembalikan tren terakhir.">A</button>
                                                    </div>
                                                    <span id="vwap-20d" class="font-mono text-yellow-500">-</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
            
                                    <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">⚡ Momentum & Kondisi Saat Ini</h3>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between items-center"><span class="text-gray-500">RSI (14)</span><div><span id="rsi-value" class="font-mono text-xs">-</span> <span id="rsi-status" class="tag tag-gray"></span></div></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500">Stoch RSI (%K/%D)</span><div><span id="stoch-value" class="font-mono text-xs">-</span> <span id="stoch-status" class="tag tag-gray"></span></div></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500">MACD</span><div><span id="macd-status" class="font-mono font-semibold">-</span> <span id="macd-hist" class="font-mono text-xs ml-1">-</span></div></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="RSI Divergence|Kondisi di mana harga dan indikator RSI bergerak ke arah berlawanan, menandakan potensi pembalikan tren.<br><br><b>Kondisi:</b><br>• <b>BULLISH:</b> Harga 'Lower Low', RSI 'Higher Low'.<br>• <b>BEARISH:</b> Harga 'Higher High', RSI 'Lower High'.">RSI Divergence</span><span id="rsi-divergence" class="font-mono font-semibold text-xs">-</span></div>
                                            <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50"><span class="text-gray-500">Parabolic SAR</span><span id="psar-status" class="font-mono">-</span></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Rate of Change (ROC)|Mengukur kecepatan perubahan harga dalam persentase.<br><br><b>Kondisi:</b><br>• <b>Positif (> 0):</b> Momentum Bullish.<br>• <b>Negatif (< 0):</b> Momentum Bearish.">Rate of Change (ROC)</span><span id="roc-status" class="font-mono">-</span></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Linear Regression Channel|Kanal statistik yang menunjukkan tren utama harga dan deviasi normalnya.<br><br><b>Kondisi:</b><br>• <b>Upper Line:</b> Area overbought/resistance.<br>• <b>Lower Line:</b> Area oversold/support.<br>• <b>In Channel:</b> Harga bergerak dalam rentang normal.">LinReg Channel</span><span id="linreg-status" class="font-mono">-</span></div>
                                        </div>
                                    </div>

                                    <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">🔬 Volatilitas & Sentimen Jangka Pendek</h3>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between items-center"><span class="text-blue-500" data-tooltip="Bollinger Squeeze|Indikasi volatilitas pasar yang sangat rendah, seringkali mendahului pergerakan harga yang besar.<br><br><b>Kondisi:</b><br>• <b>SQUEEZE PRO!:</b> Volatilitas sangat terkompresi (BB di dalam Keltner Channel).<br>• <b>Squeeze!:</b> Volatilitas rendah (BB menyempit).<br>• <b>Normal:</b> Volatilitas normal.">Bollinger Squeeze</span><span id="bollinger-squeeze-status" class="font-mono">-</span></div>
                                            <div class="flex justify-between items-center"><span class="text-yellow-500">BB Rejection</span><span id="bollinger-rejection-status" class="font-mono">-</span></div>
                                            <div class="flex justify-between items-center"><span class="text-gray-500">BB Walk the Bands</span><span id="bollinger-walk-status" class="font-mono">-</span></div>    
                                            <div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500">Bollinger Bands</span>
                                                    <span id="bollinger-bands-status" class="font-mono">-</span>
                                                </div>
                                                <div class="text-right text-xs text-gray-400 font-mono">
                                                    <span id="bb-upper-value">-</span> / 
                                                    <span id="bb-middle-value">-</span> / 
                                                    <span id="bb-lower-value">-</span>
                                                </div>
                                            </div>
                                            
                                        </div>
                                    </div>

                                    <div class="hidden">
                                        <div class="flex justify-between items-center">
                                            <h2 class="text-base font-semibold">Korelasi Pasar</h2>
                                            <div class="flex items-center justify-center gap-2">
                                                <span class="text-sm text-gray-400">vs.</span>
                                                <input type="text" id="correlation-asset-input" class="input-primary !w-32 text-center uppercase font-mono text-xs" value="BTCUSDT">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
            </section>
        <section id="onchain-card" class="card p-6">
            <button id="toggle-onchain-btn" class="w-full flex justify-between items-center text-left mb-4">
                                        <h2 class="text-xl font-bold">⛓️‍💥 Aktivitas On-Chain</h2>
                                        <svg id="toggle-onchain-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <div id="onchain-content-wrapper" class="collapsible-content">
                                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                            <div id="specific-token-analysis" class="mb-4">
                                                <h3 id="specific-token-title" class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Analisis Token Spesifik</h3>
                                                <div id="specific-token-content" class="text-sm space-y-1"><p class="text-xs text-gray-500 text-center">Mencari data on-chain untuk aset yang dianalisa...</p></div>
                                            </div>                                    
                                            <div>
                                                <h3 class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Pool Trending Teratas</h3>
                                                <div id="trending-pools-content" class="text-sm space-y-2"><div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div></div>
                                            </div>
                                        </div>
                                    </div>
            </section>
    </div>

    <section id="ai-analysis-section" class="card p-6 relative lg:col-span-2">
        <div class="flex justify-between items-center mb-4">
                                <h2 class="text-xl font-bold">💡 Analisis AI</h2>
                            </div>

                            <div id="ai-verdict-content-wrapper" class="collapsible-content expanded">
                                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                    <button id="run-comprehensive-ai-btn" class="btn-primary w-full mb-4">
                            <span>🚀 ANALISA</span>
                            <div class="loader w-5 h-5 hidden">
                                <div class="dot"></div>
                                <div class="dot"></div>
                                <div class="dot"></div>
                            </div>
                        </button>
                                    <div id="ai-content-container" class="hidden space-y-6">
                                        <div id="ai-narrative-content" class="prose prose-sm dark:prose-invert max-w-none text-gray-600 space-y-4"></div>
                                        <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">🔮 Proyeksi Harga</h3><div id="projection-results-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div></div>
                                        <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">♟️ Saran Strategis</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-green-500 mb-2">Untuk Calon Buyer</h4><p id="saran-buyer" class="text-lg font-bold"></p><p id="alasan-buyer" class="text-sm text-gray-500 mt-1"></p></div><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-blue-500 mb-2">Untuk Holder</h4><p id="saran-holder" class="text-lg font-bold"></p><p id="alasan-holder" class="text-sm text-gray-500 mt-1"></p></div></div></div>
                                    </div>
                                </div>
                            </div>

                            <div class="absolute bottom-2 right-2">
                                <button id="toggle-ai-verdict-btn" class="p-1 rounded-full text-gray-400 hover:bg-gray-700 focus:outline-none">
                                    <svg id="toggle-ai-verdict-icon" class="w-5 h-5 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                    </svg>
                                </button>
                            </div>
        </section>
</div>
                    
                    <div id="initial-placeholder" class="text-center py-20">
                        <p class="text-xs font-mono text-gray-500">Pilih Spot or Futures ERROR? REFRESH browser</p>
                    </div>
                    <div id="loader-overlay" class="... flex-col ...">
                        <div class="loader">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                        <p id="loader-text" class="text-white font-semibold mt-4">Memulai Analisa...</p>
                    </div>
        </main>
    </div>

<script>
    // =======================================================
    // BAGIAN 1: DEKLARASI SEMUA ELEMEN DOM
    // =======================================================
    const gainersList = document.getElementById('gainers-list');
    const losersList = document.getElementById('losers-list');
    const navWrapper = document.getElementById('sticky-nav-wrapper');
    const mainContent = document.getElementById('main-content-container');
    const toggleAiVerdictBtn = document.getElementById('toggle-ai-verdict-btn');
    const toggleAiVerdictIcon = document.getElementById('toggle-ai-verdict-icon');
    const aiVerdictContentWrapper = document.getElementById('ai-verdict-content-wrapper');
    const assetInput = document.getElementById('asset-input');
    const apiKeyInput = document.getElementById('gemini-api-key');
    const timeframeSelect = document.getElementById('timeframe-select');
    const marketTypeSelect = document.getElementById('market-type-select');
    const analyzeBtn = document.getElementById('analyze-asset-btn');
    const buttonText = document.getElementById('button-text');
    const buttonLoader = document.getElementById('button-loader');
    const assetError = document.getElementById('asset-error');
    const dashboardContent = document.getElementById('dashboard-content');
    const initialPlaceholder = document.getElementById('initial-placeholder');
    const loaderOverlay = document.getElementById('loader-overlay');
    const loaderText = document.getElementById('loader-text');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const darkIcon = document.getElementById('theme-toggle-dark-icon');
    const lightIcon = document.getElementById('theme-toggle-light-icon');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');   
    const projectionResultsContainer = document.getElementById('projection-results-container');
    const specificTokenTitle = document.getElementById('specific-token-title');
    const specificTokenContent = document.getElementById('specific-token-content');
    const trendingPoolsContent = document.getElementById('trending-pools-content');
    const fullOrderBookContainer = document.getElementById('full-order-book-container');
    const tradeLink = document.getElementById('trade-link');
    const watchlistInput = document.getElementById('watchlist-input');
    const saveWatchlistBtn = document.getElementById('save-watchlist-btn');
    const scanWatchlistBtn = document.getElementById('scan-watchlist-btn');
    const watchlistResultsBody = document.getElementById('watchlist-results-body');
    const navVolume24h = document.getElementById('nav-volume-24h');
    const navAth = document.getElementById('nav-ath');
    const navAtl = document.getElementById('nav-atl');
    const resetBtn = document.getElementById('reset-btn');
    // =======================================================
    // BAGIAN 2: KONSTANTA KONFIGURASI
    // =======================================================
    const UI_UPDATE_INTERVAL = 500;
    const KLINE_CACHE_DURATION = 5 * 60 * 1000; // Cache berlaku 5 menit
    // =======================================================
    // BAGIAN 3: DEKLARASI STATE & VARIABEL GLOBAL
    // =======================================================
    // Satu objek cache utama untuk semua data real-time dan analisis
    const realtimeCache = {
        // Data untuk aset yang sedang dianalisis secara spesifik
        main: {
            symbol: null,
            tickerData: {},
            klines: [],
            calculatedData: {},
            liveScores: { pumpStrength: 0, dumpRisk: 0 }
        },
        // Data real-time untuk aset Top Movers
        movers: {}
    };
    let userSettings = {
        active: {
            weights: {}, // Akan diisi oleh preset
            indicatorParams: {} // Akan diisi oleh timeframe
        },
        presets: {
            'default': {
                weights: { ma: 2, pivot: 2, vwap: 2, ichimoku: 3, rsi: 1.5, stoch: 1, macd: 2, candlePattern: 1.5, psar: 1, linreg: 1, roc: 1, bollingerBands: 1, rsiDivergence: 2.5, obvDivergence: 3.0, openInterest: 1, funding: 1, lsr: 1, orderBookBias: 1, bbSqueeze: 1 },
                // [BARU] Tambahkan parameter Stoch RSI default
                indicatorParams: { 
                    rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9,
                    stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 
                }
            },
            
        }
    };
    const timeframeParameterMap = {
        // Kategori Scalping (Timeframe <= 15m) -> Stoch RSI lebih sensitif
        '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        // Kategori Day Trading (Timeframe > 15m dan <= 4h) -> Stoch RSI standar
        '30m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '2h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        // Kategori Swing Trading (Timeframe > 4h) -> Stoch RSI lebih stabil
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1w': { rsi_period: 25, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 25, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };

    let klineCache = {};
    let latestBids = [];
    let latestAsks = [];
    let liveAnalysisScores = {};
    let coinListCache = null;
    let exchangeInfoCache = { spot: null, futures: null };
    let charts = [];
    let candlestickSeries = null; 
    let cvdChartInstance = null;
    let liveCvdValue = 0;
    let liveCvdData = [];
    let isChartsVisible = false;
    let liveCvdValueUsdt = 0;
    let periodicUpdateInterval = null;
    let latestCalculatedData = {};
    let lastUiUpdateTime = 0;
    let tradeQueue = [];
    let depthQueue = [];
    let klineQueue = [];
    let processingInterval = null;
    let fundingRateTimer = null;
    let watchlist = [];
    let orderBookDOMElements = null;
    let orderBookHistory = {
        avgVolumes: [], 
        maxSize: 50     
    };
    let topMoversInterval = null;
    let topMoversCountdown = null;
    let currentTimeframe = "1h";
    let currentInterval = 60000; // default 10 detik
    let remainingTime = currentInterval / 1000;
    let isTooltipActive = false;
// =======================================================
// OBJEK WEBSOCKET MANAGER HARUS DIDEKLARASIKAN DI AWAL
// =======================================================
const WebSocketManager = {
    ws: null,
    mainSubscriptions: new Set(),
    moverSubscriptions: new Set(),
    messageHandlers: {},
    reconnectBaseDelay: 5000, 
    reconnectAttempts: 0,
    maxReconnectDelay: 60000,
    isConnecting: false,
    
    handleOpen() {
        this.isConnecting = false;
        this.reconnectAttempts = 0; 
    },

    handleMessage(event) {
        const message = JSON.parse(event.data);
        if (message.result !== undefined) return;

        if (message.stream && message.data) {
            const streamName = message.stream;
            const payload = message.data;
            const symbol = streamName.split('@')[0].toUpperCase();

            // Cek apakah data ini untuk Top Movers
            if (this.moverSubscriptions.has(symbol)) {
                onNewMoverData(symbol, streamName, payload);
            }
            
            // Cek apakah data ini untuk panel analisis utama
            if (realtimeCache.main.symbol && realtimeCache.main.symbol === symbol) {
                if (streamName.includes('@kline')) {
                    if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                } else if (streamName.includes('@aggTrade')) {
                    if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                } else if (streamName.includes('@depth')) {
                    if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                } else if (streamName.includes('@bookTicker')) {
                    if (this.messageHandlers['bookTicker']) this.messageHandlers['bookTicker'](payload);
                }
            }
        }
    },

    handleClose() {
        this.isConnecting = false;
        if (this.mainSubscriptions.size > 0 || this.moverSubscriptions.size > 0) {
            this.reconnectAttempts++;
            const delay = Math.min(this.reconnectBaseDelay * (2 ** this.reconnectAttempts), this.maxReconnectDelay);
            setTimeout(() => this.connect(), delay);
        }
    },

    handleError(error) {
        console.error("Kesalahan WebSocket:", error);
        this.isConnecting = false;
        if (this.ws) this.ws.close();
    },

    connect() {
        if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) return;
        this.isConnecting = true;
        
        const moverStreams = Array.from(this.moverSubscriptions).flatMap(s => [`${s.toLowerCase()}@kline_1h`, `${s.toLowerCase()}@aggTrade`, `${s.toLowerCase()}@depth20`]);
        const mainStreams = Array.from(this.mainSubscriptions);
        const allSubscriptions = new Set([...mainStreams, ...moverStreams]);
        
        const streamNames = Array.from(allSubscriptions).join('/');
        
        if (streamNames.length === 0) {
            this.isConnecting = false;
            return;
        }
        const url = `wss://fstream.binance.com/stream?streams=${streamNames}`;
        this.ws = new WebSocket(url);
        this.ws.onopen = this.handleOpen.bind(this);
        this.ws.onmessage = this.handleMessage.bind(this);
        this.ws.onclose = this.handleClose.bind(this);
        this.ws.onerror = this.handleError.bind(this);
    },
    
    subscribe(streams) { // Hanya untuk panel utama
        this.mainSubscriptions.clear();
        streams.forEach(stream => this.mainSubscriptions.add(stream));
        this.reconnect();
    },

    resetSubscriptions() { // Hanya mereset langganan utama
        this.mainSubscriptions.clear();
        this.reconnect();
    },

    subscribeToMovers(symbols) {
        const newSubs = new Set(symbols);
        if (new Set([...newSubs]).size === this.moverSubscriptions.size && [...newSubs].every(s => this.moverSubscriptions.has(s))) {
            return; // Tidak ada perubahan, tidak perlu reconnect
        }
        this.moverSubscriptions = newSubs;
        this.reconnect();
    },

    reconnect() {
        if (this.ws) {
            this.ws.onclose = null;
            this.ws.close();
        }
        this.connect();
    },

    registerHandler(streamName, handler) {
        this.messageHandlers[streamName] = handler;
    }
};
// =======================================================
    // BAGIAN 4: DEFINISI FUNGSI-FUNGSI
// =======================================================

// =======================================================
    function adaptIndicatorParamsToTimeframe(timeframe) {
        const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];

        userSettings.active.indicatorParams = { ...userSettings.presets['default'].indicatorParams, ...params };

        document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
        document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
        document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
        document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
        document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;       
    }
// =======================================================
    function applyPreset(presetName) {
            if (!userSettings.presets[presetName]) return;

            // Fungsi ini sekarang HANYA menyalin bobot
            userSettings.active.weights = { ...userSettings.presets['default'].weights, ...userSettings.presets[presetName].weights };

            // Update nilai input bobot di UI
            document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
            document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
            document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;

            //console.log(`Preset bobot '${presetName}' diterapkan.`);
            
            if (realtimeCache.main.calculatedData) {
                updateQuickConfluenceWidget();
            }
        }
    // BARU: Fungsi helper untuk Debounce
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }
    
// =================UPGRADES======================================
function determineMarketRegime(klines, closes) {
    if (!klines || klines.length < 200) {
        return { regime: 'RANGING', reason: 'Data kurang' };
    }

    const adxData = calculateADX(klines, 14);
    const ema200 = calculateEMA(closes, 200).pop();
    const lastPrice = closes[closes.length - 1];
    
    const isTrending = parseFloat(adxData.adx) > 25;

    if (isTrending) {
        if (lastPrice > ema200) {
            return { regime: 'TRENDING_UP', reason: `ADX (${adxData.adx}) > 25 & Harga > EMA 200` };
        } else {
            return { regime: 'TRENDING_DOWN', reason: `ADX (${adxData.adx}) > 25 & Harga < EMA 200` };
        }
    } else {
        return { regime: 'RANGING', reason: `ADX (${adxData.adx}) < 25` };
    }
}
// =======================================================
   function displaySentimentDataInDashboard(data) {
        const container = document.getElementById('sentiment-display-container');

        // --- Interpretasi & Pewarnaan untuk setiap data poin ---
        const netflowClass = data.netflow < 0 ? 'positive' : 'negative';
        const netflowText = data.netflow < 0 ? `Outflow (Bullish)` : `Inflow (Bearish)`;

        const oiClass = data.oiChange > 0 ? 'positive' : 'negative';
        const oiText = data.oiChange > 0 ? `Naik` : `Turun`;

        // Funding rate dianggap sehat jika dekat dengan nol
        const fundingClass = Math.abs(data.fundingRate) > 0.02 ? 'negative' : 'text-gray-400';
        const fundingText = Math.abs(data.fundingRate) > 0.02 ? `Ekstrem` : `Sehat`;

        // Ekstrak L/S Ratio untuk pewarnaan
        const lsParts = data.lsRatio24h.split('/');
        const longRatio = parseFloat(lsParts[0]);
        const shortRatio = parseFloat(lsParts[1]);
        const lsClass = longRatio > shortRatio ? 'positive' : (shortRatio > longRatio ? 'negative' : 'text-gray-400');
        const lsText = longRatio > shortRatio ? `Dominan Long` : (shortRatio > longRatio ? `Dominan Short` : `Seimbang`);

        container.innerHTML = `
            <h3 class="text-lg font-bold mb-4 text-center">🌡️ Sentimen Pasar (via AI)</h3>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between items-center"><span class="text-gray-400">Aliran Bursa (Netflow BTC)</span><span class="font-bold ${netflowClass}">${data.netflow.toFixed(2)} BTC (${netflowText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Perubahan Open Interest</span><span class="font-bold ${oiClass}">${data.oiChange.toFixed(2)}% (${oiText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rata-rata Funding Rate</span><span class="font-bold ${fundingClass}">${(data.fundingRate * 100).toFixed(4)}% (${fundingText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rasio Long/Short (24j)</span><span class="font-bold ${lsClass}">${data.lsRatio24h} (${lsText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Likuidasi (Long vs Short)</span><span class="font-bold text-gray-200">${data.liquidations}</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">MVRV Z-Score</span><span class="font-bold text-yellow-400">${data.mvrv_z_score.toFixed(2)}</span></div>
                <p class="text-center text-xs text-gray-500 pt-2">Data diambil oleh AI pada: ${new Date().toLocaleTimeString('id-ID')}</p>
            </div>
        `;
    }
// --- FUNGSI PENGATURAN ---
    function saveSettings() {
        // Menyimpan parameter indikator (jika diubah manual)
        userSettings.active.indicatorParams.rsi_period = parseInt(document.getElementById('setting-rsi-period').value);
        userSettings.active.indicatorParams.macd_fast = parseInt(document.getElementById('setting-macd-fast').value);
        userSettings.active.indicatorParams.macd_slow = parseInt(document.getElementById('setting-macd-slow').value);
        userSettings.active.indicatorParams.macd_signal = parseInt(document.getElementById('setting-macd-signal').value);
        
        // Menyimpan bobot
        userSettings.active.weights.rsiDivergence = parseFloat(document.getElementById('setting-weight-divergence').value);
        userSettings.active.weights.macd = parseFloat(document.getElementById('setting-weight-macd').value);
        userSettings.active.weights.obvDivergence = parseFloat(document.getElementById('setting-weight-obv-divergence').value);

        // Simpan hanya bobot dan parameter yang aktif
        localStorage.setItem('ultimateAppSettings', JSON.stringify(userSettings.active)); 
        const msgEl = document.getElementById('settings-saved-msg');
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 2000);
    }

// =======================================================
    function loadSettings() {
        const savedActiveSettings = localStorage.getItem('ultimateAppSettings');
        
        applyPreset('default'); 
        
        if (savedActiveSettings) {
            try {
                const parsed = JSON.parse(savedActiveSettings);
                if (parsed.weights) userSettings.active.weights = { ...userSettings.active.weights, ...parsed.weights };
                if (parsed.indicatorParams && Object.keys(parsed.indicatorParams).length > 0) {
                    userSettings.active.indicatorParams = { ...userSettings.active.indicatorParams, ...parsed.indicatorParams };
                }
            } catch (e) {
                console.error("Gagal parse pengaturan.", e);
            }
        }

        if (Object.keys(userSettings.active.indicatorParams).length === 0) {
            //console.log("Parameter indikator kosong, memuat default berdasarkan timeframe...");
            adaptIndicatorParamsToTimeframe(timeframeSelect.value);
        }

        document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
        // [BARU] Muat parameter Stoch RSI ke UI
        document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
        document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
        document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
        document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;

        document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
        document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
        document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;
    }

// --- FUNGSI UTAMA & UTILITIES ---
    function showError(message) {
        assetError.textContent = message;
        assetError.classList.remove('hidden');
    }
// =======================================================
    function hideError() {
        assetError.classList.add('hidden');
    }
// =======================================================
    function showLoader(show, text = '') {
        if (show) {
            loaderText.textContent = text;
            loaderOverlay.classList.remove('hidden');
            loaderOverlay.classList.add('flex');
            analyzeBtn.disabled = true;
            buttonText.classList.add('hidden');
            buttonLoader.classList.remove('hidden');
        } else {
            loaderOverlay.classList.add('hidden');
            loaderOverlay.classList.remove('flex');
            analyzeBtn.disabled = false;
            buttonText.classList.remove('hidden');
            buttonLoader.classList.add('hidden');
        }
    }
// =======================================================
    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) {
            console.error('Elemen toggle tidak ditemukan untuk:', buttonId);
            return;
        }
        contentWrapper.classList.add('collapsible-content');
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };
        let isVisible = startVisible;
        applyState(isVisible);
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }
// =======================================================
    function adjustContentPadding() {
        if (navWrapper && mainContent) {
            const navHeight = navWrapper.offsetHeight;
            mainContent.style.paddingTop = `${navHeight}px`;
        }
    }
// =======================================================
    const formatPrice = (price) => {
        if (price === null || price === undefined) return '-';
        if (price >= 1) {
            return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }
        const priceString = price.toString();
        const decimalPart = priceString.includes('.') ? priceString.split('.')[1] : '';
        if (decimalPart.length === 0) return `$${price.toFixed(2)}`;
        let nonZeroIndex = -1;
        for (let i = 0; i < decimalPart.length; i++) {
            if (decimalPart[i] !== '0') {
                nonZeroIndex = i;
                break;
            }
        }
        if (nonZeroIndex !== -1) {
            const significantDigits = 4;
            return `$${price.toFixed(nonZeroIndex + significantDigits)}`;
        }
        return `$${price.toFixed(8)}`;
    };
// =======================================================
    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 7;
        return 8;
    }
// =======================================================
    function getUltimateSignalScore(indicator, signalData) {
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const mapRange = (x, inMin, inMax, outMin, outMax) => {
            const t = (x - inMin) / (inMax - inMin);
            return outMin + clamp(t, 0, 1) * (outMax - outMin);
        };       
        const confidence = (typeof signalData?.confidence === 'number')
            ? clamp(signalData.confidence, 0, 1)
            : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const biasSigned = (typeof signalData?.biasSigned === 'number')
            ? Math.sign(signalData.biasSigned)
            : null;
        // Normalisasi indikator by name
        if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }

        // Divergence
        if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }

        // Open Interest
        if (indicator === 'openInterest') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('UP')) return +1 * confidence;
            if (text.includes('DOWN')) return -1 * confidence;
            return 0;
        }

        // Funding / fundingRate
        if (indicator === 'funding' || indicator === 'fundingRate') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 0; // ex: 0.0005 = 0.05%
            const s = Math.max(-1, Math.min(1, v / 0.0025));
            return s * confidence;
            }

        // Long/Short Ratio (lsr / lsRatio)
        if (indicator === 'lsr' || indicator === 'lsRatio') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 1;
            // map 0.7..1.3 ke -1..+1, clamp
            const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
            return s * confidence;
            }

        // Order Book Bias
        if (indicator === 'orderBookBias') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BID')) return +1 * confidence;
            if (text.includes('ASK')) return -1 * confidence;
            return 0;
        }

        // BB Squeeze
        if (indicator === 'bbSqueeze') {
            const st = (signalData?.status || '').toString().toUpperCase();
            if (st.includes('RELEASE')) return +1 * confidence; // siap bergerak
            if (st.includes('ON')) return 0; // kompresi
            if (st.includes('OFF')) return 0.3 * confidence; // keluar channel
            return 0;
        }

        // fallback
        return 0;
    }
// =======================================================
    async function updateQuickConfluenceWidget() {
        const data = realtimeCache.main.calculatedData;
            if (!data) return;

        const mtfAlignmentScore = realtimeCache.main.tfAlignmentSummary?.score || 0;
        const mtfMultiplier = 1 + (Math.abs(mtfAlignmentScore) / 4) * 0.25;

        let totalBullScore = 0;
        let totalBearScore = 0;
        let maxPossibleScore = 0;

        const marketType = marketTypeSelect.value;
        const marketRegime = realtimeCache.main.marketRegime?.regime || 'RANGING';
        const trendIndicators = ['ma', 'ichimoku', 'psar', 'adx'];
        const rangeIndicators = ['rsi', 'stoch', 'rsiDivergence', 'bollingerBands'];

        for (const indicator in userSettings.active.weights) {
            if (['funding', 'lsr', 'openInterest'].includes(indicator)) {
                if (marketType !== 'futures') {
                    continue;
                }
            }
            
            let weight = userSettings.active.weights[indicator] || 0;

            if (marketRegime.includes('TRENDING') && rangeIndicators.includes(indicator)) {
                weight *= 0.5;
            }
            if (marketRegime === 'RANGING' && trendIndicators.includes(indicator)) {
                weight *= 0.5;
            }
            
            if (data[indicator]) {
                const rawScore = getUltimateSignalScore(indicator, data[indicator]);
                let finalWeight = weight;

                if (rawScore > 0 && mtfAlignmentScore > 0) {
                    finalWeight *= mtfMultiplier;
                } else if (rawScore < 0 && mtfAlignmentScore < 0) {
                    finalWeight *= mtfMultiplier;
                } else if ((rawScore > 0 && mtfAlignmentScore < 0) || (rawScore < 0 && mtfAlignmentScore > 0)) {
                    finalWeight *= 0.75; 
                }

                const weightedScore = rawScore * finalWeight;
                
                if (weightedScore > 0) totalBullScore += weightedScore;
                if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
            }
            maxPossibleScore += Math.abs(weight);
        }

        const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
        const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;
        
        realtimeCache.main.quickConfluenceScore = { 
            score: bullPercentage - bearPercentage,
            bull: bullPercentage,
            bear: bearPercentage
        };
        
        const { text: verdict, class: verdictClass } = generateShortVerdict(bullPercentage, bearPercentage);
        const mtfScoreText = mtfAlignmentScore > 0 ? `+${mtfAlignmentScore}` : mtfAlignmentScore;
        const mtfHtml = `<div class="text-xs text-center text-gray-400 mt-2">Kekuatan Tren Multi-TF: <span class="font-bold ${mtfAlignmentScore > 0 ? 'positive' : (mtfAlignmentScore < 0 ? 'negative' : '')}">${mtfScoreText}</span></div>`;

        document.getElementById('quick-confluence-timeframe').textContent = timeframeSelect.value;
        document.getElementById('quick-finalBullishScore').textContent = `${bullPercentage.toFixed(0)}% 🐂`;
        document.getElementById('quick-finalBearishScore').textContent = `🐻 ${bearPercentage.toFixed(0)}%`;
        const totalStrength = bullPercentage + bearPercentage;
        const bullWidthPercentage = totalStrength > 0 ? (bullPercentage / totalStrength) * 100 : 50;
        document.getElementById('quick-confluenceBarBullish').style.width = `${bullWidthPercentage}%`;
        document.getElementById('quick-confluenceBarBearish').style.width = `${100 - bullWidthPercentage}%`;
        // --- AWAL BLOK PERUBAHAN ---

        // 1. Hitung Skor Tensi
        const tensionScore = Math.min(100, bullPercentage + bearPercentage);
        let tensionText = "Rendah";
        if (tensionScore > 50) tensionText = "Sedang";
        if (tensionScore > 75) tensionText = "Tinggi";
        if (tensionScore > 90) tensionText = "Ekstrem";

        // 2. Tampilkan Verdict Utama
        const verdictEl = document.getElementById('quick-finalVerdict');
        verdictEl.innerHTML = `${verdict} <span class="text-sm font-mono ${verdictClass}">(${(bullPercentage - bearPercentage).toFixed(0)})</span> ${mtfHtml}`;
        // Hapus text-center karena sudah dihandle oleh div container baru
        verdictEl.className = `font-semibold`;

        // 3. Tampilkan Skor Tensi
        const tensionContainer = document.getElementById('tension-score-container');
        tensionContainer.innerHTML = `
            <span class="text-gray-400">Tensi Pasar: <strong>${tensionText}</strong> (${tensionScore.toFixed(0)}/100)</span>
            <div class="tension-bar-bg">
                <div class="tension-bar-fill" style="width: ${tensionScore}%;"></div>
            </div>
        `;
        
        // --- AKHIR BLOK PERUBAHAN ---

        analyzeAndDisplayConfluenceContributors();
        
        // Asumsi elemen span ada di dalam verdictEl dan bukan satu-satunya span
        const verdictSpan = verdictEl.querySelector(`.${verdictClass.split(' ')[0]}`);
        if (verdictSpan) {
            verdictSpan.className = verdictClass;
        } else {
            // Fallback jika struktur HTML berubah
            const textNode = verdictEl.childNodes[0];
            const newSpan = document.createElement('span');
            newSpan.className = verdictClass;
            newSpan.textContent = textNode.textContent;
            verdictEl.replaceChild(newSpan, textNode);
        }
        
        

        analyzeAndDisplayConfluenceContributors();
    }
// =======================================================   
    function updateCvdTableLive() {
        const tableBody = document.getElementById('cvd-table-body');
        if (!tableBody || liveCvdData.length === 0) return;

        // Ambil data paling baru
        const lastDataPoint = liveCvdData[liveCvdData.length - 1];

        // Buat baris baru dan masukkan di paling atas (index 0)
        const newRow = tableBody.insertRow(0);
        
        const date = new Date(lastDataPoint.x);
        const formattedTime = date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        // Tentukan warna berdasarkan perubahan nilai USDT
        const prevUsdt = liveCvdData.length > 1 ? liveCvdData[liveCvdData.length - 2].y_usdt : 0;
        const colorClass = lastDataPoint.y_usdt > prevUsdt ? 'positive' : 'negative';

        // Isi sel di baris baru
        newRow.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${formattedTime}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">${lastDataPoint.y_coin.toFixed(4)}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">$${lastDataPoint.y_usdt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        `;

        // Jaga agar jumlah baris tidak lebih dari 5, hapus yang paling bawah
        while (tableBody.rows.length > 5) {
            tableBody.deleteRow(tableBody.rows.length - 1);
        }
    }

// --- BAGIAN UPGRADE: Fungsi terpusat untuk update indikator real-time ---
    function updateRealTimeIndicators(klines) {
        if (!klines || klines.length < 50) return; // Pengaman
        const closes = klines.map(k => parseFloat(k[4]));
        const adx = calculateADX(klines);
        const ma = (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? { status: 'Uptrend', class: 'positive' } : { status: 'Downtrend', class: 'negative' };
        const rsiValues = calculateRSI(closes);
        const rsiLast = rsiValues.filter(v=>v!==undefined).pop() || 50;
        const rsi = { values: rsiValues, last: rsiLast.toFixed(2), status: rsiLast > 70 ? 'Overbought' : (rsiLast < 30 ? 'Oversold' : 'Netral'), class: rsiLast > 70 ? 'tag-red' : (rsiLast < 30 ? 'tag-green' : 'tag-yellow') };
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);
        const stoch = calculateStochasticRSI(closes);
        const macd = calculateMACD(closes);
        const bollingerBands = calculateBollingerBands(closes);
        const atr = calculateATR(klines);
        const candlePattern = findCandlestickPatterns(klines);
        const chartPattern = findChartPatterns(klines);
        const roc = calculateROC(closes);
        const psar = calculateParabolicSAR(klines);
        const linreg = calculateLinearRegressionChannel(closes);

        // Simpan hasil kalkulasi terbaru ke state
        latestCalculatedData = { adx, ma, rsi, rsiDivergence, stoch, macd, bollingerBands, atr, candlePattern, chartPattern, roc, psar, linreg };

        // Update UI dengan data terbaru
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = ma.status;
        maStatusEl.className = `font-mono font-semibold ${ma.class}`;

        document.getElementById('rsi-value').textContent = rsi.last;
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = rsi.status;
        rsiStatusEl.className = `tag ${rsi.class}`;
        
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${rsiDivergence.class}`;

        document.getElementById('stoch-value').textContent = `${stoch.k}/${stoch.d}`;
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = stoch.status;
        stochStatusEl.className = `tag ${stoch.class}`;

        document.getElementById('macd-status').textContent = macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${macd.class}`;
        document.getElementById('macd-hist').textContent = macd.hist;
        
        document.getElementById('bollinger-bands-status').textContent = bollingerBands.status;
        document.getElementById('atr-status').textContent = `${atr.value.toFixed(6)} (${atr.status})`;
        
        const psarStatusEl = document.getElementById('psar-status');
        psarStatusEl.textContent = psar.status;
        psarStatusEl.className = `font-mono font-semibold ${psar.status === 'Bullish' ? 'positive' : 'negative'}`;

        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${roc.value.toFixed(2)}% (${roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${roc.status === 'Positif' ? 'positive' : 'negative'}`;

        document.getElementById('linreg-status').textContent = linreg.status;

        document.getElementById('adx-value').textContent = adx.adx;
        document.getElementById('plus-di-value').textContent = adx.plusDI;
        document.getElementById('minus-di-value').textContent = adx.minusDI;

        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const formattedTime = candlePattern.timestamp ? new Date(candlePattern.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
        let biasClass = '';
        if (candlePattern.bias === 'BULLISH') biasClass = 'positive';
        if (candlePattern.bias === 'BEARISH') biasClass = 'negative';
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Pola Candlestick</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            ${candlePattern.svg}
            <p id="candlestick-pattern" class="font-semibold ${candlePattern.class}">${candlePattern.pattern}</p>
            ${candlePattern.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candlePattern.bias}</p>` : ''}
        `;
        
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${chartPattern.class}`;
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// --- BAGIAN UPGRADE: Fungsi untuk update data yang sifatnya periodik (API Polling) ---
    async function updatePeriodicData() {
        try {
            const binanceSymbol = realtimeCache.main.binanceSymbol;
            if (!binanceSymbol || marketTypeSelect.value !== 'futures') return;

            //console.log("Memperbarui data periodik (L/S Ratio)...");

            const [lsRatioUmumData, lsRatioTopData] = await Promise.all([
                 fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                 fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            ]);

            realtimeCache.main.lsRatioUmumData = lsRatioUmumData;
            realtimeCache.main.lsRatioTopData = lsRatioTopData;

            if (lsRatioUmumData?.[0]) {
                document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            }
            if (lsRatioTopData?.[0]) {
                document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
            }

        } catch(error) {
            console.error("Gagal memperbarui data periodik:", error);
        }
    }


    
// --- 3. API & CALCULATION ENGINES (ORIGINAL CODE) ---
    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
        const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Binance API error (${marketType}): ${errorData.msg || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from Binance ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari Binance ${marketType.toUpperCase()}.`);
        }
    }
// =======================================================
    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }
    // =======================================================
    async function fetchCoinGeckoData(coinId) {
        if (!coinId) return null;
        const url = `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) return null;
            return response.json();
        } catch (error) { return null; }
    }
// =======================================================
    async function fetchUsdToIdrRate() {
        try {
            const response = await fetch('https://api.frankfurter.app/latest?from=USD&to=IDR');
            if (!response.ok) return 16200;
            const data = await response.json();
            return (data && data.rates && data.rates.IDR) ? data.rates.IDR : 16200;
        } catch (error) { return 16200; }
    }
// =======================================================
    async function getCoinGeckoId(baseAssetSymbol) {
        if (!coinListCache) {
            const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
            if (!response.ok) throw new Error('Gagal unduh daftar koin CoinGecko.');
            coinListCache = await response.json();
        }
        const assetSymbolLower = baseAssetSymbol.toLowerCase();
        const priorityMap = {
            'btc': 'bitcoin', 'eth': 'ethereum', 'bnb': 'binancecoin', 'weth': 'wrapped-ether',
            'sol': 'solana', 'wbtc': 'wrapped-bitcoin', 'uni': 'uniswap', 'shib': 'shiba-inu',
            'pepe': 'pepe', 'cross': 'cross-2', 'ada': 'cardano', 'xrp': 'ripple', 'ava': 'avant-usd', 'ethw': 'ethereum-pow-iou',
            'avax': 'avalanche-2'
        };
        if (priorityMap[assetSymbolLower]) return priorityMap[assetSymbolLower];

        let match = coinListCache.find(coin => coin.symbol === assetSymbolLower);
        if (match) return match.id;

        //console.log(`Simbol ${baseAssetSymbol} tidak ditemukan, mencoba pencarian cerdas...`);
        try {
            const searchResult = await fetchGeckoTerminal(`search/pools?query=${baseAssetSymbol}`);
            if (searchResult.data && searchResult.data.length > 0) {
                const topResult = searchResult.data[0];
                if (topResult.relationships.base_token.data.id) {
                    const coinId = topResult.relationships.base_token.data.id.split('_')[1];
                    if (coinId) return coinId;
                }
            }
        } catch (e) { console.error("Pencarian cerdas gagal:", e); }

        throw new Error(`Simbol "${baseAssetSymbol}" tidak ditemukan di CoinGecko.`);
    }
// =======================================================
    async function initializeExchangeInfo(marketType) {
        if (exchangeInfoCache[marketType]) return;
        const url = marketType === 'spot' ? 'https://api.binance.com/api/v3/exchangeInfo' : 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
        const data = await response.json();
        exchangeInfoCache[marketType] = data.symbols;
        if (document.getElementById('market-type-select').value === marketType) {
            populateAssetDatalist(data.symbols, marketType);
        }
    }
// =======================================================
    function populateAssetDatalist(symbols, marketType) {
        const dataList = document.getElementById('asset-list');
        if (!dataList) return;
        dataList.innerHTML = '';
        const filterFn = s => s.quoteAsset === 'USDT' && s.status === 'TRADING' && (marketType === 'spot' || s.contractType === 'PERPETUAL');
        symbols.filter(filterFn).sort((a, b) => a.symbol.localeCompare(b.symbol)).forEach(s => {
            const option = document.createElement('option');
            option.value = s.symbol;
            dataList.appendChild(option);
        });
    }
// =======================================================    
    async function validateBinanceSymbol(symbol, marketType) {
        if (!exchangeInfoCache[marketType]) {
            await initializeExchangeInfo(marketType);
        }
        
        const symbolData = exchangeInfoCache[marketType].find(s => s.symbol === symbol);
        if (!symbolData || symbolData.status !== 'TRADING') {
            throw new Error(`Simbol "${symbol}" tidak valid atau tidak aktif di Binance ${marketType}.`);
        }
    }
// =======================================================    
    async function callGemini(parts, isJsonOutput = true) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) throw new Error("API Key Google AI belum dimasukkan.");
        const model = 'gemini-2.5-flash-preview-05-20';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts }] };
        if (isJsonOutput) {
            payload.generationConfig = {
                "response_mime_type": "application/json",
                "max_output_tokens": 8192
            };
        }
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(`Google AI API error: ${errorBody?.error?.message || response.statusText}`);
        }
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
        throw new Error("Respons dari AI tidak valid atau kosong.");
    }

// =======================================================
    // == BLOK FUNGSI KALKULASI INDIKATOR BARU (MULAI) ==
// =======================================================
    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);

        const P = (high + low + close) / 3;
        const R1 = (2 * P) - low;
        const S1 = (2 * P) - high;
        const R2 = P + (high - low);
        const S2 = P - (high - low);
        const R3 = high + 2 * (P - low);
        const S3 = low - 2 * (high - P);

        return { P, R1, S1, R2, S2, R3, S3 };
    }
// =======================================================
    function calculateKeltnerChannels(klines, period = 20, multiplier = 2, atrPeriod = 10) {
        if (!klines || klines.length < period) return { upper: [], middle: [], lower: [], width: [] };
        const closes = klines.map(k => parseFloat(k[4]));
        const emaMiddle = calculateEMA(closes, period);
        const atr = calculateATR(klines, atrPeriod).value; // Menggunakan fungsi ATR yang sudah ada

        const upper = emaMiddle.map(val => val !== undefined ? val + (atr * multiplier) : undefined);
        const lower = emaMiddle.map(val => val !== undefined ? val - (atr * multiplier) : undefined);
        const width = upper.map((u, i) => (u !== undefined && lower[i] !== undefined) ? u - lower[i] : undefined);
        
        return { upper, middle: emaMiddle, lower, width };
    }
// =======================================================
    function calculateIchimokuCloud(klines, tenkanP = 9, kijunP = 26, senkouP = 52) {
        if (klines.length < senkouP) return null;
        
        const result = { tenkan: [], kijun: [], senkouA: [], senkouB: [], chikou: [], status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= tenkanP - 1 ? getHighLow(klines.slice(i - tenkanP + 1, i + 1)) : { high: 0, low: 0 };
            result.tenkan.push(i >= tenkanP - 1 ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= kijunP - 1 ? getHighLow(klines.slice(i - kijunP + 1, i + 1)) : { high: 0, low: 0 };
            result.kijun.push(i >= kijunP - 1 ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
            result.chikou.push(parseFloat(klines[i][4]));
        }
        for (let i = 0; i < klines.length; i++) {
            const senkouA_val = (result.tenkan[i] !== undefined && result.kijun[i] !== undefined) ? (result.tenkan[i] + result.kijun[i]) / 2 : undefined;
            result.senkouA.push(senkouA_val);
            const senkouB_HighLow = i >= senkouP - 1 ? getHighLow(klines.slice(i - senkouP + 1, i + 1)) : { high: 0, low: 0 };
            result.senkouB.push(i >= senkouP - 1 ? (senkouB_HighLow.high + senkouB_HighLow.low) / 2 : undefined);
        }

        // --- LOGIKA STATUS BARU YANG LEBIH STANDAR DAN AKURAT ---
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = result.tenkan[result.tenkan.length - 1];
        const lastKijun = result.kijun[result.kijun.length - 1];
        
        // Cloud yang relevan untuk harga saat ini dihitung 26 periode lalu
        const currentSenkouA = result.senkouA[klines.length - 1 - kijunP];
        const currentSenkouB = result.senkouB[klines.length - 1 - kijunP];
        
        // Chikou Span (harga saat ini) dibandingkan dengan harga 26 periode lalu
        const pastPriceForChikou = parseFloat(klines[klines.length - 1 - kijunP][4]);

        // Kondisi Bullish: Harga > Awan, Tenkan > Kijun, Chikou > Harga Masa Lalu
        const isBullish = lastPrice > currentSenkouA && lastPrice > currentSenkouB &&
                        lastTenkan > lastKijun &&
                        lastPrice > pastPriceForChikou;

        // Kondisi Bearish: Harga < Awan, Tenkan < Kijun, Chikou < Harga Masa Lalu
        const isBearish = lastPrice < currentSenkouA && lastPrice < currentSenkouB &&
                        lastTenkan < lastKijun &&
                        lastPrice < pastPriceForChikou;

        if (isBullish) {
            result.status = "Bullish";
        } else if (isBearish) {
            result.status = "Bearish";
        }
        // Jika tidak memenuhi keduanya, status tetap "Netral"

        return result;
    }
// =======================================================
    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A' };
        }

        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
            trs.push(tr);
        }

        const atrValues = [];
        let sum = 0;
        for (let i = 0; i < trs.length; i++) {
            sum += trs[i];
            if (i >= period - 1) {
                if (i > period - 1) {
                    sum = sum - trs[i - period];
                }
                atrValues.push(sum / period);
            } else {
                atrValues.push(undefined);
            }
        }
        
        const atr = atrValues[atrValues.length - 1] || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;

        let status;
        if (atrPercent > 5) {
            status = 'Sangat Tinggi';
        } else if (atrPercent > 2.5) {
            status = 'Tinggi';
        } else if (atrPercent < 1) {
            status = 'Rendah';
        } else {
            status = 'Normal';
        }
        return { value: atr, status: status }; 
    }
    const calculateEMA = (data, period) => {
        if (!data || data.length < period) return [];
        const k = 2 / (period + 1);
        let emaArray = Array(period - 1).fill(undefined);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        let currentEma = sum / period;
        emaArray.push(currentEma);
        for (let i = period; i < data.length; i++) {
            currentEma = (data[i] * k) + (currentEma * (1 - k));
            emaArray.push(currentEma);
        }
        return emaArray;
    };
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) return [];
        let sma = Array(period - 1).fill(undefined);
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            sma.push(slice.reduce((a, b) => a + b, 0) / period);
        }
        return sma;
    };
    const calculateRSI = (closes, period = userSettings.active.indicatorParams.rsi_period) => {
        if (!closes || closes.length <= period) return Array(closes?.length || 0).fill(undefined);
        let gains = [], losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        if (avgLoss === 0) return Array(closes.length).fill(100);
        let rsi = [100 - (100 / (1 + (avgGain / avgLoss)))];
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            if (avgLoss === 0) { rsi.push(100); } 
            else { rsi.push(100 - (100 / (1 + (avgGain / avgLoss)))); }
        }
        return Array(period).fill(undefined).concat(rsi);
    };
    const calculateMACD = (closes, fast = userSettings.active.indicatorParams.macd_fast, slow = userSettings.active.indicatorParams.macd_slow, signal = userSettings.active.indicatorParams.macd_signal) => {
        if (closes.length < slow + signal) {
            // Mengembalikan nilai default jika data tidak cukup
            return { status: 'Netral', hist: 'Netral', class: 'text-gray-500', macdLine: [], signalLine: [], histogram: [] };
        }
        
    const emaFast = calculateEMA(closes, fast);
    const emaSlow = calculateEMA(closes, slow);
        
    // Hitung garis MACD
    const macdLine = emaSlow.map((slowVal, i) => {
        if (slowVal !== undefined && emaFast[i] !== undefined) {
            return emaFast[i] - slowVal;
        }
            return undefined;
        });

    // Hitung garis Sinyal
        const signalLine = calculateEMA(macdLine.filter(v => v !== undefined), signal);

        // Hitung Histogram
        const histogram = macdLine.map((macdVal, i) => {
            // Sesuaikan indeks karena signalLine lebih pendek
            const signalIndex = i - (slow - 1); 
            if (macdVal !== undefined && signalLine[signalIndex] !== undefined) {
                const histValue = macdVal - signalLine[signalIndex];
                const prevHistValue = (i > 0 && macdLine[i-1] !== undefined && signalLine[signalIndex-1] !== undefined) 
                                    ? (macdLine[i-1] - signalLine[signalIndex-1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        });

        // Tentukan status terakhir untuk widget
        const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
        const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
        const lastHist = histogram.filter(v => v !== undefined).pop()?.value || 0;
        const prevMacdLine = macdLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        const prevSignalLine = signalLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        
        let status = 'Netral', macdClass = 'text-gray-500';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) { 
            status = 'Bullish Cross'; 
            macdClass = 'positive'; 
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) { 
            status = 'Bearish Cross'; 
            macdClass = 'negative'; 
        }
        
        return { 
            status, 
            hist: lastHist > 0 ? '(Naik)' : '(Turun)', 
            class: macdClass, 
            macdLine, 
            signalLine, 
            histogram 
        };
    };

    const calculateStochasticRSI = (closes, 
        rsiPeriod = userSettings.active.indicatorParams.stoch_rsi_period, 
        stochPeriod = userSettings.active.indicatorParams.stoch_stoch_period, 
        kSmooth = userSettings.active.indicatorParams.stoch_k_smooth, 
        dSmooth = userSettings.active.indicatorParams.stoch_d_smooth
    ) => {
        const rsiValues = calculateRSI(closes, rsiPeriod).filter(v => v !== undefined);
        if (rsiValues.length < stochPeriod) {
            return { k: 50, d: 50, status: 'Netral', class: 'tag-gray', kLine: [], dLine: [], kOffset: 0, dOffset: 0 };
        }
        const stochArr = [];
        for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
            const window = rsiValues.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((rsiValues[i] - minR) / denom) * 100);
        }
        const kLine = calculateSMA(stochArr, kSmooth);
        const dLine = calculateSMA(kLine.filter(v => v !== undefined), dSmooth);
        const lastK = kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = dLine.filter(v => v !== undefined).pop() || 50;
        let status = 'Netral', stochClass = 'tag-yellow';
        if (lastK > 80 && lastD > 80) { status = 'Overbought'; stochClass = 'tag-red'; }
        else if (lastK < 20 && lastD < 20) { status = 'Oversold'; stochClass = 'tag-green'; }
        const kOffset = closes.length - kLine.length;
        const dOffset = closes.length - dLine.length;
        return {
            k: lastK.toFixed(2), d: lastD.toFixed(2), status, class: stochClass,
            kLine, dLine, kOffset, dOffset
        };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) return { upper: [], middle: [], lower: [], width: [], status: 'N/A' };
        const middle = calculateSMA(closes, period);
        let upper = Array(period - 1).fill(undefined);
        let lower = Array(period - 1).fill(undefined);
        let width = Array(period - 1).fill(undefined);

        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                width.push(undefined);
                continue;
            };
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            upper.push(middle[i] + (stdev * stdDev));
            lower.push(middle[i] - (stdev * stdDev));
            width.push((middle[i] + (stdev * stdDev)) - (middle[i] - (stdev * stdDev))); // KALKULASI LEBAR BANDS
        }

        const lastClose = closes[closes.length - 1];
        const lastUpper = upper.filter(v => v !== undefined).pop();
        const lastLower = lower.filter(v => v !== undefined).pop();
        const lastWidth = width.filter(v => v !== undefined).pop();

        let status = 'Dalam Band';
        if (lastClose > lastUpper) status = 'Di Atas Band';
        if (lastClose < lastLower) status = 'Di Bawah Band';

        // Tambahkan deteksi squeeze
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            const recentWidths = width.slice(-50);
            const minWidth = Math.min(...recentWidths);
            const avgWidth = recentWidths.reduce((a, b) => a + b, 0) / recentWidths.length;
            if (lastWidth < avgWidth * 0.7) { // 30% lebih kecil dari rata-rata 50 periode terakhir
                squeezeStatus = 'Squeeze!';
            }
        }

        return { upper, middle, lower, width, status, squeezeStatus }; // TAMBAHKAN 'width' dan 'squeezeStatus'
    };
    const calculateVPVR = (klines, numRows = 70, valueAreaPercent = 0.70) => {
        if (!klines || klines.length === 0) return { poc: 0, vah: 0, val: 0 };
        let overallLow = Infinity, overallHigh = -Infinity;
        const candles = klines.map(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]);
            if (high > overallHigh) overallHigh = high;
            if (low < overallLow) overallLow = low;
            return { high, low, volume: parseFloat(k[5]) };
        });
        const rowSize = (overallHigh - overallLow) / numRows;
        let profile = Array.from({ length: numRows }, (_, i) => ({ price: overallLow + (i * rowSize), volume: 0 }));
        let totalVolume = 0;
        candles.forEach(c => {
            totalVolume += c.volume;
            const startIdx = Math.max(0, Math.floor((c.low - overallLow) / rowSize));
            const endIdx = Math.min(numRows - 1, Math.floor((c.high - overallLow) / rowSize));
            const volPerRow = c.volume / (endIdx - startIdx + 1);
            for (let i = startIdx; i <= endIdx; i++) profile[i].volume += volPerRow;
        });
        if (totalVolume === 0) return { poc: 0, vah: 0, val: 0 };
        let pocIndex = profile.reduce((maxIdx, row, idx, arr) => row.volume > arr[maxIdx].volume ? idx : maxIdx, 0);
        const poc = profile[pocIndex].price + (rowSize / 2);
        const targetVolume = totalVolume * valueAreaPercent;
        let vaVolume = profile[pocIndex].volume;
        let upperIdx = pocIndex, lowerIdx = pocIndex;
        while (vaVolume < targetVolume) {
            const volAbove = (upperIdx + 1 < numRows) ? profile[upperIdx + 1].volume : -1;
            const volBelow = (lowerIdx - 1 >= 0) ? profile[lowerIdx - 1].volume : -1;
            if (volAbove === -1 && volBelow === -1) break;
            if (volAbove > volBelow) {
                upperIdx++;
                vaVolume += profile[upperIdx].volume;
            } else {
                lowerIdx--;
                vaVolume += profile[lowerIdx].volume;
            }
        }
        return { poc, vah: profile[upperIdx].price + rowSize, val: profile[lowerIdx].price };
    };
// =======================================================
    function CVDanalyze(klines, cvdData) {
        if (!klines || klines.length < 2 || !cvdData || cvdData.length < 2) {
        return { trend: 'N/A', divergence: 'N/A', summary: 'Data tidak cukup untuk analisa CVD.' };
        }

        // Determine price trend
        const firstPrice = parseFloat(klines[0][4]);
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const priceTrend = lastPrice > firstPrice ? 'Naik' : (lastPrice < firstPrice ? 'Turun' : 'Datar');

        // Determine CVD trend
        const firstCvd = cvdData[0].cvd;
        const lastCvd = cvdData[cvdData.length - 1].cvd;
        const cvdTrend = lastCvd > firstCvd ? 'Naik' : (lastCvd < firstCvd ? 'Turun' : 'Datar');

        // Detect divergence
        let divergence = 'Tidak Ada';
        let summary = `Tren harga dan CVD bergerak selaras (${priceTrend}).`;

            if (priceTrend === 'Naik' && cvdTrend === 'Turun') {
                divergence = 'Bearish 👎';
                summary = 'Harga naik tetapi tekanan beli melemah. Hati-hati, ini adalah sinyal divergensi bearish.';
            } else if (priceTrend === 'Turun' && cvdTrend === 'Naik') {
                divergence = 'Bullish 👍';
                summary = 'Harga turun tetapi tekanan beli menguat. Ini adalah sinyal divergensi bullish yang potensial.';
            }

            return {
                trend: cvdTrend,
                divergence: divergence,
                summary: summary
            };
    }
    const calculateCVD = (trades) => {
        let cumulativeDeltaCoin = 0;
        let cumulativeDeltaUsdt = 0;
        return trades.map(t => {
            const quantity = parseFloat(t.q);
            const price = parseFloat(t.p);
            const sign = t.m ? -1 : 1; // -1 untuk sell, 1 untuk buy
            
            cumulativeDeltaCoin += quantity * sign;
            cumulativeDeltaUsdt += (quantity * price) * sign;

            return { 
                time: t.T / 1000, 
                cvd_coin: cumulativeDeltaCoin,
                cvd_usdt: cumulativeDeltaUsdt 
            };
        });
    };
// =======================================================
    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { adx: 'N/A', plusDI: 'N/A', minusDI: 'N/A' };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { adx: adxValues.filter(v=>v!==undefined).pop()?.toFixed(2) || 'N/A', plusDI: plusDIs.pop()?.toFixed(2) || 'N/A', minusDI: minusDIs.pop()?.toFixed(2) || 'N/A' };
    };
// =======================================================    
    const findCandlestickPatterns = (klines) => {        
        if (!klines || klines.length < 3) {            
            return { pattern: 'TIDAK ADA', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: null };
        }
               
        const lastCandleTimestamp = klines[klines.length - 1][0];
        const getCandleDetails = (k) => {
            const [open, high, low, close] = k.slice(1, 5).map(parseFloat);
            return { open, high, low, close, body: Math.abs(close - open), isGreen: close > open, isRed: close < open };
        };

        const c1 = getCandleDetails(klines[klines.length - 1]); // Paling Baru
        const c2 = getCandleDetails(klines[klines.length - 2]);
        const c3 = getCandleDetails(klines[klines.length - 3]);

        
        let result = { pattern: 'TIDAK ADA', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: lastCandleTimestamp };

        // Cek Pola 3-Candle
        if (c3.isGreen && c2.isGreen && c1.isGreen && c1.close > c2.close && c2.close > c3.close) {
            result = { pattern: 'THREE WHITE SOLDIERS', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('THREE_WHITE_SOLDIERS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.isRed && c1.isRed && c1.close < c2.close && c2.close < c3.close) {
            result = { pattern: 'THREE BLACK CROWS', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('THREE_BLACK_CROWS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.body < c3.body * 0.3 && c1.isGreen && c1.close > c3.open) {
            result = { pattern: 'MORNING STAR', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('MORNING_STAR'), timestamp: lastCandleTimestamp };
        } else if (c3.isGreen && c2.body < c3.body * 0.3 && c1.isRed && c1.close < c3.open) {
            result = { pattern: 'EVENING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('EVENING_STAR'), timestamp: lastCandleTimestamp };
        }

        // Jika belum ketemu, cek Pola 2-Candle
        if (result.pattern === 'TIDAK ADA') {
            if (c2.isRed && c1.isGreen && c1.close > c2.open && c1.open < c2.close) {
                result = { pattern: 'BULLISH ENGULFING', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.close < c2.open && c1.open > c2.close) {
                result = { pattern: 'BEARISH ENGULFING', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.close && c1.close < c2.open && c1.close > (c2.open + c2.body/2)) {
                result = { pattern: 'DARK CLOUD COVER', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('DARK_CLOUD_COVER'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.close && c1.close > c2.open && c1.close < (c2.open - c2.body/2)) {
                result = { pattern: 'PIERCING LINE', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('PIERCING_LINE'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close) {
                result = { pattern: 'BEARISH HARAMI', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close) {
                result = { pattern: 'BULLISH HARAMI', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.high - c2.high) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER TOP', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('TWEEZER_TOP'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.low - c2.low) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER BOTTOM', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('TWEEZER_BOTTOM'), timestamp: lastCandleTimestamp };
            }
        }

        // Jika masih belum ketemu, cek Pola 1-Candle
        if (result.pattern === 'TIDAK ADA') {
            const lowerWick = Math.min(c1.open, c1.close) - c1.low;
            const upperWick = c1.high - Math.max(c1.open, c1.close);
            if (lowerWick > c1.body * 2 && upperWick < c1.body * 0.5) {
                result = { pattern: 'HAMMER', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('HAMMER'), timestamp: lastCandleTimestamp };
            } else if (upperWick > c1.body * 2 && lowerWick < c1.body * 0.5) {
                result = { pattern: 'SHOOTING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('SHOOTING_STAR'), timestamp: lastCandleTimestamp };
            }
        }
        
        return result;
    };
    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'TIDAK ADA', class: 'text-gray-500' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPeaks = (data, isHigh) => {
            let peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    peaks.push({ index: i, value: data[i] });
                }
            }
            return peaks;
        };
        const priceLows = findPeaks(recentCloses, false), priceHighs = findPeaks(recentCloses, true);
        const rsiLows = findPeaks(recentRSI, false), rsiHighs = findPeaks(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'TIDAK ADA', class: 'text-gray-500' };
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'TIDAK ADA', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'TIDAK ADA', class: 'text-gray-500' };
    };
// =======================================================    
    function getPatternSVG(patternName) {
        // Pengaturan dasar untuk semua SVG
        const svgHeader = `<svg viewBox="0 0 110 60" class="w-24 h-auto mx-auto my-2">`;
        const svgFooter = `</svg>`;
        const green = '#26a69a', red = '#ef5350', gray = '#2A1E27';

        let content = '';

        // Logika untuk membuat satu candle
        const createCandle = (x, open, high, low, close, color) => {
            const bodyY = Math.min(open, close);
            const bodyHeight = Math.abs(open - close);
            return `
                <line x1="${x+10}" y1="${high}" x2="${x+10}" y2="${low}" stroke="${color}" stroke-width="1"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" fill="${color}"/>
            `;
        };

        switch(patternName) {
            // --- POLA BULLISH ---
            case 'BULLISH_ENGULFING':
                content = createCandle(20, 40, 45, 25, 30, red) + createCandle(50, 28, 55, 10, 50, green);
                break;
            case 'HAMMER':
                content = createCandle(40, 50, 52, 10, 48, red);
                break;
            case 'MORNING_STAR':
                content = createCandle(10, 50, 55, 15, 20, red) + createCandle(40, 15, 20, 5, 12, gray) + createCandle(70, 18, 50, 15, 45, green);
                break;
            case 'THREE_WHITE_SOLDIERS':
                content = createCandle(10, 25, 35, 10, 30, green) + createCandle(40, 32, 45, 28, 40, green) + createCandle(70, 42, 55, 38, 50, green);
                break;
            case 'BULLISH_HARAMI':
                content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                break;
            case 'TWEEZER_BOTTOM':
                content = createCandle(20, 40, 45, 10, 20, red) + createCandle(50, 22, 48, 10, 35, green);
                break;
            // --- POLA BEARISH ---
            case 'BEARISH_ENGULFING':
                content = createCandle(20, 20, 45, 15, 40, green) + createCandle(50, 42, 55, 10, 15, red);
                break;
            case 'SHOOTING_STAR':
                content = createCandle(40, 12, 50, 10, 15, green);
                break;
            case 'EVENING_STAR':
                content = createCandle(10, 15, 50, 10, 45, green) + createCandle(40, 52, 58, 48, 50, gray) + createCandle(70, 48, 50, 15, 20, red);
                break;
            case 'THREE_BLACK_CROWS':
                content = createCandle(10, 50, 55, 30, 45, red) + createCandle(40, 42, 48, 20, 25, red) + createCandle(70, 22, 28, 5, 10, red);
                break;
            case 'BEARISH_HARAMI':
                content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                break;
            case 'TWEEZER_TOP':
                content = createCandle(20, 20, 55, 15, 40, green) + createCandle(50, 38, 55, 18, 25, red);
                break;
            default:
                return ''; // Tidak ada SVG untuk pola ini
        }

        return svgHeader + content + svgFooter;
    }
// =======================================================
    function getTimeAgo(date) {
        if (!(date instanceof Date) || isNaN(date)) {
            return 'beberapa saat lalu'; // Fallback jika tanggal tidak valid
        }
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 0) return 'baru saja'; // Handle jika ada sedikit perbedaan waktu
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " tahun lalu";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " bulan lalu";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " hari lalu";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " jam lalu";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " menit lalu";
        return Math.floor(seconds) + " detik lalu";
    }

// =======================================================
    function getExplorerUrl(networkName) {
        const explorerMap = {
            'eth': 'https://etherscan.io', // Perbaikan untuk Ethereum
            'ethereum': 'https://etherscan.io',
            'solana': 'https://solscan.io',
            'bsc': 'https://bscscan.com',
            'arbitrum': 'https://arbiscan.io',
            'base': 'https://basescan.org'
        };
        const baseUrl = explorerMap[networkName] || `https://${networkName}.info`;
        // Kembalikan URL terpisah untuk dompet dan transaksi
        return {
            address: `${baseUrl}/address/`,
            tx: `${baseUrl}/tx/`
        };
    }
// =======================================================
    function getHolderCategory(usdValue) {
        if (usdValue >= 500000) return { name: 'Humpback', class: 'text-purple-400' };
        if (usdValue >= 100000) return { name: 'Whale', class: 'text-blue-400' };
        if (usdValue >= 50000) return { name: 'Tuna', class: 'text-teal-400' };
        if (usdValue >= 10000) return { name: 'Dolphin', class: 'text-cyan-400' };
        if (usdValue >= 1000) return { name: 'Crab', class: 'text-yellow-400' };
        return { name: 'Shrimp', class: 'text-gray-400' };
    }
// =======================================================
    function findPivots(klines, lookback = 10) {
        const pivots = [];
        if (klines.length < lookback * 2 + 1) return [];

        for (let i = lookback; i < klines.length - lookback; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            let isHigh = true, isLow = true;

            for (let j = 1; j <= lookback; j++) {
                if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
            }
            if (isHigh) pivots.push({ type: 'high', price: high, index: i });
            else if (isLow) pivots.push({ type: 'low', price: low, index: i });
        }
        return pivots;
    }
// =======================================================
    function calculateSlope(p1, p2) {
        if (p2.index === p1.index) return Infinity; // Garis vertikal
        return (p2.price - p1.price) / (p2.index - p1.index);
    }
    
// =======================================================
    function detectHeadAndShoulders(pivots) {
        for (let i = 4; i < pivots.length; i++) {
            // Cek Head & Shoulders (Bearish): H, L, H, L, H
            const p1 = pivots[i-4], p2 = pivots[i-3], p3 = pivots[i-2], p4 = pivots[i-1], p5 = pivots[i];
            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high' && p4.type === 'low' && p5.type === 'high') {
                if (p3.price > p1.price && p3.price > p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'HEAD & SHOULDERS', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Inverse Head & Shoulders (Bullish): L, H, L, H, L
            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low' && p4.type === 'high' && p5.type === 'low') {
                 if (p3.price < p1.price && p3.price < p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'INVERSE H&S', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

// =======================================================
    function detectDoubles(pivots) {
        for (let i = 2; i < pivots.length; i++) {
            // Cek Double Top: H, L, H
            const p1_dt = pivots[i-2], p2_dt = pivots[i-1], p3_dt = pivots[i];
            if (p1_dt.type === 'high' && p2_dt.type === 'low' && p3_dt.type === 'high') {
                if (Math.abs(p1_dt.price - p3_dt.price) / p3_dt.price < 0.03 && p2_dt.price < p1_dt.price) {
                    return { pattern: 'DOUBLE TOP', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Double Bottom: L, H, L
            const p1_db = pivots[i-2], p2_db = pivots[i-1], p3_db = pivots[i];
            if (p1_db.type === 'low' && p2_db.type === 'high' && p3_db.type === 'low') {
                if (Math.abs(p1_db.price - p3_db.price) / p3_db.price < 0.03 && p2_db.price > p1_db.price) {
                    return { pattern: 'DOUBLE BOTTOM', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

// =======================================================
    function detectTriangles(pivots) {
        const recentPivots = pivots.slice(-7); // Fokus pada 7 pivot terakhir
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lastLow = lows[lows.length - 1], prevLow = lows[lows.length - 2];
            const lastHigh = highs[highs.length - 1], prevHigh = highs[highs.length - 2];

            const isLowsAscending = lastLow.price > prevLow.price;
            const isHighsFlat = Math.abs(lastHigh.price - prevHigh.price) / prevHigh.price < 0.015; // Toleransi 1.5%
            if (isLowsAscending && isHighsFlat) return { pattern: 'ASCENDING TRIANGLE', class: 'positive' };

            const isHighsDescending = lastHigh.price < prevHigh.price;
            const isLowsFlat = Math.abs(lastLow.price - prevLow.price) / prevLow.price < 0.015; // Toleransi 1.5%
            if (isHighsDescending && isLowsFlat) return { pattern: 'DESCENDING TRIANGLE', class: 'negative' };

            if (isLowsAscending && isHighsDescending) return { pattern: 'SYMMETRICAL TRIANGLE', class: 'text-yellow-400' };
        }
        return null;
    }
    
// =======================================================
    function detectWedges(pivots) {
        const recentPivots = pivots.slice(-7);
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lowSlope = calculateSlope(lows[lows.length - 2], lows[lows.length - 1]);
            const highSlope = calculateSlope(highs[highs.length - 2], highs[highs.length - 1]);

            // Rising Wedge: Kedua garis miring ke atas, garis bawah lebih curam.
            if (lowSlope > 0 && highSlope > 0 && lowSlope > highSlope) {
                 return { pattern: 'RISING WEDGE', class: 'negative blinking-text-animation' };
            }
            // Falling Wedge: Kedua garis miring ke bawah, garis atas lebih curam (nilai absolutnya).
            if (lowSlope < 0 && highSlope < 0 && Math.abs(highSlope) > Math.abs(lowSlope)) {
                return { pattern: 'FALLING WEDGE', class: 'positive blinking-text-animation' };
            }
        }
        return null;
    }

// =======================================================
    function detectFlags(klines) {
        const lookback = 30; // Jarak untuk mencari "tiang"
        const flagLength = 10; // Panjang "bendera"
        if (klines.length < lookback + flagLength) return null;
        
        const closes = klines.map(k => parseFloat(k[4]));
        const poleStartPrice = closes[closes.length - flagLength - lookback];
        const poleEndPrice = closes[closes.length - flagLength];
        const priceChange = (poleEndPrice - poleStartPrice) / poleStartPrice;
        
        // Bull Flag: Tiang naik tajam (>5%), diikuti konsolidasi
        if (priceChange > 0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            // Konsolidasi harus berada di bagian atas tiang
            if (flagLow > poleStartPrice + (poleEndPrice - poleStartPrice) * 0.5) {
                return { pattern: 'BULL FLAG', class: 'positive' };
            }
        }
        // Bear Flag: Tiang turun tajam (<-5%), diikuti konsolidasi
        if (priceChange < -0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            // Konsolidasi harus berada di bagian bawah tiang
            if (flagHigh < poleStartPrice - (poleStartPrice - poleEndPrice) * 0.5) {
                return { pattern: 'BEAR FLAG', class: 'negative' };
            }
        }
        return null;
    }

// =======================================================
    function findChartPatterns(klines) {
        if (!klines || klines.length < 50) {
            return { pattern: 'Data Kurang', class: 'text-gray-500' };
        }
        
        const pivots = findPivots(klines, 10);
        let pattern;
            
        // Urutkan dari pola yang paling signifikan atau kompleks
        pattern = detectHeadAndShoulders(pivots);
        if (pattern) return pattern;

        pattern = detectDoubles(pivots);
        if (pattern) return pattern;
        
        pattern = detectWedges(pivots);
        if (pattern) return pattern;

        pattern = detectTriangles(pivots);
        if (pattern) return pattern;

        pattern = detectFlags(klines);
        if (pattern) return pattern;

        return { pattern: 'Tidak Terdeteksi', class: 'text-gray-500' };
    }
// =======================================================
// == BLOK FUNGSI BARU UNTUK DETEKSI POLA CHART (SELESAI) ==
// =======================================================
    function findLastSignificantSwing(klines) {
        const pivots = findPivots(klines.slice(-100), 5); // Analisa 100 candle terakhir
        if (pivots.length < 3) return null;

        const lastPivot = pivots[pivots.length - 1];
        const prevPivot = pivots[pivots.length - 2];
        const prevPrevPivot = pivots[pivots.length - 3];

        // Swing untuk potensi LONG (kita mencari titik A, B, C: Low -> High -> Low)
        if (lastPivot.type === 'low' && prevPivot.type === 'high' && prevPrevPivot.type === 'low') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'UP' };
        }
        // Swing untuk potensi SHORT (kita mencari titik A, B, C: High -> Low -> High)
        if (lastPivot.type === 'high' && prevPivot.type === 'low' && prevPrevPivot.type === 'high') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'DOWN' };
        }
        return null;
    }

// =======================================================
    function calculateFibonacciExtension(swing) {
        if (!swing) return null;
        const impulseMove = Math.abs(swing.B.price - swing.A.price);
        if (swing.type === 'UP') {
            return swing.C.price + (impulseMove * 1.618);
        } else { // DOWN
            return swing.C.price - (impulseMove * 1.618);
        }
    }
    
// =================kalkulasi entri dan tp/sl======================================    
function calculateAndDisplayScalpingSetup() {
    // [DIRAPIKAN] Ambil semua data yang dibutuhkan di awal
    const { klines, calculatedData, symbol, selectedTimeframe, klines1h } = realtimeCache.main;
    
    if (!klines || klines.length < 50 || !calculatedData) {
        document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Data tidak cukup.</p>';
        return;
    }

    // [DIPERBAIKI] Atur judul panel
    document.getElementById('scalping-timeframe-display').textContent = `${symbol} - ${selectedTimeframe}`;

    // --- BAGIAN 1: Mengisi Modul Hybrid Bar & Rincian Trigger ---
    const scoreData = calculateShortConfluenceScore(symbol) || { score: 0, breakdown: {} };
    const dumpRiskScore = scoreData.score;
    const triggerBreakdown = scoreData.breakdown;
    const pumpStrength = realtimeCache.main.liveScores.pumpStrength || 0;

    document.getElementById('main-pump-bar').style.width = `${pumpStrength}%`;
    document.getElementById('main-dump-bar').style.width = `${dumpRiskScore * 10}%`;
    document.getElementById('main-pump-score').textContent = `${pumpStrength.toFixed(0)}%`;
    document.getElementById('main-dump-score').textContent = `${dumpRiskScore}/10`;
    renderTriggerBreakdown(triggerBreakdown);

    // --- BAGIAN 2: Menghitung & Menampilkan Setup Scalping (Entri, SL, TP) ---
    const container = document.getElementById('scalping-setup-content');
    const closes = klines.map(k => parseFloat(k[4]));
    const lastPrice = closes[closes.length - 1];

    // === Tentukan BIAS KONTEKSTUAL terlebih dahulu ===
    let biasKontekstual = "NETRAL / CHOP";
    let biasClass = "status-chop";
    let biasDetail = "Menunggu sinyal...";

    let trenUtama = "CHOP";
    if (klines1h && klines1h.length > 50) {
        const closes1h = klines1h.map(k => parseFloat(k[4]));
        const ema21_1h = calculateEMA(closes1h, 21).pop();
        const ema50_1h = calculateEMA(closes1h, 50).pop();
        if (ema21_1h > ema50_1h) trenUtama = "UPTREND";
        if (ema50_1h > ema21_1h) trenUtama = "DOWNTREND";
    }

    const analisisTrigger = getConfluenceAnalysis(klines); 
    const { skorBullish, skorBearish, detail } = analisisTrigger;
    biasDetail = detail;

    if (skorBullish > skorBearish + 1.5) {
        if (trenUtama === 'UPTREND') {
            biasKontekstual = 'LONG (Follow Trend)';
            biasClass = 'status-uptrend';
        } else if (trenUtama === 'DOWNTREND') {
            biasKontekstual = 'LONG (Counter Trend)';
            biasClass = 'status-uptrend';
        } else {
            biasKontekstual = 'LONG (Range Trading)';
            biasClass = 'status-uptrend';
        }
    } else if (skorBearish > skorBullish + 1.5) {
        if (trenUtama === 'DOWNTREND') {
            biasKontekstual = 'SHORT (Follow Trend)';
            biasClass = 'status-downtrend';
        } else if (trenUtama === 'UPTREND') {
            biasKontekstual = 'SHORT (Counter Trend)';
            biasClass = 'status-downtrend';
        } else {
            biasKontekstual = 'SHORT (Range Trading)';
            biasClass = 'status-downtrend';
        }
    }

    // === [FINAL] Gabungan perbaikan: Cek kondisi NETRAL terlebih dahulu ===
    if (biasKontekstual !== "NETRAL / CHOP") {
        // --- JIKA TIDAK NETRAL, LAKUKAN SEMUA KALKULASI SL/TP ---
        const biasKalkulator = biasKontekstual.startsWith('LONG') ? 'LONG' : 'SHORT';
        const ema9 = calculateEMA(closes, 9).pop();
        
        let entryPrice, stopLoss, takeProfit1, takeProfit2, takeProfit3;
        const recentKlines = klines.slice(-15);
        const recentSwingHigh = Math.max(...recentKlines.map(k => parseFloat(k[2])));
        const recentSwingLow = Math.min(...recentKlines.map(k => parseFloat(k[3])));

        if (biasKalkulator === 'LONG') {
            entryPrice = ema9; 
            stopLoss = recentSwingLow * 0.999;
            takeProfit1 = recentSwingHigh;

            const rrTarget2 = entryPrice + (Math.abs(entryPrice - stopLoss) * 1.5);
            takeProfit2 = Math.max(rrTarget2, takeProfit1);

            const upperBB = calculatedData.bollingerBands.upper.filter(v=>v).pop();
            const dailyPivot = calculatedData.pivot.data?.P;
            let potentialTP3s = [upperBB, dailyPivot].filter(p => p && p > takeProfit2);
            takeProfit3 = potentialTP3s.length > 0 ? Math.min(...potentialTP3s) : 'N/A';

        } else { // SHORT
            entryPrice = ema9; 
            stopLoss = recentSwingHigh * 1.001;
            takeProfit1 = recentSwingLow;

            const rrTarget2 = entryPrice - (Math.abs(stopLoss - entryPrice) * 1.5);
            takeProfit2 = Math.min(rrTarget2, takeProfit1);

            const lowerBB = calculatedData.bollingerBands.lower.filter(v=>v).pop();
            const dailyPivot = calculatedData.pivot.data?.P;
            let potentialTP3s = [lowerBB, dailyPivot].filter(p => p && p < takeProfit2);
            takeProfit3 = potentialTP3s.length > 0 ? Math.max(...potentialTP3s) : 'N/A';
        }

        const calculatePercentage = (targetPrice, entry) => {
            if (typeof targetPrice !== 'number' || entry === 0) return '';
            return `(${( (targetPrice - entry) / entry * 100).toFixed(2)}%)`;
        };

        const entryPercent = `(Pullback ke ${calculatePercentage(entryPrice, lastPrice)})`;
        const slPercent = calculatePercentage(stopLoss, entryPrice);
        const tp1Percent = calculatePercentage(takeProfit1, entryPrice);
        const tp2Percent = calculatePercentage(takeProfit2, entryPrice);
        const tp3Percent = calculatePercentage(takeProfit3, entryPrice);
        const slColorClass = 'negative';
        const tpColorClass = 'positive';
        const tp3Display = takeProfit3 !== 'N/A' ? `${formatPrice(takeProfit3)}<br><span class="text-xs font-mono ${tpColorClass}">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';

        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                <div class="col-span-1">
                     <p class="text-xs text-gray-500">Bias Kontekstual (TF: 1H)</p>
                     <p class="font-bold text-lg blinking-text-animation ${biasClass}">${biasKontekstual}</p>
                     <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
                </div>
                <div class="col-span-2 grid grid-cols-2 gap-4">
                     <div>
                        <p class="text-xs text-gray-500">Saran Entri</p>
                        <p class="font-semibold text-sm text-yellow-400">${formatPrice(entryPrice)}</p>
                        <p class="text-xs font-mono text-yellow-500">${entryPercent}</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-500">SL (Struktural)</p>
                        <p class="font-semibold text-sm ${slColorClass}">${formatPrice(stopLoss)}</p>
                        <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                    </div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">TP 1 (Struktural)</p>
                    <p class="font-semibold ${tpColorClass}">${formatPrice(takeProfit1)}</p>
                    <p class="text-xs font-mono ${tpColorClass}">${tp1Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 2 (R:R 1:1.5)</p>
                    <p class="font-semibold ${tpColorClass}">${formatPrice(takeProfit2)}</p>
                    <p class="text-xs font-mono ${tpColorClass}">${tp2Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 3 (Level Kunci)</p>
                    <p class="font-semibold text-sm">${tp3Display}</p>
                </div>
            </div>
        `;
        
        calculatePositionSize({ entry: entryPrice, sl: stopLoss, tp1: takeProfit1 });
        realtimeCache.main.latestScalpingSetup = { entry: entryPrice, sl: stopLoss, tp1: takeProfit1 };

    } else { // --- JIKA NETRAL, TAMPILKAN PESAN PERINGATAN ---
        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                 <div class="col-span-3">
                     <p class="text-xs text-gray-500">Bias Kontekstual (TF: 1H)</p>
                     <p class="font-bold text-lg ${biasClass}">${biasKontekstual}</p>
                     <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-center p-4 rounded-lg bg-gray-100 dark:bg-gray-800/50">
                <p class="font-semibold text-yellow-400">PASAR SIDEWAYS</p>
                <p class="text-sm text-gray-400 mt-1">Tidak ada setup Long/Short yang jelas. Disarankan untuk tidak masuk posisi.</p>
            </div>
        `;
        
        calculatePositionSize(null);
        realtimeCache.main.latestScalpingSetup = null;
    }
}

// =======================================================
    function calculatePositionSize(levels) {
        const riskAmountInput = document.getElementById('risk-amount-input');
        const leverageInput = document.getElementById('leverage-input'); // [BARU] Ambil input leverage
        const riskAmount = parseFloat(riskAmountInput.value);
        const leverage = parseFloat(leverageInput.value) || 1; // [BARU] Ambil nilai leverage

        const positionSizeEl = document.getElementById('position-size-display');
        const positionSizeUsdEl = document.getElementById('position-size-usd-display');
        const rrRatioEl = document.getElementById('rr-ratio-display');
        const marginRequiredEl = document.getElementById('margin-required-display'); // [BARU] Elemen untuk margin

        if (!levels || !riskAmount || isNaN(riskAmount) || riskAmount <= 0) {
            positionSizeEl.textContent = '-';
            positionSizeUsdEl.textContent = '-';
            rrRatioEl.textContent = '-';
            marginRequiredEl.textContent = '-'; // [BARU] Reset margin
            return;
        }

        const { entry, sl, tp1 } = levels;
        const stopLossDistance = Math.abs(entry - sl);
        const takeProfitDistance = Math.abs(tp1 - entry);
        
        if (stopLossDistance === 0) return;

        // Kalkulasi Ukuran Posisi (Notional) - Tetap sama
        const positionSizeCoin = riskAmount / stopLossDistance;
        const positionSizeUsd = positionSizeCoin * entry;
        positionSizeEl.textContent = positionSizeCoin.toFixed(4);
        positionSizeUsdEl.textContent = `($${positionSizeUsd.toLocaleString('en-US', {maximumFractionDigits: 0})})`;

        // [BARU] Kalkulasi Margin yang Dibutuhkan
        const marginRequired = positionSizeUsd / leverage;
        marginRequiredEl.textContent = `$${marginRequired.toLocaleString('en-US', {maximumFractionDigits: 2})}`;

        // Kalkulasi Risk/Reward Ratio - Tetap sama
        const rrRatio = takeProfitDistance / stopLossDistance;
        rrRatioEl.textContent = `1 : ${rrRatio.toFixed(2)}`;
    }

// [BARU] Tambahkan event listener untuk input leverage
    document.getElementById('leverage-input').addEventListener('input', () => {
        if (realtimeCache.main.latestScalpingSetup) {
            calculatePositionSize(realtimeCache.main.latestScalpingSetup);
        }
    });
// =======================================================
    function calculateATRPercentage(klines, period = 14) {
        if (!klines || klines.length === 0) {
            return 0; // Kembalikan 0 jika tidak ada data
        }
        
        // Panggil fungsi ATR yang sudah ada
        const atrResult = calculateATR(klines, period);
        const atrValue = atrResult.value;

        // Ambil harga penutupan terakhir
        const lastClose = parseFloat(klines[klines.length - 1][4]);

        if (lastClose === 0) {
            return 0; // Hindari pembagian dengan nol
        }

        // Hitung dan kembalikan dalam bentuk persen
        const atrPercent = (atrValue / lastClose) * 100;
        
        return atrPercent;
    }
// =======================================================
    async function fetchGeckoTerminal(endpoint) {
        const baseUrl = 'https://api.geckoterminal.com/api/v2';
        const url = `${baseUrl}/${endpoint}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GeckoTerminal API error: ${errorData.errors?.[0]?.title || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from GeckoTerminal ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari GeckoTerminal.`);
        }
    }
// =======================================================
    function renderTrendingPools(poolsData) {
        let html = '';
        const topPools = poolsData.slice(0, 5); // Ambil 5 teratas

        topPools.forEach(pool => {
            const attributes = pool.attributes;
            const priceChange = parseFloat(attributes.price_change_percentage.h24);
            const colorClass = priceChange >= 0 ? 'positive' : 'negative';
            const volume = parseFloat(attributes.volume_usd.h24);

            html += `
                <div class="p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                    <div class="flex justify-between items-center font-semibold">
                        <span>${attributes.name}</span>
                        <span class="${colorClass}">${priceChange.toFixed(2)}%</span>
                    </div>
                    <div class="text-xs text-gray-400 flex justify-between mt-1">
                        <span>Vol 24j: $${(volume / 1_000_000).toFixed(2)}jt</span>
                        <span>Jaringan: ${pool.relationships.network.data.id}</span>
                    </div>
                </div>
            `;
        });
        trendingPoolsContent.innerHTML = html;
    }
// =======================================================
// GANTI SELURUH FUNGSI runFullAnalysis DENGAN KODE DI BAWAH INI
// =======================================================
    async function runFullAnalysis(symbol = null) {
        // Bagian awal (setup)
        adaptIndicatorParamsToTimeframe(timeframeSelect.value);
        WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
        WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
        WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));
        orderBookDOMElements = null;
        hideError();
        showLoader(true, 'Memulai Analisa...');

        destroyCharts();
        specificTokenTitle.innerHTML = 'Analisis Token Spesifik';
        specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Mencari data on-chain...</p>`;
        trendingPoolsContent.innerHTML = `<div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div>`;
        
        try {
            // Reset UI AI
            const aiContentContainer = document.getElementById('ai-content-container');
            if (aiContentContainer) aiContentContainer.classList.add('hidden');
            const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
            if (comprehensiveBtn) {
                const btnText = comprehensiveBtn.querySelector('span');
                const btnLoader = comprehensiveBtn.querySelector('.loader');
                btnText.classList.remove('hidden');
                btnLoader.classList.add('hidden');
                comprehensiveBtn.disabled = false;
            }

            // Ambil input
            // PERBAIKAN: Gunakan nilai dari input jika symbol kosong atau tidak valid
            const binanceSymbol = (symbol || assetInput.value.trim() || 'BTCUSDT').toUpperCase();
            
            // PERBAIKAN: Jika symbol dari klik, update juga kotak inputnya
            if (symbol) { 
                assetInput.value = symbol;
            }
            
            const correlationAsset = document.getElementById('correlation-asset-input').value.trim().toUpperCase() || 'BTCUSDT';
            const marketType = marketTypeSelect.value;
            const selectedTimeframe = timeframeSelect.value;
            
            // Validasi Simbol
            await validateBinanceSymbol(binanceSymbol, marketType);

            // --- PENGAMBILAN DATA PARALEL (CEPAT & AMAN) ---
            showLoader(true, 'Mengambil semua data pasar...');
            const baseAsset = binanceSymbol.replace(/USDT$|^\d+/g, '');

            // Siapkan semua 'janji' (Promise) untuk dijalankan bersamaan
            let promisesToRun = [
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: selectedTimeframe, limit: 500 }, marketType), // TF Pilihan
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1h', limit: 200 }, marketType), // <-- TAMBAHKAN INI (Kompas 1H)
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '15m', limit: 200 }, marketType), // <-- TAMBAHKAN INI (Kompas 15M)
                fetchBinanceAPIData('ticker/24hr', { symbol: binanceSymbol }, marketType),
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 30 }, marketType),
                fetchBinanceAPIData('klines', { symbol: correlationAsset, interval: '1d', limit: 30 }, 'spot'),
                fetchBinanceAPIData('depth', { symbol: binanceSymbol, limit: 100 }, marketType),
                fetchUsdToIdrRate(),
                fetch('https://api.coingecko.com/api/v3/global').then(res => res.json()),
                // Promise untuk mengambil data CoinGecko, dibungkus agar tidak menghentikan proses jika gagal
                (async () => {
                    try {
                        const coinGeckoId = await getCoinGeckoId(baseAsset);
                        return await fetchCoinGeckoData(coinGeckoId);
                    } catch (e) {
                        console.warn(`Gagal mengambil data CoinGecko: ${e.message}`);
                        return null; // Kembalikan null jika gagal
                    }
                })()
            ];

            // Jika pasar adalah futures, tambahkan promise khusus futures
            if (marketType === 'futures') {
                promisesToRun.push(
                    fetchBinanceAPIData('openInterest', { symbol: binanceSymbol }, 'futures'),
                    fetchBinanceAPIData('premiumIndex', { symbol: binanceSymbol }, 'futures'),
                    fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                    fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
                );
            }

            // Jalankan semua promise secara paralel dan tunggu hasilnya
        const results = await Promise.allSettled(promisesToRun);

        // ======================= AWAL BLOK PENGGANTI =======================
        // Ekstrak data dari hasil dengan indeks yang sudah dikoreksi total
        const klines = results[0].status === 'fulfilled' ? results[0].value : null;
        const klines1h = results[1].status === 'fulfilled' ? results[1].value : null;
        const klines15m = results[2].status === 'fulfilled' ? results[2].value : null;
        const tickerData = results[3].status === 'fulfilled' ? results[3].value : null;
        const assetDailyKlines = results[4].status === 'fulfilled' ? results[4].value : null;
        const btcDailyKlines = results[5].status === 'fulfilled' ? results[5].value : null;
        const orderBookData = results[6].status === 'fulfilled' ? results[6].value : null; // <-- INI YANG KRUSIAL
        const usdToIdrRate = results[7].status === 'fulfilled' ? results[7].value : 16200;
        const globalData = results[8].status === 'fulfilled' ? results[8].value : null;
        const coinGeckoData = results[9].status === 'fulfilled' ? results[9].value : null;

        // Ekstrak data futures jika ada
        let openInterestData = null, fundingRateData = null, lsRatioUmumData = null, lsRatioTopData = null;
        if (marketType === 'futures' && results.length > 10) {
            openInterestData = results[10].status === 'fulfilled' ? results[10].value : null;
            fundingRateData = results[11].status === 'fulfilled' ? results[11].value : null;
            lsRatioUmumData = results[12].status === 'fulfilled' ? results[12].value : null;
            lsRatioTopData = results[13].status === 'fulfilled' ? results[13].value : null;
        }
        // ======================= AKHIR BLOK PENGGANTI =======================

        // Validasi: Pastikan data paling penting berhasil dimuat
        if (!klines || !tickerData) {
            throw new Error("Gagal memuat data esensial (Kline & Ticker) dari Binance. Coba lagi.");
        }

            // Cache kline data setelah berhasil diambil
            klineCache[binanceSymbol + selectedTimeframe] = { data: klines, timestamp: Date.now() };

            let correlationValue = null;
            if (binanceSymbol !== 'BTCUSDT' && assetDailyKlines && btcDailyKlines && assetDailyKlines.length === btcDailyKlines.length) {
                correlationValue = calculateCorrelation(assetDailyKlines.map(k=>parseFloat(k[4])), btcDailyKlines.map(k=>parseFloat(k[4])));
            }

            // KODE LENGKAP & BENAR
            realtimeCache.main = { 
                symbol: binanceSymbol,
                tickerData, 
                klines,
                klines1h, // <-- TAMBAHKAN INI
                klines15m, // <-- TAMBAHKAN INI
                orderBookData, 
                usdToIdrRate, 
                globalData, 
                coinGeckoData, 
                openInterestData, 
                fundingRateData, 
                lsRatioUmumData, 
                lsRatioTopData, 
                binanceSymbol, 
                selectedTimeframe, 
                correlationData: correlationValue,
                liveScores: { pumpStrength: 0, dumpRisk: 0 } // <-- INI YANG DITAMBAHKAN
            };


            showLoader(true, 'Menghitung indikator...');

            const allTrades = await fetchBinanceAPIData('aggTrades', { symbol: binanceSymbol, limit: 1000 }, marketType);
            const cvdData = calculateCVD(allTrades);
            realtimeCache.main.cvdData = cvdData;

            const closes = klines.map(k => parseFloat(k[4]));
            const lastPrice = closes[closes.length - 1];
            const rsiValues = calculateRSI(closes);
            const ema21Values = calculateEMA(closes, 21);
            const ema50Values = calculateEMA(closes, 50);
            const lastEma21 = ema21Values.filter(v => v !== undefined).pop();
            const lastEma50 = ema50Values.filter(v => v !== undefined).pop();

            let trendStatus = 'Netral';
            let trendClass = 'text-yellow-400';
            if (lastEma21 > lastEma50) {
                if (lastPrice > lastEma21) {
                    trendStatus = 'Uptrend Kuat';
                    trendClass = 'positive';
                } else {
                    trendStatus = 'Koreksi dalam Uptrend';
                    trendClass = 'text-yellow-400';
                }
            } else if (lastEma50 > lastEma21) {
                if (lastPrice < lastEma21) {
                    trendStatus = 'Downtrend Kuat';
                    trendClass = 'negative';
                } else {
                    trendStatus = 'Reli dalam Downtrend';
                    trendClass = 'text-yellow-400';
                }
            }
            
            const pivotPoints = calculatePivotPoints(assetDailyKlines[assetDailyKlines.length - 2]);
            const ichimoku = calculateIchimokuCloud(klines);
            const keltnerChannels = calculateKeltnerChannels(klines);
            const activeMode = document.querySelector('.vwap-mode-btn.active')?.dataset.mode || 'rolling';
            const vwapValue = calculateVWAP(klines, activeMode);
            const vwapStatus = lastPrice > vwapValue ? 'Bullish' : 'Bearish';

            realtimeCache.main.calculatedData = {
                adx: calculateADX(klines), 
                cvd: CVDanalyze(klines, cvdData), 
                vpvr: calculateVPVR(klines),
                ma: { status: trendStatus, class: trendClass, value21: lastEma21, value50: lastEma50 },
                rsi: { values: rsiValues, last: rsiValues.filter(v => v !== undefined).pop()?.toFixed(2) || 50, status: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'Overbought' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'Oversold' : 'Netral'), class: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'tag-red' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'tag-green' : 'tag-yellow') },
                rsiDivergence: detectRSIDivergence(closes, rsiValues), 
                obvDivergence: detectOBVDivergence(closes, klines),
                stoch: calculateStochasticRSI(closes), 
                macd: calculateMACD(closes),
                bollingerBands: calculateBollingerBands(closes), 
                atr: calculateATR(klines),
                atrPercent: calculateATRPercentage(klines), 
                candlePattern: findCandlestickPatterns(klines),
                chartPattern: findChartPatterns(klines), 
                roc: calculateROC(closes), 
                psar: calculateParabolicSAR(klines), 
                linreg: calculateLinearRegressionChannel(closes),
                vwap: { status: vwapStatus, value: vwapValue },
                pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
                ichimoku: { status: ichimoku?.status || 'Netral', data: ichimoku },
                keltnerChannels: keltnerChannels,
                fundingRate: realtimeCache.main.fundingRateData,
                lsRatio: realtimeCache.main.lsRatioUmumData?.[0],
                openInterest: { status: (realtimeCache.main.openInterestData?.openInterest > 0 && parseFloat(realtimeCache.main.tickerData.priceChangePercent) > 0) ? 'Bullish' : (realtimeCache.main.openInterestData?.openInterest > 0 && parseFloat(realtimeCache.main.tickerData.priceChangePercent) < 0) ? 'Bearish' : 'Netral' }
            };

            const bbPriceAction = analyzeBollingerBandsPriceAction(klines, realtimeCache.main.calculatedData.bollingerBands);
            realtimeCache.main.calculatedData.bollingerBands.rejection = bbPriceAction.rejection;
            realtimeCache.main.calculatedData.bollingerBands.walkTheBands = bbPriceAction.walkTheBands;
            const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
            realtimeCache.main.tfAlignmentSummary = tfAlignmentSummary;
            const marketRegime = determineMarketRegime(klines, closes);
            realtimeCache.main.marketRegime = marketRegime;

            updateDashboardUI();
            
            const navPriceEl = document.getElementById('nav-price');
            const navIdrEl = document.getElementById('nav-price-idr');
            if(navPriceEl && navIdrEl) {
                navPriceEl.textContent = formatPrice(parseFloat(tickerData.lastPrice));
                navIdrEl.textContent = `Rp ${(parseFloat(tickerData.lastPrice) * (realtimeCache.main.usdToIdrRate || 0)).toLocaleString('id-ID', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            }
            
            if (orderBookData) {
                latestBids = orderBookData.bids;
                latestAsks = orderBookData.asks;
                const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
                const precision = getPrecisionForAsset(parseFloat(latestPrice));
                const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
                renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
            }

            const symbolLower = binanceSymbol.toLowerCase();
            const streamsToSub = [
                `${symbolLower}@kline_${selectedTimeframe}`,
                `${symbolLower}@aggTrade`,
                `${symbolLower}@depth20@100ms`
            ];
            WebSocketManager.subscribe(streamsToSub);

            (async () => {
                try {
                    const searchQuery = (await getCoinGeckoId(baseAsset).then(id => fetchCoinGeckoData(id)).catch(() => null))?.platforms?.ethereum || baseAsset;
                    specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span>`;
                    const searchResult = await fetchGeckoTerminal(`search/pools?query=${searchQuery}`);
                    if (searchResult.data && searchResult.data.length > 0) {
                        searchResult.data.sort((a, b) => parseFloat(b.attributes.reserve_in_usd) - parseFloat(a.attributes.reserve_in_usd));
                        const topPool = searchResult.data[0];
                        const attrs = topPool.attributes;
                        const networkName = topPool.id.split('_')[0];
                        const dexName = topPool.relationships?.dex?.data?.id.split('_').join(' ') || attrs.name.split(' ').pop();
                        if (networkName.includes('sepolia')) {
                            document.getElementById('onchain-card').style.display = 'none';
                            return;
                        } else {
                            document.getElementById('onchain-card').style.display = 'block';
                        }
                        specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span> <span class="text-xs text-gray-400 capitalize">(${networkName} / ${dexName})</span>`;
                        const price = formatPrice(parseFloat(attrs.base_token_price_usd));
                        const volume = (parseFloat(attrs.volume_usd.h24) / 1000000).toFixed(2);
                        const liquidity = attrs.reserve_in_usd ? (parseFloat(attrs.reserve_in_usd) / 1000000).toFixed(2) : 'N/A';
                        let staticContentHtml = `<div class="flex justify-between items-baseline"><span class="text-gray-500 capitalize">Harga DEX (${dexName})</span><span class="font-bold text-lg text-yellow-400">${price}</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Volume 24j DEX</span><span>$${volume}jt</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Likuiditas Pool</span><span>$${liquidity}jt</span></div>`;
                        specificTokenContent.innerHTML = staticContentHtml;
                        try {
                            const poolAddress = attrs.address;
                            const tradesData = await fetchGeckoTerminal(`networks/${networkName}/pools/${poolAddress}/trades`);
                            const tradeEvents = tradesData.data.filter(trade => trade.attributes.kind === 'buy' || trade.attributes.kind === 'sell').map(trade => ({ kind: trade.attributes.kind, usd: parseFloat(trade.attributes.volume_in_usd), price: parseFloat(trade.attributes.price_in_usd || attrs.base_token_price_usd), time: new Date(trade.attributes.block_timestamp), trader: trade.attributes.tx_from_address, network: topPool.id.split('_')[0] })).filter(event => event.usd >= 5000).slice(0, 100);
                            if (tradeEvents.length > 0) {
                                let buyVolume = 0, sellVolume = 0;
                                let buyCount = 0, sellCount = 0;
                                tradeEvents.forEach(event => { if (event.kind === 'buy') { buyVolume += event.usd; buyCount++; } else { sellVolume += event.usd; sellCount++; } });
                                realtimeCache.main.onChainSummary = { totalBuyVolume: buyVolume, totalSellVolume: sellVolume, buyTransactions: buyCount, sellTransactions: sellCount, sentiment: buyVolume > sellVolume ? 'Dominan Beli' : 'Dominan Jual', netVolume: buyVolume - sellVolume };
                                let html = '<hr class="border-slate-700/50 my-3"/><h4 class="text-lg font-semibold mb-2">100 Trans Terbaru di DEX >$5000 </h4>';
                                tradeEvents.forEach(event => {
                                    const category = getHolderCategory(event.usd);
                                    const timeAgo = getTimeAgo(event.time);
                                    const specificTime = event.time.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
                                    const walletLink = `https://dexcheck.ai/app/wallet-analyzer/${event.trader}`;
                                    const bgColor = event.kind === 'buy' ? 'bg-green-900/40 dark:bg-green-800/20' : 'bg-red-900/40 dark:bg-red-800/20';
                                    const amountColor = event.kind === 'buy' ? 'text-green-400' : 'text-red-400';
                                    const icon = event.kind === 'buy' ? '🟢' : '🔴';
                                    const actionText = event.kind === 'buy' ? 'BELI' : 'JUAL';
                                    html += `<div class="p-2 rounded-md ${bgColor}"><div class="flex justify-between items-center font-semibold"><span>${icon} ${actionText}</span><span class="${amountColor}">$${event.usd.toLocaleString('en-US', {maximumFractionDigits: 0})}</span></div><div class="text-xs text-gray-400 flex justify-between items-center mt-1"><span class="${category.class} font-bold">[${category.name}]</span><span class="font-mono text-yellow-400">@ ${formatPrice(event.price)}</span><span>${timeAgo} <span class="text-gray-500">(${specificTime})</span></span><a href="${walletLink}" target="_blank" class="underline hover:text-white">Lihat Dompet 🔗</a></div></div>`;
                                });
                                specificTokenContent.innerHTML += html;
                            } else {
                            realtimeCache.main.onChainSummary = null;
                            specificTokenContent.innerHTML += `<p class="text-xs text-gray-500 text-center pt-2">Tidak ada transaksi jual/beli signifikan baru-baru ini.</p>`;
                            }
                        } catch (tradeError) {
                            specificTokenContent.innerHTML += `<p class="text-xs text-red-500 text-center pt-2">Gagal memuat jejak trader: ${tradeError.message}</p>`;
                        }
                    } else {
                        specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Tidak ditemukan pool on-chain untuk ${baseAsset.toUpperCase()}.</p>`;
                    }
                } catch (dexError) {
                    specificTokenContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data token spesifik: ${dexError.message}</p>`;
                }
            })();

            (async () => {
                try {
                    const trendingData = await fetchGeckoTerminal('networks/trending_pools');
                    renderTrendingPools(trendingData.data);
                } catch (trendingError) {
                    trendingPoolsContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data trending: ${trendingError.message}</p>`;
                }
            })();
        } catch (error) {
            console.error("Analisis Gagal:", error);
            showError(error.message);
        } finally {
            showLoader(false);
            if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
            if (processingInterval) clearInterval(processingInterval);
            periodicUpdateInterval = setInterval(updatePeriodicData, 300000);
            processingInterval = setInterval(processQueues, 500);
        }
    }
// ===========end of async function runFullAnalysis(symbol = null) {============================================
// =============================================================================================================
    function saveWatchlist() {
        const symbols = watchlistInput.value.split(',')
            .map(s => s.trim().toUpperCase())
            .filter(s => s.length > 0);
        
        watchlist = [...new Set(symbols)]; // Hapus duplikat
        localStorage.setItem('ultimateAppWatchlist', JSON.stringify(watchlist));
        watchlistInput.value = watchlist.join(', ');
        alert('Watchlist disimpan!');
    }

// =======================================================
function loadWatchlist() {
    const savedWatchlist = localStorage.getItem('ultimateAppWatchlist');

    if (savedWatchlist && JSON.parse(savedWatchlist).length > 0) {
        // Jika ada watchlist yang tersimpan, gunakan itu.
        watchlist = JSON.parse(savedWatchlist);
    } else {
        // Jika tidak ada atau kosong, gunakan daftar default.
        watchlist = ['BTCUSDT'];
    }

    // Tampilkan watchlist ke input box.
    watchlistInput.value = watchlist.join(', ');
}
// =======================================================
    async function getConfluenceScoreForSymbol(symbol) {
        try {
            // Sekarang hanya mengambil data ticker 24 jam yang ringan
            const tickerData = await fetchBinanceAPIData('ticker/24hr', { symbol }, 'spot');
            
            return {
                symbol,
                price: parseFloat(tickerData.lastPrice),
                change24h: parseFloat(tickerData.priceChangePercent),
            };
        } catch (error) {
            console.error(`Gagal memindai ${symbol}:`, error);
            return { symbol, error: error.message };
        }
    }
// =======================================================
    async function scanWatchlist() {
        if (watchlist.length === 0) {
            //alert('Harap isi dan simpan watchlist Anda terlebih dahulu.');
            return;
        }

        const btn = scanWatchlistBtn;
        const btnText = btn.querySelector('span');
        const btnLoader = btn.querySelector('.loader');

        btnText.classList.add('hidden');
        btnLoader.classList.remove('hidden');
        btn.disabled = true;
        watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-10 text-center"><div class="loader mx-auto"></div><p class="mt-2 text-sm text-gray-400">Memindai ${watchlist.length} aset...</p></td></tr>`;

        try {
            const results = [];
            for (const symbol of watchlist) {
                const result = await getConfluenceScoreForSymbol(symbol);
                results.push(result);
                // Tambahkan jeda 300ms untuk menghindari rate limit API
                await new Promise(resolve => setTimeout(resolve, 300));
            }
    renderWatchlistTable(results);
        } catch (error) {
            watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-4 text-center text-sm text-red-500">Terjadi kesalahan saat pemindaian: ${error.message}</td></tr>`;
        } finally {
            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            btn.disabled = false;
        }
    }
// GANTI SELURUH FUNGSI renderWatchlistTable DENGAN INI:
    function renderWatchlistTable(results) {
        if (results.length === 0) {
            watchlistResultsBody.innerHTML = `<tr><td colspan="3" class="px-4 py-4 text-center text-sm text-gray-400">Tidak ada hasil.</td></tr>`;
            return;
        }
        
        let tableHtml = '';
        results.forEach(res => {
            if (res.error) {
                tableHtml += `
                    <tr class="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800" data-symbol="${res.symbol}">
                        <td class="px-4 py-3 font-medium text-gray-900 dark:text-white">${res.symbol}</td>
                        <td colspan="2" class="px-4 py-3 text-sm text-red-400">Error: ${res.error}</td>
                    </tr>
                `;
            } else {
                const priceFormatted = formatPrice(res.price);
                const changeClass = res.change24h >= 0 ? 'positive' : 'negative';

                tableHtml += `
                    <tr class="cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-800" data-symbol="${res.symbol}">
                        <td class="px-4 py-3 font-medium text-gray-900 dark:text-white">${res.symbol}</td>
                        <td class="px-4 py-3 text-sm text-gray-500 dark:text-gray-400">${priceFormatted}</td>
                        <td class="px-4 py-3 text-sm font-semibold ${changeClass}">${res.change24h.toFixed(2)}%</td>
                    </tr>
                `;
            }
        });
        watchlistResultsBody.innerHTML = tableHtml;
        attachWatchlistRowListeners();
    }
// =================================================================================
    function attachWatchlistRowListeners() {
        document.querySelectorAll('#watchlist-results-body tr').forEach(row => {
            row.addEventListener('click', () => {
                const symbol = row.dataset.symbol;
                if (symbol) {
                    assetInput.value = symbol;
                    runFullAnalysis();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
        });
    }

// ========BLOK FUNGSI BARU UNTUK FITUR WATCHLIST (SELESAI) ========================
// =============================================================================================================    
// ===BLOK KODE UPGRADE FINAL V2 UNTUK ANALISIS AI (TERMASUK KORELASI & RISIKO) ==masihh ada cache==
    async function runComprehensiveAIAnalysis() {
        if (!realtimeCache.main.tickerData) {
            showError("Jalankan 'GET DATA' terlebih dahulu untuk memuat data.");
            return;
        }

        const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
        const btnText = comprehensiveBtn.querySelector('span');
        const btnLoader = comprehensiveBtn.querySelector('.loader');
        const aiContentContainer = document.getElementById('ai-content-container');
        const aiNarrativeEl = document.getElementById('ai-narrative-content');

        btnText.classList.add('hidden');
        btnLoader.classList.remove('hidden');
        comprehensiveBtn.disabled = true;

        // --- PERBAIKAN KUNCI: BERSIHKAN SEMUA KONTENER DI SINI ---
        document.getElementById('projection-results-container').innerHTML = '';
        document.getElementById('saran-buyer').textContent = '-';
        document.getElementById('alasan-buyer').textContent = '';
        document.getElementById('saran-holder').textContent = '-';
        document.getElementById('alasan-holder').textContent = '';

        aiNarrativeEl.innerHTML = '';
        aiContentContainer.classList.remove('hidden');

        try {
            const { 
                binanceSymbol, 
                calculatedData, 
                tickerData, 
                correlationData,
                onChainSummary
            } = realtimeCache.main;
            
            const marketType = marketTypeSelect.value;

            // 1. Panggil fungsi untuk mendapatkan ringkasan TF Alignment
            const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);

            // 2. Siapkan data analisis volume
            const klines1d = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 200 }, marketType);
            const vwap20d = calculateVWAP(klines1d, 'rolling', 20);
            const obvValues = calculateOBV(klines1d);
            const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik (Akumulasi)' : 'Turun (Distribusi)';
            const vwapStatus = parseFloat(tickerData.lastPrice) > vwap20d ? 'Di Atas VWAP (Bullish)' : 'Di Bawah VWAP (Bearish)';
            
            const volumeAnalysisData = {
                vwap_20d: vwapStatus,
                obv_trend: obvTrend
            };

            // 3. Buat prompt hybrid dengan variabel yang benar
            const prompt = constructHybridAIPrompt(
                binanceSymbol, 
                calculatedData, 
                tfAlignmentSummary, // Mengirimkan hasil ringkasan
                volumeAnalysisData, 
                onChainSummary, 
                correlationData
            );
            
            const aiResponseText = await callGemini([{ text: prompt }], false);
            const parsedData = parseAIResponseWithTags(aiResponseText);
            displayComprehensiveResults(parsedData);

        } catch (error) {
            aiNarrativeEl.innerHTML = `<p class="text-red-500">Gagal mendapatkan analisa AI: ${error.message}</p>`;

        } finally {
            const btnText = comprehensiveBtn.querySelector('span');
            const btnLoader = comprehensiveBtn.querySelector('.loader');

            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            comprehensiveBtn.disabled = false;
        }
    }
// =============================================================================================================
    function constructHybridAIPrompt(symbol, singleTfData, multiTfData, volumeData, onChainSummary, correlationData) {
        const mainPriceContext = {
            current_price: formatPrice(parseFloat(realtimeCache.main.tickerData.lastPrice))
        };
        const cleanSingleTfData = {
            timeframe: timeframeSelect.value,
            candlestick_pattern: singleTfData.candlePattern,
            chart_pattern: singleTfData.chartPattern,
            rsi_divergence: singleTfData.rsiDivergence,
            obv_divergence: singleTfData.obvDivergence.status,
            volatilitas_atr: singleTfData.atr,
            order_book_bias: realtimeCache.main.orderBookBias,
            bollinger_squeeze: singleTfData.bollingerBands.squeezeStatus,
            pivot_harian_bias: singleTfData.pivot.status + ` (Pivot @ ${formatPrice(singleTfData.pivot.data.P)})`,
            vwap_20d_bias: singleTfData.vwap.status,
            ichimoku_bias: singleTfData.ichimoku.status,
            squeeze_pro_bb_kc: (singleTfData.bollingerBands.width.slice(-1)[0] < singleTfData.keltnerChannels.width.slice(-1)[0]) ? 'Terdeteksi!' : 'Tidak Aktif'
        };
        const fundamentalData = {
            market_cap: realtimeCache.main.coinGeckoData?.market_data?.market_cap?.usd?.toLocaleString() || 'N/A'
        };
        const correlationText = correlationData !== null ? correlationData.toFixed(2) : 'N/A (Aset adalah BTC atau data tidak cukup)';
        const mvrvPromptData = realtimeCache.main.mvrvData 
            ? {
                status: "Data MVRV disediakan pengguna",
                nilai_z_score: realtimeCache.main.mvrvData.value,
                tanggal_data: realtimeCache.main.mvrvData.date
            }
            : "Data MVRV tidak disediakan pengguna.";

        const ema9 = calculateEMA(realtimeCache.main.klines.map(k=>parseFloat(k[4])), 9).pop();
        const ema21 = calculateEMA(realtimeCache.main.klines.map(k=>parseFloat(k[4])), 21).pop();
        const scalpingBias = ema9 > ema21 ? 'LONG' : 'SHORT';
        const scalpingSetupData = {
            bias_sesaat: scalpingBias,
            timeframe: timeframeSelect.value
        };

        return `Sebagai seorang analis kuantitatif (Quant Analyst) senior, berikan analisis pasar yang komprehensif untuk ${symbol}.

            TUGAS UTAMA:
            1.  **CARI DATA EKSTERNAL TERBARU:** Sebelum melakukan analisis, cari data sentimen pasar TERBARU (tidak lebih dari 24 jam terakhir) untuk BITCOIN dari sumber on-chain (Glassnode, CryptoQuant, Coinglass). Sertakan data-data berikut:
                a.  **MVRV Z-Score:** Cari nilai Z-Score terbaru.
                b.  **Data Sentimen Coinglass:** Cari data Netflow, Perubahan OI, Funding Rate, Rasio L/S 24 jam, dan Likuidasi.
                c.  **Format hasilnya HANYA dalam bentuk JSON** di dalam tag [SENTIMEN_DATA_JSON_START]. Strukturnya harus: {\"mvrv_z_score\":1.23, \"netflow\":-57.82, \"oiChange\":-0.89, \"fundingRate\":0.0050, \"lsRatio24h\":\"50.9% / 49.1%\", \"liquidations\":\"215.30M vs 89.10M\"}
            2.  **ANALISIS SEMUA DATA:** Lanjutkan dengan menganalisis SEMUA data yang diberikan di bawah ini untuk mengisi sisa tag output.
            3.  **GUNAKAN JANGKAR HARGA:** Gunakan 'current_price' dari DATA #0 sebagai satu-satunya titik acuan untuk SEMUA PROYEKSI HARGA.


            **DATA #0: KONTEKS HARGA UTAMA (JANGKAR)**
            ${JSON.stringify(mainPriceContext, null, 2)}

            **DATA #1: Analisis Detail Timeframe Utama (${cleanSingleTfData.timeframe})**
            ${JSON.stringify(cleanSingleTfData, null, 2)}

            **DATA #2: Ringkasan Keselarasan Tren Multi-Timeframe (EMA 21/50)**
            ${JSON.stringify(multiTfData, null, 2)}

            **DATA #3: Analisis Berbasis Volume (CEX - Harian)**
            ${JSON.stringify(volumeData, null, 2)}

            **DATA #4: Data Fundamental Dasar**
            ${JSON.stringify(fundamentalData, null, 2)}

            **DATA #5: Ringkasan Aktivitas On-Chain (DEX - Transaksi >$5000)**
            ${onChainSummary ? JSON.stringify(onChainSummary, null, 2) : '"Data on-chain tidak tersedia untuk aset ini."'}

            **DATA #6: Korelasi Pasar (vs. BTCUSDT 30 Hari)**
            ${JSON.stringify({ correlation_coefficient: correlationText }, null, 2)}

            **DATA #7: Metrik Makro On-Chain (MVRV Z-Score)**
            ${JSON.stringify(mvrvPromptData, null, 2)}

            INSTRUKSI OUTPUT (WAJIB IKUTI FORMAT TAG DAN STRUKTUR MARKDOWN DI BAWAH INI):

            [SENTIMEN_DATA_JSON_START]
            (Letakkan hasil pencarian data sentimen Coinglass dalam format JSON murni di sini)
            [SENTIMEN_DATA_JSON_END]
            
            // ... (Sisa tag dari ANALISIS_SCALPING hingga TINGKAT_KEYAKINAN tetap sama) ...

            [NARASI_PASAR_START]
            (Berikan analisis narasi pasar. WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT:
            ### 🟥 Argumen Bearish (Jangka Pendek)
            * Poin 1...
            * Poin 2...

            ### 🟩 Argumen Bullish (Tersembunyi)
            * Poin 1...
            * Poin 2...

            ### ⚖️ Kesimpulan Narasi
            * Ringkasan kesimpulan...)
            [NARASI_PASAR_END]

            [ANALISIS_RISIKO_START]
            (Berikan analisis risiko singkat... // Instruksi ini tetap sama)
            [ANALISIS_RISIKO_END]

            [SMC_NARRATIVE_START]
            (Berikan analisis struktur pasar (SMC). WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT:
            ### 🟥 Sinyal Bearish (Distribusi)
            * Poin 1...
            * Poin 2...

            ### 🟩 Sinyal Bullish (Akumulasi)
            * Poin 1...
            * Poin 2...

            ### 🎯 Target & Konfirmasi Berikutnya
            * Poin 1...
            * Poin 2...)
            [SMC_NARRATIVE_END]

            [SMC_POI_BULLISH_START]
            (Sebutkan TIPE dan rentang harga zona POI bullish terdekat. Contoh: 'Order Block H4 di $50000 - $51000')
            [SMC_POI_BULLISH_END]

            [SMC_POI_BEARISH_START]
            (Sebutkan TIPE dan rentang harga zona POI bearish terdekat. Contoh: 'Supply zone H1 di $60000 - $61000')
            [SMC_POI_BEARISH_END]

            [PROYEKSI_LENGKAP_JSON_START]
            [
                { "periode": "Micro Scalp (1-12 jam)", "target_harga": "...", "alasan": "..." },
                { "periode": "Sangat Pendek (24-48 jam)", "target_harga": "...", "alasan": "..." },
                { "periode": "Jangka Pendek (1-7 hari)", "target_harga": "...", "alasan": "..." },
                { "periode": "Jangka Menengah (1-4 minggu)", "target_harga": "...", "alasan": "..." },
                { "periode": "Jangka Panjang (6-12 bulan)", "target_harga": "...", "alasan": "..." },
                { "periode": "Siklus Makro (1-3 tahun)", "target_harga": "...", "alasan": "..." }
            ]
            [PROYEKSI_LENGKAP_JSON_END]

            [SARAN_HOLDER_START]
            (Pilih salah satu: TAHAN, JUAL, TAMBAH, KURANGI SEBAGIAN)
            [SARAN_HOLDER_END]

            [ALASAN_HOLDER_START]
            (Jelaskan alasan teknikal untuk saran di atas)
            [ALASAN_HOLDER_END]

            [SARAN_BUYER_START]
            (Pilih salah satu: BELI SEKARANG, TUNGGU DI AREA, JANGAN MASUK)
            [SARAN_BUYER_END]

            [ALASAN_BUYER_START]
            (Jelaskan alasan teknikal. Jika TUNGGU, berikan rentang harga ideal berdasarkan POI)
            [ALASAN_BUYER_END]
            `;
    }
// =============================================================================================================
    function parseAIResponseWithTags(rawText) {
        const result = {};
        const tags = [
            "SENTIMEN_DATA_JSON",
            "PUTUSAN_FINAL", "TINGKAT_KEYAKINAN", "NARASI_PASAR", "ANALISIS_SCALPING", "ANALISIS_RISIKO",
            "SMC_NARRATIVE", "SMC_POI_BULLISH", "SMC_POI_BEARISH",
            "PROYEKSI_LENGKAP_JSON", "SARAN_HOLDER", "ALASAN_HOLDER",
            "SARAN_BUYER", "ALASAN_BUYER"
            // Tag Volatilitas, Sentimen, dll, sudah disatukan dalam narasi utama jadi tidak perlu diparsing terpisah
        ];

        tags.forEach(tag => {
            const regex = new RegExp(`\\[${tag}_START\\]([\\s\\S]*?)\\[${tag}_END\\]`, 'i');
            const match = rawText.match(regex);
            const content = match ? match[1].trim() : null;
            
            const key = tag.toLowerCase();
            if (key === "proyeksi_lengkap_json" && content) {
                try {
                    result[key] = JSON.parse(content);
                } catch (e) {
                    console.error(`Gagal parse JSON untuk tag ${tag}:`, e);
                    result[key] = [];
                }
            } else {
                result[key] = content;
            }
        });
        return result;
    }
// =============================================================================================================
// ==================UI RENDERER (VERSI ULTIMATE v2)=================
// =============================================================================================================
    function displayComprehensiveResults(data) {    
        const aiNarrativeEl = document.getElementById('ai-narrative-content');
        const projectionContainer = document.getElementById('projection-results-container');
        const buyerSaranEl = document.getElementById('saran-buyer');
        const buyerAlasanEl = document.getElementById('alasan-buyer');
        const holderSaranEl = document.getElementById('saran-holder');
        const holderAlasanEl = document.getElementById('alasan-holder');
        
        aiNarrativeEl.innerHTML = '';
        projectionContainer.innerHTML = '';
        buyerSaranEl.textContent = '-';
        buyerAlasanEl.textContent = '';
        holderSaranEl.textContent = '-';
        holderAlasanEl.textContent = '';
        // --- AKHIR PERBAIKAN ---

        if (!data || Object.keys(data).length === 0) {
            aiNarrativeEl.innerHTML = '<p class="text-red-500 text-center">AI gagal memberikan analisis yang bisa diproses. Coba lagi.</p>';
            return;
        }

        // 1. Tampilkan data sentimen (jika ada)
        if (data.sentimen_data_json) {
            try {
                const sentimentData = { ...JSON.parse(data.sentimen_data_json), lastUpdated: new Date() };
                realtimeCache.main.shortTermSentiment = sentimentData;
                displaySentimentDataInDashboard(sentimentData);
            } catch (e) {
                console.error("Gagal parse JSON sentimen dari AI:", e);
                const sentimentContainer = document.getElementById('sentiment-display-container');
                if(sentimentContainer) {
                    sentimentContainer.innerHTML = `<p class="text-xs text-center text-red-500">AI gagal memberikan data sentimen dalam format JSON yang benar.</p>`;
                }
            }
        }
        
        // 2. Buat verdict singkat berdasarkan Skor Konfluensi
        let shortVerdictHtml = '';
        if (realtimeCache.main.quickConfluenceScore) {
            const { bull, bear } = realtimeCache.main.quickConfluenceScore;
            const { text, class: verdictClass } = generateShortVerdict(bull, bear);
            shortVerdictHtml = `<p class="text-center font-bold text-2xl mb-4 ${verdictClass}">${text}</p>`;
        }

        // 3. Gunakan Marked.js untuk memformat narasi dan smc (jika ada)
        const narrativeHtml = data.narasi_pasar ? marked.parse(data.narasi_pasar) : '';
        const smcHtml = data.smc_narrative ? marked.parse(data.smc_narrative) : '';

        let detailsHtml = `
            <div class="space-y-4 text-sm">
                ${narrativeHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md">${narrativeHtml}</div>` : ''}
                ${data.analisis_risiko ? `<div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border border-dashed border-yellow-500/50"><strong>Analisis Risiko:</strong> ${data.analisis_risiko}</div>` : ''}
                ${smcHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md mt-3">${smcHtml}</div>` : ''}
            </div>
        `;
        
        // 4. Gabungkan verdict singkat dengan sisa analisis
        aiNarrativeEl.innerHTML = shortVerdictHtml + detailsHtml;

        // 5. Tampilkan Proyeksi Harga & Saran Strategis
        if (data.proyeksi_lengkap_json && data.proyeksi_lengkap_json.length > 0) {
            data.proyeksi_lengkap_json.forEach(p => {
                projectionContainer.innerHTML += `
                    <div class="card p-3 bg-gray-50 dark:bg-gray-800/50">
                        <h4 class="font-semibold text-blue-400 text-sm">${p.periode}</h4>
                        <p class="font-bold text-base text-gray-800 dark:text-white">${p.target_harga}</p>
                        <p class="text-xs text-gray-500 mt-1">${p.alasan}</p>
                    </div>`;
            });
            projectionContainer.className = `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`;
        } else {
            projectionContainer.innerHTML = '<p class="text-xs text-gray-500 col-span-full">Proyeksi harga tidak tersedia.</p>';
        }

        buyerSaranEl.textContent = data.saran_buyer || 'N/A';
        buyerAlasanEl.innerHTML = (data.alasan_buyer || 'Tidak ada alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
        holderSaranEl.textContent = data.saran_holder || 'N/A';
        holderAlasanEl.innerHTML = (data.alasan_holder || 'Tidak ada alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
    }
// =======================================================
    function generateShortVerdict(bullPercentage, bearPercentage) {
        let verdict = "NETRAL / KONSOLIDASI";
        let verdictClass = "text-yellow-400";
        
        if (bullPercentage > bearPercentage * 1.8 && bullPercentage > 40) {
            verdict = "BULLISH KUAT";
            verdictClass = "positive";
        } else if (bearPercentage > bullPercentage * 1.8 && bearPercentage > 40) {
            verdict = "BEARISH KUAT";
            verdictClass = "negative";
        } else if (bullPercentage > bearPercentage) {
            verdict = "BIAS BULLISH RINGAN";
            verdictClass = "positive";
        } else if (bearPercentage > bullPercentage) {
            verdict = "BIAS BEARISH RINGAN";
            verdictClass = "negative";
        }
        return { text: verdict, class: verdictClass };
    }
// =======================================================
    function analyzeAndDisplayConfluenceContributors() {
        const data = realtimeCache.main.calculatedData;
        if (!data) return;

        let contributors = [];
        // Loop ini sudah benar, membaca dari userSettings.active.weights
        for (const indicator in userSettings.active.weights) {
            if (data[indicator]) {
                const score = getUltimateSignalScore(indicator, data[indicator]);
                if (score !== 0) {
                    // [PERBAIKAN] Menyimpan skor mentah (raw score) untuk ditampilkan
                    contributors.push({ 
                        name: indicator.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()), 
                        score: score 
                    });
                }
            }
        }

        // Urutkan berdasarkan skor absolut
        contributors.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));

        const topBullish = contributors.filter(c => c.score > 0).slice(0, 3);
        const topBearish = contributors.filter(c => c.score < 0).slice(0, 3);

        // Bagian untuk menampilkan kontributor Bullish
        let bullishHtml = '<h4 class="font-bold positive mb-1">👍 Pro Bullish</h4><ul class="space-y-1 text-gray-400">';
        if (topBullish.length > 0) {
            topBullish.forEach(item => {
                // [PERBAIKAN] Tampilkan nama DAN skornya
                bullishHtml += `<li class="flex justify-between"><span>• ${item.name}</span> <span class="font-mono text-xs positive">+${item.score.toFixed(2)}</span></li>`;
            });
        } else {
            bullishHtml += '<li class="text-xs italic text-gray-600">Tidak ada.</li>';
        }
        bullishHtml += '</ul>';
        document.getElementById('top-bullish-contributors').innerHTML = bullishHtml;

        // Bagian untuk menampilkan kontributor Bearish
        // [PERBAIKAN] Ganti label dari "Kontra Bearish" menjadi "Pro Bearish"
        let bearishHtml = '<h4 class="font-bold negative mb-1">👎 Pro Bearish</h4><ul class="space-y-1 text-gray-400">';
        if (topBearish.length > 0) {
            topBearish.forEach(item => {
                // [PERBAIKAN] Tampilkan nama DAN skornya
                bearishHtml += `<li class="flex justify-between"><span>• ${item.name}</span> <span class="font-mono text-xs negative">${item.score.toFixed(2)}</span></li>`;
            });
        } else {
            bearishHtml += '<li class="text-xs italic text-gray-600">Tidak ada.</li>';
        }
        bearishHtml += '</ul>';
        document.getElementById('top-bearish-contributors').innerHTML = bearishHtml;
        
        document.getElementById('confluence-breakdown-container').classList.remove('hidden');
    }

// =============================================================================================================
    async function createTFAlignmentSummary(symbol, marketType) {
        const timeframes = ['15m', '1h', '4h', '1d'];
        const summary = {};
        
        let score = 0; // Dimulai dari 0
        
        const klinesPromises = timeframes.map(tf => 
            fetchBinanceAPIData('klines', { symbol, interval: tf, limit: 51 }, marketType)
        );
        const klinesResults = await Promise.all(klinesPromises);

        klinesResults.forEach((klines, index) => {
            const tf = timeframes[index];
            if (klines && klines.length >= 50) {
                const closes = klines.map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21).pop();
                const ema50 = calculateEMA(closes, 50).pop();
                summary[tf] = ema21 > ema50 ? 'BULLISH' : 'BEARISH';
            } else {
                summary[tf] = 'N/A';
            }

            // [PERBAIKAN] Tambahkan logika untuk menjumlahkan skor
            if (summary[tf] === 'BULLISH') {
                score++;
            } else if (summary[tf] === 'BEARISH') {
                score--;
            }
        });

        realtimeCache.main.tfAlignmentSummary = { summary, score };

        // Tampilkan juga di UI
        const alignmentContainer = document.getElementById('tf-alignment-summary');
        let alignmentHtml = '<h4 class="font-bold text-gray-300 mt-2 mb-1">Keselarasan Tren (EMA 21/50)</h4><div class="flex justify-center gap-2">';
        for(const tf in summary){
            const colorClass = summary[tf] === 'BULLISH' ? 'positive' : (summary[tf] === 'BEARISH' ? 'negative' : 'text-gray-500');
            alignmentHtml += `<div class="text-center p-1 rounded-md bg-gray-800/50 flex-1"><span class="font-bold">${tf}</span><br><span class="text-xs ${colorClass}">${summary[tf]}</span></div>`;
        }
        alignmentHtml += '</div>';
        if(alignmentContainer) alignmentContainer.innerHTML = alignmentHtml;

        return { summary, score };
    }
// =================================================================================
    function updateDashboardUI() {
        if (!realtimeCache.main.tickerData) return;
        const navInfoContainer = document.getElementById('nav-info-container');
        const navStatsContainer = document.getElementById('nav-stats-container');
        const tradeLinkContainer = document.getElementById('trade-link');

        if (navInfoContainer) {
            navInfoContainer.classList.remove('hidden');
            navInfoContainer.classList.add('md:flex');
        }
        if (navStatsContainer) {
            navStatsContainer.classList.remove('hidden');
            navStatsContainer.classList.add('md:flex');
        }
        if (tradeLinkContainer) {
            tradeLinkContainer.classList.remove('hidden');
        }
        initialPlaceholder.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
        const navHeight = document.getElementById('sticky-nav-wrapper').offsetHeight;
        smoothScrollTo(document.getElementById('toggle-charts-btn'), 900, navHeight + 16); // 16px = margin tambahan
        
        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        populateCorrelationWidget(); 
        
        if (isChartsVisible) {
            renderAllCharts();
        } else {
            destroyCharts(); 
            toggleChartsBtn.textContent = 'SHOW CHART';
        }
        renderCvdChart();
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// =======================================================
    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleChartsBtn.textContent = 'HIDE CHART';
            if (realtimeCache.main.klines) {
                renderAllCharts();
            }
        } else {
            chartsWrapper.style.display = 'none';
            toggleChartsBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }
// =======Menjalankan animasi scroll yang halus ke sebuah elemen dengan offset=============
    function smoothScrollTo(element, duration, offset = 0) {
        if (!element) return; // Pengaman jika elemen tidak ditemukan
        const targetPosition = element.getBoundingClientRect().top + window.pageYOffset - offset;
        const startPosition = window.pageYOffset;
        const distance = targetPosition - startPosition;
        let startTime = null;

        const easeInOutQuad = (t, b, c, d) => {
            t /= d / 2;
            if (t < 1) return c / 2 * t * t + b;
            t--;
            return -c / 2 * (t * (t - 2) - 1) + b;
        };

        const animation = (currentTime) => {
            if (startTime === null) startTime = currentTime;
            const timeElapsed = currentTime - startTime;
            const run = easeInOutQuad(timeElapsed, startPosition, distance, duration);
            window.scrollTo(0, run);
            if (timeElapsed < duration) requestAnimationFrame(animation);
        };

        requestAnimationFrame(animation);
    }
// =====FUNGSI BARU UNTUK EFEK SCROLL HALUS (SELESAI) ==
    function startFundingRateTimer(nextFundingTime) {
        if (fundingRateTimer) clearInterval(fundingRateTimer);

        const updateTimer = () => {
            const timeRemaining = formatTimeRemaining(nextFundingTime);
            document.getElementById('funding-rate-interval').textContent = timeRemaining;

            // Jika waktu sudah habis, hentikan timer
            if (timeRemaining === '00:00:00') {
                clearInterval(fundingRateTimer);
                // Di sini, Anda bisa memicu pembaruan data funding rate dari API
            }
        };

        updateTimer(); // Panggil sekali untuk pembaruan instan
        fundingRateTimer = setInterval(updateTimer, 1000);
    }
// =======================================================
    function formatTimeRemaining(timestamp) {
        const now = new Date().getTime();
        const nextFunding = new Date(timestamp);
        const diff = nextFunding - now;

        if (diff <= 0) return '00:00:00';

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        const pad = (num) => num.toString().padStart(2, '0');

        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }
// =======================================================
    function populateConfluenceDetailsWidget() {  
    const { calculatedData, tickerData, orderBookData, lsRatioUmumData, lsRatioTopData } = realtimeCache.main;
    if (calculatedData.pivot?.data) {
        document.getElementById('pivot-p').textContent = formatPrice(calculatedData.pivot.data.P);
    }
    if (calculatedData.vwap) {
        document.getElementById('vwap-20d').textContent = formatPrice(calculatedData.vwap.value);
    }
    if (calculatedData.ichimoku) {
        const ichiBiasEl = document.getElementById('ichimoku-bias');
        ichiBiasEl.textContent = calculatedData.ichimoku.status;
        ichiBiasEl.className = `font-mono font-semibold ${calculatedData.ichimoku.status === 'Bullish' ? 'positive' : (calculatedData.ichimoku.status === 'Bearish' ? 'negative' : 'text-gray-500')}`;
    }
    document.getElementById('confluence-timeframe-display').textContent = timeframeSelect.value;
    document.getElementById('vpvr-vah').textContent = formatPrice(calculatedData.vpvr.vah);
    document.getElementById('vpvr-poc').textContent = formatPrice(calculatedData.vpvr.poc);
    document.getElementById('vpvr-val').textContent = formatPrice(calculatedData.vpvr.val);
    const maStatusEl = document.getElementById('ma-status');
    maStatusEl.textContent = calculatedData.ma.status;
    maStatusEl.className = `font-mono font-semibold ${calculatedData.ma.class}`;
    document.getElementById('ema-21-value').textContent = `EMA21: ${formatPrice(calculatedData.ma.value21)}`;
    document.getElementById('ema-50-value').textContent = `EMA50: ${formatPrice(calculatedData.ma.value50)}`;
    document.getElementById('rsi-value').textContent = calculatedData.rsi.last;
    const rsiStatusEl = document.getElementById('rsi-status');
    rsiStatusEl.textContent = calculatedData.rsi.status;
    rsiStatusEl.className = `tag ${calculatedData.rsi.class}`;
    const rsiDivergenceEl = document.getElementById('rsi-divergence');
    rsiDivergenceEl.textContent = calculatedData.rsiDivergence.status;
    rsiDivergenceEl.className = `font-mono font-semibold ${calculatedData.rsiDivergence.class}`;
    document.getElementById('stoch-value').textContent = `${calculatedData.stoch.k}/${calculatedData.stoch.d}`;
    const stochStatusEl = document.getElementById('stoch-status');
    stochStatusEl.textContent = calculatedData.stoch.status;
    stochStatusEl.className = `tag ${calculatedData.stoch.class}`;
    document.getElementById('macd-status').textContent = calculatedData.macd.status;
    document.getElementById('macd-status').className = `font-mono font-semibold ${calculatedData.macd.class}`;
    document.getElementById('macd-hist').textContent = calculatedData.macd.hist;
    document.getElementById('bollinger-bands-status').textContent = calculatedData.bollingerBands.status;
    const bbData = calculatedData.bollingerBands;
    const lastUpper = bbData.upper.filter(v => v !== undefined).pop();
    const lastMiddle = bbData.middle.filter(v => v !== undefined).pop();
    const lastLower = bbData.lower.filter(v => v !== undefined).pop();
    document.getElementById('bb-upper-value').textContent = `U: ${formatPrice(lastUpper)}`;
    document.getElementById('bb-middle-value').textContent = `M: ${formatPrice(lastMiddle)}`;
    document.getElementById('bb-lower-value').textContent = `L: ${formatPrice(lastLower)}`;
    const { atr, atrPercent } = calculatedData;
    const atrStatusBadge = document.getElementById('atr-status-badge');
    const statusClassMap = { 'Rendah': 'tag-green', 'Normal': 'tag-yellow', 'Tinggi': 'tag-red', 'Sangat Tinggi': 'tag-red' };
    atrStatusBadge.textContent = atr.status;
    atrStatusBadge.className = `tag ${statusClassMap[atr.status] || 'tag-gray'} ml-2`;
    document.getElementById('atr-percent-value').textContent = `${atrPercent.toFixed(2)}%`;
    document.getElementById('atr-absolute-value').textContent = atr.value.toFixed(6);
    const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
    const candleResult = calculatedData.candlePattern;
    let biasClass = '';
    if (candleResult.bias === 'BULLISH') biasClass = 'positive';
    if (candleResult.bias === 'BEARISH') biasClass = 'negative';
    const formattedTime = candleResult.timestamp ? new Date(candleResult.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
    candlePatternContainer.innerHTML = `<div class="flex justify-between items-center mb-1"><p class="text-xs text-gray-500">Pola Candlestick</p><p class="text-xs text-gray-400 font-mono">${formattedTime}</p></div>${candleResult.svg}<p id="candlestick-pattern" class="font-semibold ${candleResult.class}">${candleResult.pattern}</p>${candleResult.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candleResult.bias}</p>` : ''}`;
    const chartPatternEl = document.getElementById('chart-pattern');
    chartPatternEl.textContent = calculatedData.chartPattern.pattern;
    chartPatternEl.className = `font-semibold ${calculatedData.chartPattern.class}`;
    const psarStatusEl = document.getElementById('psar-status');
    psarStatusEl.textContent = calculatedData.psar.status;
    psarStatusEl.className = `font-mono font-semibold ${calculatedData.psar.status === 'Bullish' ? 'positive' : 'negative'}`;
    const rocStatusEl = document.getElementById('roc-status');
    rocStatusEl.textContent = `${calculatedData.roc.value.toFixed(2)}% (${calculatedData.roc.status})`;
    rocStatusEl.className = `font-mono font-semibold ${calculatedData.roc.status === 'Positif' ? 'positive' : 'negative'}`;
    document.getElementById('linreg-status').textContent = calculatedData.linreg.status;
    const bbWidth = calculatedData.bollingerBands.width.slice(-1)[0];
    const kcWidth = calculatedData.keltnerChannels.width.slice(-1)[0];
    const bbSqueezeEl = document.getElementById('bollinger-squeeze-status');
    if (bbWidth < kcWidth) {
        bbSqueezeEl.textContent = 'SQUEEZE PRO!';
        bbSqueezeEl.className = 'font-mono font-bold negative blinking-text-animation';
    } else if (calculatedData.bollingerBands.squeezeStatus === 'Squeeze!') {
        bbSqueezeEl.textContent = 'Squeeze!';
        bbSqueezeEl.className = 'font-mono font-bold text-yellow-500 blinking-text-animation';
    } else {
        bbSqueezeEl.textContent = 'Normal';
        bbSqueezeEl.className = 'font-mono text-gray-500';
    }
    document.getElementById('bollinger-rejection-status').textContent = calculatedData.bollingerBands.rejection;
    document.getElementById('bollinger-walk-status').textContent = calculatedData.bollingerBands.walkTheBands;
    if (calculatedData.adx) {
        document.getElementById('adx-value').textContent = calculatedData.adx.adx;
        document.getElementById('plus-di-value').textContent = calculatedData.adx.plusDI;
        document.getElementById('minus-di-value').textContent = calculatedData.adx.minusDI;
    }
    const lsUmumContainer = document.getElementById('ls-umum-container'), lsTopContainer = document.getElementById('ls-top-container');
    if (marketTypeSelect.value === 'futures' && lsRatioUmumData?.[0] && lsRatioTopData?.[0]) {
        lsUmumContainer.classList.remove('hidden');
        lsTopContainer.classList.remove('hidden');
        document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
        document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
    } else {
        lsUmumContainer.classList.add('hidden');
        lsTopContainer.classList.add('hidden');
    }
    if (orderBookData?.bids && orderBookData?.asks) {
        const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
        const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
        let biasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (Banyak Beli)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (Banyak Jual)' : 'Netral');
        document.getElementById('order-book-bias').textContent = biasText;
        realtimeCache.main.orderBookBias = biasText;
    } else {
        document.getElementById('order-book-bias').textContent = 'N/A';
        realtimeCache.main.orderBookBias = 'N/A';
    }

    // [TAMBAHKAN BLOK INI DI AKHIR FUNGSI]
    // Logika untuk mengisi info resistance terdekat di panel scalping
    const resistanceContainer = document.getElementById('scalping-resistance-info');
    if (resistanceContainer && tickerData) {
        const currentPrice = parseFloat(tickerData.lastPrice);
        const potentialResistances = [
            { name: 'VAH', value: calculatedData.vpvr.vah },
            { name: 'Pivot', value: calculatedData.pivot.data?.P },
            { name: '24H High', value: parseFloat(tickerData.highPrice) }
        ].filter(r => r.value && r.value > currentPrice); // Ambil resisten di atas harga saat ini

        if (potentialResistances.length > 0) {
            // Cari yang paling dekat dengan harga saat ini
            const nearestResistance = potentialResistances.reduce((prev, curr) => 
                (Math.abs(curr.value - currentPrice) < Math.abs(prev.value - currentPrice) ? curr : prev)
            );
            resistanceContainer.querySelector('span:last-child').innerHTML = `${formatPrice(nearestResistance.value)} <span class="text-gray-500 text-xs">(${nearestResistance.name})</span>`;
        } else {
            resistanceContainer.querySelector('span:last-child').textContent = 'N/A';
        }
    }
}

// Fungsi baru untuk mendeteksi "wall"
    function detectAndDisplayWall(bids, asks) {
    // BARU: Ambil data Exchange Info dari cache untuk mendapatkan aturan pasar (tickSize, dll.)
        const symbolInfo = exchangeInfoCache[marketTypeSelect.value]?.find(s => s.symbol === realtimeCache.main.binanceSymbol);
        const priceFilter = symbolInfo?.filters.find(f => f.filterType === 'PRICE_FILTER');
        const lotSizeFilter = symbolInfo?.filters.find(f => f.filterType === 'LOT_SIZE');
        
        const tickSize = priceFilter ? parseFloat(priceFilter.tickSize) : 0.01;
        const stepSize = lotSizeFilter ? parseFloat(lotSizeFilter.stepSize) : 0.001;

        // BARU: Hitung smoothed average volume dari histori yang tersimpan
        let smoothedAvgVolume = 0;
        if (orderBookHistory.avgVolumes.length > 0) {
            smoothedAvgVolume = orderBookHistory.avgVolumes.reduce((sum, vol) => sum + vol, 0) / orderBookHistory.avgVolumes.length;
        } else {
            // Fallback jika histori kosong (misalnya saat analisis pertama kali dijalankan)
            const initialLevels = [...bids.slice(0,15), ...asks.slice(0,15)];
            if(initialLevels.length > 0) {
            smoothedAvgVolume = initialLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / initialLevels.length;
            }
        }
        
        // Fungsi internal untuk mengklasifikasikan ketebalan dinding
        const classifyWall = (volume, mediumThreshold, thickThreshold) => {
            if (volume >= thickThreshold) return 'Thick';
            if (volume >= mediumThreshold) return 'Medium';
            return 'Thin';
        };

        // Fungsi internal untuk menemukan cluster dinding
        const findWallCluster = (levels) => {
            if (!levels || levels.length < 5 || smoothedAvgVolume === 0) return null;
            
            const topLevels = levels.slice(0, 15).map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...topLevels);

            // DIUBAH: Thresholds sekarang didasarkan pada smoothedAvgVolume, membuatnya lebih stabil dan adaptif
            const thinThreshold   = Math.max(smoothedAvgVolume * 3, maxVolume * 0.2);
            const mediumThreshold = Math.max(smoothedAvgVolume * 7, maxVolume * 0.5);
            const thickThreshold  = Math.max(smoothedAvgVolume * 15, maxVolume * 0.7);

            let currentWall = null;
            let walls = [];

            for (let i = 0; i < levels.length; i++) {
                const price = parseFloat(levels[i][0]);
                const volume = parseFloat(levels[i][1]);

                if (volume >= thinThreshold) {
                    if (!currentWall) {
                        // Mulai cluster dinding baru
                        currentWall = {
                            priceStart: price,
                            priceEnd: price,
                            totalVolume: volume,
                            levels: 1,
                            levelPrices: [price]
                        };
                    } else {
                        // BARU: Gunakan tickSize untuk menentukan apakah level harga berdekatan untuk digabung
                        if (Math.abs(price - currentWall.priceEnd) <= (tickSize * 2)) {
                            // Lanjutkan cluster yang ada
                            currentWall.priceEnd = price;
                            currentWall.totalVolume += volume;
                            currentWall.levels++;
                            currentWall.levelPrices.push(price);
                        } else {
                            // Level harga terlalu jauh, cluster lama selesai, mulai yang baru
                            if (currentWall.levels >= 2) walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                            currentWall = { priceStart: price, priceEnd: price, totalVolume: volume, levels: 1, levelPrices: [price] };
                        }
                    }
                } else {
                    // Volume di bawah threshold, akhiri cluster yang sedang berjalan
                    if (currentWall && currentWall.levels >= 2) {
                        walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                    }
                    currentWall = null;
                }
            }
            
            // Cek terakhir setelah loop selesai
            if (currentWall && currentWall.levels >= 2) {
                walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
            }

            // Jika ada beberapa cluster, kembalikan yang volumenya paling besar
            if (walls.length > 0) {
                return walls.reduce((max, w) => (w.totalVolume > max.totalVolume ? w : max), walls[0]);
            }
            return null;
        };
        
        // Fungsi internal untuk menemukan satu order besar yang menonjol
        const findSingleWall = (levels) => {
            if (!levels || levels.length === 0 || smoothedAvgVolume === 0) return null;
            
            const volumes = levels.slice(0, 20).map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...volumes);

            // Sebuah order dianggap "single wall" jika jauh lebih besar dari rata-rata yang stabil
            if (maxVolume > smoothedAvgVolume * 20) { 
                const idx = volumes.findIndex(v => v === maxVolume);
                return {
                    priceStart: parseFloat(levels[idx][0]),
                    priceEnd: parseFloat(levels[idx][0]),
                    totalVolume: maxVolume,
                    levels: 1,
                    wallType: 'Thick'
                };
            }
            return null;
        };

        // Jalankan deteksi untuk Bids (Beli) dan Asks (Jual)
        const buyWallCluster = findWallCluster(bids);
        const sellWallCluster = findWallCluster(asks);
        const buyWallSingle  = findSingleWall(bids);
        const sellWallSingle = findSingleWall(asks);

        // Kembalikan hasil deteksi (prioritaskan cluster, baru single order)
        return {
            buyWall: buyWallCluster || buyWallSingle,
            sellWall: sellWallCluster || sellWallSingle
        };
    }

// =======================================================
    function renderFullOrderBook(bids, asks, wallInfo, precision) {
        const numLevels = 10;
        if (!orderBookDOMElements) {
            let asksHtml = '';
            for (let i = 0; i < numLevels; i++) {
                asksHtml += `
                    <div class="flex items-center text-xs mt-1 relative z-0">
                        <div class="ask-bar absolute inset-0 bg-red-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                        <span class="ask-price w-1/2 text-left font-mono"></span>
                        <span class="ask-qty w-1/2 text-right font-mono"></span>
                    </div>
                `;
            }
            let bidsHtml = '';
            for (let i = 0; i < numLevels; i++) {
                bidsHtml += `
                    <div class="flex items-center text-xs mt-1 relative z-0">
                        <div class="bid-bar absolute inset-0 bg-green-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                        <span class="bid-qty w-1/2 text-left font-mono"></span>
                        <span class="bid-price w-1/2 text-right font-mono"></span>
                    </div>
                `;
            }

            fullOrderBookContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-red-500 font-bold">ASKs (Jual)</h4>
                        <div id="asks-container">${asksHtml}</div>
                    </div>
                    <div>
                        <h4 class="text-green-500 font-bold">BIDs (Beli)</h4>
                        <div id="bids-container">${bidsHtml}</div>
                    </div>
                </div>
                <p id="wall-info-text" class="text-center text-xs mt-4 text-gray-500"></p>
            `;
            
            // Simpan referensi ke elemen DOM
            orderBookDOMElements = {
                asks: Array.from(document.querySelectorAll('#asks-container > div')).map(row => ({
                    row, bar: row.querySelector('.ask-bar'), price: row.querySelector('.ask-price'), qty: row.querySelector('.ask-qty')
                })).reverse(), // Reverse asks agar sesuai dengan data
                bids: Array.from(document.querySelectorAll('#bids-container > div')).map(row => ({
                    row, bar: row.querySelector('.bid-bar'), price: row.querySelector('.bid-price'), qty: row.querySelector('.bid-qty')
                })),
                wallInfo: document.getElementById('wall-info-text')
            };
        }
        const topLevels = [...bids.slice(0, 15), ...asks.slice(0, 15)];
        if (topLevels.length > 0) {
            const currentAvgVolume = topLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / topLevels.length;
        
        // Tambahkan rata-rata saat ini ke histori
        orderBookHistory.avgVolumes.push(currentAvgVolume);
        
        // Jaga agar ukuran array tidak melebihi batas maksimal
        while (orderBookHistory.avgVolumes.length > orderBookHistory.maxSize) {
            orderBookHistory.avgVolumes.shift();
        }
    }
        // --- LOGIKA UPDATE: HANYA PERBARUI TEKS DAN STYLE ---
        const totalMaxVolume = Math.max(
            ...bids.slice(0, numLevels).map(b => parseFloat(b[1])), 
            ...asks.slice(0, numLevels).map(a => parseFloat(a[1]))
        );

        // Update Asks
        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.asks[i];
            const data = asks[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.sellWall && price >= wallInfo.sellWall.priceStart && price <= wallInfo.sellWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `ask-price w-1/2 text-left font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-red-500' : 'text-red-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        // Update Bids
        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.bids[i];
            const data = bids[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.buyWall && price >= wallInfo.buyWall.priceStart && price <= wallInfo.buyWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `bid-price w-1/2 text-right font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-green-500' : 'text-green-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        // Update Wall Info Text
        let wallText = '';
        if (wallInfo.buyWall) {
            wallText += `<span class="text-green-500 font-bold">Dinding Beli ${wallInfo.buyWall.wallType.toUpperCase()}</span> terdeteksi dari ${formatPrice(wallInfo.buyWall.priceStart)} ke ${formatPrice(wallInfo.buyWall.priceEnd)} (Volume: $${(wallInfo.buyWall.totalVolume * parseFloat(bids[0][0])).toLocaleString('en-US', {notation: 'compact'})}) `;
        }
        if (wallInfo.sellWall) {
            wallText += `<span class="text-red-500 font-bold">Dinding Jual ${wallInfo.sellWall.wallType.toUpperCase()}</span> terdeteksi dari ${formatPrice(wallInfo.sellWall.priceStart)} ke ${formatPrice(wallInfo.sellWall.priceEnd)} (Volume: $${(wallInfo.sellWall.totalVolume * parseFloat(asks[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        orderBookDOMElements.wallInfo.innerHTML = wallText;
        document.getElementById('scalping-wall-info').innerHTML = wallText || 'Tidak ada wall signifikan terdeteksi.';
    }

// --- 7. CHART RENDERING ENGINE (REBUILT) ---   
    function getChartBaseOptions(height) {
        const isDarkMode = document.documentElement.classList.contains('dark');
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 48, // Parent padding
            height: height,
            layout: { background: { color: isDarkMode ? '#0e0d0d' : '#FFFFFF' }, textColor: isDarkMode ? '#D1D5DB' : '#374151' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                secondsVisible: false, 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                // [PERBAIKAN] Mengoptimalkan drag untuk panning
                lockVisibleTimeRangeOnResize: true,
                rightOffset: 5, // chart offset
                barSpacing: 6,
                minBarSpacing: 3,
                horzTouchDrag: true, 
                vertTouchDrag: true, 
                mouseScroll: false, // Menonaktifkan mouse scroll zoom
                pinchToZoom: true, // Membiarkan pinch-to-zoom di mobile
                tickMarkFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format ke jam:menit menggunakan timezone default browser pengguna
                    return date.toLocaleTimeString('id-ID', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
            },
            crosshair: { 
                mode: LightweightCharts.CrosshairMode.Normal,
                horzLine: {
                    visible: true,
                    labelVisible: true
                },
                vertLine: {
                    visible: true,
                    labelVisible: true
                }
            },
            rightPriceScale: { 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                visible: true,
                scaleMargins: {
                    top: 0.1,
                    bottom: 0.1
                }
            },
            localization: {
                timeFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format waktu yang lebih lengkap untuk tooltip, menggunakan timezone lokal
                    return date.toLocaleString('id-ID', {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        timeZone: 'Asia/Jakarta'
                    });
                }
            }
        };
    }
// =======================================================
    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if(!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (chart !== otherChart && otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }   
// [PERBAIKAN] FUNGSI renderAllCharts dengan logika perbaikan
    function renderAllCharts() {
        if (!realtimeCache.main.klines) return;
        
        destroyCharts();

        const { klines, calculatedData } = realtimeCache.main;
        const closes = klines.map(k => parseFloat(k[4]));    
        const formattedKlines = klines
            .filter(k => k && k.length >= 5 && k.slice(1, 5).every(v => v !== null && !isNaN(parseFloat(v))))
            .map(d => ({ 
                time: d[0] / 1000,
                open: parseFloat(d[1]), 
                high: parseFloat(d[2]), 
                low: parseFloat(d[3]), 
                close: parseFloat(d[4]), 
                volume: parseFloat(d[5])
            }));
        
        if (formattedKlines.length === 0) return;

        const formatLineData = (data, klineData, offset = 5) => data
            .map((value, index) => {
                const klineIndex = index + offset;
                if (klineData[klineIndex]) {
                    const time = klineData[klineIndex][0] / 1000;
                    return { time, value };
                }
                return null;
            })
            .filter(d => d && d.value !== undefined && d.value !== null && !isNaN(d.value));

        const rocPlotData = calculateROC_forPlot(closes, 12);
        const ema50PlotData = formatLineData(calculateEMA(closes, 50), klines);
        const bbPlotData = calculateBollingerBands_forPlot(closes, 20, 2, klines);
        const macdData = calculatedData.macd;
        const macdLinePlotData = formatLineData(macdData.macdLine, klines);
        const signalLinePlotData = formatLineData(macdData.signalLine, klines, (userSettings.active.indicatorParams.macd_slow - 1));
        const histogramPlotData = macdData.histogram
            .map((item, index) => {
                if (klines[index] && item !== undefined) {
                    return {
                        time: klines[index][0] / 1000, // <-- MENGGUNAKAN WAKTU UTC ASLI
                        value: item.value,
                        color: item.color
                    };
                }
                return null;
            })
            .filter(d => d);
        const volumePlotData = formattedKlines.map(d => ({
            time: d.time,
            value: d.volume,
            color: d.close >= d.open ? 'rgba(4, 150, 120, 0.5)' : 'rgba(220, 50, 80, 0.5)'
        }));
       
        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);
        candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
        candlestickSeries.setData(formattedKlines);        
        mainChart.addLineSeries({ color: 'yellow', lineWidth: 2, priceLineVisible: false, lastValueVisible: true, title: '' }).setData(ema50PlotData);
        mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.upper);
        mainChart.addLineSeries({ color: 'white', lineWidth: 2, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.middle);
        mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.lower);
        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100)); // Tinggi lebih kecil
        charts.push(volumeChart);
        volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } }).setData(volumePlotData);        
        const vpvr = calculatedData.vpvr;
            if (vpvr.poc > 0) candlestickSeries.createPriceLine({ price: vpvr.poc, color: '#fbbf24', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Solid, axisLabelVisible: true, title: 'P' });
            if (vpvr.vah > 0) candlestickSeries.createPriceLine({ price: vpvr.vah, color: '#F4511E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'H' });
            if (vpvr.val > 0) candlestickSeries.createPriceLine({ price: vpvr.val, color: '#399BC8', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'L' });        
        const pivots = calculatedData.pivot.data;
            if (pivots) {
                candlestickSeries.createPriceLine({ price: pivots.P, color: '#ffc107', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Solid, axisLabelVisible: true, title: 'Piv' });
                candlestickSeries.createPriceLine({ price: pivots.R1, color: '#f44336', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'R1' });
                candlestickSeries.createPriceLine({ price: pivots.S1, color: '#4caf50', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'S1' });
            }

        // 2. Tampilkan VWAP
        const vwapValue = calculatedData.vwap.value;
            if (vwapValue > 0) {
                candlestickSeries.createPriceLine({ price: vwapValue, color: '#03a9f4', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: 'VW' });
            }

        // 3. Tampilkan Ichimoku Cloud
        const ichimokuData = calculatedData.ichimoku.data;
            if (ichimokuData) {
                const KijunP = 26; // Periode Kijun untuk offset
                
                // Format data untuk Senkou A dan B yang digeser ke depan
                const senkouA_plot = ichimokuData.senkouA.map((val, idx) => klines[idx + KijunP] ? { time: klines[idx + KijunP][0] / 1000, value: val } : null).filter(Boolean);
                const senkouB_plot = ichimokuData.senkouB.map((val, idx) => klines[idx + KijunP] ? { time: klines[idx + KijunP][0] / 1000, value: val } : null).filter(Boolean);
                
                const cloudSeriesA = mainChart.addAreaSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, lineWidth: 1, color: 'rgba(38, 166, 154, 0.2)' });
                const cloudSeriesB = mainChart.addAreaSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, lineWidth: 1, color: 'rgba(239, 83, 80, 0.2)' });
                cloudSeriesA.setData(senkouA_plot);
                cloudSeriesB.setData(senkouB_plot);

                // Tampilkan Tenkan & Kijun
                mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false, lastValueVisible: false }).setData(formatLineData(ichimokuData.tenkan, klines));
                mainChart.addLineSeries({ color: '#D50000', lineWidth: 1, priceLineVisible: false, lastValueVisible: false }).setData(formatLineData(ichimokuData.kijun, klines));
            }
        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(150));
        charts.push(rsiChart);
        const rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2, lastValueVisible: true, priceLineVisible: false });
        rsiSeries.setData(formatLineData(calculatedData.rsi.values, klines));
        rsiSeries.createPriceLine({ price: 70, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });
        rsiSeries.createPriceLine({ price: 30, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(150));
        charts.push(stochChart);
        const stochData = calculatedData.stoch;
        const stochKSeries = stochChart.addLineSeries({ color: '#2196F3', lineWidth: 2, title: '', lastValueVisible: true, priceLineVisible: false });
        stochKSeries.setData(formatLineData(stochData.kLine, klines, stochData.dOffset));
        stochChart.addLineSeries({ color: '#FF9800', lineWidth: 2, title: '', lastValueVisible: true, priceLineVisible: false }).setData(formatLineData(stochData.dLine, klines, stochData.dOffset));
        stochKSeries.createPriceLine({ price: 80, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });
        stochKSeries.createPriceLine({ price: 20, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const rocChart = LightweightCharts.createChart(document.getElementById('roc-chart-container'), getChartBaseOptions(150));
        charts.push(rocChart);
        const rocSeries = rocChart.addLineSeries({ color: '#f472b6', lineWidth: 2, lastValueVisible: true, priceLineVisible: false });
        rocSeries.setData(rocPlotData);
        rocSeries.createPriceLine({ price: 0, color: '#9E9E9E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: '0' });        
        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(150));
        charts.push(macdChart);
        macdChart.addHistogramSeries({ base: 0 }).setData(histogramPlotData);
        macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: 'MACD', lastValueVisible: false, priceLineVisible: false }).setData(macdLinePlotData);
        macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: 'Signal', lastValueVisible: false, priceLineVisible: false }).setData(signalLinePlotData);
        const allCharts = [mainChart, volumeChart, rsiChart, stochChart, macdChart, rocChart];
        
        // Sinkronisasi Crosshair dan Time Range
        syncCharts(...allCharts);

        const initialRange = mainChart.timeScale().getVisibleRange();
        if (initialRange) {
            allCharts.forEach(chart => {
                if (chart !== mainChart && chart) {
                    chart.timeScale().setVisibleRange(initialRange);
                }
            });
        }
    }   
// [PERBAIKAN] Fungsi kalkulasi untuk plotting Bollinger Bands
    function calculateBollingerBands_forPlot(closes, period = 20, stdDev = 2, klines) {
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const middle = calculateSMA(closes, period);
        const upper = [], middleData = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                continue;
            }
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            const time = klines[i][0] / 1000;
            upper.push({ time, value: middle[i] + (stdev * stdDev) });
            lower.push({ time, value: middle[i] - (stdev * stdDev) });
            middleData.push({ time, value: middle[i] });
        }
        return { upper: upper.filter(d => d), middle: middleData.filter(d => d.value !== undefined), lower: lower.filter(d => d) };
    }
// =======================================================
    function calculateROC_forPlot(closes, period = 12) {
        if (closes.length < period + 1) return [];
        const rocData = [];
        for (let i = period; i < closes.length; i++) {
            const currentClose = closes[i];
            const pastClose = closes[i - period];
            if (pastClose !== 0) {
                const roc = ((currentClose - pastClose) / pastClose) * 100;
                rocData.push({ time: realtimeCache.main.klines[i][0] / 1000, value: roc });
            }
        }
        return rocData;
    }
// [PERBAIKAN] Fungsi kalkulasi Linear Regression Channel
    function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
        const closes = klines.map(k => parseFloat(k[4]));
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const upper = [], middle = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            const y = closes.slice(i - period + 1, i + 1);
            const n = period; 
            const sumX = (n * (n - 1)) / 2;
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
            const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate Standard Deviation from regression error
            let sumErrSq = 0;
            for (let j = 0; j < n; j++) {
                const predictedY = intercept + slope * j;
                sumErrSq += Math.pow(y[j] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middleValue = intercept + slope * (n - 1);
            middle.push({ time: klines[i][0] / 1000, value: middleValue });
            upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
            lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) }); 
        }
        return { upper, middle, lower };
    }

// Fungsi baru untuk mendeteksi pola harga pada Bollinger Bands
    function analyzeBollingerBandsPriceAction(klines, bbData) {
        if (!klines || klines.length < 2 || !bbData || bbData.upper.length < 2) {
            return { rejection: 'Tidak Ada', walkTheBands: 'Tidak Ada' };
        }

        const lastKline = klines[klines.length - 1];
        const prevKline = klines[klines.length - 2];
        const lastUpper = bbData.upper.pop()?.value;
        const lastLower = bbData.lower.pop()?.value;
        const prevUpper = bbData.upper.pop()?.value;
        const prevLower = bbData.lower.pop()?.value;
        const lastClose = parseFloat(lastKline[4]);
        const prevClose = parseFloat(prevKline[4]);

        let rejection = 'Tidak Ada';
        // Logika Rejection Bullish
        if (prevClose < prevLower && lastClose > lastLower && lastClose > prevClose) {
            rejection = 'Bullish Rejection (Lower BB)';
        }
        // Logika Rejection Bearish
        if (prevClose > prevUpper && lastClose < lastUpper && lastClose < prevClose) {
            rejection = 'Bearish Rejection (Upper BB)';
        }

        let walkTheBands = 'Tidak Ada';
        // Logika Walk the Bands Bullish
        if (lastClose >= lastUpper && prevClose >= prevUpper) {
            walkTheBands = 'Bullish (Upper BB)';
        }
        // Logika Walk the Bands Bearish
        if (lastClose <= lastLower && prevClose <= prevLower) {
            walkTheBands = 'Bearish (Lower BB)';
        }
        
        return { rejection, walkTheBands };
    }
// =======================================================
    function destroyCharts() {
        charts.forEach(chart => {
            if (chart) {
                chart.remove();
            }
        });
        charts = [];
        candlestickSeries = null;
        
        // 2. Kosongkan HANYA kontainer chart utama
        const mainChartContainers = [
            'main-chart-container', 
            'rsi-chart-container', 
            'stoch-chart-container', 
            'macd-chart-container',
            'roc-chart-container'
        ];
        mainChartContainers.forEach(id => {
            const container = document.getElementById(id);
            if (container) {
                container.innerHTML = '';
            }
        });
    }
// =======================================================
// GANTI SELURUH FUNGSI processQueues DENGAN KODE INI
const processQueues = () => {
    let shouldUpdateUI = false;

    // 1. Proses Antrian Kline (Candlestick) dengan aman
    if (klineQueue.length > 0) {
        try {
            const latestKlineMessage = klineQueue.pop();
            klineQueue = [];
            if (candlestickSeries && latestKlineMessage) {
                const candle = latestKlineMessage.k;
                const formattedCandle = {
                    time: candle.t / 1000,
                    open: parseFloat(candle.o), high: parseFloat(candle.h),
                    low: parseFloat(candle.l), close: parseFloat(candle.c)
                };
                candlestickSeries.update(formattedCandle);
                if (candle.x) {
                    realtimeCache.main.klines.shift();
                    realtimeCache.main.klines.push([candle.t, candle.o, candle.h, candle.l, candle.c, candle.v, candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B]);
                    updateRealTimeIndicators(realtimeCache.main.klines);
                }
            }
        } catch (error) {
            console.error("Error saat memproses kline:", error);
        }
        shouldUpdateUI = true;
    }
    
    // 2. Proses Antrian Trade (untuk CVD dan Harga Live) dengan aman
    if (tradeQueue.length > 0) {
        try {
            const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
            tradesToProcess.forEach(trade => {
                const quantity = parseFloat(trade.q);
                const price = parseFloat(trade.p);
                const navPriceEl = document.getElementById('nav-price');
                const navIdrEl = document.getElementById('nav-price-idr');
                if (navPriceEl && navIdrEl) {
                    navPriceEl.textContent = formatPrice(price);
                    navIdrEl.textContent = `Rp ${(price * (realtimeCache.main.usdToIdrRate || 0)).toLocaleString('id-ID', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
                }
                if (cvdChartInstance) {
                    if (isNaN(quantity) || quantity === 0) return;
                    const sign = trade.m ? -1 : 1;
                    liveCvdValue += quantity * sign;
                    liveCvdValueUsdt += (quantity * price) * sign;
                    const newPoint = { x: trade.T, y_coin: liveCvdValue, y_usdt: liveCvdValueUsdt };
                    cvdChartInstance.data.datasets[0].data.push(newPoint);
                    liveCvdData.push(newPoint);
                    while (cvdChartInstance.data.datasets[0].data.length > 300) {
                        cvdChartInstance.data.datasets[0].data.shift();
                        liveCvdData.shift();
                    }
                    cvdChartInstance.update('none');
                    updateCvdTableLive();
                }
            });
        } catch (error) {
            console.error("Error saat memproses trade:", error);
        }
        shouldUpdateUI = true;
    }

    // 3. Proses Antrian Depth (Order Book) dengan aman
    if (depthQueue.length > 0) {
        try {
            const updatesToProcess = depthQueue.splice(0, depthQueue.length);
            updatesToProcess.forEach(update => {
                if (update.b) {
                    update.b.forEach(([price, qty]) => {
                        const existingIndex = latestBids.findIndex(bid => bid[0] === price);
                        if (parseFloat(qty) === 0) {
                            if (existingIndex !== -1) latestBids.splice(existingIndex, 1);
                        } else {
                            if (existingIndex !== -1) latestBids[existingIndex] = [price, qty];
                            else latestBids.push([price, qty]);
                        }
                    });
                }
                if (update.a) {
                    update.a.forEach(([price, qty]) => {
                        const existingIndex = latestAsks.findIndex(ask => ask[0] === price);
                        if (parseFloat(qty) === 0) {
                            if (existingIndex !== -1) latestAsks.splice(existingIndex, 1);
                        } else {
                            if (existingIndex !== -1) latestAsks[existingIndex] = [price, qty];
                            else latestAsks.push([price, qty]);
                        }
                    });
                }
            });
            latestBids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
            latestAsks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
            const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
            const precision = getPrecisionForAsset(parseFloat(latestPrice));
            const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
            renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
        } catch (error) {
            console.error("Error saat memproses depth:", error);
        }
        shouldUpdateUI = true;
    }

    // Panggil fungsi pembaruan hanya jika ada data baru DAN realtimeCache sudah diisi
    if (shouldUpdateUI && realtimeCache.main.calculatedData) {
        // Perbarui data ticker 24h secara real-time
        if (tradeQueue.length > 0) {
            const latestTradePrice = parseFloat(tradeQueue[tradeQueue.length - 1].p);
            if (realtimeCache.main.tickerData) {
                realtimeCache.main.tickerData.lastPrice = latestTradePrice.toString();
            }
        }
        
        // Panggil fungsi pembaruan UI utama
        calculateAndDisplayScalpingSetup();
        updateQuickConfluenceWidget();
    }
};
// =======================================================
    function populateCurrentStateWidget() {
        const { tickerData, coinGeckoData, usdToIdrRate, globalData, openInterestData, fundingRateData, binanceSymbol } = realtimeCache.main;
        
        // Mengisi Navigasi Atas
        document.getElementById('nav-symbol').textContent = binanceSymbol;
        const navChange24hEl = document.getElementById('nav-change-24h');
        const navChange1hEl = document.getElementById('nav-change-1h');
        
        const change24h = parseFloat(tickerData.priceChangePercent);
        if (navChange24hEl) {
            navChange24hEl.textContent = `${change24h.toFixed(2)}%`;
            navChange24hEl.className = `font-semibold ${change24h >= 0 ? 'positive' : 'negative'}`;
        }
        
        if (navChange1hEl && coinGeckoData?.market_data) {
            const change1h = coinGeckoData.market_data.price_change_percentage_1h_in_currency.usd || 0;
            navChange1hEl.textContent = `${change1h.toFixed(2)}%`;
            navChange1hEl.className = `font-semibold ${change1h >= 0 ? 'positive' : 'negative'}`;
        }
        navVolume24h.textContent = `$${parseFloat(tickerData.quoteVolume).toLocaleString('en-US', { notation: 'compact' })}`;
        if (coinGeckoData?.market_data) {
            navAth.textContent = formatPrice(coinGeckoData.market_data.ath.usd);
            navAtl.textContent = formatPrice(coinGeckoData.market_data.atl.usd);
        }

        // Mengisi Kartu DATA DASAR yang Disederhanakan
        if (coinGeckoData?.market_data) {
            document.getElementById('market-cap').textContent = formatPrice(coinGeckoData.market_data.market_cap.usd);
        }
        if (globalData?.data) {
            document.getElementById('btc-dominance').textContent = `${globalData.data.market_cap_percentage.btc.toFixed(2)}%`;
        }

        // Mengisi Bagian Lain yang Masih Ada di Dasbor
        document.getElementById('current-state-title').innerHTML = `<span class="text-yellow-500 font-semibold">💲 ${binanceSymbol}</span>`;
        document.getElementById('range-24h').textContent = `${formatPrice(parseFloat(tickerData.lowPrice)).replace('$', '')} - ${formatPrice(parseFloat(tickerData.highPrice)).replace('$', '')}`;
        
        const futuresContainer = document.getElementById('futures-data-container');
        const price = parseFloat(tickerData.lastPrice);
        if (marketTypeSelect.value === 'futures' && openInterestData && fundingRateData) {
            futuresContainer.classList.remove('hidden');
            // [PERBAIKAN] Tambahkan pengecekan data Open Interest sebelum ditampilkan
            if (openInterestData && parseFloat(openInterestData.openInterest) > 0) {
                const oiValue = parseFloat(openInterestData.openInterest) * price;
                document.getElementById('open-interest').textContent = `$${oiValue.toLocaleString('en-US', { notation: 'compact' })}`;
            } else {
                // Tampilkan strip jika data tidak ada atau nol
                document.getElementById('open-interest').textContent = '-';
            }
            document.getElementById('funding-rate').textContent = `${(parseFloat(fundingRateData.lastFundingRate) * 100).toFixed(4)}%`;
            if (fundingRateData.nextFundingTime) {
                startFundingRateTimer(fundingRateData.nextFundingTime);
            } else {
                document.getElementById('funding-rate-interval').textContent = '-';
            }
        } else {
            futuresContainer.classList.add('hidden');
        }
    }
// =======================================================
    function renderCvdChart() {
        const { cvdData } = realtimeCache.main;
        if (!cvdData || cvdData.length === 0) return;

        // Inisialisasi data live dengan format baru yang lengkap
        liveCvdData = cvdData.map(d => ({ 
            x: d.time * 1000, 
            y_coin: d.cvd_coin,
            y_usdt: d.cvd_usdt 
        }));
        
        // Inisialisasi nilai kumulatif terakhir
        if (liveCvdData.length > 0) {
            const lastPoint = liveCvdData[liveCvdData.length - 1];
            liveCvdValue = lastPoint.y_coin;
            liveCvdValueUsdt = lastPoint.y_usdt;
        }

        const ctx = document.getElementById('cvdChart').getContext('2d');
        if (cvdChartInstance) cvdChartInstance.destroy();
        
        const isDarkMode = document.documentElement.classList.contains('dark');
        const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
        const negativeColor = isDarkMode ? '#f87171' : '#dc2626';

        cvdChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'CVD (USDT)',
                    data: liveCvdData,
                    parsing: {
                        yAxisKey: 'y_usdt' // <-- PENTING: Memberitahu chart untuk menggunakan nilai USDT
                    },
                    fill: false, tension: 0.1, pointRadius: 0, borderWidth: 2,
                    segment: {
                        borderColor: ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor,
                    }
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'time', time: { tooltipFormat: 'MMM dd, HH:mm:ss', unit: 'second' }, grid: { display: false }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563', source: 'auto', maxRotation: 0, autoSkip: true } },
                    y: { grid: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563' } }
                },
                plugins: { legend: { display: false } },
                interaction: { mode: 'index', intersect: false }
            }
        });

        // Perbarui tabel dengan data awal
        updateCvdTableLive(liveCvdData);
    }
    
    const reconnectDelay = 5000; // Coba sambung kembali setiap 5 detik

// =======================================================
    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { value: 0, status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { value: 0, status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { value: roc, status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { value: 0, status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { value: sar, status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }

    function calculateLinearRegressionChannel(closes, period = 14, stdDev = 2) {
        if (closes.length < period) return { upper: 0, middle: 0, lower: 0, status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Calculate Standard Deviation from regression error
        let sumErrSq = 0;
        for (let i = 0; i < n; i++) {
            const predictedY = intercept + slope * i;
            sumErrSq += Math.pow(y[i] - predictedY, 2);
        }
        const stdErr = Math.sqrt(sumErrSq / (n - 2));

        const middle = intercept + slope * (n - 1);
        const upper = middle + (stdDev * stdErr);
        const lower = middle - (stdDev * stdErr);
        
        const lastClose = closes[closes.length - 1];
        let status = "In Channel";
        if(lastClose > upper) status = "Upper Line Channel";
        if(lastClose < lower) status = "Lower Line Channel";

        return { upper, middle, lower, status };
    }
// [BARU] Tambahkan fungsi yang hilang ini untuk plot PSAR
    function calculateParabolicSAR_forPlot(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return [];
        let sar = parseFloat(klines[0][3]);
        let ep = parseFloat(klines[0][2]);
        let af = step;
        let isUptrend = true;
        const sarData = [];

        for (let i = 1; i < klines.length; i++) {
            const time = klines[i][0] / 1000;
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevSar = sar;

            if (isUptrend) {
                sar = prevSar + af * (ep - prevSar);
                if (low < sar) {
                    isUptrend = false;
                    sar = ep;
                    ep = low;
                    af = step;
                } else {
                    if (high > ep) {
                        ep = high;
                        af = Math.min(max, af + step);
                    }
                }
            } else { // Downtrend
                sar = prevSar - af * (prevSar - ep);
                if (high > sar) {
                    isUptrend = true;
                    sar = ep;
                    ep = high;
                    af = step;
                } else {
                    if (low < ep) {
                        ep = low;
                        af = Math.min(max, af + step);
                    }
                }
            }
            sarData.push({ time, value: sar });
        }
        return sarData;
    }
 
    // Salin dan tempel fungsi utilitas dan kalkulasi yang dibutuhkan dari projector.html
    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) {
                obv.push(obv[i - 1] + volume);
            } else if (close < prevClose) {
                obv.push(obv[i - 1] - volume);
            } else {
                obv.push(obv[i - 1]);
            }
        }
        return obv;
    };

// =======================================================
    function calculateVWAP(klines, mode = 'rolling', period = 20) {
        if (!klines || klines.length === 0) return 0;

        let sumPV = 0; // sum(Price * Volume)
        let sumV = 0;  // sum(Volume)
        let vwapValues = [];

        if (mode === 'rolling') {
            const recentKlines = klines.slice(-period);
            recentKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;

        } else if (mode === 'session') {
            const todayUTC = new Date().toISOString().slice(0, 10);
            const sessionKlines = klines.filter(k => new Date(k[0]).toISOString().slice(0, 10) === todayUTC);
            if (sessionKlines.length === 0) return 0; // Tidak ada data untuk sesi hari ini
            
            sessionKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;

        } else if (mode === 'anchored') {
            const anchorLookback = 200; // Mencari titik terendah dalam 200 candle terakhir
            const recentSlice = klines.slice(-anchorLookback);
            if (recentSlice.length === 0) return 0;

            let lowestLow = Infinity;
            let anchorIndex = -1;
            
            recentSlice.forEach((k, index) => {
                const low = parseFloat(k[3]);
                if (low < lowestLow) {
                    lowestLow = low;
                    anchorIndex = klines.length - anchorLookback + index;
                }
            });

            const anchoredKlines = klines.slice(anchorIndex);
            anchoredKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;
        }
        return 0; // Fallback
    }

    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR KORELASI (MULAI) ==
    // =======================================================
    function calculateCorrelation(dataX, dataY) {
        if (dataX.length !== dataY.length || dataX.length === 0) {
            return null;
        }
        const n = dataX.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += dataX[i];
            sumY += dataY[i];
            sumXY += dataX[i] * dataY[i];
            sumX2 += dataX[i] * dataX[i];
            sumY2 += dataY[i] * dataY[i];
        }

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        if (denominator === 0) {
            return 0; // Tidak ada variasi, korelasi netral
        }
        
        return numerator / denominator;
    }

// == BLOK FUNGSI UNTUK FITUR KORELASI  ==
    function populateCorrelationWidget() {
        const valueEl = document.getElementById('correlation-value');
        const textEl = document.getElementById('correlation-text');        
        const correlationData = realtimeCache.main.correlationData;

        if (correlationData === null || correlationData === undefined) {
            valueEl.textContent = '-';
            textEl.textContent = 'Data tidak cukup untuk menghitung korelasi.';
            valueEl.className = 'text-lg font-sbold text-gray-400 dark:text-gray-500';
            return;
        }

        const value = correlationData;
        valueEl.textContent = value.toFixed(2);

        let text = 'Tidak Ada Korelasi';
        let colorClass = 'text-gray-400 dark:text-gray-500';

        if (value >= 0.7) { text = 'Korelasi Positif Kuat'; colorClass = 'positive'; } 
        else if (value >= 0.4) { text = 'Korelasi Positif Sedang'; colorClass = 'positive'; } 
        else if (value >= 0.1) { text = 'Korelasi Positif Lemah'; colorClass = 'text-yellow-400'; } 
        else if (value <= -0.7) { text = 'Korelasi Negatif Kuat'; colorClass = 'negative'; } 
        else if (value <= -0.4) { text = 'Korelasi Negatif Sedang'; colorClass = 'negative'; } 
        else if (value <= -0.1) { text = 'Korelasi Negatif Lemah'; colorClass = 'text-yellow-400'; }
        
        textEl.textContent = text;
        valueEl.className = `text-lg font-semibold ${colorClass}`;
    }
// == BLOK FUNGSI BARU UNTUK FITUR KORELASI (SELESAI) ==
// === FUNGSI RESET BARU ===
    function resetDashboard() {
        //console.log("Mereset dasbor...");
        // Hentikan semua proses real-time
        WebSocketManager.resetSubscriptions();
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (fundingRateTimer) clearInterval(fundingRateTimer);
        
        // Sembunyikan dasbor & tampilkan placeholder
        dashboardContent.classList.add('hidden');
        initialPlaceholder.classList.remove('hidden');

        // Sembunyikan elemen navigasi
        document.getElementById('nav-info-container').classList.add('hidden');
        document.getElementById('nav-stats-container').classList.add('hidden');
        document.getElementById('trade-link').classList.add('hidden');
        
        // Hancurkan chart & reset state
        destroyCharts();
        realtimeCache.main = {};
        klineCache = {}; // Kosongkan juga cache kline
        orderBookHistory = { avgVolumes: [], maxSize: 30 };
        
        // Gulir kembali ke atas
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
// =======================================================
    function updateVwapDisplay(mode) {
        if (!realtimeCache.main.klines) return;
        
        // Gunakan klines yang sesuai dengan timeframe
        const vwapValue = calculateVWAP(realtimeCache.main.klines, mode);
        const lastPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
        
        // Simpan ke cache untuk digunakan oleh skor konfluensi dan AI
        realtimeCache.main.calculatedData.vwap = {
            status: lastPrice > vwapValue ? 'Bullish' : 'Bearish',
            value: vwapValue
        };
        
        // Perbarui tampilan di panel Data Timeframe
        document.getElementById('vwap-20d').textContent = formatPrice(vwapValue);

        // Panggil ulang update skor konfluensi agar ikut berubah
        updateQuickConfluenceWidget();
    }
// --- [BLOK FINAL] KUMPULAN FUNGSI UNTUK TOP MOVERS V4 (HYBRID) ---
// GANTI SELURUH FUNGSI DENGAN VERSI "CERDAS" INI
function renderTriggerBreakdown(breakdown) {
    const container = document.getElementById('trigger-breakdown-list');
    if (!container) return;

    const renderTrigger = (name, triggerData, valueText, conditionText = '') => {
        // [BARU] Pengaman jika triggerData tidak ada
        const safeTriggerData = triggerData || { triggered: false, points: 0 };
        const isTriggered = safeTriggerData.triggered;
        const points = safeTriggerData.points;
        const icon = isTriggered ? '✅' : '❌';
        const pointsText = isTriggered ? `+${points.toFixed(1).replace('.0', '')} Poin` : `0 Poin`;
        const mainColor = isTriggered ? 'text-green-400' : 'text-gray-500';
        const pointColor = isTriggered ? 'text-green-400' : 'text-gray-500';
        
        return `
            <li class="flex justify-between items-center py-2 border-b border-gray-700/50 ${mainColor}">
                <span>${icon} ${name}</span>
                <div class="text-right text-xs">
                    <span class="font-semibold">${valueText}</span>
                    <span class="text-gray-600 ml-1">${conditionText}</span>
                    <br>
                    <span class="font-mono font-bold ${pointColor}">${pointsText}</span>
                </div>
            </li>
        `;
    };

    let html = '<ul class="list-none">';
    
    html += renderTrigger('Candle Merah Paska-Puncak', breakdown.candleRed, breakdown.candleRed?.triggered ? 'Terdeteksi' : 'Tidak Ada');
    html += renderTrigger('Pola Candle Bearish', breakdown.doji, breakdown.candlePattern, '(cth: Shooting Star)');
    // [BARU] Tambahkan baris ini untuk Volume Exhaustion
    html += renderTrigger('Volume Exhaustion', breakdown.volumeExhaustion, breakdown.volumeExhaustion?.triggered ? 'Terdeteksi' : 'Normal', '(Vol Puncak < 60% Avg)');
    html += renderTrigger('CVD Menukik Tajam', breakdown.cvdDip, breakdown.cvdDip?.triggered ? 'Ya' : 'Tidak');
    html += renderTrigger('Divergensi / Arah CVD', breakdown.cvdDivergence, breakdown.cvdStatus, '(Kondisi: Bearish)');
    html += renderTrigger('Rejection Bollinger Band', breakdown.bbRejection, breakdown.bbStatus);
    html += renderTrigger('MACD Bearish Cross', breakdown.macdCross, `Status: ${breakdown.macdStatus}`);
    html += renderTrigger('RSI Overbought', breakdown.rsiOverbought, `Value: ${breakdown.rsiValue}`, '(Kondisi: > 70)');

    html += '</ul>';
    container.innerHTML = html;
}
// Fungsi ini mendeteksi sell wall yang menonjol di order book
function detectSignificantSellWall(asks) {
    if (!asks || asks.length === 0) return null;
    
    let totalVolume = asks.reduce((sum, ask) => sum + parseFloat(ask[1]), 0);
    let avgVolume = totalVolume / asks.length;
    let sellWallVolume = 0;
    
    // Asumsi: 'wall' adalah order yang volumenya > 5x rata-rata
    const wallThreshold = avgVolume * 5; 
    
    for (const ask of asks) {
        if (parseFloat(ask[1]) > wallThreshold) {
            sellWallVolume += parseFloat(ask[1]);
        }
    }
    
    // Jika total volume sell wall lebih dari 20% dari total volume order book yang terlihat, anggap sebagai signifikan
    if (sellWallVolume > totalVolume * 0.2) {
        return { volume: sellWallVolume, type: 'significant' };
    }
    
    return null;
}
// GANTI SELURUH FUNGSI updateTopMovers DENGAN KODE INI
async function updateTopMovers(timeframe = "1h") {
    try {
        const topGainersList = document.getElementById('gainers-list');
        const losersList = document.getElementById('losers-list');
        //topGainersList.innerHTML = `<div><div class="loader mx-auto"></div></div>`;
        //losersList.innerHTML = `<div><div class="loader mx-auto"></div></div>`;

        // TAMBAHKAN INI UNTUK FEEDBACK INSTAN
        const loaderHtml = `<div class="p-4 flex justify-center items-center"><div class="loader"></div></div>`;
        if (topGainersList.innerHTML === "") { // Hanya tampilkan loader saat pertama kali
             topGainersList.innerHTML = loaderHtml;
             losersList.innerHTML = loaderHtml;
        }

        if (!exchangeInfoCache.futures) {
            await initializeExchangeInfo('futures');
        }
        const tradingSymbols = new Set(exchangeInfoCache.futures
            .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
            .map(s => s.symbol)
        );
        
        const response = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
        if (!response.ok) throw new Error('Network response error');
        const data = await response.json();
        
        const usdtPairs = data.filter(d => d.symbol.endsWith('USDT') && tradingSymbols.has(d.symbol));

        usdtPairs.forEach(d => {
            const priceChange = parseFloat(d.priceChangePercent);
            const volume = parseFloat(d.quoteVolume);
            d.strengthScore = priceChange * Math.log10(volume + 1); 
        });

        usdtPairs.sort((a, b) => b.strengthScore - a.strengthScore);
        const top10Gainers = usdtPairs.slice(0, 10); //jumlah koin top mover
        
        usdtPairs.sort((a, b) => parseFloat(a.priceChangePercent) - parseFloat(b.priceChangePercent));
        const top10Losers = usdtPairs.slice(0, 1);
        
        const gainersWithDetails = await Promise.all(top10Gainers.map(async (mover) => {
            const [klines1h, klines15m] = await Promise.all([
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 200 }, 'futures').catch(() => null)
            ]);
            const calculateChange = (kData) => {
                if (!kData || kData.length < 2) return 'N/A';
                const prevClose = parseFloat(kData[0][4]);
                const currentClose = parseFloat(kData[1][4]);
                return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
            };

            // [PERBAIKAN] Simpan data ke realtimeCache.movers
            realtimeCache.movers[mover.symbol] = {
                klines_1h: klines1h.map(k => ({ Open_time: k[0], Open: parseFloat(k[1]), High: parseFloat(k[2]), Low: parseFloat(k[3]), Close: parseFloat(k[4]), Volume: parseFloat(k[5]), Close_time: k[6] })),
                aggTrades: []
            };
            return { ...mover, change1h: calculateChange(klines1h.slice(-2)), change15m: calculateChange(klines15m) };
        }));

        renderMoversList('gainers-list', gainersWithDetails, true);
        renderMoversList('losers-list', top10Losers, false);
        attachTopMoversListeners();
        WebSocketManager.subscribeToMovers(top10Gainers.map(m => m.symbol));
        
    } catch (error) {
        console.error("Gagal mengambil data Top Movers:", error);
        document.getElementById('gainers-list').innerHTML = `<div class="text-red-500 text-xs">Gagal memuat.</div>`;
        document.getElementById('losers-list').innerHTML = `<div class="text-red-500 text-xs">Gagal memuat.</div>`;
    }
}

function renderMoversList(containerId, moversData, isGainer) {
    const container = document.getElementById(containerId);
    container.innerHTML = "";
    const maxStrengthScore = isGainer && moversData.length > 0 ? moversData[0].strengthScore : 1;

    moversData.forEach(item => {
        const itemElement = document.createElement('div');
        itemElement.className = "flex flex-col bg-gray-800 p-2 rounded gap-2 mover-item";
        itemElement.dataset.symbol = item.symbol;
        
        const priceChange24h = parseFloat(item.priceChangePercent);
        let headerHtml = `<div class="flex justify-between items-center text-sm font-semibold"><span class="font-bold text-white cursor-pointer" onclick="runFullAnalysis('${item.symbol}')">${item.symbol}</span><span class="font-mono text-white" id="price-${item.symbol}">${formatPrice(parseFloat(item.lastPrice))}</span></div>`;
        let detailsHtml = '';

        if (isGainer) {
            const pumpStrengthPercentage = Math.max(0, (item.strengthScore / maxStrengthScore) * 100);
            const formatChange = (val, lbl) => {
                if (val === 'N/A' || isNaN(parseFloat(val))) return `<span class="text-gray-500">${lbl}: --</span>`;
                const value = parseFloat(val);
                const color = value >= 0 ? 'positive' : 'negative';
                return `<span class="${color}">${lbl}: ${value.toFixed(2)}%</span>`;
            };
            detailsHtml = `<div class="flex justify-between items-center"><div class="flex items-center gap-2 text-xs font-mono">${formatChange(priceChange24h, '24H')} ${formatChange(item.change1h, '1H')} ${formatChange(item.change15m, '15M')}</div><div class="hybrid-bar" id="hybrid-bar-${item.symbol}"><div class="pump-strength" style="width: ${pumpStrengthPercentage}%"></div><div class="dump-risk" style="width:0%;"></div></div></div>`;
        } else {
            detailsHtml = `<div class="flex justify-end items-center text-sm"><span class="font-semibold negative">24H: ${priceChange24h.toFixed(2)}%</span></div>`;
        }
        
        itemElement.innerHTML = headerHtml + detailsHtml;
        container.appendChild(itemElement);
    });
}
// GANTI FUNGSI YANG ADA DENGAN INI
// GANTI DENGAN KODE FUNGSI LENGKAP INI
    // GANTI SELURUH FUNGSI DENGAN VERSI "CERDAS" INI
function calculateShortConfluenceScore(symbol = realtimeCache.main.symbol) {
    if (!symbol) return { score: 0, breakdown: {} };

    const isMoverDataAvailable = realtimeCache.movers[symbol] && realtimeCache.movers[symbol].klines_1h && realtimeCache.movers[symbol].klines_1h.length > 20;
    const dataSource = isMoverDataAvailable ? realtimeCache.movers[symbol] : realtimeCache.main;

    if (!dataSource || (!dataSource.klines && !dataSource.klines_1h)) {
        return { score: 0, breakdown: {} };
    }

    const klines = isMoverDataAvailable 
        ? dataSource.klines_1h.map(k => [k.Open_time, k.Open, k.High, k.Low, k.Close, k.Volume, k.Close_time]) 
        : dataSource.klines;
    
    const closes = klines.map(k => parseFloat(k[4]));

    const indicators = {
        candlePattern: findCandlestickPatterns(klines),
        macd: calculateMACD(closes),
        rsi: calculateRSI(closes),
        bollingerBands: analyzeBollingerBandsPriceAction(klines, calculateBollingerBands(closes)),
        cvd: CVDanalyze(klines, dataSource.cvdData || calculateCVD(dataSource.aggTrades || [])),
        atr: calculateATR(klines)
    };
    
    const atrStatus = indicators.atr.status;
    let volatilityMultiplier = 1.0; 

    if (atrStatus === 'Tinggi') {
        volatilityMultiplier = 0.75;
    } else if (atrStatus === 'Sangat Tinggi') {
        volatilityMultiplier = 0.5;
    }

    const lastRsiValue = indicators.rsi.filter(v => v !== undefined).pop() || 50;
    let score = 0;
    
    let breakdown = {
        rsiValue: lastRsiValue.toFixed(2),
        macdStatus: indicators.macd.status,
        bbStatus: indicators.bollingerBands.rejection,
        cvdStatus: indicators.cvd.divergence,
        candlePattern: indicators.candlePattern.pattern,
        candleRed: { triggered: false, points: 0 },
        doji: { triggered: false, points: 0 },
        cvdDip: { triggered: false, points: 0 },
        cvdDivergence: { triggered: false, points: 0 },
        rsiOverbought: { triggered: false, points: 0 },
        bbRejection: { triggered: false, points: 0 },
        macdCross: { triggered: false, points: 0 },
        // [BARU] Tambahkan properti baru untuk volume exhaustion di breakdown
        volumeExhaustion: { triggered: false, points: 0 }
    };

    const lookbackPeriod = 15;
    const recentKlines = klines.slice(-lookbackPeriod);
    
    if (recentKlines.length >= 3) {
        let peakIndex = 0;
        for (let i = 1; i < recentKlines.length; i++) {
            if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
        }

        // --- Perhitungan Skor dengan Multiplier ---
        if (peakIndex < lookbackPeriod - 2) {
            const triggerCandleArr = recentKlines[peakIndex + 1];
            if (triggerCandleArr) {
                const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                if (triggerCandle.Close < triggerCandle.Open) {
                    const points = 3 * volatilityMultiplier;
                    score += points;
                    breakdown.candleRed = { triggered: true, points: points };
                }
            }
        }
        
        // [BARU] BLOK LOGIKA UNTUK VOLUME EXHAUSTION
        if (peakIndex > 4 && peakIndex < recentKlines.length - 1) { // Pastikan ada cukup data sebelum puncak
            const pumpVolumeLookback = 5;
            const pumpCandles = recentKlines.slice(peakIndex - pumpVolumeLookback, peakIndex);
            
            if (pumpCandles.length > 0) {
                const avgPumpVolume = pumpCandles.reduce((sum, k) => sum + parseFloat(k[5]), 0) / pumpCandles.length;
                const peakVolume = parseFloat(recentKlines[peakIndex][5]);

                // Kondisi: Volume di puncak < 60% dari rata-rata volume pendorongnya
                if (peakVolume < (avgPumpVolume * 0.6)) {
                    const points = 2; // Poin tetap, karena ini sinyal kuat
                    score += points;
                    breakdown.volumeExhaustion = { triggered: true, points: points };
                }
            }
        }
        // [AKHIR BLOK BARU]
    }
    
    if (indicators.candlePattern.bias === 'BEARISH') {
        const points = 1 * volatilityMultiplier;
        score += points;
        breakdown.doji = { triggered: true, points: points };
    }
    
    const cvdValues = (dataSource.cvdData || calculateCVD(dataSource.aggTrades || [])).map(d => d.cvd_usdt);
    if (cvdValues.length > 5) {
        const recentCvdSegment = cvdValues.slice(-5);
        if (recentCvdSegment.length === 5) {
            const startCvd = recentCvdSegment[0];
            const endCvd = recentCvdSegment[4];
            if (endCvd < startCvd) { 
                const points = 2 * volatilityMultiplier;
                score += points;
                breakdown.cvdDip = { triggered: true, points: points };
            }
        }
    }

    if (indicators.cvd.divergence.includes('Bearish')) {
        const points = 2 * volatilityMultiplier;
        score += points;
        breakdown.cvdDivergence = { triggered: true, points: points };
    }
    
    if (lastRsiValue > 70) {
        const points = 2 * volatilityMultiplier;
        score += points;
        breakdown.rsiOverbought = { triggered: true, points: points };
    }

    // --- Trigger Robust (Poin Tetap) ---
    if (indicators.bollingerBands.rejection === 'Bearish Rejection (Upper BB)') {
        score += 3;
        breakdown.bbRejection = { triggered: true, points: 3 };
    }
    if (indicators.macd.status === 'Bearish Cross') {
        score += 2;
        breakdown.macdCross = { triggered: true, points: 2 };
    }
    
    return { score: Math.min(score, 10), breakdown };
}

function getConfluenceAnalysis(klines) {
    if (!klines || klines.length < 50) {
        return { skorBullish: 0, skorBearish: 0, detail: 'Data Kurang' };
    }

    let skorBullish = 0;
    let skorBearish = 0;
    const closes = klines.map(k => parseFloat(k[4]));

    // --- Kalkulasi Indikator Penting ---
    const rsiValues = calculateRSI(closes);
    const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
    const macd = calculateMACD(closes);
    const candlePattern = findCandlestickPatterns(klines);
    const rsiDivergence = detectRSIDivergence(closes, rsiValues);

    // --- Logika Penilaian Bearish ---
    if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
    if (macd.status === 'Bearish Cross') skorBearish += 2.0;
    if (lastRsi > 70) skorBearish += 1.5; // Overbought
    if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

    // --- Logika Penilaian Bullish ---
    if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
    if (macd.status === 'Bullish Cross') skorBullish += 2.0;
    if (lastRsi < 30) skorBullish += 1.5; // Oversold
    if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
    
    // Total skor maksimal adalah 8
    const totalPossibleScore = 8.0;

    return { 
        skorBullish: (skorBullish / totalPossibleScore) * 10,
        skorBearish: (skorBearish / totalPossibleScore) * 10,
        detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
    };
}
// GANTI SELURUH FUNGSI onNewMoverData DENGAN KODE INI
// GANTI SELURUH FUNGSI onNewMoverData DENGAN KODE INI
// GANTI SELURUH FUNGSI onNewMoverData DENGAN KODE LENGKAP INI

function onNewMoverData(symbol, streamName, payload) {
    // Pastikan ada objek untuk simbol ini di cache
    if (!realtimeCache.movers[symbol]) {
        realtimeCache.movers[symbol] = { klines_1h: [], aggTrades: [], orderBook: { bids: [], asks: [] } };
    }
    const moverData = realtimeCache.movers[symbol];

    // Perbarui data berdasarkan jenis stream (kline, trade, atau order book)
    if (streamName.includes('@kline_1h')) {
        const k = payload.k;
        const newKline = { Open_time: k.t, Open: parseFloat(k.o), High: parseFloat(k.h), Low: parseFloat(k.l), Close: parseFloat(k.c), Volume: parseFloat(k.v), Close_time: k.T };
        if (moverData.klines_1h.length > 0 && moverData.klines_1h[moverData.klines_1h.length - 1].Open_time === k.t) {
            moverData.klines_1h[moverData.klines_1h.length - 1] = newKline;
        } else {
            moverData.klines_1h.push(newKline);
        }
        if (moverData.klines_1h.length > 200) moverData.klines_1h.shift();
    } else if (streamName.includes('@aggTrade')) {
        moverData.aggTrades.push(payload);
        if (moverData.aggTrades.length > 1000) moverData.aggTrades.shift();
    } else if (streamName.includes('@depth20')) {
        moverData.orderBook = { bids: payload.bids, asks: payload.asks };
    }
    
    // --- ALUR LOGIKA BARU YANG EFISIEN ---

    // 1. Panggil "Si Otak" SEKALI SAJA untuk menghitung skor Dump Risk
    const scoreData = calculateShortConfluenceScore(symbol);

    if (scoreData !== null) {
        // 2. Langsung perbarui UI untuk bar di panel Top Movers
        updateShortScoreUI(symbol, scoreData.score, scoreData.breakdown);

        // 3. Cek apakah aset ini yang sedang kita lihat di panel utama
        if (realtimeCache.main.symbol === symbol) {
            // Jika ya, lakukan sinkronisasi:
            
            // a. Hitung Pump Strength
            const klines1h = moverData.klines_1h;
            if (klines1h.length >= 2) {
                const prevClose = klines1h[klines1h.length - 2].Close;
                const lastClose = klines1h[klines1h.length - 1].Close;
                const change1h = ((lastClose - prevClose) / prevClose) * 100;
                const totalVolume = klines1h.reduce((sum, k) => sum + k.Volume, 0);
                const strengthScore = change1h * Math.log10(totalVolume + 1);
                realtimeCache.main.liveScores.pumpStrength = (change1h > 0) ? Math.min(100, strengthScore) : 0;
            } else {
                realtimeCache.main.liveScores.pumpStrength = 0;
            }
            
            // b. Simpan skor Dump Risk yang sudah kita hitung tadi ke cache utama
            realtimeCache.main.liveScores.dumpRisk = scoreData.score;
            
            // c. Picu update UI untuk panel "Setup Scalping Cepat"
            calculateAndDisplayScalpingSetup();
        }
    }
}

// GANTI SELURUH FUNGSI DENGAN KODE LENGKAP INI
function calculateAndDisplayScalpingSetup() {
    // Bagian awal ini tetap sama (mengambil data)
    const { klines, calculatedData, symbol, selectedTimeframe, klines1h } = realtimeCache.main;
    if (!klines || klines.length < 50 || !calculatedData) {
        document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Data tidak cukup.</p>';
        return;
    }
    document.getElementById('scalping-timeframe-display').textContent = `${symbol} - ${selectedTimeframe}`;
    const scoreData = calculateShortConfluenceScore(symbol) || { score: 0, breakdown: {} };
    const dumpRiskScore = scoreData.score;
    const triggerBreakdown = scoreData.breakdown;
    const pumpStrength = realtimeCache.main.liveScores.pumpStrength || 0;
    document.getElementById('main-pump-bar').style.width = `${pumpStrength}%`;
    document.getElementById('main-dump-bar').style.width = `${dumpRiskScore * 10}%`;
    document.getElementById('main-pump-score').textContent = `${pumpStrength.toFixed(0)}%`;
    document.getElementById('main-dump-score').textContent = `${dumpRiskScore}/10`;
    renderTriggerBreakdown(triggerBreakdown);

    // Bagian penentuan Bias Kontekstual juga tetap sama
    const container = document.getElementById('scalping-setup-content');
    const closes = klines.map(k => parseFloat(k[4]));
    const lastPrice = closes[closes.length - 1];
    let biasKontekstual = "NETRAL / CHOP";
    let biasClass = "status-chop";
    let biasDetail = "Menunggu sinyal...";
    let trenUtama = "CHOP";
    if (klines1h && klines1h.length > 50) {
        const closes1h = klines1h.map(k => parseFloat(k[4]));
        const ema21_1h = calculateEMA(closes1h, 21).pop();
        const ema50_1h = calculateEMA(closes1h, 50).pop();
        if (ema21_1h > ema50_1h) trenUtama = "UPTREND";
        if (ema50_1h > ema21_1h) trenUtama = "DOWNTREND";
    }
    const analisisTrigger = getConfluenceAnalysis(klines); 
    const { skorBullish, skorBearish, detail } = analisisTrigger;
    biasDetail = detail;
    if (skorBullish > skorBearish + 1.5) {
        if (trenUtama === 'UPTREND') {
            biasKontekstual = 'LONG (Follow Trend)';
            biasClass = 'status-uptrend';
        } else if (trenUtama === 'DOWNTREND') {
            biasKontekstual = 'LONG (Counter Trend)';
            biasClass = 'status-uptrend';
        } else {
            biasKontekstual = 'LONG (Range Trading)';
            biasClass = 'status-uptrend';
        }
    } else if (skorBearish > skorBullish + 1.5) {
        if (trenUtama === 'DOWNTREND') {
            biasKontekstual = 'SHORT (Follow Trend)';
            biasClass = 'status-downtrend';
        } else if (trenUtama === 'UPTREND') {
            biasKontekstual = 'SHORT (Counter Trend)';
            biasClass = 'status-downtrend';
        } else {
            biasKontekstual = 'SHORT (Range Trading)';
            biasClass = 'status-downtrend';
        }
    }

    // [PERBAIKAN KUNCI]
    // Logika pengecekan sekarang ada di sini, SEBELUM kalkulasi apapun.
    if (biasKontekstual !== "NETRAL / CHOP") {
        // --- JIKA TIDAK NETRAL, BARU LAKUKAN SEMUA KALKULASI SL/TP ---

        // [DIPINDAHKAN KE SINI]
        // Semua logika kalkulasi sekarang aman di dalam blok ini.
        const biasKalkulator = biasKontekstual.startsWith('LONG') ? 'LONG' : 'SHORT';
        const ema9 = calculateEMA(closes, 9).pop();
        let entryPrice, stopLoss, takeProfit1, takeProfit2, takeProfit3;
        const recentKlines = klines.slice(-15);
        const recentSwingHigh = Math.max(...recentKlines.map(k => parseFloat(k[2])));
        const recentSwingLow = Math.min(...recentKlines.map(k => parseFloat(k[3])));

        if (biasKalkulator === 'LONG') {
            entryPrice = ema9;
            stopLoss = recentSwingLow * 0.999;
            takeProfit1 = recentSwingHigh;
            const rrTarget2 = entryPrice + (Math.abs(entryPrice - stopLoss) * 1.5);
            takeProfit2 = Math.max(rrTarget2, takeProfit1);
            const upperBB = calculatedData.bollingerBands.upper.filter(v=>v).pop();
            const dailyPivot = calculatedData.pivot.data?.P;
            let potentialTP3s = [upperBB, dailyPivot].filter(p => p && p > takeProfit2);
            takeProfit3 = potentialTP3s.length > 0 ? Math.min(...potentialTP3s) : 'N/A';
        } else { // SHORT
            entryPrice = ema9;
            stopLoss = recentSwingHigh * 1.001;
            takeProfit1 = recentSwingLow;
            const rrTarget2 = entryPrice - (Math.abs(stopLoss - entryPrice) * 1.5);
            takeProfit2 = Math.min(rrTarget2, takeProfit1);
            const lowerBB = calculatedData.bollingerBands.lower.filter(v=>v).pop();
            const dailyPivot = calculatedData.pivot.data?.P;
            let potentialTP3s = [lowerBB, dailyPivot].filter(p => p && p < takeProfit2);
            takeProfit3 = potentialTP3s.length > 0 ? Math.max(...potentialTP3s) : 'N/A';
        }

        const calculatePercentage = (targetPrice, entry) => {
            if (typeof targetPrice !== 'number' || entry === 0) return '';
            return `(${( (targetPrice - entry) / entry * 100).toFixed(2)}%)`;
        };

        const entryPercent = `(Pullback ke ${calculatePercentage(entryPrice, lastPrice)})`;
        const slPercent = calculatePercentage(stopLoss, entryPrice);
        const tp1Percent = calculatePercentage(takeProfit1, entryPrice);
        const tp2Percent = calculatePercentage(takeProfit2, entryPrice);
        const tp3Percent = calculatePercentage(takeProfit3, entryPrice);
        const slColorClass = 'negative';
        const tpColorClass = 'positive';
        const tp3Display = takeProfit3 !== 'N/A' ? `${formatPrice(takeProfit3)}<br><span class="text-xs font-mono ${tpColorClass}">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';

        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                <div class="col-span-1">
                     <p class="text-xs text-gray-500">Bias Kontekstual (TF: 1H)</p>
                     <p class="font-bold text-lg blinking-text-animation ${biasClass}">${biasKontekstual}</p>
                     <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
                </div>
                <div class="col-span-2 grid grid-cols-2 gap-4">
                     <div>
                        <p class="text-xs text-gray-500">Saran Entri</p>
                        <p class="font-semibold text-sm text-yellow-400">${formatPrice(entryPrice)}</p>
                        <p class="text-xs font-mono text-yellow-500">${entryPercent}</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-500">SL (Struktural)</p>
                        <p class="font-semibold text-sm ${slColorClass}">${formatPrice(stopLoss)}</p>
                        <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                    </div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">TP 1 (Struktural)</p>
                    <p class="font-semibold ${tpColorClass}">${formatPrice(takeProfit1)}</p>
                    <p class="text-xs font-mono ${tpColorClass}">${tp1Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 2 (R:R 1:1.5)</p>
                    <p class="font-semibold ${tpColorClass}">${formatPrice(takeProfit2)}</p>
                    <p class="text-xs font-mono ${tpColorClass}">${tp2Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 3 (Level Kunci)</p>
                    <p class="font-semibold text-sm">${tp3Display}</p>
                </div>
            </div>
        `;
        
        calculatePositionSize({ entry: entryPrice, sl: stopLoss, tp1: takeProfit1 });
        realtimeCache.main.latestScalpingSetup = { entry: entryPrice, sl: stopLoss, tp1: takeProfit1 };

    } else { 
        // --- JIKA NETRAL, TAMPILKAN PESAN PERINGATAN ---
        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                 <div class="col-span-3">
                     <p class="text-xs text-gray-500">Bias Kontekstual (TF: 1H)</p>
                     <p class="font-bold text-lg ${biasClass}">${biasKontekstual}</p>
                     <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-center p-4 rounded-lg bg-gray-100 dark:bg-gray-800/50">
                <p class="font-semibold text-yellow-400">PASAR SIDEWAYS / CHOP</p>
                <p class="text-sm text-gray-400 mt-1">Tidak ada setup Long/Short yang jelas. Disarankan untuk tidak masuk posisi.</p>
            </div>
        `;
        
        calculatePositionSize(null);
        realtimeCache.main.latestScalpingSetup = null;
    }
}
// GANTI FUNGSI YANG ADA DENGAN INI
// GANTI SELURUH FUNGSI DENGAN VERSI "CERDAS" INI
function calculateShortConfluenceScore(symbol = realtimeCache.main.symbol) {
    if (!symbol) return { score: 0, breakdown: {} };

    const isMoverDataAvailable = realtimeCache.movers[symbol] && realtimeCache.movers[symbol].klines_1h && realtimeCache.movers[symbol].klines_1h.length > 20;
    const dataSource = isMoverDataAvailable ? realtimeCache.movers[symbol] : realtimeCache.main;

    if (!dataSource || (!dataSource.klines && !dataSource.klines_1h)) {
        return { score: 0, breakdown: {} };
    }

    const klines = isMoverDataAvailable 
        ? dataSource.klines_1h.map(k => [k.Open_time, k.Open, k.High, k.Low, k.Close, k.Volume, k.Close_time]) 
        : dataSource.klines;
    
    const closes = klines.map(k => parseFloat(k[4]));

    const indicators = {
        candlePattern: findCandlestickPatterns(klines),
        macd: calculateMACD(closes),
        rsi: calculateRSI(closes),
        bollingerBands: analyzeBollingerBandsPriceAction(klines, calculateBollingerBands(closes)),
        cvd: CVDanalyze(klines, dataSource.cvdData || calculateCVD(dataSource.aggTrades || [])),
        atr: calculateATR(klines)
    };
    
    const atrStatus = indicators.atr.status;
    let volatilityMultiplier = 1.0; 

    if (atrStatus === 'Tinggi') {
        volatilityMultiplier = 0.75;
    } else if (atrStatus === 'Sangat Tinggi') {
        volatilityMultiplier = 0.5;
    }

    const lastRsiValue = indicators.rsi.filter(v => v !== undefined).pop() || 50;
    let score = 0;
    
    // [UPGRADE] Breakdown sekarang menyimpan objek { triggered, points }
    let breakdown = {
        rsiValue: lastRsiValue.toFixed(2),
        macdStatus: indicators.macd.status,
        bbStatus: indicators.bollingerBands.rejection,
        cvdStatus: indicators.cvd.divergence,
        candlePattern: indicators.candlePattern.pattern,
        candleRed: { triggered: false, points: 0 },
        doji: { triggered: false, points: 0 },
        cvdDip: { triggered: false, points: 0 },
        cvdDivergence: { triggered: false, points: 0 },
        rsiOverbought: { triggered: false, points: 0 },
        bbRejection: { triggered: false, points: 0 },
        macdCross: { triggered: false, points: 0 }
    };

    const lookbackPeriod = 15;
    const recentKlines = klines.slice(-lookbackPeriod);
    
    // --- Perhitungan Skor dengan Multiplier ---
    if (recentKlines.length >= 3) {
        let peakIndex = 0;
        for (let i = 1; i < recentKlines.length; i++) {
            if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
        }
        if (peakIndex < lookbackPeriod - 2) {
            const triggerCandleArr = recentKlines[peakIndex + 1];
            if (triggerCandleArr) {
                const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                if (triggerCandle.Close < triggerCandle.Open) {
                    const points = 3 * volatilityMultiplier;
                    score += points;
                    breakdown.candleRed = { triggered: true, points: points };
                }
            }
        }
    }
    
    if (indicators.candlePattern.bias === 'BEARISH') {
        const points = 1 * volatilityMultiplier;
        score += points;
        breakdown.doji = { triggered: true, points: points };
    }
    
    const cvdValues = calculateCVD(dataSource.aggTrades || []).map(d => d.cvd_usdt);
    if (cvdValues.length > 5) {
        const recentCvdSegment = cvdValues.slice(-5);
        const startCvd = recentCvdSegment[0];
        const endCvd = recentCvdSegment[4];
        if (endCvd < startCvd) { 
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.cvdDip = { triggered: true, points: points };
        }
    }

    if (indicators.cvd.divergence.includes('Bearish')) {
        const points = 2 * volatilityMultiplier;
        score += points;
        breakdown.cvdDivergence = { triggered: true, points: points };
    }
    
    if (lastRsiValue > 70) {
        const points = 2 * volatilityMultiplier;
        score += points;
        breakdown.rsiOverbought = { triggered: true, points: points };
    }

    // --- Trigger Robust (Poin Tetap) ---
    if (indicators.bollingerBands.rejection === 'Bearish Rejection (Upper BB)') {
        score += 3;
        breakdown.bbRejection = { triggered: true, points: 3 };
    }
    if (indicators.macd.status === 'Bearish Cross') {
        score += 2;
        breakdown.macdCross = { triggered: true, points: 2 };
    }
    
    return { score: Math.min(score, 10), breakdown };
}

function updateShortScoreUI(symbol, score, breakdown) {
    const dumpRiskElement = document.querySelector(`#hybrid-bar-${symbol} .dump-risk`);
    if (dumpRiskElement) dumpRiskElement.style.width = `${score * 10}%`;
    const moverItem = document.querySelector(`.mover-item[data-symbol="${symbol}"]`);
    if (moverItem) {
        moverItem.dataset.dumpRiskScore = score;
        moverItem.dataset.breakdown = JSON.stringify(breakdown || {});
    }
}

function attachTopMoversListeners() {
    document.querySelectorAll("#gainers-list .mover-item").forEach(el => {
        el.addEventListener("mouseenter", e => { showCustomTooltip(e.currentTarget); });
        el.addEventListener("mouseleave", () => { hideCustomTooltip(); });
        el.addEventListener("click", e => {
            if (!el.classList.contains("tooltip-active")) {
                document.querySelectorAll('.mover-item.tooltip-active').forEach(activeEl => activeEl.classList.remove('tooltip-active'));
                el.classList.add("tooltip-active");
                showCustomTooltip(e.currentTarget);
                e.stopPropagation();
            } else {
                el.classList.remove("tooltip-active");
                hideCustomTooltip();
                runFullAnalysis(el.dataset.symbol);
            }
        });
    });
}

function showCustomTooltip(target) {
    isTooltipActive = true;
    const tooltip = document.getElementById("custom-tooltip");
    const symbol = target.dataset.symbol;
    const score = target.dataset.dumpRiskScore || '0';
    const breakdown = JSON.parse(target.dataset.breakdown || '{}');

    tooltip.innerHTML = `
        <strong>${symbol} - Analisis Short</strong>
        <p>Skor Potensi Dump: ${score}/10</p>
        <ul class="list-none text-xs mt-2 space-y-1">
            <li>Candle Merah: ${breakdown.candleRed ? "✅" : "❌"}</li>
            <li>CVD Menukik: ${breakdown.cvd ? "✅" : "❌"}</li>
            <li>Shooting Star/Doji: ${breakdown.doji ? "✅" : "❌"}</li>
            <li class="italic text-gray-500">Resistance & Sell Wall (di panel utama)</li>
        </ul>`;
    tooltip.style.opacity = 1;
    tooltip.style.visibility = "visible";
    const rect = target.getBoundingClientRect();
    tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
    tooltip.style.left = `${rect.left + window.scrollX}px`;
}

function hideCustomTooltip() {
    isTooltipActive = false;
    const tooltip = document.getElementById("custom-tooltip");
    if(tooltip) {
        tooltip.style.opacity = 0;
        tooltip.style.visibility = "hidden";
    }
    document.querySelectorAll('.mover-item.tooltip-active').forEach(el => el.classList.remove('tooltip-active'));
}

function initTopMoversTimeframeSelector() {
    document.querySelectorAll(".top-movers-tf-btn").forEach(btn => {
        btn.addEventListener("click", () => {
            document.querySelectorAll(".top-movers-tf-btn").forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
            const timeframe = btn.dataset.timeframe;
            startTopMoversAutoRefresh(timeframe, currentInterval);
        });
    });
}

function initRefreshIntervalSelector() {
    const select = document.getElementById("refresh-interval-select");
    select.addEventListener("change", () => {
        const interval = parseInt(select.value, 10);
        startTopMoversAutoRefresh(currentTimeframe, interval);
    });
}

function startTopMoversAutoRefresh(timeframe = "1h", interval = 10000) {
    currentTimeframe = timeframe;
    currentInterval = interval;
    remainingTime = interval / 1000;
    if (topMoversInterval) clearInterval(topMoversInterval);
    if (topMoversCountdown) clearInterval(topMoversCountdown);
    
    updateTopMovers(timeframe);
    
    topMoversInterval = setInterval(() => {
        if (!isTooltipActive) {
            updateTopMovers(timeframe);
            remainingTime = interval / 1000;
        }
    }, interval);
    
    topMoversCountdown = setInterval(() => {
        if (!isTooltipActive) {
            remainingTime--;
            if (remainingTime < 0) remainingTime = interval / 1000;
        }
        const countdownEl = document.getElementById("refresh-countdown");
        if (countdownEl) {
            countdownEl.textContent = isTooltipActive ? "⏸ Paused" : `⏱️ ${remainingTime}s`;
        }
    }, 1000);
}

// --- AKHIR BLOK FINAL ---
// =======================================================
// BAGIAN 5: EVENT LISTENER UTAMA
// =======================================================
document.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    loadWatchlist();
    
    // [FINAL] Inisialisasi semua fungsi Top Movers baru
    initTopMoversTimeframeSelector(); 
    initRefreshIntervalSelector();
    startTopMoversAutoRefresh("1h", 10000); // Default: 1h, 10s 

    // Sisa event listener Anda yang tidak berubah
    scanWatchlist();
    adjustContentPadding();
    setupToggle('toggle-scalping-btn', 'scalping-content-wrapper', 'toggle-scalping-icon', true);
    setupToggle('toggle-risk-btn', 'risk-content-wrapper', 'toggle-risk-icon', false);
    setupToggle('toggle-sentiment-btn', 'sentiment-content-wrapper', 'toggle-sentiment-icon', false);
    setupToggle('toggle-market-state-btn', 'current-state-content-wrapper', 'toggle-market-state-icon', true);
    setupToggle('toggle-confluence-btn', 'confluence-content-wrapper', 'toggle-confluence-icon', false);
    setupToggle('toggle-onchain-btn', 'onchain-content-wrapper', 'toggle-onchain-icon', false);        
    setupToggle('toggle-settings-btn', 'settings-content-wrapper', 'toggle-settings-icon', false);
    setupToggle('toggle-ai-verdict-btn', 'ai-verdict-content-wrapper', 'toggle-ai-verdict-icon', true);
    
    window.addEventListener('resize', adjustContentPadding); 
    document.getElementById('save-settings-btn').addEventListener('click', saveSettings);
    
    timeframeSelect.addEventListener('change', (e) => {
        adaptIndicatorParamsToTimeframe(e.target.value);
    });

    themeToggleBtn.addEventListener('click', () => {
        document.documentElement.classList.toggle('dark');
        darkIcon.classList.toggle('hidden');
        lightIcon.classList.toggle('hidden');
        localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            if (isChartsVisible) { 
                destroyCharts();
                renderAllCharts();
            }
            if (cvdChartInstance) {
                const isDarkMode = document.documentElement.classList.contains('dark');
                const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
                const negativeColor = isDarkMode ? '#f87171' : '#dc2626';
                cvdChartInstance.data.datasets[0].segment.borderColor = ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor;
                cvdChartInstance.options.scales.x.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                cvdChartInstance.options.scales.y.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                cvdChartInstance.options.scales.y.grid.color = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                cvdChartInstance.update();
            }
    });

    if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
        darkIcon.classList.remove('hidden');
    } else {
        lightIcon.classList.remove('hidden');
    }

    apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
    apiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', apiKeyInput.value));
    assetInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') runFullAnalysis(); });
    const presetSelect = document.getElementById('preset-select');

    presetSelect.addEventListener('change', (e) => {
        applyPreset(e.target.value);
    });

    document.getElementById('risk-amount-input').addEventListener('input', () => {
        if (realtimeCache.main.latestScalpingSetup) {
            calculatePositionSize(realtimeCache.main.latestScalpingSetup);
        }
    });

    document.getElementById('vwap-mode-buttons').addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const mode = e.target.dataset.mode;
            document.querySelectorAll('.vwap-mode-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            updateVwapDisplay(mode);
        }
    });

    document.getElementById('run-comprehensive-ai-btn').addEventListener('click', runComprehensiveAIAnalysis);
    
    tradeLink.addEventListener('click', (e) => {
        e.preventDefault();
        const binanceSymbol = realtimeCache.main.binanceSymbol;
        if (!binanceSymbol) return;
        const marketType = marketTypeSelect.value;
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const desktopUrl = marketType === 'futures' ? `https://www.binance.com/en/futures/${binanceSymbol}` : `https://www.binance.com/en/trade/${binanceSymbol}`;
        const mobileUrl = marketType === 'futures' ? `binance://futures/trade?symbol=${binanceSymbol}` : `binance://trade?symbol=${binanceSymbol}`;
        if (isMobile) {
            window.location.href = mobileUrl;
            setTimeout(() => { window.location.href = desktopUrl; }, 1500);
        } else {
            window.open(desktopUrl, '_blank');
        }
    });

    marketTypeSelect.addEventListener('change', () => initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message)));
    initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message));
    toggleChartsBtn.addEventListener('click', () => toggleChartsVisibility());
    saveWatchlistBtn.addEventListener('click', saveWatchlist);
    scanWatchlistBtn.addEventListener('click', scanWatchlist);
    resetBtn.addEventListener('click', resetDashboard);
    const tooltipElement = document.createElement('div');
    tooltipElement.id = 'custom-tooltip';
    document.body.appendChild(tooltipElement);

    // GANTI event listener ini di bagian bawah skrip Anda
const debouncedRunAnalysis = debounce(runFullAnalysis, 500); 
analyzeBtn.addEventListener('click', () => {
    analyzeBtn.disabled = true;
    debouncedRunAnalysis();
});
assetInput.addEventListener('keypress', (e) => { 
    if (e.key === 'Enter') {
        analyzeBtn.disabled = true; 
        debouncedRunAnalysis();
    } 
});
    
    const showTooltip = (e) => {
        const target = e.currentTarget;
        const tooltipContent = target.getAttribute('data-tooltip');
        if (!tooltipContent) return;
        
        const [title, ...body] = tooltipContent.split('|');
        const formattedContent = `<strong>${title}</strong><p>${body.join('<br>')}</p>`;
        tooltipElement.innerHTML = formattedContent;

        const targetRect = target.getBoundingClientRect();
        tooltipElement.style.opacity = '1';
        tooltipElement.style.visibility = 'visible';
        
        const tooltipRect = tooltipElement.getBoundingClientRect();
        let top = targetRect.top - tooltipRect.height - 10;
        let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);

        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        if (top < 10) {
            top = targetRect.bottom + 10;
            tooltipElement.style.setProperty('--arrow-top', '-6px');
            tooltipElement.style.setProperty('--arrow-border-color', 'transparent transparent #2d3748 transparent');
        } else {
            tooltipElement.style.setProperty('--arrow-top', '100%');
            tooltipElement.style.setProperty('--arrow-border-color', '#2d3748 transparent transparent transparent');
        }

        tooltipElement.style.left = `${left}px`;
        tooltipElement.style.top = `${top + window.scrollY}px`;
    };

    const hideTooltip = () => {
        tooltipElement.style.opacity = '0';
        tooltipElement.style.visibility = 'hidden';
    };

    const triggers = document.querySelectorAll('[data-tooltip]');
    triggers.forEach(trigger => {
        trigger.classList.add('tooltip-trigger');
        trigger.addEventListener('mouseenter', showTooltip);
        trigger.addEventListener('mouseleave', hideTooltip);
        
        let isTooltipVisible = false;
        trigger.addEventListener('click', (e) => {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                e.preventDefault();
                if (!isTooltipVisible) {
                    showTooltip(e);
                    isTooltipVisible = true;
                } else {
                    hideTooltip();
                    isTooltipVisible = false;
                }
            }
        });
    });
    
    document.body.addEventListener('click', (e) => {
        if (!e.target.hasAttribute('data-tooltip')) {
            hideTooltip();
            triggers.forEach(trigger => trigger.isTooltipVisible = false);
        }
    }, true);
});
</script>
</body>
</html