<!DOCTYPE html>
<html lang="id" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate CEX_DEX</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF7;
            color: #3D352E;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .card {
            background-color: #FFFFFF;
            border: 1px solid #EAE5E0;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            transition: all 0.3s ease-in-out;
        }
        .btn-primary {
            background-color: #c97c00;
            color: #2b2a28;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary:hover { background-color: #eb9413 }
        .btn-primary:disabled { background-color: #303710; cursor: not-allowed; }
        .input-primary {
            background-color: #F8F5F1;
            border: 1px solid #DCD6CF;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #3D352E;
        }
        .input-primary:focus {
            outline: none;
            border-color: #747462;
            box-shadow: 0 0 0 2px rgba(34, 55, 40, 0.2);
        }
        .tag { padding: 0.25rem 0.625rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; }
        .tag-green { background-color: #E6F4EA; color: #4A7C59; }
        .tag-red { background-color: #FCE8E8; color: #A83A3A; }
        .tag-yellow { background-color: #FFF8E1; color: #B5840F; }
        .tag-gray { background-color: #F1F3F4; color: #5F6368; }

        /* Dark Mode Styles */
        .dark body { background-color: #000000; color: #E0E0E0; }
        .dark .card { background-color: #1e1d1d; border-color: #333; }
        .dark .input-primary { background-color: #1c1b1b; border-color: #444; color: #E0E0E0; }
        .dark .input-primary:focus { border-color: #2b2d2b; box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.3); }
        .dark .tag-green { background-color: rgba(74, 124, 89, 0.2); color: #69b37f; }
        .dark .tag-red { background-color: rgba(168, 58, 58, 0.2); color: #d17474; }
        .dark .tag-yellow { background-color: rgba(181, 132, 15, 0.2); color: #e0c273; }
        .dark .tag-gray { background-color: rgba(95, 99, 104, 0.2); color: #9aa0a6; }
        .dark .text-gray-800 { color: #E0E0E0; }
        .dark .text-gray-500 { color: #9E9E9E; }
        .dark .text-gray-600 { color: #BDBDBD; }
        .dark .text-gray-700 { color: #E0E0E0; }
        .dark hr { border-color: #3e4946; }
        .dark .positive { color: #69b37f; }
        .dark .negative { color: #d17474; }

        /* Chart Container Styles */
        .chart-container { position: relative; width: 100%; }
        #main-chart-container { height: 450px; }
        .pane-chart-container { height: 150px; margin-top: 8px; border-top: 1px solid rgba(128, 128, 128, 0.2); padding-top: 8px;}
        .pane-title { position: absolute; top: 15px; left: 15px; z-index: 10; font-size: 12px; font-weight: bold; color: #dddddd; }
        .dark .pane-title { color: #d9d5d5; }

        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px; /* Jarak antar titik */
        }

        .dot {
            width: 14px;
            height: 14px;
            background-color: #289498; /* Warna hijau dari tema Anda */
            border-radius: 50%;
            animation: bounce 1.0s infinite ease-in-out both;
        }

        /* Atur penundaan animasi untuk setiap titik */
        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1.5);
            }
        }
        
        .positive { color: #16a34a; }
        .dark .positive { color: #4ade80; }
        .negative { color: #dc2626; }
        .dark .negative { color: #f87171; }
        .blinking-text-animation { animation: blinking-text 1.0s infinite; }
        @keyframes blinking-text { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        /* Untuk loader di dalam tombol, buat titiknya lebih kecil */
        #button-loader .dot {
            width: 8px;
            height: 8px;
        }

        /* Style untuk tombol toggle indikator */
        .toggle-btn {
            background-color: #E7A13B;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #d1d5db;
        }
        .toggle-btn:hover {
            background-color: #d1d5db;
        }
        .toggle-btn.active {
            background-color: #4A7C59;
            color: #ffffff;
            border-color: #4A7C59;
        }
        .dark .toggle-btn {
            background-color: #1c1b1b;
            color: #d1d5db;
            border-color: #444;
        }
        .dark .toggle-btn:hover {
            background-color: #444;
        }
        .dark .toggle-btn.active {
            background-color: #4A7C59;
            color: #ffffff;
            border-color: #4A7C59;
        }
        .projection-results-container .card {
            background-color: #1c1b1b;
            border-color: #444;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .projection-results-container h4 {
            font-size: 1rem;
            color: #6ee7b7;
        }
        .projection-results-container p {
            color: #e0e0e0;
        }
        .btn-yellow {
            background-color: #f59e0b; /* Tailwind yellow-500 */
            color: #1f2937; /* Tailwind gray-800 */
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-yellow:hover {
            background-color: #d97706;
        }
        .dark .btn-yellow {
            color: #120f0f;
        }
        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }
        #trade-link:hover {
            text-decoration: none;
        }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (MULAI) === */
        .status-uptrend { color: #34d399; }
        .dark .status-uptrend { color: #4ade80; }
        .status-downtrend { color: #ef4444; }
        .dark .status-downtrend { color: #f87171; }
        .status-chop { color: #fbbf24; }
        .dark .status-chop { color: #fcd34d; }

        .confluence-bar-container {
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            height: 30px;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .dark .confluence-bar-container { background-color: #374151; }

        .confluence-bar {
            height: 100%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
            color: #111827;
        }

        .confluence-bar-bullish { background: linear-gradient(to right, #22c55e, #86efac); }
        .confluence-bar-bearish { background: linear-gradient(to right, #ef4444, #fca5a5); }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (SELESAI) === */
        .dark .btn-yellow {
            color: #120f0f;
        }
        /* === TAMBAHKAN BLOK CSS DI BAWAH INI === */
        .btn-secondary {
            background-color: #6b7280; /* gray-500 */
            color: #FFFFFF;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* gray-600 */
        }
        .dark .btn-secondary {
            background-color: #4b5563; /* gray-600 */
        }
        .dark .btn-secondary:hover {
            background-color: #374151; /* gray-700 */
        }
     /* === CSS BARU UNTUK SINKRONISASI LEBAR SUMBU HARGA (MULAI) === */
        .chart-container table td:last-child {
            /* Memaksa kolom terakhir (sumbu harga) memiliki lebar 80px */
            width: 80px !important; 
        }
        .chart-container table td:first-child {
            /* Memastikan kolom utama (area chart) mengisi sisa ruang */
            width: calc(100% - 80px) !important;
        }
        /* === CSS BARU UNTUK SINKRONISASI LEBAR SUMBU HARGA (SELESAI) === */

    </style>
</head>
<body class="antialiased">

    <div id="sticky-nav-wrapper" class="sticky top-0 z-50 bg-[#FDFBF7]/80 dark:bg-[#121212]/80 backdrop-blur-lg border-b border-gray-200/50 dark:border-gray-700/50 shadow-sm">
        <div class="flex items-center justify-between py-2 px-4 sm:px-6 lg:px-8">
            <div class="flex items-center gap-3">
                <a href="https://copilot.page.gd/" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-lg transition-colors duration-300 text-sm">🏠</a>
                
                <div id="nav-info-container" class="items-center gap-2 hidden md:flex">
                    <div class="flex flex-col">
                        <span id="nav-symbol" class="text-base font-bold text-yellow-500 dark:text-yellow-500"></span>
                        <div class="font-mono text-[10px]">
                            <span class="text-gray-400">VOL 24H:</span>
                            <span id="nav-volume-24h" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                    </div>
                    <div class="flex flex-col text-left text-xs">
                        <span id="nav-change-24h" class="font-semibold positive">-</span>
                        <span id="nav-change-1h" class="font-semibold positive">-</span>
                    </div>
                </div>
            </div>

            <div id="nav-stats-container" class="items-center gap-4 font-mono text-[10px] hidden md:flex">
                <div class="flex flex-col text-left">
                    <div>
                        <span class="text-gray-400">ATH:</span>
                        <span id="nav-ath" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                    </div>
                    <div>
                        <span class="text-gray-400">ATL:</span>
                        <span id="nav-atl" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                    </div>
                </div>
            </div>
            
            <a href="#" id="trade-link" class="text-right no-underline hidden">
                <span id="nav-price" class="text-yellow-500 text-lg">-</span>
                <span id="nav-price-idr" class="block text-[10px] text-gray-400"></span>
            </a>
        </div>
    </div>

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <header class="py-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-gray-800">ULTIMATE</h1>
                <p class="text-yellow-500 font-mono mt-1 text-sm">Last Update 15/08/2025 10:50</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none">
                <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8 0 1010.586 10.586z"></path></svg>
                <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414 1.414zM-.707 7.072l.707-.707a1 1 0 10-1.414-1.414l-.707.707a1 1 0 001.414 1.414zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z"></path></svg>
            </button>
        </header>

        <main>
            <div class="space-y-6 mb-8">
                <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                    <div>
                        <input type="password" id="gemini-api-key" class="input-primary" placeholder="Tempel API Key dari Google AI Studio...">
                        <p class="text-xs text-gray-400 mt-1">🔑 API 👆🏻<a href="https://aistudio.google.com/app/apikey" target="_blank" class="underline hover:text-blue-500">GET KEY</a>.</p>
                    </div>
                    <div>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <input type="text" id="asset-input" list="asset-list" class="input-primary text-sm flex-grow uppercase" placeholder="Ketik Simbol Aset (cth: BTCUSDT)" value="BTCUSDT">
                            <datalist id="asset-list"></datalist>
                            <select id="market-type-select" class="input-primary text-sm !w-auto">
                                <option value="spot">Spot</option>
                                <option value="futures" selected>Perp</option>
                            </select>
                            <select id="timeframe-select" class="input-primary text-sm !w-auto">
                                <option value="1m">1m</option><option value="3m">3m</option><option value="5m">5m</option><option value="15m"selected>15m</option><option value="30m">30m</option><option value="1h" >1h</option><option value="2h">2h</option><option value="4h">4h</option><option value="1d">1d</option><option value="1w">W</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="md:col-span-2 flex gap-4">
                         <button id="analyze-asset-btn" class="btn-primary w-full font-bold text-xl">
                            <span id="button-text">GET DATA</span>
                            <div id="button-loader" class="loader hidden">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                        </button>
                        <p id="asset-error" class="text-red-600 text-sm mt-2 text-center hidden"></p>
                        <button id="reset-btn" class="btn-secondary !w-auto">REFRESH</button>
                    </div>
                </section>
                <section id="settings-card" class="card p-4">
                    <button id="toggle-settings-btn" class="w-full flex justify-between items-center text-left">
                        <h2 class="text-lg font-bold">Indicators Settings</h2>
                        <svg id="toggle-settings-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>                                
                    </button>
                    <div id="settings-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Parameter Indikator</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between"><label for="setting-rsi-period" class="text-gray-500">Periode RSI</label><input type="number" id="setting-rsi-period" class="input-primary !w-20 text-center" value="14"></div>
                                        <div class="flex items-center justify-between"><label for="setting-macd-fast" class="text-gray-500">MACD Fast/Slow/Signal</label><div class="flex gap-1"><input type="number" id="setting-macd-fast" class="input-primary !w-16 text-center" value="12"><input type="number" id="setting-macd-slow" class="input-primary !w-16 text-center" value="26"><input type="number" id="setting-macd-signal" class="input-primary !w-16 text-center" value="9"></div></div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-weight-obv-divergence" class="text-gray-500">Bobot Divergensi OBV</label>
                                            <input type="number" step="0.1" id="setting-weight-obv-divergence" class="input-primary !w-20 text-center" value="3.0">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Bobot Skor Konfluensi</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between"><label for="setting-weight-divergence" class="text-gray-500">Bobot Divergensi RSI</label><input type="number" step="0.1" id="setting-weight-divergence" class="input-primary !w-20 text-center" value="2.5"></div>
                                        <div class="flex items-center justify-between"><label for="setting-weight-macd" class="text-gray-500">Bobot MACD Cross</label><input type="number" step="0.1" id="setting-weight-macd" class="input-primary !w-20 text-center" value="2.0"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-right mt-4"><button id="save-settings-btn" class="btn-primary">💾 Simpan</button></div>
                            <p id="settings-saved-msg" class="text-green-500 text-sm mt-2 text-center hidden">Pengaturan disimpan!</p>
                        </div>
                    </div>
                </section>
                <section id="watchlist-section" class="card p-6">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
                        <h2 class="text-base font-senibold">📈 Watchlist Scanner</h2>
                        <div class="w-full sm:w-auto flex items-center gap-2">
                            <input type="text" id="watchlist-input" class="input-primary text-sm flex-grow uppercase" placeholder="BTCUSDT, ETHUSDT, SOLUSDT...">
                            <button id="save-watchlist-btn" class="btn-primary !p-2" title="Simpan Watchlist">💾</button>
                        </div>
                    </div>
                    <button id="scan-watchlist-btn" class="btn-yellow w-full mb-4">
                        <span>🔍 Aset di Watchlist</span>
                        <div class="loader w-5 h-5 hidden"></div>
                    </button>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                            <thead class="bg-gray-50 dark:bg-gray-800">
                                <tr>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Aset</th>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Harga</th>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Perubahan 24j</th>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Skor Konfluensi</th>
                                </tr>
                            </thead><tbody id="watchlist-results-body" class="bg-white dark:bg-gray-900 divide-y divide-gray-500 dark:divide-gray-700">
                                <tr>
                                    <td colspan="4" class="px-4 py-4 text-center text-sm text-gray-900">Jalankan pemindaian untuk melihat hasil.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>
                <section id="top-movers-section" class="card p-6 hidden">
                    <h2 class="text-base font-semibold mb-4">Top 10 Movers USDⓈ-M Perpetual</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><h3 class="text-lg font-semibold text-green-500 mb-2">Gainers 🟢</h3><div id="gainers-list" class="space-y-2"></div></div>
                        <div><h3 class="text-lg font-semibold text-red-500 mb-2">Losers 🔴</h3><div id="losers-list" class="space-y-2"></div></div>
                    </div>
                </section>
                
                
            </div>

            <div id="dashboard-content" class="hidden">
                <div class="space-y-8">
                    <button id="toggle-charts-btn" class="btn-yellow w-full">SHOW CHART</button>
                    <section id="charts-wrapper" class="card p-6" style="display: none;">
                        <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                        <div class="chart-container relative"><div class="pane-title">Price</div><div id="main-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">Volume</div>
                            <div id="volume-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">RSI (14)</div><div id="rsi-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">Stochastic RSI</div><div id="stoch-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">MACD</div>
                            <div id="macd-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">Rate of Change (ROC)</div><div id="roc-chart-container"></div></div>
                    </section>
                    
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:items-start">
                        <div class="flex flex-col gap-4">
                            <section id="scalping-setup-section" class="card p-6">
                                <h2 class="text-xl font-bold mb-4">⚡ Setup Scalping Cepat (<span id="scalping-timeframe-display"></span>)</h2>
                                
                                <div id="futures-data-container" class="hidden space-y-1 text-sm">
                                    <div class="flex justify-between items-center"><span class="text-gray-500">Open Interest</span><span id="open-interest">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-yellow-500">Funding Rate</span><span id="funding-rate" class="font-mono text-yellow-500">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500">Funding Interval</span><span id="funding-rate-interval" class="font-mono">-</span></div>
                                </div>
                                
                                <div id="ls-umum-container" class="flex justify-between items-center text-sm"><span class="text-gray-500">L/S Ratio (Umum)</span><span id="ls-ratio-umum" class="font-mono">-</span></div>
                                <div id="ls-top-container" class="flex justify-between items-center text-sm"><span class="text-gray-500">L/S Ratio (Top Trader)</span><span id="ls-ratio-top" class="font-mono">-</span></div>
                                
                                <div class="text-sm mt-1">
                                    <span class="text-gray-500">Volatilitas (ATR)</span>
                                    <span id="atr-percent-status" class="font-mono text-blue-500">-</span>
                                    <span id="atr-status" class="text-xs text-gray-400">-</span>
                                </div>
                                
                                <div id="scalping-setup-content" class="text-center mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                    <p class="text-sm text-gray-500">Menunggu data...</p>
                                </div>
                            </section>

                            <section id="sentiment-display-container" class="card p-6">
                                <p class="text-center text-gray-500">Data Tambahan Sentimen via "AI" belum dimuat.</p>
                            </section>
                        
                            <section id="current-state-section" class="card p-6">
                                <button id="toggle-market-state-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 id="current-state-title" class="text-xl font-semibold">Kondisi Pasar (CEX)</h2>
                                    <svg id="toggle-market-state-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="current-state-content-wrapper" class="collapsible-content expanded">
                                    <div class="space-y-6">
                                        <h2 class="text-lg font-semibold text-center">Timeframe <span id="quick-confluence-timeframe">15m</span></h2>
                                        <div class="flex items-center gap-4 my-2">
                                            <div id="quick-finalBearishScore" class="text-2xl font-bold status-downtrend text-right w-1/5">🐻 0%</div>
                                            <div class="confluence-bar-container w-3/5">
                                                <div id="quick-confluenceBarBearish" class="confluence-bar confluence-bar-bearish" style="width: 50%;"></div>
                                                <div id="quick-confluenceBarBullish" class="confluence-bar confluence-bar-bullish" style="width: 50%;"></div>
                                            </div>
                                            <div id="quick-finalBullishScore" class="text-2xl font-bold status-uptrend text-left w-1/5">0% 🐂</div>
                                        </div>
                                        <p id="quick-finalVerdict" class="text-center font-semibold"></p>
                                        <div class="space-y-2 pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                                <p class="text-sm text-gray-500">Pola Candlestick</p>
                                                <p id="candlestick-pattern" class="font-semibold">BELUM ADA</p>
                                            </div>
                                            <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                                <p id="chart-pattern-label" class="text-xs text-gray-500">Pola Chart</p>
                                                <p id="chart-pattern" class="font-semibold">BELUM ADA</p>
                                            </div>
                                        </div>
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h2 class="text-xl font-bold mb-4">Live Order Book</h2>
                                            <div id="full-order-book-container" class="space-y-2 text-sm"><p class="text-center text-gray-500">Menunggu data order book...</p></div>
                                        </div>
                                        
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h3 class="text-lg font-bold mb-4">CVD Order Flow</h3>
                                            <div class="chart-container" style="height: 150px;"><canvas id="cvdChart"></canvas></div>
                                        </div>
                                    </div>
                                </div>
                            </section>
                        
                        <div class="flex flex-col gap-3">
                            <section id="confluence-details-section" class="card p-6">
                                <button id="toggle-confluence-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 class="text-lg font-bold">📊 Data Timeframe <span id="confluence-timeframe-display">1H</span></h2>
                                    <svg id="toggle-confluence-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="confluence-content-wrapper" class="collapsible-content expanded">                                                                           
                                        <div>
                                            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Volume Profile (VPVR)</h3>
                                                <div class="space-y-1 text-sm">
                                                    <div class="flex justify-between"><span class="text-gray-500">Value Area High</span><span id="vpvr-vah" class="font-mono text-red-500">-</span></div>
                                                    <div class="flex justify-between"><span class="text-gray-500">Point of Control</span><span id="vpvr-poc" class="font-mono font-bold text-blue-500">-</span></div>
                                                    <div class="flex justify-between"><span class="text-gray-500">Value Area Low</span><span id="vpvr-val" class="font-mono text-green-500">-</span></div>
                                                    <div class="flex justify-between items-center"><span class="text-gray-500">Rentang 24 Jam</span><span id="range-24h" class="font-mono font-semibold">-</span></div>
                                                </div>
                                            </div>
                                            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Level Kunci & Acuan</h3>
                                                <div class="space-y-1 text-sm">
                                                    <div class="flex justify-between items-center"><span class="text-gray-500">Pivot Harian (P)</span><span id="pivot-p" class="font-mono font-bold text-blue-500">-</span></div>
                                                    <div class="flex justify-between items-center"><span class="text-gray-500">VWAP (20D)</span><span id="vwap-20d" class="font-mono text-yellow-500">-</span></div>
                                                    <div class="flex justify-between items-center"><span class="text-gray-500">Ichimoku Bias</span><span id="ichimoku-bias" class="font-mono font-semibold">-</span></div>
                                                </div>
                                            </div>
                                            <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Sentimen Pasar</h3>
                                            <div class="space-y-1">
                                                
                                                <div class="flex justify-between items-center"><span class="text-gray-500">Order Book Bias</span><span id="order-book-bias" class="font-mono">-</span></div>
                                            </div>
                                        
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <div>
                                                    
                                                </div>
                                            <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Momentum & Volatilitas</h3>
                                            <div class="space-y-1">
                                                <div class="flex justify-between items-center"><span class="text-blue-500">Bollinger Squeeze</span><span id="bollinger-squeeze-status" class="font-mono">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-yellow-500">BB Rejection</span><span id="bollinger-rejection-status" class="font-mono">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">BB Walk the Bands</span><span id="bollinger-walk-status" class="font-mono">-</span></div>    
                                                <div>
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500">Bollinger Bands</span>
                                                        <span id="bollinger-bands-status" class="font-mono">-</span>
                                                    </div>
                                                    <div class="text-right text-xs text-gray-400 font-mono">
                                                        <span id="bb-upper-value">-</span> / 
                                                        <span id="bb-middle-value">-</span> / 
                                                        <span id="bb-lower-value">-</span>
                                                    </div>
                                                </div>
                                                <div>
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500">Tren (EMA 21/50)</span>
                                                        <span id="ma-status" class="font-mono font-semibold">-</span>
                                                    </div>
                                                    <div class="text-right text-xs text-gray-400 font-mono">
                                                        <span id="ema-21-value">-</span> / 
                                                        <span id="ema-50-value">-</span>
                                                    </div>
                                                </div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">RSI Divergence</span><span id="rsi-divergence" class="font-mono font-semibold text-xs">-</span></div>
                                                <div class="flex justify-between items-center pt-2 mt-2 border-t border-gray-200 dark:border-gray-700"><span class="text-gray-500">RSI (14)</span><div><span id="rsi-value" class="font-mono text-xs">-</span> <span id="rsi-status" class="tag tag-gray"></span></div></div>                                                
                                                <div class="flex justify-between items-center"><span class="text-gray-500">Stoch RSI (%K/%D)</span><div><span id="stoch-value" class="font-mono text-xs">-</span> <span id="stoch-status" class="tag tag-gray"></span></div></div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">MACD</span><div><span id="macd-status" class="font-mono font-semibold">-</span> <span id="macd-hist" class="font-mono text-xs ml-1">-</span></div></div>
                                                
                                                <div class="flex justify-between items-center"><span class="text-gray-500">Parabolic SAR</span><span id="psar-status" class="font-mono">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">Rate of Change (ROC)</span><span id="roc-status" class="font-mono">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">LinReg Channel</span><span id="linreg-status" class="font-mono">-</span></div>
                                            </div>
                                        </div>
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Kekuatan Tren (ADX)</h3>
                                            <div class="space-y-1">
                                                <div class="flex justify-between items-center"><span class="text-gray-500">ADX (14)</span><span id="adx-value" class="font-mono font-semibold">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">+DI (Momentum Beli)</span><span id="plus-di-value" class="font-mono positive">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-gray-500">-DI (Momentum Jual)</span><span id="minus-di-value" class="font-mono negative">-</span></div>
                                            </div>
                                            <hr class="border-green-500 border-2 border-solid my-4"/>
                                            <div class="space-y-1 text-sm">
                                                <div class="flex justify-between items-center"><span class="text-orange-500">Market Cap</span><span id="market-cap" class="text-orange-500">-</span></div>
                                                <div class="flex justify-between items-center"><span class="text-orange-500">Dominasi BTC</span><span id="btc-dominance" class="text-orange-500 font-mono">-</span></div>
                                                <div class="flex justify-between items-center">
                                                    <h2 class="text-base font-semibold">Korelasi Pasar</h2>
                                                    <div class="flex items-center justify-center gap-2">
                                                        <span class="text-sm text-gray-400">vs.</span>
                                                        <input type="text" id="correlation-asset-input" class="input-primary !w-32 text-center uppercase font-mono text-xs" value="BTCUSDT">
                                                        <span class="text-sm text-gray-400">30 Hari</span>
                                                        <span id="correlation-value" class="text-base font-semibold text-gray-300"></span>
                                                    </div>
                                                </div>
                                                <div class="text-right">
                                                    <p id="correlation-text" class="font-semibold text-gray-500 mt-1">...</p>
                                                </div>
                                            </div>                     
                                        </div>
                                    </div>
                                </section>
                                <section id="onchain-card" class="card p-6">
                                    <button id="toggle-onchain-btn" class="w-full flex justify-between items-center text-left mb-4">
                                        <h2 class="text-xl font-bold">⛓️‍💥 Aktivitas On-Chain</h2>
                                        <svg id="toggle-onchain-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <div id="onchain-content-wrapper" class="collapsible-content">
                                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                            <div id="specific-token-analysis" class="mb-4">
                                                <h3 id="specific-token-title" class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Analisis Token Spesifik</h3>
                                                <div id="specific-token-content" class="text-sm space-y-1"><p class="text-xs text-gray-500 text-center">Mencari data on-chain untuk aset yang dianalisa...</p></div>
                                            </div>                                    
                                            <div>
                                                <h3 class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Pool Trending Teratas</h3>
                                                <div id="trending-pools-content" class="text-sm space-y-2"><div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div></div>
                                            </div>
                                        </div>
                                    </div>
                                </section>
                            </div>
                        </div> 
                    <div class="space-y-4">   
                        <section id="ai-analysis-section" class="card p-6">
                            <button id="toggle-ai-verdict-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-xl font-bold">💡 Analisis AI</h2>
                                <svg id="toggle-ai-verdict-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                            </button>
                            <div id="ai-verdict-content-wrapper" class="collapsible-content expanded">
                                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                    <button id="run-comprehensive-ai-btn" class="btn-primary w-full mb-4">
                                        <span>🚀 ANALISA</span>
                                        <div class="loader w-5 h-5 hidden"></div>
                                    </button>
                                    <div id="ai-content-container" class="hidden space-y-6">
                                        <div id="ai-narrative-content" class="prose prose-sm dark:prose-invert max-w-none text-gray-600 space-y-4"></div>
                                        <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">🔮 Proyeksi Harga</h3><div id="projection-results-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div></div>                                    
                                        <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">♟️ Saran Strategis</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-green-500 mb-2">Untuk Calon Buyer</h4><p id="saran-buyer" class="text-lg font-bold"></p><p id="alasan-buyer" class="text-sm text-gray-500 mt-1"></p></div><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-blue-500 mb-2">Untuk Holder</h4><p id="saran-holder" class="text-lg font-bold"></p><p id="alasan-holder" class="text-sm text-gray-500 mt-1"></p></div></div></div>
                                    </div>
                                </div>
                            </div>
                        </section>                         
                    </div>
                    
            <div id="initial-placeholder" class="text-center py-20">
                <p class="text-xs font-mono text-gray-500">Pilih Spot or Futures ERROR? REFRESH browser</p>
            </div>
            <div id="loader-overlay" class="... flex-col ...">
                <div class="loader">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
                <p id="loader-text" class="text-white font-semibold mt-4">Memulai Analisa...</p>
            </div>
        </main>
    </div>

<script>
    // =======================================================
    // BAGIAN 1: DEKLARASI SEMUA ELEMEN DOM
    // =======================================================
    const gainersList = document.getElementById('gainers-list');
    const losersList = document.getElementById('losers-list');
    const navWrapper = document.getElementById('sticky-nav-wrapper');
    const mainContent = document.getElementById('main-content-container');
    const toggleAiVerdictBtn = document.getElementById('toggle-ai-verdict-btn');
    const toggleAiVerdictIcon = document.getElementById('toggle-ai-verdict-icon');
    const aiVerdictContentWrapper = document.getElementById('ai-verdict-content-wrapper');
    const assetInput = document.getElementById('asset-input');
    const apiKeyInput = document.getElementById('gemini-api-key');
    const timeframeSelect = document.getElementById('timeframe-select');
    const marketTypeSelect = document.getElementById('market-type-select');
    const analyzeBtn = document.getElementById('analyze-asset-btn');
    const buttonText = document.getElementById('button-text');
    const buttonLoader = document.getElementById('button-loader');
    const assetError = document.getElementById('asset-error');
    const dashboardContent = document.getElementById('dashboard-content');
    const initialPlaceholder = document.getElementById('initial-placeholder');
    const loaderOverlay = document.getElementById('loader-overlay');
    const loaderText = document.getElementById('loader-text');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const darkIcon = document.getElementById('theme-toggle-dark-icon');
    const lightIcon = document.getElementById('theme-toggle-light-icon');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');   
    const projectionResultsContainer = document.getElementById('projection-results-container');
    const specificTokenTitle = document.getElementById('specific-token-title');
    const specificTokenContent = document.getElementById('specific-token-content');
    const trendingPoolsContent = document.getElementById('trending-pools-content');
    const topMoversSection = document.getElementById('top-movers-section');
    const fullOrderBookContainer = document.getElementById('full-order-book-container');
    const tradeLink = document.getElementById('trade-link');
    const watchlistInput = document.getElementById('watchlist-input');
    const saveWatchlistBtn = document.getElementById('save-watchlist-btn');
    const scanWatchlistBtn = document.getElementById('scan-watchlist-btn');
    const watchlistResultsBody = document.getElementById('watchlist-results-body');
    const navVolume24h = document.getElementById('nav-volume-24h');
    const navAth = document.getElementById('nav-ath');
    const navAtl = document.getElementById('nav-atl');
    const resetBtn = document.getElementById('reset-btn');
    // =======================================================
    // BAGIAN 2: KONSTANTA KONFIGURASI
    // =======================================================
    const UI_UPDATE_INTERVAL = 500;
    const KLINE_CACHE_DURATION = 5 * 60 * 1000; // Cache berlaku 5 menit
    // =======================================================
    // BAGIAN 3: DEKLARASI STATE & VARIABEL GLOBAL
    // =======================================================
    let userSettings = {
        indicator: {
            rsi_period: 14,
            macd_fast: 12,
            macd_slow: 26,
            macd_signal: 9,
        },
        weights: {
            rsiDivergence: 2.5,
            macd: 2.0,
            obvDivergence: 3.0,
            candlePattern: 2.0,
            ma: 1.5,
            psar: 1.5,
            stoch: 1.5,
            rsi: 1.0,
            linreg: 1.0,
            roc: 0.5,
            bollingerBands: 0.5,
            pivot: 2.5,       // Bobot tinggi karena merupakan acuan harian
             vwap: 2.0,        // Bobot kuat, patokan institusional
            ichimoku: 3.0 
        }
    };
    let klineCache = {};
    let latestBids = [];
    let latestAsks = [];
    let topMoversInterval = null;
    let coinListCache = null;
    let exchangeInfoCache = { spot: null, futures: null };
    let analysisCache = {};
    let charts = [];
    let candlestickSeries = null; 
    let cvdChartInstance = null;
    let liveCvdValue = 0;
    let liveCvdData = [];
    let isChartsVisible = false;
    let liveCvdValueUsdt = 0;
    let periodicUpdateInterval = null;
    let latestCalculatedData = {};
    let lastUiUpdateTime = 0;
    let tradeQueue = [];
    let depthQueue = [];
    let klineQueue = [];
    let processingInterval = null;
    let fundingRateTimer = null;
    let watchlist = [];
    let orderBookDOMElements = null;

    // =======================================================
    // BAGIAN 4: DEFINISI FUNGSI-FUNGSI
    // =======================================================
    function displaySentimentDataInDashboard(data) {
    const container = document.getElementById('sentiment-display-container');

    const netflowClass = data.netflow < 0 ? 'positive' : 'negative';
    const netflowText = data.netflow < 0 ? `Outflow (Bullish)` : `Inflow (Bearish)`;
    const oiClass = data.oiChange > 0 ? 'positive' : 'negative';
    const oiText = data.oiChange > 0 ? `Naik` : `Turun`;
    const fundingClass = Math.abs(data.funding) > 0.02 ? 'negative' : 'text-gray-400';
    const fundingText = Math.abs(data.funding) > 0.02 ? `Ekstrem` : `Sehat`;

    container.innerHTML = `
        <h3 class="text-lg font-bold mb-4 text-center">🌡️ Sentimen Pasar (via AI)</h3>
        <div class="space-y-2 text-sm">
            <div class="flex justify-between items-center"><span class="text-gray-400">Aliran Bursa (Netflow BTC)</span><span class="font-bold ${netflowClass}">${data.netflow.toFixed(2)} BTC (${netflowText})</span></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">Perubahan Open Interest</span><span class="font-bold ${oiClass}">${data.oiChange.toFixed(2)}% (${oiText})</span></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">Rata-rata Funding Rate</span><span class="font-bold ${fundingClass}">${(data.funding * 100).toFixed(4)}% (${fundingText})</span></div>
            <div class="flex justify-between items-center"><span class="text-gray-400">Likuidasi (Long vs Short)</span><span class="font-bold text-gray-200">${data.liquidations}</span></div>
            <p class="text-center text-xs text-gray-500 pt-2">Data diambil oleh AI pada: ${data.lastUpdated.toLocaleTimeString('id-ID')}</p>
        </div>
    `;
}
    // --- FUNGSI PENGATURAN ---
    function saveSettings() {
        userSettings.indicator.rsi_period = parseInt(document.getElementById('setting-rsi-period').value);
        userSettings.indicator.macd_fast = parseInt(document.getElementById('setting-macd-fast').value);
        userSettings.indicator.macd_slow = parseInt(document.getElementById('setting-macd-slow').value);
        userSettings.indicator.macd_signal = parseInt(document.getElementById('setting-macd-signal').value);
        userSettings.weights.rsiDivergence = parseFloat(document.getElementById('setting-weight-divergence').value);
        userSettings.weights.macd = parseFloat(document.getElementById('setting-weight-macd').value);
        userSettings.weights.obvDivergence = parseFloat(document.getElementById('setting-weight-obv-divergence').value);
        localStorage.setItem('ultimateAppSettings', JSON.stringify(userSettings));
        const msgEl = document.getElementById('settings-saved-msg');
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 2000);
    }

    function loadSettings() {
        const savedSettings = localStorage.getItem('ultimateAppSettings');
        if (savedSettings) {
            try {
                const parsed = JSON.parse(savedSettings);
                // Lakukan merge untuk memastikan semua properti ada
                userSettings = {
                    indicator: { ...userSettings.indicator, ...parsed.indicator },
                    weights: { ...userSettings.weights, ...parsed.weights }
                };
            } catch (e) {
                console.error("Gagal parse pengaturan dari localStorage, gunakan default.", e);
            }
        }
        document.getElementById('setting-rsi-period').value = userSettings.indicator.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.indicator.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.indicator.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.indicator.macd_signal;
        document.getElementById('setting-weight-divergence').value = userSettings.weights.rsiDivergence;
        document.getElementById('setting-weight-macd').value = userSettings.weights.macd;
        document.getElementById('setting-weight-obv-divergence').value = userSettings.weights.obvDivergence;
    }
    
    // --- FUNGSI UTAMA & UTILITIES ---
    function showError(message) {
        assetError.textContent = message;
        assetError.classList.remove('hidden');
    }

    function hideError() {
        assetError.classList.add('hidden');
    }

    function showLoader(show, text = '') {
        if (show) {
            loaderText.textContent = text;
            loaderOverlay.classList.remove('hidden');
            loaderOverlay.classList.add('flex');
            analyzeBtn.disabled = true;
            buttonText.classList.add('hidden');
            buttonLoader.classList.remove('hidden');
        } else {
            loaderOverlay.classList.add('hidden');
            loaderOverlay.classList.remove('flex');
            analyzeBtn.disabled = false;
            buttonText.classList.remove('hidden');
            buttonLoader.classList.add('hidden');
        }
    }

    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) {
            console.error('Elemen toggle tidak ditemukan untuk:', buttonId);
            return;
        }
        contentWrapper.classList.add('collapsible-content');
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };
        let isVisible = startVisible;
        applyState(isVisible);
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }

    function adjustContentPadding() {
        if (navWrapper && mainContent) {
            const navHeight = navWrapper.offsetHeight;
            mainContent.style.paddingTop = `${navHeight}px`;
        }
    }

    const formatPrice = (price) => {
        if (price === null || price === undefined) return '-';
        if (price >= 1) {
            return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }
        const priceString = price.toString();
        const decimalPart = priceString.includes('.') ? priceString.split('.')[1] : '';
        if (decimalPart.length === 0) return `$${price.toFixed(2)}`;
        let nonZeroIndex = -1;
        for (let i = 0; i < decimalPart.length; i++) {
            if (decimalPart[i] !== '0') {
                nonZeroIndex = i;
                break;
            }
        }
        if (nonZeroIndex !== -1) {
            const significantDigits = 4;
            return `$${price.toFixed(nonZeroIndex + significantDigits)}`;
        }
        return `$${price.toFixed(8)}`;
    };

    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 7;
        return 8;
    }

    function getUltimateSignalScore(indicator, signalData) {
        if (!signalData) return 0;
        
        // Daftar sinyal positif dan negatif
        const bullishSignals = ['Uptrend', 'BULLISH', 'Bullish', 'Bullish Cross', 'Oversold', 'Lower Line Channel', 'Positif'];
        const bearishSignals = ['Downtrend', 'BEARISH', 'Bearish', 'Bearish Cross', 'Overbought', 'Upper Line Channel', 'Negatif'];

        let signalText = '';
        // Logika spesifik untuk setiap indikator
        if (['rsiDivergence', 'obvDivergence', 'ma', 'psar', 'linreg', 'roc', 'pivot', 'vwap', 'ichimoku'].includes(indicator)) {
            signalText = signalData.status;
        } else if (indicator === 'macd') {
            signalText = signalData.status; // 'Bullish Cross' atau 'Bearish Cross'
        } else if (indicator === 'stoch') {
            signalText = signalData.status; // 'Oversold' atau 'Overbought'
        } else if (indicator === 'rsi') {
            signalText = signalData.status; // 'Oversold' atau 'Overbought'
        } else if (indicator === 'candlePattern') {
            signalText = signalData.bias; // Menggunakan bias 'BULLISH' atau 'BEARISH'
        } else if (indicator === 'bollingerBands') {
            if(signalData.rejection === 'Bullish Rejection (Lower BB)') return userSettings.weights[indicator];
            if(signalData.rejection === 'Bearish Rejection (Upper BB)') return -userSettings.weights[indicator];
        }
        
        // Memberikan skor berdasarkan teks sinyal
        if (bullishSignals.includes(signalText)) return userSettings.weights[indicator] || 0;    if (bearishSignals.includes(signalText)) return -(userSettings.weights[indicator] || 0);
        
        return 0; // Netral
    }

    function updateQuickConfluenceWidget() {
        const data = analysisCache.calculatedData;
        if (!data) return;

        let totalBullScore = 0;
        let totalBearScore = 0;
        // Hitung maxScore berdasarkan indikator yang digunakan
        let maxScore = Object.values(userSettings.weights).reduce((sum, weight) => sum + weight, 0);

        // Iterasi melalui indikator yang berbobot
        for (const indicator in userSettings.weights) {
            if (data[indicator]) {
                const score = getUltimateSignalScore(indicator, data[indicator]);
                if (score > 0) totalBullScore += score;
                if (score < 0) totalBearScore += Math.abs(score);
            }
        }

        const bullPercentage = maxScore > 0 ? (totalBullScore / maxScore) * 100 : 0;
        const bearPercentage = maxScore > 0 ? (totalBearScore / maxScore) * 100 : 0;

        // Update elemen UI
        document.getElementById('quick-confluence-timeframe').textContent = timeframeSelect.value;
        document.getElementById('quick-finalBullishScore').textContent = `${bullPercentage.toFixed(0)}% 🐂 🟢`;
        document.getElementById('quick-finalBearishScore').textContent = `${bearPercentage.toFixed(0)}% 🐻 🔴`;

        const totalScore = totalBullScore + totalBearScore;
        const normalizedBull = totalScore > 0 ? (totalBullScore / totalScore) * 100 : 50;
        document.getElementById('quick-confluenceBarBullish').style.width = `${normalizedBull}%`;
        document.getElementById('quick-confluenceBarBearish').style.width = `${100 - normalizedBull}%`;

        let verdict = "NEUTRAL / MARKET TIDAK TERARAH";
        let verdictClass = "status-chop";
        if (bullPercentage > bearPercentage * 1.8 && bullPercentage > 40) {
            verdict = "KONFLUENSI BULLISH KUAT TERDETEKSI";
            verdictClass = "status-uptrend blinking-text-animation";
        } else if (bearPercentage > bullPercentage * 1.8 && bearPercentage > 40) {
            verdict = "KONFLUENSI BEARISH KUAT TERDETEKSI";
            verdictClass = "status-downtrend blinking-text-animation";
        } else if (bullPercentage > bearPercentage) {
            verdict = "BIAS BULLISH RINGAN";
            verdictClass = "status-uptrend";
        } else if (bearPercentage > bullPercentage) {
            verdict = "BIAS BEARISH RINGAN";
            verdictClass = "status-downtrend";
        }
        const verdictEl = document.getElementById('quick-finalVerdict');
        verdictEl.textContent = verdict;
        verdictEl.className = `text-center text-xl font-semibold ${verdictClass}`;
    }
    
    // OBJEK WEBSOCKET MANAGER HARUS DIDEKLARASIKAN DI AWAL
    const WebSocketManager = {
        ws: null,
        subscriptions: new Set(),
        messageHandlers: {},
        reconnectInterval: 5000,
        pingTimer: null,
        isConnecting: false,

        handleOpen() {
            console.log("Koneksi WebSocket Berhasil Dibuka.");
            this.isConnecting = false;
            this.startPing();
        },
        handleMessage(event) {
            const message = JSON.parse(event.data);
            if (message.result !== undefined) return;
            if (message.stream && message.data) {
                const streamName = message.stream;
                const payload = message.data;
                if (streamName.includes('@kline')) {
                    if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                } else if (streamName.includes('@aggTrade')) {
                    if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                } else if (streamName.includes('@depth')) {
                    if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                } else if (streamName.includes('@bookTicker')) {
                    if (this.messageHandlers['bookTicker']) this.messageHandlers['bookTicker'](payload);
                }
            }
        },
        handleClose() {
            console.warn("Koneksi WebSocket Ditutup. Mencoba menghubungkan kembali...");
            this.stopPing();
            this.isConnecting = false;
            if (this.subscriptions.size > 0) {
                 setTimeout(() => this.connect(), this.reconnectInterval);
            }
        },
        handleError(error) {
            console.error("Kesalahan WebSocket:", error);
            this.isConnecting = false;
            if (this.ws) {
                this.ws.close();
            }
        },
        connect() {
            if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) || this.isConnecting) {
                return;
            }
            this.isConnecting = true;
            const streamNames = Array.from(this.subscriptions).join('/');
            if (streamNames.length === 0) {
                this.isConnecting = false;
                return;
            }
            const url = `wss://stream.binance.com:9443/stream?streams=${streamNames}`;
            console.log("Menyambung ke:", url);
            this.ws = new WebSocket(url);
            this.ws.onopen = this.handleOpen.bind(this);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);
        },
        startPing() {
            this.stopPing();
            this.pingTimer = setInterval(() => {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ method: "PONG", id: new Date().getTime() }));
                }
            }, 3 * 60 * 1000);
        },
        stopPing() {
            clearInterval(this.pingTimer);
        },
        subscribe(streams) {
            streams.forEach(stream => this.subscriptions.add(stream));
            this.connect();
        },
        resetSubscriptions() {
            this.subscriptions.clear();
            if (this.ws) {
                this.ws.onclose = null; 
                this.ws.close();
            }
            this.stopPing();
            if (processingInterval) clearInterval(processingInterval);
        },
        registerHandler(streamName, handler) {
            this.messageHandlers[streamName] = handler;
        }
    };


    function updateCvdTableLive() {
        const tableBody = document.getElementById('cvd-table-body');
        if (!tableBody || liveCvdData.length === 0) return;

        // Ambil data paling baru
        const lastDataPoint = liveCvdData[liveCvdData.length - 1];

        // Buat baris baru dan masukkan di paling atas (index 0)
        const newRow = tableBody.insertRow(0);
        
        const date = new Date(lastDataPoint.x);
        const formattedTime = date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        // Tentukan warna berdasarkan perubahan nilai USDT
        const prevUsdt = liveCvdData.length > 1 ? liveCvdData[liveCvdData.length - 2].y_usdt : 0;
        const colorClass = lastDataPoint.y_usdt > prevUsdt ? 'positive' : 'negative';

        // Isi sel di baris baru
        newRow.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${formattedTime}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">${lastDataPoint.y_coin.toFixed(4)}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">$${lastDataPoint.y_usdt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        `;

        // Jaga agar jumlah baris tidak lebih dari 5, hapus yang paling bawah
        while (tableBody.rows.length > 5) {
            tableBody.deleteRow(tableBody.rows.length - 1);
        }
    }

    async function fetchTopMovers() {
        try {
            const response = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
            if (!response.ok) {
                throw new Error('Failed to fetch top movers data.');
            }
            const tickers = await response.json();

            // Ambil info bursa untuk memfilter koin yang aktif
            const exchangeInfo = await fetchBinanceAPIData('exchangeInfo', {}, 'futures');
            const tradingSymbols = new Set(exchangeInfo.symbols.filter(s => s.status === 'TRADING').map(s => s.symbol));

            // Filter untuk kontrak perpetual, USDT, dan status TRADING
            const filteredTickers = tickers
                .filter(t => t.symbol.endsWith('USDT') && parseFloat(t.priceChangePercent) !== 0 && tradingSymbols.has(t.symbol));

            // Ambil data harga 1 jam tambahan
            const tickersWith1h = await Promise.all(filteredTickers.map(async t => {
                try {
                    const klineResponse = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${t.symbol}&interval=1h&limit=2`);
                    if (!klineResponse.ok) return { ...t, priceChangePercent1h: 'N/A' };
                    const klines = await klineResponse.json();
                    if (klines.length < 2) return { ...t, priceChangePercent1h: 'N/A' };
                    const prevPrice = parseFloat(klines[0][4]);
                    const currentPrice = parseFloat(klines[1][4]);
                    const priceChange1h = ((currentPrice - prevPrice) / prevPrice) * 100;
                    return { ...t, priceChangePercent1h: priceChange1h.toFixed(2) };
                } catch (error) {
                    return { ...t, priceChangePercent1h: 'N/A' };
                }
            }));

            // Urutkan berdasarkan perubahan 24 jam
            tickersWith1h.sort((a, b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));

            // Ambil top 5 gainers dan losers
            const gainers = tickersWith1h.slice(0, 10);
            const losers = tickersWith1h.slice(-10).reverse(); //JUMLAH TOP MOVERS

            // Tampilkan data ke UI
            displayTopMovers(gainers, gainersList, 'positive');
            displayTopMovers(losers, losersList, 'negative');

            // Tambahkan event listener untuk tombol yang dapat diklik
            attachTopMoversListeners();
            topMoversSection.classList.remove('hidden');

        } catch (error) {
            console.error('Error fetching top movers:', error);
            topMoversSection.classList.add('hidden'); // Sembunyikan panel jika terjadi error
        }
    }

// Fungsi untuk menampilkan data ke UI dalam format tabel
    function displayTopMovers(data, container, colorClass) {
        container.innerHTML = '';
        let html = '';
        data.forEach(item => {
            const formattedPrice = formatPrice(parseFloat(item.lastPrice)).replace('$', '');
            html += `
                <button class="w-full text-left p-2 rounded-md bg-gray-100 dark:bg-gray-800/50 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors duration-200" data-symbol="${item.symbol}">
                    <div class="flex justify-between items-center text-sm font-semibold">
                        <span>${item.symbol.replace('USDT', '')}</span>
                        <span>${formattedPrice}</span>
                    </div>
                    <div class="flex justify-between items-center text-xs mt-1">
                        <span class="${colorClass}">${parseFloat(item.priceChangePercent).toFixed(2)}% (24H)</span>
                        <span class="${colorClass}">${item.priceChangePercent1h}% (1H)</span>
                    </div>
                </button>
            `;
        });
        container.innerHTML = html;
    }

    // Fungsi untuk menambahkan event listeners ke tombol-tombol
    function attachTopMoversListeners() {
        document.querySelectorAll('#top-movers-section button').forEach(button => {
            button.addEventListener('click', () => {
                const symbol = button.getAttribute('data-symbol');
                if (symbol) {
                    assetInput.value = symbol;
                    // Langsung jalankan analisa dan scroll ke atas
                    runFullAnalysis();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
        });
    }

    // --- BAGIAN UPGRADE: Fungsi terpusat untuk update indikator real-time ---
    function updateRealTimeIndicators(klines) {
        if (!klines || klines.length < 50) return; // Pengaman

        console.log("Memperbarui indikator dari data candle terbaru...");

        const closes = klines.map(k => parseFloat(k[4]));

        // Hitung ulang semua indikator yang relevan
        const adx = calculateADX(klines);
        const ma = (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? { status: 'Uptrend', class: 'positive' } : { status: 'Downtrend', class: 'negative' };
        const rsiValues = calculateRSI(closes);
        const rsiLast = rsiValues.filter(v=>v!==undefined).pop() || 50;
        const rsi = { values: rsiValues, last: rsiLast.toFixed(2), status: rsiLast > 70 ? 'Overbought' : (rsiLast < 30 ? 'Oversold' : 'Netral'), class: rsiLast > 70 ? 'tag-red' : (rsiLast < 30 ? 'tag-green' : 'tag-yellow') };
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);
        const stoch = calculateStochasticRSI(closes);
        const macd = calculateMACD(closes);
        const bollingerBands = calculateBollingerBands(closes);
        const atr = calculateATR(klines);
        const candlePattern = findCandlestickPatterns(klines);
        const chartPattern = findChartPatterns(klines);
        const roc = calculateROC(closes);
        const psar = calculateParabolicSAR(klines);
        const linreg = calculateLinearRegressionChannel(closes);

        // Simpan hasil kalkulasi terbaru ke state
        latestCalculatedData = { adx, ma, rsi, rsiDivergence, stoch, macd, bollingerBands, atr, candlePattern, chartPattern, roc, psar, linreg };

        // Update UI dengan data terbaru
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = ma.status;
        maStatusEl.className = `font-mono font-semibold ${ma.class}`;

        document.getElementById('rsi-value').textContent = rsi.last;
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = rsi.status;
        rsiStatusEl.className = `tag ${rsi.class}`;
        
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${rsiDivergence.class}`;

        document.getElementById('stoch-value').textContent = `${stoch.k}/${stoch.d}`;
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = stoch.status;
        stochStatusEl.className = `tag ${stoch.class}`;

        document.getElementById('macd-status').textContent = macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${macd.class}`;
        document.getElementById('macd-hist').textContent = macd.hist;
        
        document.getElementById('bollinger-bands-status').textContent = bollingerBands.status;
        document.getElementById('atr-status').textContent = `${atr.value.toFixed(6)} (${atr.status})`;
        
        const psarStatusEl = document.getElementById('psar-status');
        psarStatusEl.textContent = psar.status;
        psarStatusEl.className = `font-mono font-semibold ${psar.status === 'Bullish' ? 'positive' : 'negative'}`;

        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${roc.value.toFixed(2)}% (${roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${roc.status === 'Positif' ? 'positive' : 'negative'}`;

        document.getElementById('linreg-status').textContent = linreg.status;

        document.getElementById('adx-value').textContent = adx.adx;
        document.getElementById('plus-di-value').textContent = adx.plusDI;
        document.getElementById('minus-di-value').textContent = adx.minusDI;

        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const formattedTime = candlePattern.timestamp ? new Date(candlePattern.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
        let biasClass = '';
        if (candlePattern.bias === 'BULLISH') biasClass = 'positive';
        if (candlePattern.bias === 'BEARISH') biasClass = 'negative';
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Pola Candlestick</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            ${candlePattern.svg}
            <p id="candlestick-pattern" class="font-semibold ${candlePattern.class}">${candlePattern.pattern}</p>
            ${candlePattern.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candlePattern.bias}</p>` : ''}
        `;
        
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${chartPattern.class}`;
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }

    // --- BAGIAN UPGRADE: Fungsi untuk update data yang sifatnya periodik (API Polling) ---
    async function updatePeriodicData() {
        try {
            const binanceSymbol = analysisCache.binanceSymbol;
            if (!binanceSymbol || marketTypeSelect.value !== 'futures') return;

            console.log("Memperbarui data periodik (L/S Ratio)...");

            const [lsRatioUmumData, lsRatioTopData] = await Promise.all([
                 fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                 fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            ]);

            analysisCache.lsRatioUmumData = lsRatioUmumData;
            analysisCache.lsRatioTopData = lsRatioTopData;

            if (lsRatioUmumData?.[0]) {
                document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            }
            if (lsRatioTopData?.[0]) {
                document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
            }

        } catch(error) {
            console.error("Gagal memperbarui data periodik:", error);
        }
    }
    // --- 3. API & CALCULATION ENGINES (ORIGINAL CODE) ---
    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
        const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Binance API error (${marketType}): ${errorData.msg || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from Binance ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari Binance ${marketType.toUpperCase()}.`);
        }
    }
    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }
    async function fetchCoinGeckoData(coinId) {
        if (!coinId) return null;
        const url = `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) return null;
            return response.json();
        } catch (error) { return null; }
    }
    async function fetchUsdToIdrRate() {
        try {
            const response = await fetch('https://api.frankfurter.app/latest?from=USD&to=IDR');
            if (!response.ok) return 16200;
            const data = await response.json();
            return (data && data.rates && data.rates.IDR) ? data.rates.IDR : 16200;
        } catch (error) { return 16200; }
    }
    async function getCoinGeckoId(baseAssetSymbol) {
        if (!coinListCache) {
            const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
            if (!response.ok) throw new Error('Gagal unduh daftar koin CoinGecko.');
            coinListCache = await response.json();
        }
        const assetSymbolLower = baseAssetSymbol.toLowerCase();
        const priorityMap = {
            'btc': 'bitcoin', 'eth': 'ethereum', 'bnb': 'binancecoin', 'weth': 'wrapped-ether',
            'sol': 'solana', 'wbtc': 'wrapped-bitcoin', 'uni': 'uniswap', 'shib': 'shiba-inu',
            'pepe': 'pepe', 'cross': 'cross-2', 'ada': 'cardano', 'xrp': 'ripple', 'ava': 'avant-usd', 'ethw': 'ethereum-pow-iou',
            'avax': 'avalanche-2'
        };
        if (priorityMap[assetSymbolLower]) return priorityMap[assetSymbolLower];

        let match = coinListCache.find(coin => coin.symbol === assetSymbolLower);
        if (match) return match.id;

        console.log(`Simbol ${baseAssetSymbol} tidak ditemukan, mencoba pencarian cerdas...`);
        try {
            const searchResult = await fetchGeckoTerminal(`search/pools?query=${baseAssetSymbol}`);
            if (searchResult.data && searchResult.data.length > 0) {
                const topResult = searchResult.data[0];
                if (topResult.relationships.base_token.data.id) {
                    const coinId = topResult.relationships.base_token.data.id.split('_')[1];
                    if (coinId) return coinId;
                }
            }
        } catch (e) { console.error("Pencarian cerdas gagal:", e); }

        throw new Error(`Simbol "${baseAssetSymbol}" tidak ditemukan di CoinGecko.`);
    }
    async function initializeExchangeInfo(marketType) {
        if (exchangeInfoCache[marketType]) return;
        const url = marketType === 'spot' ? 'https://api.binance.com/api/v3/exchangeInfo' : 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
        const data = await response.json();
        exchangeInfoCache[marketType] = data.symbols;
        if (document.getElementById('market-type-select').value === marketType) {
            populateAssetDatalist(data.symbols, marketType);
        }
    }

    function populateAssetDatalist(symbols, marketType) {
        const dataList = document.getElementById('asset-list');
        if (!dataList) return;
        dataList.innerHTML = '';
        const filterFn = s => s.quoteAsset === 'USDT' && s.status === 'TRADING' && (marketType === 'spot' || s.contractType === 'PERPETUAL');
        symbols.filter(filterFn).sort((a, b) => a.symbol.localeCompare(b.symbol)).forEach(s => {
            const option = document.createElement('option');
            option.value = s.symbol;
            dataList.appendChild(option);
        });
    }
    async function validateBinanceSymbol(symbol, marketType) {
        if (!exchangeInfoCache[marketType]) await initializeExchangeInfo(marketType);
        const symbolData = exchangeInfoCache[marketType].find(s => s.symbol === symbol);
        if (!symbolData || symbolData.status !== 'TRADING') throw new Error(`Simbol "${symbol}" tidak valid atau tidak aktif di Binance ${marketType}.`);
    }
    async function callGemini(parts, isJsonOutput = true) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) throw new Error("API Key Google AI belum dimasukkan.");
        const model = 'gemini-2.5-flash-preview-05-20';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts }] };
        if (isJsonOutput) {
            payload.generationConfig = {
                "response_mime_type": "application/json",
                "max_output_tokens": 8192
            };
        }
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(`Google AI API error: ${errorBody?.error?.message || response.statusText}`);
        }
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
        throw new Error("Respons dari AI tidak valid atau kosong.");
    }

    // =======================================================
    // == BLOK FUNGSI KALKULASI INDIKATOR BARU (MULAI) ==
    // =======================================================

    /**
     * Menghitung Pivot Points harian berdasarkan data High, Low, Close dari hari sebelumnya.
     */
    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);

        const P = (high + low + close) / 3;
        const R1 = (2 * P) - low;
        const S1 = (2 * P) - high;
        const R2 = P + (high - low);
        const S2 = P - (high - low);
        const R3 = high + 2 * (P - low);
        const S3 = low - 2 * (high - P);

        return { P, R1, S1, R2, S2, R3, S3 };
    }

    /**
     * Menghitung Keltner Channels.
     */
    function calculateKeltnerChannels(klines, period = 20, multiplier = 2, atrPeriod = 10) {
        if (!klines || klines.length < period) return { upper: [], middle: [], lower: [], width: [] };
        const closes = klines.map(k => parseFloat(k[4]));
        const emaMiddle = calculateEMA(closes, period);
        const atr = calculateATR(klines, atrPeriod).value; // Menggunakan fungsi ATR yang sudah ada

        const upper = emaMiddle.map(val => val !== undefined ? val + (atr * multiplier) : undefined);
        const lower = emaMiddle.map(val => val !== undefined ? val - (atr * multiplier) : undefined);
        const width = upper.map((u, i) => (u !== undefined && lower[i] !== undefined) ? u - lower[i] : undefined);
        
        return { upper, middle: emaMiddle, lower, width };
    }
    /**
     * Menghitung Ichimoku Cloud dengan logika yang diperbaiki dan standar.
     */
    // KODE BARU DENGAN LOGIKA STATUS YANG DISEMPURNAKAN
function calculateIchimokuCloud(klines, tenkanP = 9, kijunP = 26, senkouP = 52) {
    if (klines.length < senkouP) return null;
    
    const result = { tenkan: [], kijun: [], senkouA: [], senkouB: [], chikou: [], status: 'Netral' };
    
    // ... (isi fungsi kalkulasi tenkan, kijun, dll. tetap sama seperti yang sudah ada di file Anda) ...
    const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
    for (let i = 0; i < klines.length; i++) {
        const tenkanHighLow = i >= tenkanP - 1 ? getHighLow(klines.slice(i - tenkanP + 1, i + 1)) : { high: 0, low: 0 };
        result.tenkan.push(i >= tenkanP - 1 ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
        const kijunHighLow = i >= kijunP - 1 ? getHighLow(klines.slice(i - kijunP + 1, i + 1)) : { high: 0, low: 0 };
        result.kijun.push(i >= kijunP - 1 ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
        result.chikou.push(parseFloat(klines[i][4]));
    }
    for (let i = 0; i < klines.length; i++) {
        const senkouA_val = (result.tenkan[i] !== undefined && result.kijun[i] !== undefined) ? (result.tenkan[i] + result.kijun[i]) / 2 : undefined;
        result.senkouA.push(senkouA_val);
        const senkouB_HighLow = i >= senkouP - 1 ? getHighLow(klines.slice(i - senkouP + 1, i + 1)) : { high: 0, low: 0 };
        result.senkouB.push(i >= senkouP - 1 ? (senkouB_HighLow.high + senkouB_HighLow.low) / 2 : undefined);
    }
    // ... (akhir dari bagian yang sama) ...

    // --- LOGIKA STATUS BARU YANG LEBIH STANDAR DAN AKURAT ---
    const lastPrice = parseFloat(klines[klines.length - 1][4]);
    const lastTenkan = result.tenkan[result.tenkan.length - 1];
    const lastKijun = result.kijun[result.kijun.length - 1];
    
    // Cloud yang relevan untuk harga saat ini dihitung 26 periode lalu
    const currentSenkouA = result.senkouA[klines.length - 1 - kijunP];
    const currentSenkouB = result.senkouB[klines.length - 1 - kijunP];
    
    // Chikou Span (harga saat ini) dibandingkan dengan harga 26 periode lalu
    const pastPriceForChikou = parseFloat(klines[klines.length - 1 - kijunP][4]);

    // Kondisi Bullish: Harga > Awan, Tenkan > Kijun, Chikou > Harga Masa Lalu
    const isBullish = lastPrice > currentSenkouA && lastPrice > currentSenkouB &&
                      lastTenkan > lastKijun &&
                      lastPrice > pastPriceForChikou;

    // Kondisi Bearish: Harga < Awan, Tenkan < Kijun, Chikou < Harga Masa Lalu
    const isBearish = lastPrice < currentSenkouA && lastPrice < currentSenkouB &&
                      lastTenkan < lastKijun &&
                      lastPrice < pastPriceForChikou;

    if (isBullish) {
        result.status = "Bullish";
    } else if (isBearish) {
        result.status = "Bearish";
    }
    // Jika tidak memenuhi keduanya, status tetap "Netral"

    return result;
}

    // =======================================================
    // == BLOK FUNGSI KALKULASI INDIKATOR BARU (SELESAI) ==
    // =======================================================
    // GANTI FUNGSI LAMA DENGAN VERSI BARU INI
    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A' };
        }

        // Kalkulasi TR (True Range) tetap sama
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
            trs.push(tr);
        }

        // Kalkulasi ATR tetap sama
        const atrValues = [];
        let sum = 0;
        for (let i = 0; i < trs.length; i++) {
            sum += trs[i];
            if (i >= period - 1) {
                if (i > period - 1) {
                    sum = sum - trs[i - period];
                }
                atrValues.push(sum / period);
            } else {
                atrValues.push(undefined);
            }
        }
        
        const atr = atrValues[atrValues.length - 1] || 0;

        // --- LOGIKA STATUS BARU BERDASARKAN PERSENTASE ---
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;

        let status;
        if (atrPercent > 5) {
            status = 'Sangat Tinggi';
        } else if (atrPercent > 2.5) {
            status = 'Tinggi';
        } else if (atrPercent < 1) {
            status = 'Rendah';
        } else {
            status = 'Normal';
        }
        // --- AKHIR LOGIKA BARU ---

        return { value: atr, status: status }; // Kembalikan status baru
    }

    const calculateEMA = (data, period) => {
        if (!data || data.length < period) return [];
        const k = 2 / (period + 1);
        let emaArray = Array(period - 1).fill(undefined);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        let currentEma = sum / period;
        emaArray.push(currentEma);
        for (let i = period; i < data.length; i++) {
            currentEma = (data[i] * k) + (currentEma * (1 - k));
            emaArray.push(currentEma);
        }
        return emaArray;
    };
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) return [];
        let sma = Array(period - 1).fill(undefined);
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            sma.push(slice.reduce((a, b) => a + b, 0) / period);
        }
        return sma;
    };
   const calculateRSI = (closes, period = userSettings.indicator.rsi_period) => {
        if (!closes || closes.length <= period) return Array(closes?.length || 0).fill(undefined);
        let gains = [], losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        if (avgLoss === 0) return Array(closes.length).fill(100);
        let rsi = [100 - (100 / (1 + (avgGain / avgLoss)))];
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            if (avgLoss === 0) { rsi.push(100); } 
            else { rsi.push(100 - (100 / (1 + (avgGain / avgLoss)))); }
        }
        return Array(period).fill(undefined).concat(rsi);
    };
    const calculateMACD = (closes, fast = userSettings.indicator.macd_fast, slow = userSettings.indicator.macd_slow, signal = userSettings.indicator.macd_signal) => {
        if (closes.length < slow + signal) {
            // Mengembalikan nilai default jika data tidak cukup
            return { status: 'Netral', hist: 'Netral', class: 'text-gray-500', macdLine: [], signalLine: [], histogram: [] };
        }
        
        const emaFast = calculateEMA(closes, fast);
        const emaSlow = calculateEMA(closes, slow);
        
        // Hitung garis MACD
        const macdLine = emaSlow.map((slowVal, i) => {
            if (slowVal !== undefined && emaFast[i] !== undefined) {
                return emaFast[i] - slowVal;
            }
            return undefined;
        });

        // Hitung garis Sinyal
        const signalLine = calculateEMA(macdLine.filter(v => v !== undefined), signal);

        // Hitung Histogram
        const histogram = macdLine.map((macdVal, i) => {
            // Sesuaikan indeks karena signalLine lebih pendek
            const signalIndex = i - (slow - 1); 
            if (macdVal !== undefined && signalLine[signalIndex] !== undefined) {
                const histValue = macdVal - signalLine[signalIndex];
                const prevHistValue = (i > 0 && macdLine[i-1] !== undefined && signalLine[signalIndex-1] !== undefined) 
                                    ? (macdLine[i-1] - signalLine[signalIndex-1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        });

        // Tentukan status terakhir untuk widget
        const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
        const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
        const lastHist = histogram.filter(v => v !== undefined).pop()?.value || 0;
        const prevMacdLine = macdLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        const prevSignalLine = signalLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        
        let status = 'Netral', macdClass = 'text-gray-500';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) { 
            status = 'Bullish Cross'; 
            macdClass = 'positive'; 
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) { 
            status = 'Bearish Cross'; 
            macdClass = 'negative'; 
        }
        
        return { 
            status, 
            hist: lastHist > 0 ? '(Naik)' : '(Turun)', 
            class: macdClass, 
            macdLine, 
            signalLine, 
            histogram 
        };
    };

    const calculateStochasticRSI = (closes, rsiPeriod = 14, stochPeriod = 14, kSmooth = 3, dSmooth = 3) => {
        const rsiValues = calculateRSI(closes, rsiPeriod).filter(v => v !== undefined);
        if (rsiValues.length < stochPeriod) return { k: 50, d: 50, status: 'Netral', class: 'tag-gray', kLine: [], dLine: [], kOffset: 0, dOffset: 0 };
        let stochRSI = [];
        for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
            const slice = rsiValues.slice(i - stochPeriod + 1, i + 1);
            const minRSI = Math.min(...slice);
            const maxRSI = Math.max(...slice);
            stochRSI.push(((rsiValues[i] - minRSI) / (maxRSI - minRSI)) * 100 || 0);
        }
        const kLine = calculateSMA(stochRSI, kSmooth);
        const dLine = calculateSMA(kLine.filter(v => v !== undefined), dSmooth);
        const lastK = kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = dLine.filter(v => v !== undefined).pop() || 50;
        let status = 'Netral', stochClass = 'tag-yellow';
        if (lastK > 80 && lastD > 80) { status = 'Overbought'; stochClass = 'tag-red'; }
        else if (lastK < 20 && lastD < 20) { status = 'Oversold'; stochClass = 'tag-green'; }
        const kOffset = closes.length - kLine.length;
        const dOffset = closes.length - dLine.length;
        return { k: lastK.toFixed(2), d: lastD.toFixed(2), status, class: stochClass, kLine, dLine, kOffset, dOffset };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) return { upper: [], middle: [], lower: [], width: [], status: 'N/A' };
        const middle = calculateSMA(closes, period);
        let upper = Array(period - 1).fill(undefined);
        let lower = Array(period - 1).fill(undefined);
        let width = Array(period - 1).fill(undefined);

        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                width.push(undefined);
                continue;
            };
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            upper.push(middle[i] + (stdev * stdDev));
            lower.push(middle[i] - (stdev * stdDev));
            width.push((middle[i] + (stdev * stdDev)) - (middle[i] - (stdev * stdDev))); // KALKULASI LEBAR BANDS
        }

        const lastClose = closes[closes.length - 1];
        const lastUpper = upper.filter(v => v !== undefined).pop();
        const lastLower = lower.filter(v => v !== undefined).pop();
        const lastWidth = width.filter(v => v !== undefined).pop();

        let status = 'Dalam Band';
        if (lastClose > lastUpper) status = 'Di Atas Band';
        if (lastClose < lastLower) status = 'Di Bawah Band';

        // Tambahkan deteksi squeeze
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            const recentWidths = width.slice(-50);
            const minWidth = Math.min(...recentWidths);
            const avgWidth = recentWidths.reduce((a, b) => a + b, 0) / recentWidths.length;
            if (lastWidth < avgWidth * 0.7) { // 30% lebih kecil dari rata-rata 50 periode terakhir
                squeezeStatus = 'Squeeze!';
            }
        }

        return { upper, middle, lower, width, status, squeezeStatus }; // TAMBAHKAN 'width' dan 'squeezeStatus'
    };
    const calculateVPVR = (klines, numRows = 70, valueAreaPercent = 0.70) => {
        if (!klines || klines.length === 0) return { poc: 0, vah: 0, val: 0 };
        let overallLow = Infinity, overallHigh = -Infinity;
        const candles = klines.map(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]);
            if (high > overallHigh) overallHigh = high;
            if (low < overallLow) overallLow = low;
            return { high, low, volume: parseFloat(k[5]) };
        });
        const rowSize = (overallHigh - overallLow) / numRows;
        let profile = Array.from({ length: numRows }, (_, i) => ({ price: overallLow + (i * rowSize), volume: 0 }));
        let totalVolume = 0;
        candles.forEach(c => {
            totalVolume += c.volume;
            const startIdx = Math.max(0, Math.floor((c.low - overallLow) / rowSize));
            const endIdx = Math.min(numRows - 1, Math.floor((c.high - overallLow) / rowSize));
            const volPerRow = c.volume / (endIdx - startIdx + 1);
            for (let i = startIdx; i <= endIdx; i++) profile[i].volume += volPerRow;
        });
        if (totalVolume === 0) return { poc: 0, vah: 0, val: 0 };
        let pocIndex = profile.reduce((maxIdx, row, idx, arr) => row.volume > arr[maxIdx].volume ? idx : maxIdx, 0);
        const poc = profile[pocIndex].price + (rowSize / 2);
        const targetVolume = totalVolume * valueAreaPercent;
        let vaVolume = profile[pocIndex].volume;
        let upperIdx = pocIndex, lowerIdx = pocIndex;
        while (vaVolume < targetVolume) {
            const volAbove = (upperIdx + 1 < numRows) ? profile[upperIdx + 1].volume : -1;
            const volBelow = (lowerIdx - 1 >= 0) ? profile[lowerIdx - 1].volume : -1;
            if (volAbove === -1 && volBelow === -1) break;
            if (volAbove > volBelow) {
                upperIdx++;
                vaVolume += profile[upperIdx].volume;
            } else {
                lowerIdx--;
                vaVolume += profile[lowerIdx].volume;
            }
        }
        return { poc, vah: profile[upperIdx].price + rowSize, val: profile[lowerIdx].price };
    };
    function CVDanalyze(klines, cvdData) {
        if (!klines || klines.length < 2 || !cvdData || cvdData.length < 2) {
        return { trend: 'N/A', divergence: 'N/A', summary: 'Data tidak cukup untuk analisa CVD.' };
        }

        // Determine price trend
        const firstPrice = parseFloat(klines[0][4]);
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const priceTrend = lastPrice > firstPrice ? 'Naik' : (lastPrice < firstPrice ? 'Turun' : 'Datar');

        // Determine CVD trend
        const firstCvd = cvdData[0].cvd;
        const lastCvd = cvdData[cvdData.length - 1].cvd;
        const cvdTrend = lastCvd > firstCvd ? 'Naik' : (lastCvd < firstCvd ? 'Turun' : 'Datar');

        // Detect divergence
        let divergence = 'Tidak Ada';
        let summary = `Tren harga dan CVD bergerak selaras (${priceTrend}).`;

            if (priceTrend === 'Naik' && cvdTrend === 'Turun') {
                divergence = 'Bearish 👎';
                summary = 'Harga naik tetapi tekanan beli melemah. Hati-hati, ini adalah sinyal divergensi bearish.';
            } else if (priceTrend === 'Turun' && cvdTrend === 'Naik') {
                divergence = 'Bullish 👍';
                summary = 'Harga turun tetapi tekanan beli menguat. Ini adalah sinyal divergensi bullish yang potensial.';
            }

            return {
                trend: cvdTrend,
                divergence: divergence,
                summary: summary
            };
    }
    // GANTI FUNGSI LAMA DENGAN INI
    const calculateCVD = (trades) => {
        let cumulativeDeltaCoin = 0;
        let cumulativeDeltaUsdt = 0;
        return trades.map(t => {
            const quantity = parseFloat(t.q);
            const price = parseFloat(t.p);
            const sign = t.m ? -1 : 1; // -1 untuk sell, 1 untuk buy
            
            cumulativeDeltaCoin += quantity * sign;
            cumulativeDeltaUsdt += (quantity * price) * sign;

            return { 
                time: t.T / 1000, 
                cvd_coin: cumulativeDeltaCoin,
                cvd_usdt: cumulativeDeltaUsdt 
            };
        });
    };
    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { adx: 'N/A', plusDI: 'N/A', minusDI: 'N/A' };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { adx: adxValues.filter(v=>v!==undefined).pop()?.toFixed(2) || 'N/A', plusDI: plusDIs.pop()?.toFixed(2) || 'N/A', minusDI: minusDIs.pop()?.toFixed(2) || 'N/A' };
    };
    
    const findCandlestickPatterns = (klines) => {        
        if (!klines || klines.length < 3) {            
            return { pattern: 'TIDAK ADA', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: null };
        }
               
        const lastCandleTimestamp = klines[klines.length - 1][0];
        const getCandleDetails = (k) => {
            const [open, high, low, close] = k.slice(1, 5).map(parseFloat);
            return { open, high, low, close, body: Math.abs(close - open), isGreen: close > open, isRed: close < open };
        };

        const c1 = getCandleDetails(klines[klines.length - 1]); // Paling Baru
        const c2 = getCandleDetails(klines[klines.length - 2]);
        const c3 = getCandleDetails(klines[klines.length - 3]);

        
        let result = { pattern: 'TIDAK ADA', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: lastCandleTimestamp };

        // Cek Pola 3-Candle
        if (c3.isGreen && c2.isGreen && c1.isGreen && c1.close > c2.close && c2.close > c3.close) {
            result = { pattern: 'THREE WHITE SOLDIERS', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('THREE_WHITE_SOLDIERS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.isRed && c1.isRed && c1.close < c2.close && c2.close < c3.close) {
            result = { pattern: 'THREE BLACK CROWS', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('THREE_BLACK_CROWS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.body < c3.body * 0.3 && c1.isGreen && c1.close > c3.open) {
            result = { pattern: 'MORNING STAR', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('MORNING_STAR'), timestamp: lastCandleTimestamp };
        } else if (c3.isGreen && c2.body < c3.body * 0.3 && c1.isRed && c1.close < c3.open) {
            result = { pattern: 'EVENING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('EVENING_STAR'), timestamp: lastCandleTimestamp };
        }

        // Jika belum ketemu, cek Pola 2-Candle
        if (result.pattern === 'TIDAK ADA') {
            if (c2.isRed && c1.isGreen && c1.close > c2.open && c1.open < c2.close) {
                result = { pattern: 'BULLISH ENGULFING', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.close < c2.open && c1.open > c2.close) {
                result = { pattern: 'BEARISH ENGULFING', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.close && c1.close < c2.open && c1.close > (c2.open + c2.body/2)) {
                result = { pattern: 'DARK CLOUD COVER', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('DARK_CLOUD_COVER'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.close && c1.close > c2.open && c1.close < (c2.open - c2.body/2)) {
                result = { pattern: 'PIERCING LINE', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('PIERCING_LINE'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close) {
                result = { pattern: 'BEARISH HARAMI', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close) {
                result = { pattern: 'BULLISH HARAMI', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.high - c2.high) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER TOP', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('TWEEZER_TOP'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.low - c2.low) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER BOTTOM', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('TWEEZER_BOTTOM'), timestamp: lastCandleTimestamp };
            }
        }

        // Jika masih belum ketemu, cek Pola 1-Candle
        if (result.pattern === 'TIDAK ADA') {
            const lowerWick = Math.min(c1.open, c1.close) - c1.low;
            const upperWick = c1.high - Math.max(c1.open, c1.close);
            if (lowerWick > c1.body * 2 && upperWick < c1.body * 0.5) {
                result = { pattern: 'HAMMER', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('HAMMER'), timestamp: lastCandleTimestamp };
            } else if (upperWick > c1.body * 2 && lowerWick < c1.body * 0.5) {
                result = { pattern: 'SHOOTING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('SHOOTING_STAR'), timestamp: lastCandleTimestamp };
            }
        }
        
        return result;
    };
    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'TIDAK ADA', class: 'text-gray-500' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPeaks = (data, isHigh) => {
            let peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    peaks.push({ index: i, value: data[i] });
                }
            }
            return peaks;
        };
        const priceLows = findPeaks(recentCloses, false), priceHighs = findPeaks(recentCloses, true);
        const rsiLows = findPeaks(recentRSI, false), rsiHighs = findPeaks(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'TIDAK ADA', class: 'text-gray-500' };
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'TIDAK ADA', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'TIDAK ADA', class: 'text-gray-500' };
    };
    
    function getPatternSVG(patternName) {
        // Pengaturan dasar untuk semua SVG
        const svgHeader = `<svg viewBox="0 0 110 60" class="w-24 h-auto mx-auto my-2">`;
        const svgFooter = `</svg>`;
        const green = '#26a69a', red = '#ef5350', gray = '#9E9E9E';

        let content = '';

        // Logika untuk membuat satu candle
        const createCandle = (x, open, high, low, close, color) => {
            const bodyY = Math.min(open, close);
            const bodyHeight = Math.abs(open - close);
            return `
                <line x1="${x+10}" y1="${high}" x2="${x+10}" y2="${low}" stroke="${color}" stroke-width="1"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" fill="${color}"/>
            `;
        };

        switch(patternName) {
            // --- POLA BULLISH ---
            case 'BULLISH_ENGULFING':
                content = createCandle(20, 40, 45, 25, 30, red) + createCandle(50, 28, 55, 10, 50, green);
                break;
            case 'HAMMER':
                content = createCandle(40, 50, 52, 10, 48, red);
                break;
            case 'MORNING_STAR':
                content = createCandle(10, 50, 55, 15, 20, red) + createCandle(40, 15, 20, 5, 12, gray) + createCandle(70, 18, 50, 15, 45, green);
                break;
            case 'THREE_WHITE_SOLDIERS':
                content = createCandle(10, 25, 35, 10, 30, green) + createCandle(40, 32, 45, 28, 40, green) + createCandle(70, 42, 55, 38, 50, green);
                break;
            case 'BULLISH_HARAMI':
                content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                break;
            case 'TWEEZER_BOTTOM':
                content = createCandle(20, 40, 45, 10, 20, red) + createCandle(50, 22, 48, 10, 35, green);
                break;
            // --- POLA BEARISH ---
            case 'BEARISH_ENGULFING':
                content = createCandle(20, 20, 45, 15, 40, green) + createCandle(50, 42, 55, 10, 15, red);
                break;
            case 'SHOOTING_STAR':
                content = createCandle(40, 12, 50, 10, 15, green);
                break;
            case 'EVENING_STAR':
                content = createCandle(10, 15, 50, 10, 45, green) + createCandle(40, 52, 58, 48, 50, gray) + createCandle(70, 48, 50, 15, 20, red);
                break;
            case 'THREE_BLACK_CROWS':
                content = createCandle(10, 50, 55, 30, 45, red) + createCandle(40, 42, 48, 20, 25, red) + createCandle(70, 22, 28, 5, 10, red);
                break;
            case 'BEARISH_HARAMI':
                content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                break;
            case 'TWEEZER_TOP':
                content = createCandle(20, 20, 55, 15, 40, green) + createCandle(50, 38, 55, 18, 25, red);
                break;
            default:
                return ''; // Tidak ada SVG untuk pola ini
        }

        return svgHeader + content + svgFooter;
    }
    function getTimeAgo(date) {
        if (!(date instanceof Date) || isNaN(date)) {
            return 'beberapa saat lalu'; // Fallback jika tanggal tidak valid
        }
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 0) return 'baru saja'; // Handle jika ada sedikit perbedaan waktu
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " tahun lalu";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " bulan lalu";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " hari lalu";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " jam lalu";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " menit lalu";
        return Math.floor(seconds) + " detik lalu";
    }


    function getExplorerUrl(networkName) {
        const explorerMap = {
            'eth': 'https://etherscan.io', // Perbaikan untuk Ethereum
            'ethereum': 'https://etherscan.io',
            'solana': 'https://solscan.io',
            'bsc': 'https://bscscan.com',
            'arbitrum': 'https://arbiscan.io',
            'base': 'https://basescan.org'
        };
        const baseUrl = explorerMap[networkName] || `https://${networkName}.info`;
        // Kembalikan URL terpisah untuk dompet dan transaksi
        return {
            address: `${baseUrl}/address/`,
            tx: `${baseUrl}/tx/`
        };
    }

    function getHolderCategory(usdValue) {
        if (usdValue >= 500000) return { name: 'Humpback', class: 'text-purple-400' };
        if (usdValue >= 100000) return { name: 'Whale', class: 'text-blue-400' };
        if (usdValue >= 50000) return { name: 'Tuna', class: 'text-teal-400' };
        if (usdValue >= 10000) return { name: 'Dolphin', class: 'text-cyan-400' };
        if (usdValue >= 1000) return { name: 'Crab', class: 'text-yellow-400' };
        return { name: 'Shrimp', class: 'text-gray-400' };
    }
// =======================================================
    // == BLOK FUNGSI BARU UNTUK DETEKSI POLA CHART (MULAI) ==
    // =======================================================

    /**
     * Mencari titik-titik pivot (puncak dan lembah) pada data klines.
     */
    function findPivots(klines, lookback = 10) {
        const pivots = [];
        if (klines.length < lookback * 2 + 1) return [];

        for (let i = lookback; i < klines.length - lookback; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            let isHigh = true, isLow = true;

            for (let j = 1; j <= lookback; j++) {
                if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
            }
            if (isHigh) pivots.push({ type: 'high', price: high, index: i });
            else if (isLow) pivots.push({ type: 'low', price: low, index: i });
        }
        return pivots;
    }
    
    /**
     * Fungsi bantuan untuk menghitung kemiringan (slope) antara dua titik pivot.
     */
    function calculateSlope(p1, p2) {
        if (p2.index === p1.index) return Infinity; // Garis vertikal
        return (p2.price - p1.price) / (p2.index - p1.index);
    }
    
    /**
     * Mendeteksi pola klasik: Head and Shoulders (Bearish) & Inverse H&S (Bullish).
     */
    function detectHeadAndShoulders(pivots) {
        for (let i = 4; i < pivots.length; i++) {
            // Cek Head & Shoulders (Bearish): H, L, H, L, H
            const p1 = pivots[i-4], p2 = pivots[i-3], p3 = pivots[i-2], p4 = pivots[i-1], p5 = pivots[i];
            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high' && p4.type === 'low' && p5.type === 'high') {
                if (p3.price > p1.price && p3.price > p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'HEAD & SHOULDERS', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Inverse Head & Shoulders (Bullish): L, H, L, H, L
            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low' && p4.type === 'high' && p5.type === 'low') {
                 if (p3.price < p1.price && p3.price < p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'INVERSE H&S', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

    /**
     * Mendeteksi pola klasik: Double Top (Bearish) & Double Bottom (Bullish).
     */
    function detectDoubles(pivots) {
        for (let i = 2; i < pivots.length; i++) {
            // Cek Double Top: H, L, H
            const p1_dt = pivots[i-2], p2_dt = pivots[i-1], p3_dt = pivots[i];
            if (p1_dt.type === 'high' && p2_dt.type === 'low' && p3_dt.type === 'high') {
                if (Math.abs(p1_dt.price - p3_dt.price) / p3_dt.price < 0.03 && p2_dt.price < p1_dt.price) {
                    return { pattern: 'DOUBLE TOP', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Double Bottom: L, H, L
            const p1_db = pivots[i-2], p2_db = pivots[i-1], p3_db = pivots[i];
            if (p1_db.type === 'low' && p2_db.type === 'high' && p3_db.type === 'low') {
                if (Math.abs(p1_db.price - p3_db.price) / p3_db.price < 0.03 && p2_db.price > p1_db.price) {
                    return { pattern: 'DOUBLE BOTTOM', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

    /**
     * Mendeteksi pola segitiga: Ascending, Descending, & Symmetrical.
     */
    function detectTriangles(pivots) {
        const recentPivots = pivots.slice(-7); // Fokus pada 7 pivot terakhir
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lastLow = lows[lows.length - 1], prevLow = lows[lows.length - 2];
            const lastHigh = highs[highs.length - 1], prevHigh = highs[highs.length - 2];

            const isLowsAscending = lastLow.price > prevLow.price;
            const isHighsFlat = Math.abs(lastHigh.price - prevHigh.price) / prevHigh.price < 0.015; // Toleransi 1.5%
            if (isLowsAscending && isHighsFlat) return { pattern: 'ASCENDING TRIANGLE', class: 'positive' };

            const isHighsDescending = lastHigh.price < prevHigh.price;
            const isLowsFlat = Math.abs(lastLow.price - prevLow.price) / prevLow.price < 0.015; // Toleransi 1.5%
            if (isHighsDescending && isLowsFlat) return { pattern: 'DESCENDING TRIANGLE', class: 'negative' };

            if (isLowsAscending && isHighsDescending) return { pattern: 'SYMMETRICAL TRIANGLE', class: 'text-yellow-400' };
        }
        return null;
    }
    
    /**
     * Mendeteksi pola baji: Rising Wedge (Bearish) & Falling Wedge (Bullish).
     */
    function detectWedges(pivots) {
        const recentPivots = pivots.slice(-7);
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lowSlope = calculateSlope(lows[lows.length - 2], lows[lows.length - 1]);
            const highSlope = calculateSlope(highs[highs.length - 2], highs[highs.length - 1]);

            // Rising Wedge: Kedua garis miring ke atas, garis bawah lebih curam.
            if (lowSlope > 0 && highSlope > 0 && lowSlope > highSlope) {
                 return { pattern: 'RISING WEDGE', class: 'negative blinking-text-animation' };
            }
            // Falling Wedge: Kedua garis miring ke bawah, garis atas lebih curam (nilai absolutnya).
            if (lowSlope < 0 && highSlope < 0 && Math.abs(highSlope) > Math.abs(lowSlope)) {
                return { pattern: 'FALLING WEDGE', class: 'positive blinking-text-animation' };
            }
        }
        return null;
    }

    /**
     * Mendeteksi pola bendera: Bull Flag (Bullish) & Bear Flag (Bearish).
     */
    function detectFlags(klines) {
        // Logika ini disederhanakan untuk deteksi cepat
        const lookback = 30; // Jarak untuk mencari "tiang"
        const flagLength = 10; // Panjang "bendera"
        if (klines.length < lookback + flagLength) return null;
        
        const closes = klines.map(k => parseFloat(k[4]));
        const poleStartPrice = closes[closes.length - flagLength - lookback];
        const poleEndPrice = closes[closes.length - flagLength];
        const priceChange = (poleEndPrice - poleStartPrice) / poleStartPrice;
        
        // Bull Flag: Tiang naik tajam (>5%), diikuti konsolidasi
        if (priceChange > 0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            // Konsolidasi harus berada di bagian atas tiang
            if (flagLow > poleStartPrice + (poleEndPrice - poleStartPrice) * 0.5) {
                return { pattern: 'BULL FLAG', class: 'positive' };
            }
        }
        // Bear Flag: Tiang turun tajam (<-5%), diikuti konsolidasi
        if (priceChange < -0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            // Konsolidasi harus berada di bagian bawah tiang
            if (flagHigh < poleStartPrice - (poleStartPrice - poleEndPrice) * 0.5) {
                return { pattern: 'BEAR FLAG', class: 'negative' };
            }
        }
        return null;
    }

    /**
     * FUNGSI UTAMA BARU: Mengatur pemanggilan semua fungsi deteksi pola.
     */
    function findChartPatterns(klines) {
        if (!klines || klines.length < 50) {
            return { pattern: 'Data Kurang', class: 'text-gray-500' };
        }
        
        const pivots = findPivots(klines, 10);
        let pattern;
            
        // Urutkan dari pola yang paling signifikan atau kompleks
        pattern = detectHeadAndShoulders(pivots);
        if (pattern) return pattern;

        pattern = detectDoubles(pivots);
        if (pattern) return pattern;
        
        pattern = detectWedges(pivots);
        if (pattern) return pattern;

        pattern = detectTriangles(pivots);
        if (pattern) return pattern;

        pattern = detectFlags(klines);
        if (pattern) return pattern;

        return { pattern: 'Tidak Terdeteksi', class: 'text-gray-500' };
    }
    // =======================================================
    // == BLOK FUNGSI BARU UNTUK DETEKSI POLA CHART (SELESAI) ==
    // === TAMBAHKAN DUA FUNGSI BANTUAN BARU DI BAWAH INI ===
    /**
     * Menemukan titik-titik swing terakhir (Low-High-Low untuk uptrend, High-Low-High untuk downtrend)
     * untuk kalkulasi Fibonacci.
     */
    function findLastSignificantSwing(klines) {
        const pivots = findPivots(klines.slice(-100), 5); // Analisa 100 candle terakhir
        if (pivots.length < 3) return null;

        const lastPivot = pivots[pivots.length - 1];
        const prevPivot = pivots[pivots.length - 2];
        const prevPrevPivot = pivots[pivots.length - 3];

        // Swing untuk potensi LONG (kita mencari titik A, B, C: Low -> High -> Low)
        if (lastPivot.type === 'low' && prevPivot.type === 'high' && prevPrevPivot.type === 'low') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'UP' };
        }
        // Swing untuk potensi SHORT (kita mencari titik A, B, C: High -> Low -> High)
        if (lastPivot.type === 'high' && prevPivot.type === 'low' && prevPrevPivot.type === 'high') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'DOWN' };
        }
        return null;
    }

    /**
     * Menghitung target Fibonacci Extension 1.618.
     */
    function calculateFibonacciExtension(swing) {
        if (!swing) return null;
        const impulseMove = Math.abs(swing.B.price - swing.A.price);
        if (swing.type === 'UP') {
            return swing.C.price + (impulseMove * 1.618);
        } else { // DOWN
            return swing.C.price - (impulseMove * 1.618);
        }
    }
    
    
    function calculateAndDisplayScalpingSetup() {
        const { klines, calculatedData } = analysisCache;
        if (!klines || klines.length < 50 || !calculatedData) {
            document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Data tidak cukup untuk setup scalping.</p>';
            return;
        }

        const container = document.getElementById('scalping-setup-content');
        document.getElementById('scalping-timeframe-display').textContent = timeframeSelect.value;
        const closes = klines.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        
        // 1. Tentukan Bias Sesaat (EMA 9 vs EMA 21)
        const ema9 = calculateEMA(closes, 9).pop();
        const ema21 = calculateEMA(closes, 21).pop();
        const bias = ema9 > ema21 ? 'LONG' : 'SHORT';

        // 2. Kalkulasi Stop Loss & TP 1 berdasarkan ATR & R:R
        const atrValue = calculatedData.atr.value;
        if (atrValue === 0) {
            container.innerHTML = '<p class="text-sm text-gray-500">Volatilitas terlalu rendah untuk menghitung setup.</p>';
            return;
        }
        const slMultiplier = 1.5;
        const tp1Multiplier = 1.5; // R:R 1:1.5 untuk TP1
        const stopLoss = bias === 'LONG' ? lastPrice - (atrValue * slMultiplier) : lastPrice + (atrValue * slMultiplier);
        const takeProfit1 = bias === 'LONG' ? lastPrice + (atrValue * tp1Multiplier) : lastPrice - (atrValue * tp1Multiplier);

        // 3. Kalkulasi TP2 & TP3
        const pivots = findPivots(klines, 5);
        const lastSwing = findLastSignificantSwing(klines);
        let takeProfit2 = 'N/A', takeProfit3 = 'N/A';

        if (bias === 'LONG') {
            const atrTarget2 = lastPrice + (atrValue * 3.0); // R:R 1:2
            const pivotTarget = pivots.filter(p => p.type === 'high' && p.price > takeProfit1).map(p => p.price).sort((a, b) => a - b)[0];
            takeProfit2 = pivotTarget ? Math.min(atrTarget2, pivotTarget) : atrTarget2;
            const fibTarget = calculateFibonacciExtension(lastSwing);
            if (fibTarget && fibTarget > takeProfit2) takeProfit3 = fibTarget;

        } else if (bias === 'SHORT') {
            const atrTarget2 = lastPrice - (atrValue * 3.0); // R:R 1:2
            const pivotTarget = pivots.filter(p => p.type === 'low' && p.price < takeProfit1).map(p => p.price).sort((a, b) => b - a)[0];
            takeProfit2 = pivotTarget ? Math.max(atrTarget2, pivotTarget) : atrTarget2;
            const fibTarget = calculateFibonacciExtension(lastSwing);
            if (fibTarget && fibTarget < takeProfit2) takeProfit3 = fibTarget;
        }
        
        // --- [BARU] FUNGSI BANTUAN UNTUK MENGHITUNG PERSENTASE ---
        const calculatePercentage = (targetPrice, entryPrice) => {
            if (typeof targetPrice !== 'number' || entryPrice === 0) return '';
            const percentage = ((targetPrice - entryPrice) / entryPrice) * 100;
            return `(${percentage.toFixed(2)}%)`;
        };

        // --- [BARU] Hitung semua persentase ---
        const slPercent = calculatePercentage(stopLoss, lastPrice);
        const tp1Percent = calculatePercentage(takeProfit1, lastPrice);
        const tp2Percent = calculatePercentage(takeProfit2, lastPrice);
        const tp3Percent = calculatePercentage(takeProfit3, lastPrice);
        
        // --- Tampilan UI yang Diperbarui ---
        const biasClass = bias === 'LONG' ? 'positive' : 'negative';
        const tpColorClass = bias === 'LONG' ? 'positive' : 'negative'; // Untuk SHORT, TP lebih rendah dari entri, jadi warnanya harus 'negative' jika ingin konsisten, atau 'positive' jika ingin menandakan profit. Kita gunakan 'positive' untuk profit.
        const slColorClass = 'negative'; // SL selalu negatif

        // Logika tampilan untuk TP2 dan TP3 jika 'N/A'
        const tp2Display = takeProfit2 !== 'N/A' ? `${formatPrice(takeProfit2)}<br><span class="text-xs font-mono positive">${tp2Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';
        const tp3Display = takeProfit3 !== 'N/A' ? `${formatPrice(takeProfit3)}<br><span class="text-xs font-mono positive">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';

        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">Bias Sesaat</p>
                    <p class="font-bold text-2xl ${biasClass}">${bias}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">Saran Entri</p>
                    <p class="font-semibold text-lg text-gray-800 dark:text-gray-200">${formatPrice(lastPrice)}</p>
                </div>
                <div>
                    <p class="text-sm text-gray-500">SL (ATR x${slMultiplier})</p>
                    <p class="font-semibold text-lg ${slColorClass}">${formatPrice(stopLoss)}</p>
                    <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">TP 1 (R:R 1:1.5)</p>
                    <p class="font-semibold positive">${formatPrice(takeProfit1)}</p>
                    <p class="text-xs font-mono positive">${tp1Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 2 (Pivot/R:R)</p>
                    <p class="font-semibold positive">${tp2Display}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 3 (Fibonacci)</p>
                    <p class="font-semibold positive">${tp3Display}</p>
                </div>
            </div>
        `;
    }
    // =======================================================
    /**
     * Fungsi baru untuk menghitung ATR dalam bentuk persentase.
     */
    function calculateATRPercentage(klines, period = 14) {
        if (!klines || klines.length === 0) {
            return 0; // Kembalikan 0 jika tidak ada data
        }
        
        // Panggil fungsi ATR yang sudah ada
        const atrResult = calculateATR(klines, period);
        const atrValue = atrResult.value;

        // Ambil harga penutupan terakhir
        const lastClose = parseFloat(klines[klines.length - 1][4]);

        if (lastClose === 0) {
            return 0; // Hindari pembagian dengan nol
        }

        // Hitung dan kembalikan dalam bentuk persen
        const atrPercent = (atrValue / lastClose) * 100;
        
        return atrPercent;
    }
    // =======================================================

    async function fetchGeckoTerminal(endpoint) {
        const baseUrl = 'https://api.geckoterminal.com/api/v2';
        const url = `${baseUrl}/${endpoint}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GeckoTerminal API error: ${errorData.errors?.[0]?.title || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from GeckoTerminal ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari GeckoTerminal.`);
        }
    }

    function renderTrendingPools(poolsData) {
        let html = '';
        const topPools = poolsData.slice(0, 5); // Ambil 5 teratas

        topPools.forEach(pool => {
            const attributes = pool.attributes;
            const priceChange = parseFloat(attributes.price_change_percentage.h24);
            const colorClass = priceChange >= 0 ? 'positive' : 'negative';
            const volume = parseFloat(attributes.volume_usd.h24);

            html += `
                <div class="p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                    <div class="flex justify-between items-center font-semibold">
                        <span>${attributes.name}</span>
                        <span class="${colorClass}">${priceChange.toFixed(2)}%</span>
                    </div>
                    <div class="text-xs text-gray-400 flex justify-between mt-1">
                        <span>Vol 24j: $${(volume / 1_000_000).toFixed(2)}jt</span>
                        <span>Jaringan: ${pool.relationships.network.data.id}</span>
                    </div>
                </div>
            `;
        });
        trendingPoolsContent.innerHTML = html;
    }

async function runFullAnalysis() {
    WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
    WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
    WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));
    
    orderBookDOMElements = null;
    topMoversSection.classList.add('hidden');
    hideError();
    showLoader(true, 'Memulai Analisa...');
    WebSocketManager.resetSubscriptions();
    destroyCharts();

    specificTokenTitle.innerHTML = 'Analisis Token Spesifik';
    specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Mencari data on-chain...</p>`;
    trendingPoolsContent.innerHTML = `<div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div>`;
    
    try {
        const aiContentContainer = document.getElementById('ai-content-container');
        if (aiContentContainer) {
            aiContentContainer.classList.add('hidden'); // Sembunyikan hasil AI lama
        }
        const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
        if (comprehensiveBtn) {
            const btnText = comprehensiveBtn.querySelector('span');
            const btnLoader = comprehensiveBtn.querySelector('.loader');
            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            comprehensiveBtn.disabled = false;
        }
        const binanceSymbol = assetInput.value.trim().toUpperCase();
        const correlationAsset = document.getElementById('correlation-asset-input').value.trim().toUpperCase() || 'BTCUSDT';
        const marketType = marketTypeSelect.value;
        const selectedTimeframe = timeframeSelect.value;
        
        await validateBinanceSymbol(binanceSymbol, marketType);

        // --- LOGIKA CACHE BARU (MULAI) ---
        let klines;
        const cachedItem = klineCache[binanceSymbol + selectedTimeframe];
        if (cachedItem && (Date.now() - cachedItem.timestamp < KLINE_CACHE_DURATION)) {
            console.log(`Menggunakan Klines dari Cache untuk ${binanceSymbol}`);
            klines = cachedItem.data;
            showLoader(true, 'Menggunakan data dari cache...');
        } else {
            console.log(`Mengambil Klines dari API untuk ${binanceSymbol}`);
            showLoader(true, 'Mengambil data candle...');
            klines = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: selectedTimeframe, limit: 500 }, marketType);
            klineCache[binanceSymbol + selectedTimeframe] = { data: klines, timestamp: Date.now() };
        }
        // --- LOGIKA CACHE BARU (SELESAI) ---

        const baseAsset = binanceSymbol.replace(/USDT$|^\d+/g, '');
        let coinGeckoId;
        try {
            coinGeckoId = await getCoinGeckoId(baseAsset);
        } catch (e) {
            console.warn(`Gagal mendapatkan CoinGecko ID untuk ${baseAsset}: ${e.message}`);
        }

        showLoader(true, 'Mengambil data pasar lainnya...');
        const promises = [
            fetchBinanceAPIData('ticker/24hr', { symbol: binanceSymbol }, marketType),
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 30 }, marketType),
            fetchBinanceAPIData('klines', { symbol: correlationAsset, interval: '1d', limit: 30 }, 'spot'), // Ambil data harian ASET PEMBANDING
            fetchBinanceAPIData('depth', { symbol: binanceSymbol, limit: 100 }, marketType),
            fetchUsdToIdrRate(),
            fetch('https://api.coingecko.com/api/v3/global').then(res => res.json()),
            coinGeckoId ? fetchCoinGeckoData(coinGeckoId) : Promise.resolve(null)
        ];

        if (marketType === 'futures') {
            promises.push(
                fetchBinanceAPIData('openInterest', { symbol: binanceSymbol }, 'futures'),
                fetchBinanceAPIData('premiumIndex', { symbol: binanceSymbol }, 'futures'),
                fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            );
        }

        const promiseResults = await Promise.all(promises);

        const [
            tickerData, assetDailyKlines, btcDailyKlines,
            orderBookData, usdToIdrRate, globalData, coinGeckoData,
            ...futuresData
        ] = promiseResults;

        let openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData;
        if (marketType === 'futures') {
            [openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData] = futuresData;
        }
        // --- AKHIR PERBAIKAN ---

        let correlationValue = null;
        if (binanceSymbol !== 'BTCUSDT' && assetDailyKlines && btcDailyKlines && assetDailyKlines.length === btcDailyKlines.length) {
            const assetCloses = assetDailyKlines.map(k => parseFloat(k[4]));
            const btcCloses = btcDailyKlines.map(k => parseFloat(k[4]));
            correlationValue = calculateCorrelation(assetCloses, btcCloses);
        }
        showLoader(true, 'Menghitung indikator baru...');
        const vwap20d = calculateVWAP(klines, 20); // VWAP sudah ada, kita gunakan saja
        const pivotPoints = calculatePivotPoints(assetDailyKlines[assetDailyKlines.length - 2]); // Gunakan data H-1
        const ichimoku = calculateIchimokuCloud(klines);
        const keltnerChannels = calculateKeltnerChannels(klines);
        
        analysisCache = { tickerData, klines, orderBookData, usdToIdrRate, globalData, coinGeckoData, openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData, binanceSymbol, selectedTimeframe, correlationData: correlationValue };
        
        showLoader(true, 'Menghitung indikator...');

        const allTrades = await fetchBinanceAPIData('aggTrades', { symbol: binanceSymbol, limit: 1000 }, marketType);
        const cvdData = calculateCVD(allTrades);
        analysisCache.cvdData = cvdData;

        const closes = klines.map(k => parseFloat(k[4]));
        const rsiValues = calculateRSI(closes);
        const ema21Values = calculateEMA(closes, 21);
        const ema50Values = calculateEMA(closes, 50);
        const lastEma21 = ema21Values.filter(v=>v!==undefined).pop();
        const lastEma50 = ema50Values.filter(v=>v!==undefined).pop();
        const lastPrice = closes[closes.length - 1];

        // Logika status tren yang lebih cerdas
        let trendStatus = 'Netral';
        let trendClass = 'text-yellow-400';
        if (lastEma21 > lastEma50) { // Kerangka tren utama adalah Bullish
            if (lastPrice > lastEma21) {
                trendStatus = 'Uptrend Kuat';
                trendClass = 'positive';
            } else {
                trendStatus = 'Koreksi dalam Uptrend';
                trendClass = 'text-yellow-400';
            }
        } else if (lastEma50 > lastEma21) { // Kerangka tren utama adalah Bearish
            if (lastPrice < lastEma21) {
                trendStatus = 'Downtrend Kuat';
                trendClass = 'negative';
            } else {
                trendStatus = 'Reli dalam Downtrend';
                trendClass = 'text-yellow-400';
            }
        }


        analysisCache.calculatedData = {
            adx: calculateADX(klines), 
            cvd: CVDanalyze(klines, cvdData), 
            vpvr: calculateVPVR(klines),
            ma: {
                status: trendStatus,
                class: trendClass,
                value21: lastEma21,
                value50: lastEma50
            },
            rsi: { values: rsiValues, last: rsiValues.filter(v=>v!==undefined).pop()?.toFixed(2) || 50, status: (rsiValues.filter(v=>v!==undefined).pop() || 50) > 70 ? 'Overbought' : ((rsiValues.filter(v=>v!==undefined).pop() || 50) < 30 ? 'Oversold' : 'Netral'), class: (rsiValues.filter(v=>v!==undefined).pop() || 50) > 70 ? 'tag-red' : ((rsiValues.filter(v=>v!==undefined).pop() || 50) < 30 ? 'tag-green' : 'tag-yellow') },
            rsiDivergence: detectRSIDivergence(closes, rsiValues), 
            obvDivergence: detectOBVDivergence(closes, klines),
            stoch: calculateStochasticRSI(closes), 
            macd: calculateMACD(closes),
            bollingerBands: calculateBollingerBands(closes), 
            atr: calculateATR(klines),
            atrPercent: calculateATRPercentage(klines), 
            candlePattern: findCandlestickPatterns(klines),
            chartPattern: findChartPatterns(klines), 
            roc: calculateROC(closes), 
            psar: calculateParabolicSAR(klines), 
            linreg: calculateLinearRegressionChannel(closes),
            pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
            vwap: { status: (lastPrice > vwap20d) ? 'Bullish' : 'Bearish', value: vwap20d },
            ichimoku: { status: ichimoku?.status || 'Netral', data: ichimoku },
            keltnerChannels: keltnerChannels
        };
        const bbPriceAction = analyzeBollingerBandsPriceAction(klines, analysisCache.calculatedData.bollingerBands);
        analysisCache.calculatedData.bollingerBands.rejection = bbPriceAction.rejection;
        analysisCache.calculatedData.bollingerBands.walkTheBands = bbPriceAction.walkTheBands;

        updateDashboardUI();
        
        const navPriceEl = document.getElementById('nav-price');
        const navIdrEl = document.getElementById('nav-price-idr');
        if(navPriceEl && navIdrEl) {
            navPriceEl.textContent = formatPrice(parseFloat(tickerData.lastPrice));
            navIdrEl.textContent = `Rp ${(parseFloat(tickerData.lastPrice) * (analysisCache.usdToIdrRate || 0)).toLocaleString('id-ID', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
        }
        
        if (orderBookData) {
            latestBids = orderBookData.bids;
            latestAsks = orderBookData.asks;
            const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
            const precision = getPrecisionForAsset(parseFloat(latestPrice));
            const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
            renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
        }

        const symbolLower = binanceSymbol.toLowerCase();
        const streamsToSub = [
            `${symbolLower}@kline_${selectedTimeframe}`,
            `${symbolLower}@aggTrade`,
            `${symbolLower}@depth20@100ms`
        ];
        WebSocketManager.subscribe(streamsToSub);

        // Blok untuk data On-Chain (lengkap)
        (async () => {
            try {
                const searchQuery = (await getCoinGeckoId(baseAsset).then(id => fetchCoinGeckoData(id)).catch(() => null))?.platforms?.ethereum || baseAsset;
                specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span>`;
                
                const searchResult = await fetchGeckoTerminal(`search/pools?query=${searchQuery}`);
                
                if (searchResult.data && searchResult.data.length > 0) {
                    searchResult.data.sort((a, b) => parseFloat(b.attributes.reserve_in_usd) - parseFloat(a.attributes.reserve_in_usd));
                    const topPool = searchResult.data[0];
                    const attrs = topPool.attributes;
                    const networkName = topPool.id.split('_')[0];
                    const dexName = topPool.relationships?.dex?.data?.id.split('_').join(' ') || attrs.name.split(' ').pop();
                    
                    if (networkName.includes('sepolia')) {
                        document.getElementById('onchain-card').style.display = 'none';
                        return;
                    } else {
                        document.getElementById('onchain-card').style.display = 'block';
                    }
                    specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span> <span class="text-xs text-gray-400 capitalize">(${networkName} / ${dexName})</span>`;
                    
                    const price = formatPrice(parseFloat(attrs.base_token_price_usd));
                    const volume = (parseFloat(attrs.volume_usd.h24) / 1000000).toFixed(2);
                    const liquidity = attrs.reserve_in_usd ? (parseFloat(attrs.reserve_in_usd) / 1000000).toFixed(2) : 'N/A';
                    
                    let staticContentHtml = `
                         <div class="flex justify-between items-baseline"><span class="text-gray-500 capitalize">Harga DEX (${dexName})</span><span class="font-bold text-lg text-yellow-400">${price}</span></div>
                         <div class="flex justify-between items-baseline"><span class="text-gray-500">Volume 24j DEX</span><span>$${volume}jt</span></div>
                         <div class="flex justify-between items-baseline"><span class="text-gray-500">Likuiditas Pool</span><span>$${liquidity}jt</span></div>`;
                    
                    specificTokenContent.innerHTML = staticContentHtml;

                    try {
                        const poolAddress = attrs.address;
                        const tradesData = await fetchGeckoTerminal(`networks/${networkName}/pools/${poolAddress}/trades`);

                        const tradeEvents = tradesData.data
                        .filter(trade => trade.attributes.kind === 'buy' || trade.attributes.kind === 'sell')
                        .map(trade => ({
                            kind: trade.attributes.kind,
                            usd: parseFloat(trade.attributes.volume_in_usd),
                            price: parseFloat(trade.attributes.price_in_usd || attrs.base_token_price_usd), // <-- TAMBAHKAN BARIS INI
                            time: new Date(trade.attributes.block_timestamp),
                            trader: trade.attributes.tx_from_address,
                            network: topPool.id.split('_')[0]
                        }))
                            .filter(event => event.usd >= 5000)
                            .slice(0, 100);

                        if (tradeEvents.length > 0) {
                            let buyVolume = 0, sellVolume = 0;
                            let buyCount = 0, sellCount = 0;
                            
                            tradeEvents.forEach(event => {
                                if (event.kind === 'buy') {
                                    buyVolume += event.usd;
                                    buyCount++;
                                } else {
                                    sellVolume += event.usd;
                                    sellCount++;
                                }
                            });

                            analysisCache.onChainSummary = {
                                totalBuyVolume: buyVolume,
                                totalSellVolume: sellVolume,
                                buyTransactions: buyCount,
                                sellTransactions: sellCount,
                                sentiment: buyVolume > sellVolume ? 'Dominan Beli' : 'Dominan Jual',
                                netVolume: buyVolume - sellVolume
                            };
                            let html = '<hr class="border-slate-700/50 my-3"/><h4 class="text-lg font-semibold mb-2">100 Trans Terbaru di DEX >$5000 </h4>';
                            // KODE BARU YANG DIJAMIN BENAR
tradeEvents.forEach(event => {
    const category = getHolderCategory(event.usd);
    const timeAgo = getTimeAgo(event.time);
    const specificTime = event.time.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
    
    // --- PERUBAHAN DI SINI ---
    // 1. Hapus total baris 'const explorer = ...' yang sudah tidak relevan.
    // 2. Langsung arahkan walletLink ke DexCheck.
    const walletLink = `https://dexcheck.ai/app/wallet-analyzer/${event.trader}`;
    // --- AKHIR PERUBAHAN ---

    const bgColor = event.kind === 'buy' ? 'bg-green-900/40 dark:bg-green-800/20' : 'bg-red-900/40 dark:bg-red-800/20';
    const amountColor = event.kind === 'buy' ? 'text-green-400' : 'text-red-400';
    const icon = event.kind === 'buy' ? '🟢' : '🔴';
    const actionText = event.kind === 'buy' ? 'BELI' : 'JUAL';

    html += `
        <div class="p-2 rounded-md ${bgColor}">
            <div class="flex justify-between items-center font-semibold">
                <span>${icon} ${actionText}</span>
                <span class="${amountColor}">$${event.usd.toLocaleString('en-US', {maximumFractionDigits: 0})}</span>
            </div>
            <div class="text-xs text-gray-400 flex justify-between items-center mt-1">
                <span class="${category.class} font-bold">[${category.name}]</span>
                <span class="font-mono text-yellow-400">@ ${formatPrice(event.price)}</span>
                <span>${timeAgo} <span class="text-gray-500">(${specificTime})</span></span>
                <a href="${walletLink}" target="_blank" class="underline hover:text-white">Lihat Dompet 🔗</a>
            </div>
        </div>
    `;
});
                            specificTokenContent.innerHTML += html;
                        } else {
                           analysisCache.onChainSummary = null;
                           specificTokenContent.innerHTML += `<p class="text-xs text-gray-500 text-center pt-2">Tidak ada transaksi jual/beli signifikan baru-baru ini.</p>`;
                        }
                    } catch (tradeError) {
                        specificTokenContent.innerHTML += `<p class="text-xs text-red-500 text-center pt-2">Gagal memuat jejak trader: ${tradeError.message}</p>`;
                    }
                } else {
                     specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Tidak ditemukan pool on-chain untuk ${baseAsset.toUpperCase()}.</p>`;
                }
            } catch (dexError) {
                specificTokenContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data token spesifik: ${dexError.message}</p>`;
            }
        })();

        // Blok untuk Trending Pools (lengkap)
        (async () => {
            try {
                const trendingData = await fetchGeckoTerminal('networks/trending_pools');
                renderTrendingPools(trendingData.data);
            } catch (trendingError) {
                trendingPoolsContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data trending: ${trendingError.message}</p>`;
            }
        })();
    } catch (error) {
        console.error("Analisis Gagal:", error);
        showError(error.message);
    } finally {
        showLoader(false);
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (processingInterval) clearInterval(processingInterval);
        periodicUpdateInterval = setInterval(updatePeriodicData, 300000);
        processingInterval = setInterval(processQueues, 500);
    }
}
    /**
     * Menyimpan daftar watchlist dari input ke localStorage.
     */
    function saveWatchlist() {
        const symbols = watchlistInput.value.split(',')
            .map(s => s.trim().toUpperCase())
            .filter(s => s.length > 0);
        
        watchlist = [...new Set(symbols)]; // Hapus duplikat
        localStorage.setItem('ultimateAppWatchlist', JSON.stringify(watchlist));
        watchlistInput.value = watchlist.join(', ');
        alert('Watchlist disimpan!');
    }

    /**
     * Memuat daftar watchlist dari localStorage saat halaman dibuka.
     */
    function loadWatchlist() {
    console.log("1. Memulai fungsi loadWatchlist..."); // Mata-mata #1
    const savedWatchlist = localStorage.getItem('ultimateAppWatchlist');
    
    if (savedWatchlist && JSON.parse(savedWatchlist).length > 0) {
        console.log("2. Menemukan watchlist yang tersimpan di localStorage."); // Mata-mata #2a
        watchlist = JSON.parse(savedWatchlist);
    } else {
        console.log("2. TIDAK ada watchlist tersimpan, menggunakan daftar DEFAULT."); // Mata-mata #2b
        watchlist = ['BTCUSDT', 'ETHUSDT', 'XRPUSDT', 'SOLUSDT'];
    }
    
    watchlistInput.value = watchlist.join(', ');
    console.log("3. Selesai menjalankan loadWatchlist. Isi variabel 'watchlist' sekarang:", watchlist); // Mata-mata #3
}

    /**
     * Menjalankan pemindaian untuk satu simbol dan mengembalikan skor konfluensinya.
     */
    async function getConfluenceScoreForSymbol(symbol) {
        try {
            const [tickerData, klines] = await Promise.all([
                fetchBinanceAPIData('ticker/24hr', { symbol }, 'spot'),
                fetchBinanceAPIData('klines', { symbol, interval: '15m', limit: 200 }, 'spot')
            ]);

            if (!klines || klines.length < 50) {
                return { symbol, error: 'Data kline tidak cukup.' };
            }

            const closes = klines.map(k => parseFloat(k[4]));
            const rsiValues = calculateRSI(closes);

            // Kalkulasi data yang dibutuhkan untuk skor
            const calculatedData = {
                ma: (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? { status: 'Uptrend' } : { status: 'Downtrend' },
                rsiDivergence: detectRSIDivergence(closes, rsiValues),
                stoch: calculateStochasticRSI(closes),
                macd: calculateMACD(closes),
                candlePattern: findCandlestickPatterns(klines),
                psar: calculateParabolicSAR(klines),
                linreg: calculateLinearRegressionChannel(closes),
                roc: calculateROC(closes)
            };

            // Hitung skor
            let totalBullScore = 0;
            let totalBearScore = 0;
            let maxScore = Object.values(userSettings.weights).reduce((sum, weight) => sum + weight, 0);

            for (const indicator in userSettings.weights) {
                if (calculatedData[indicator]) {
                    const score = getUltimateSignalScore(indicator, calculatedData[indicator]);
                    if (score > 0) totalBullScore += score;
                    if (score < 0) totalBearScore += Math.abs(score);
                }
            }
            
            const bullPercentage = maxScore > 0 ? (totalBullScore / maxScore) * 100 : 0;
            const bearPercentage = maxScore > 0 ? (totalBearScore / maxScore) * 100 : 0;
            
            let verdict = "NEUTRAL";
            if (bullPercentage > bearPercentage * 1.5) verdict = "BULLISH";
            if (bearPercentage > bullPercentage * 1.5) verdict = "BEARISH";

            return {
                symbol,
                price: parseFloat(tickerData.lastPrice),
                change24h: parseFloat(tickerData.priceChangePercent),
                bullScore: bullPercentage,
                bearScore: bearPercentage,
                verdict
            };
        } catch (error) {
            console.error(`Gagal memindai ${symbol}:`, error);
            return { symbol, error: error.message };
        }
    }

    /**
     * Mengatur dan menjalankan pemindaian untuk semua aset di watchlist.
     */
    async function scanWatchlist() {
        if (watchlist.length === 0) {
            alert('Harap isi dan simpan watchlist Anda terlebih dahulu.');
            return;
        }

        const btn = scanWatchlistBtn;
        const btnText = btn.querySelector('span');
        const btnLoader = btn.querySelector('.loader');

        btnText.classList.add('hidden');
        btnLoader.classList.remove('hidden');
        btn.disabled = true;
        watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-10 text-center"><div class="loader mx-auto"></div><p class="mt-2 text-sm text-gray-400">Memindai ${watchlist.length} aset...</p></td></tr>`;

        try {
            const results = [];
            for (const symbol of watchlist) {
                const result = await getConfluenceScoreForSymbol(symbol);
                results.push(result);
                // Tambahkan jeda 300ms untuk menghindari rate limit API
                await new Promise(resolve => setTimeout(resolve, 300));
            }
renderWatchlistTable(results);
        } catch (error) {
            watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-4 text-center text-sm text-red-500">Terjadi kesalahan saat pemindaian: ${error.message}</td></tr>`;
        } finally {
            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            btn.disabled = false;
        }
    }

    /**
     * Menampilkan hasil pemindaian watchlist ke dalam tabel.
     */
    function renderWatchlistTable(results) {
        if (results.length === 0) {
            watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-4 text-center text-sm text-gray-400">Tidak ada hasil.</td></tr>`;
            return;
        }
        
        let tableHtml = '';
        results.forEach(res => {
            if (res.error) {
                tableHtml += `
                    <tr class="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800" data-symbol="${res.symbol}">
                        <td class="px-4 py-3 font-medium text-gray-900 dark:text-white">${res.symbol}</td>
                        <td colspan="3" class="px-4 py-3 text-sm text-red-400">Error: ${res.error}</td>
                    </tr>
                `;
            } else {
                const priceFormatted = formatPrice(res.price);
                const changeClass = res.change24h >= 0 ? 'positive' : 'negative';
                let verdictClass = '';
                if (res.verdict === 'BULLISH') verdictClass = 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
                if (res.verdict === 'BEARISH') verdictClass = 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300';
                if (res.verdict === 'NEUTRAL') verdictClass = 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';

                tableHtml += `
                    <tr class="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800" data-symbol="${res.symbol}">
                        <td class="px-4 py-3 font-medium text-gray-900 dark:text-white">${res.symbol}</td>
                        <td class="px-4 py-3 text-sm text-gray-500 dark:text-gray-400">${priceFormatted}</td>
                        <td class="px-4 py-3 text-sm ${changeClass}">${res.change24h.toFixed(2)}%</td>
                        <td class="px-4 py-3 text-sm">
                            <div class="flex items-center justify-between gap-2">
                                <span class="font-semibold px-2 py-1 text-xs rounded-full ${verdictClass}">${res.verdict}</span>
                                <div class="text-right">
                                    <div class="text-xs positive">🐂 ${res.bullScore.toFixed(0)}%</div>
                                    <div class="text-xs negative">🐻 ${res.bearScore.toFixed(0)}%</div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }
        });
        watchlistResultsBody.innerHTML = tableHtml;
        attachWatchlistRowListeners();
    }

    /**
     * Menambahkan event listener ke setiap baris di tabel watchlist.
     */
    function attachWatchlistRowListeners() {
        document.querySelectorAll('#watchlist-results-body tr').forEach(row => {
            row.addEventListener('click', () => {
                const symbol = row.dataset.symbol;
                if (symbol) {
                    assetInput.value = symbol;
                    runFullAnalysis();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
        });
    }

    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR WATCHLIST (SELESAI) ==
// =================================================================================
// == BLOK KODE UPGRADE FINAL V2 UNTUK ANALISIS AI (TERMASUK KORELASI & RISIKO) ==
// =================================================================================

/**
 * FUNGSI UTAMA: Menjalankan seluruh alur analisis AI yang komprehensif.
 */
async function runComprehensiveAIAnalysis() {
    if (!analysisCache.tickerData) {
        showError("Jalankan 'GET DATA' terlebih dahulu untuk memuat data.");
        return;
    }

   // --- BLOK PENGGANTI UNTUK UI LOADER ---
            const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
            const btnText = comprehensiveBtn.querySelector('span');
            const btnLoader = comprehensiveBtn.querySelector('.loader');
            const aiContentContainer = document.getElementById('ai-content-container');
            const aiNarrativeEl = document.getElementById('ai-narrative-content');

            // 1. Aktifkan loader HANYA pada tombol
            btnText.classList.add('hidden');
            btnLoader.classList.remove('hidden');
            comprehensiveBtn.disabled = true;

            // 2. Bersihkan konten lama dan tampilkan pesan status sederhana di panel
            document.getElementById('projection-results-container').innerHTML = '';
            document.getElementById('saran-buyer').textContent = '';
            document.getElementById('alasan-buyer').textContent = '';
            document.getElementById('saran-holder').textContent = '';
            document.getElementById('alasan-holder').textContent = '';
            
            aiNarrativeEl.innerHTML = '<p class="text-sm text-center text-gray-500 animate-pulse">AI sedang menganalisa, mohon tunggu...</p>';
            aiContentContainer.classList.remove('hidden');
            // --- AKHIR BLOK PENGGANTI ---

    try {
        const { binanceSymbol, calculatedData, tickerData, correlationData } = analysisCache; // <-- Ambil correlationData dari cache
        const marketType = marketTypeSelect.value;
        // 1. Ambil data klines terbaru untuk semua timeframe relevan
        const [klines15m, klines1h, klines4h, klines1d] = await Promise.all([
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '15m', limit: 200 }, marketType),
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1h', limit: 200 }, marketType),
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '4h', limit: 200 }, marketType),
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 200 }, marketType)
        ]);

        // 2. Siapkan ringkasan Multi-Timeframe (MTA) untuk AI
        const multiTimeframeIndicators = {};
        const timeframes = { '15 Menit': klines15m, '1 Jam': klines1h, '4 Jam': klines4h, '1 Hari': klines1d };
        for (const tf in timeframes) {
            const klines = timeframes[tf];
            if (klines && klines.length > 50) {
                 const closes = klines.map(k => parseFloat(k[4]));
                 multiTimeframeIndicators[tf] = {
                     tren_ema_21_50: (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? 'BULLISH' : 'BEARISH',
                     rsi_14: calculateRSI(closes).pop()?.toFixed(2) || 'N/A',
                     adx_14: calculateADX(klines).adx,
                     macd_status: calculateMACD(closes).status
                 };
            }
        }

        // 3. Hitung dan siapkan data analisis volume (OBV & VWAP)
        const vwap20d = calculateVWAP(klines1d, 20);
        const obvValues = calculateOBV(klines1d);
        const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik (Akumulasi)' : 'Turun (Distribusi)';
        const vwapStatus = parseFloat(tickerData.lastPrice) > vwap20d ? 'Di Atas VWAP (Bullish)' : 'Di Bawah VWAP (Bearish)';
        const volumeAnalysisData = { vwap_20d: vwapStatus, obv_trend: obvTrend };

        // 4. Buat prompt hybrid yang paling komprehensif
        const prompt = constructHybridAIPrompt(binanceSymbol, calculatedData, multiTimeframeIndicators, volumeAnalysisData, analysisCache.onChainSummary, correlationData); // <-- Kirim correlationData ke prompt
        
        const aiResponseText = await callGemini([{ text: prompt }], false);
        const parsedData = parseAIResponseWithTags(aiResponseText);
        displayComprehensiveResults(parsedData);

    } catch (error) {
        aiNarrativeEl.innerHTML = `<p class="text-red-500">Gagal mendapatkan analisa AI: ${error.message}</p>`;
    } finally {
        btnText.classList.remove('hidden');
        btnLoader.classList.add('hidden');
        comprehensiveBtn.disabled = false;
    }
}

// GANTI SELURUH FUNGSI INI DENGAN VERSI FINAL YANG PALING ROBUST
function constructHybridAIPrompt(symbol, singleTfData, multiTfData, volumeData, onChainSummary, correlationData) {
    const mainPriceContext = {
        current_price: formatPrice(parseFloat(analysisCache.tickerData.lastPrice))
    };
    const cleanSingleTfData = {
        timeframe: timeframeSelect.value,
        candlestick_pattern: singleTfData.candlePattern,
        chart_pattern: singleTfData.chartPattern,
        rsi_divergence: singleTfData.rsiDivergence,
        obv_divergence: singleTfData.obvDivergence.status,
        volatilitas_atr: singleTfData.atr,
        order_book_bias: analysisCache.orderBookBias,
        bollinger_squeeze: singleTfData.bollingerBands.squeezeStatus,
        // --- PENAMBAHAN BARU UNTUK AI ---
        pivot_harian_bias: singleTfData.pivot.status + ` (Pivot @ ${formatPrice(singleTfData.pivot.data.P)})`,
        vwap_20d_bias: singleTfData.vwap.status,
        ichimoku_bias: singleTfData.ichimoku.status,
        squeeze_pro_bb_kc: (singleTfData.bollingerBands.width.slice(-1)[0] < singleTfData.keltnerChannels.width.slice(-1)[0]) ? 'Terdeteksi!' : 'Tidak Aktif'
    };
    const fundamentalData = {
        market_cap: analysisCache.coinGeckoData?.market_data?.market_cap?.usd?.toLocaleString() || 'N/A'
    };
    const correlationText = correlationData !== null ? correlationData.toFixed(2) : 'N/A (Aset adalah BTC atau data tidak cukup)';

    const ema9 = calculateEMA(analysisCache.klines.map(k=>parseFloat(k[4])), 9).pop();
    const ema21 = calculateEMA(analysisCache.klines.map(k=>parseFloat(k[4])), 21).pop();
    const scalpingBias = ema9 > ema21 ? 'LONG' : 'SHORT';
    const scalpingSetupData = {
        bias_sesaat: scalpingBias,
        timeframe: timeframeSelect.value
    };
    

    return `Sebagai seorang analis kuantitatif (Quant Analyst) senior, berikan analisis pasar yang komprehensif untuk ${symbol}.

        TUGAS UTAMA:
        1.  **CARI DATA EKSTERNAL:** Sebelum melakukan analisis, cari data sentimen pasar terbaru (khusus untuk BTC) dari sumber seperti Coinglass. Format hasilnya HANYA dalam bentuk JSON di dalam tag [SENTIMEN_DATA_JSON_START]. Strukturnya harus: {"netflow":-123.45,"oiChange":1.23,"funding":0.0001,"liquidations":"123.45M vs 67.89M"}
        2.  **ANALISIS SEMUA DATA:** Lanjutkan dengan menganalisis SEMUA data yang diberikan di bawah ini (DATA #0 hingga DATA #6) untuk mengisi sisa tag output.
        3.  **GUNAKAN JANGKAR HARGA:** Gunakan 'current_price' dari DATA #0 sebagai satu-satunya titik acuan untuk SEMUA PROYEKSI HARGA.

        **DATA #0: KONTEKS HARGA UTAMA (JANGKAR)**
        ${JSON.stringify(mainPriceContext, null, 2)}

        **DATA #1: Analisis Detail Timeframe Utama (${cleanSingleTfData.timeframe})**
        ${JSON.stringify(cleanSingleTfData, null, 2)}

        **DATA #2: Ringkasan Sinyal Kunci di Berbagai Timeframe (MTA)**
        ${JSON.stringify(multiTfData, null, 2)}

        **DATA #3: Analisis Berbasis Volume (CEX - Harian)**
        ${JSON.stringify(volumeData, null, 2)}

        **DATA #4: Data Fundamental Dasar**
        ${JSON.stringify(fundamentalData, null, 2)}

        **DATA #5: Ringkasan Aktivitas On-Chain (DEX - Transaksi >$5000)**
        ${onChainSummary ? JSON.stringify(onChainSummary, null, 2) : '"Data on-chain tidak tersedia untuk aset ini."'}

        **DATA #6: Korelasi Pasar (vs. BTCUSDT 30 Hari)**
        ${JSON.stringify({ correlation_coefficient: correlationText }, null, 2)}

        


        **INSTRUKSI OUTPUT (WAJIB IKUTI FORMAT TAG DI BAWAH INI SECARA PERSIS DAN LENGKAP):**

        [SENTIMEN_DATA_JSON_START]
        (Letakkan hasil pencarian data sentimen Coinglass dalam format JSON di sini)
        [SENTIMEN_DATA_JSON_END]
        
        [ANALISIS_SCALPING_START]
        (Berdasarkan SEMUA data pasar (MTA, Volume, On-Chain, dll.), berikan evaluasi singkat untuk 'SETUP SCALPING' dari DATA #7. Apakah kondisi pasar secara umum mendukung untuk mengambil posisi ${scalpingBias} pada timeframe ${scalpingSetupData.timeframe}? Berikan kesimpulan: 'KONDISI MENDUKUNG', 'NETRAL / PERLU HATI-HATI', atau 'KONDISI BERISIKO TINGGI'. Berikan 1-2 kalimat alasan singkat.)
        [ANALISIS_SCALPING_END]

        [PUTUSAN_FINAL_START]
        (Berikan putusan akhir dalam 2-5 kata. Contoh: BULLISH DENGAN KONFIRMASI, BEARISH POTENSI REVERSAL, KONSOLIDASI)
        [PUTUSAN_FINAL_END]

        [TINGKAT_KEYAKINAN_START]
        (Berikan persentase keyakinan Anda terhadap putusan di atas. Contoh: 80)
        [TINGKAT_KEYAKINAN_END]

        [NARASI_PASAR_START]
        (Berikan analisis narasi pasar yang mendalam dalam beberapa poin atau paragraf singkat. Sintesiskan semua data yang diberikan—MTA, Volume, On-Chain, Korelasi, dan Squeeze—untuk membangun cerita yang kohesif tentang apa yang sedang terjadi di pasar.)
        [NARASI_PASAR_END]

        [ANALISIS_RISIKO_START]
        (Berikan analisis risiko singkat (Rendah/Sedang/Tinggi) berdasarkan 3 faktor: Volatilitas dari ATR, Likuiditas dari Order Book Bias, dan Korelasi dengan BTC. Jelaskan alasannya.)
        [ANALISIS_RISIKO_END]

        [SMC_NARRATIVE_START]
        (Berikan analisis struktur pasar (SMC) yang detail. Jelaskan alur order flow, identifikasi Break of Structure (BOS) atau Change of Character (CHoCH) terkini, dan tunjukkan di mana area likuiditas (inducement) yang menjadi target.)
        [SMC_NARRATIVE_END]

        [SMC_POI_BULLISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bullish terdekat. Contoh: 'Order Block H4 di $50000 - $51000')
        [SMC_POI_BULLISH_END]

        [SMC_POI_BEARISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bearish terdekat. Contoh: 'Supply zone H1 di $60000 - $61000')
        [SMC_POI_BEARISH_END]

        [PROYEKSI_LENGKAP_JSON_START]
        [
            { "periode": "Sangat Pendek (24-48 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Pendek (1-7 hari)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Menengah (1-4 minggu)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Panjang (6-12 bulan)", "target_harga": "...", "alasan": "..." },
            { "periode": "Siklus Makro (1-3 tahun)", "target_harga": "...", "alasan": "..." }
        ]
        [PROYEKSI_LENGKAP_JSON_END]

        [SARAN_HOLDER_START]
        (Pilih salah satu: TAHAN, JUAL, TAMBAH, KURANGI SEBAGIAN)
        [SARAN_HOLDER_END]

        [ALASAN_HOLDER_START]
        (Jelaskan alasan teknikal untuk saran di atas)
        [ALASAN_HOLDER_END]

        [SARAN_BUYER_START]
        (Pilih salah satu: BELI SEKARANG, TUNGGU DI AREA, JANGAN MASUK)
        [SARAN_BUYER_END]

        [ALASAN_BUYER_START]
        (Jelaskan alasan teknikal. Jika TUNGGU, berikan rentang harga ideal berdasarkan POI)
        [ALASAN_BUYER_END]
        `;
    }
function parseAIResponseWithTags(rawText) {
    const result = {};
    const tags = [
        "SENTIMEN_DATA_JSON",
        "PUTUSAN_FINAL", "TINGKAT_KEYAKINAN", "NARASI_PASAR", "ANALISIS_SCALPING", "ANALISIS_RISIKO",
        "SMC_NARRATIVE", "SMC_POI_BULLISH", "SMC_POI_BEARISH",
        "PROYEKSI_LENGKAP_JSON", "SARAN_HOLDER", "ALASAN_HOLDER",
        "SARAN_BUYER", "ALASAN_BUYER"
        // Tag Volatilitas, Sentimen, dll, sudah disatukan dalam narasi utama jadi tidak perlu diparsing terpisah
    ];

    tags.forEach(tag => {
        const regex = new RegExp(`\\[${tag}_START\\]([\\s\\S]*?)\\[${tag}_END\\]`, 'i');
        const match = rawText.match(regex);
        const content = match ? match[1].trim() : null;
        
        const key = tag.toLowerCase();
        if (key === "proyeksi_lengkap_json" && content) {
            try {
                result[key] = JSON.parse(content);
            } catch (e) {
                console.error(`Gagal parse JSON untuk tag ${tag}:`, e);
                result[key] = [];
            }
        } else {
            result[key] = content;
        }
    });
    return result;
}


/**
 * UI RENDERER (VERSI ULTIMATE v2): Menampilkan hasil analisis baru termasuk risiko.
 */
function displayComprehensiveResults(data) {
    if (!data || !data.putusan_final) {
        document.getElementById('ai-narrative-content').innerHTML = '<p class="text-red-500 text-center">AI gagal memberikan analisis yang valid. Coba lagi.</p>';
        document.getElementById('projection-results-container').innerHTML = '';
        document.getElementById('saran-buyer').textContent = '-';
        document.getElementById('alasan-buyer').textContent = '';
        document.getElementById('saran-holder').textContent = '-';
        document.getElementById('alasan-holder').textContent = '';
        return;
    }
    if (data.sentimen_data_json) {
        try {
            const sentimentData = {
                ...JSON.parse(data.sentimen_data_json),
                lastUpdated: new Date()
            };
            analysisCache.shortTermSentiment = sentimentData;

            // Fungsi untuk menampilkan (kita buat di bawah)
            displaySentimentDataInDashboard(sentimentData);
        } catch (e) {
            console.error("Gagal parse JSON sentimen dari AI:", e);
            document.getElementById('sentiment-display-container').innerHTML = `<p class="text-xs text-center text-red-500">AI gagal memberikan data sentimen dalam format JSON yang benar.</p>`;
        }
    }
    let finalVerdictHtml = '';
    if (data.putusan_final && data.tingkat_keyakinan) {
        const verdictClass = data.putusan_final.toLowerCase().includes('bullish') || data.putusan_final.toLowerCase().includes('naik') ? 'positive' 
                           : (data.putusan_final.toLowerCase().includes('bearish') || data.putusan_final.toLowerCase().includes('turun') ? 'negative' : 'text-yellow-400');
        finalVerdictHtml = `
            <div class="text-center mb-4 p-3 rounded-lg bg-gray-100 dark:bg-gray-800/50">
                <p class="text-xl font-bold ${verdictClass}">${data.putusan_final.toUpperCase()}</p>
                <p class="text-sm text-gray-500">Tingkat Keyakinan: ${data.tingkat_keyakinan}%</p>
            </div>
        `;
    }

    let detailsHtml = `
        <div class="space-y-4 text-sm">
            ${data.narasi_pasar ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md"><strong>Narasi Pasar:</strong> ${data.narasi_pasar}</div>` : ''}
            
            ${data.analisis_scalping ? `<div class="p-3 bg-blue-50 dark:bg-blue-900/20 rounded-md border border-dashed border-blue-500/50"><strong>Evaluasi Setup Scalping:</strong> ${data.analisis_scalping}</div>` : ''}

            ${data.analisis_risiko ? `<div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border border-dashed border-yellow-500/50"><strong>Analisis Risiko:</strong> ${data.analisis_risiko}</div>` : ''}

            ${data.smc_narrative ? `
                <div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md mt-3">
                    <h5 class="font-bold mb-1">Analisis Struktur Pasar (SMC)</h5>
                    <p>${data.smc_narrative}</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2">
                        ${data.smc_poi_bullish ? `<div class="bg-green-500/10 p-2 rounded"><strong>🎯 POI Bullish:</strong> ${data.smc_poi_bullish}</div>` : ''}
                        ${data.smc_poi_bearish ? `<div class="bg-red-500/10 p-2 rounded"><strong>🎯 POI Bearish:</strong> ${data.smc_poi_bearish}</div>` : ''}
                    </div>
                </div>` : ''}
        </div>
    `;
    document.getElementById('ai-narrative-content').innerHTML = finalVerdictHtml + detailsHtml;

    // Tampilkan Proyeksi Harga
    const projectionContainer = document.getElementById('projection-results-container');
    projectionContainer.innerHTML = '';
    if (data.proyeksi_lengkap_json && data.proyeksi_lengkap_json.length > 0) {
        data.proyeksi_lengkap_json.forEach(p => {
            projectionContainer.innerHTML += `
                <div class="card p-3 bg-gray-50 dark:bg-gray-800/50">
                    <h4 class="font-semibold text-blue-400 text-sm">${p.periode}</h4>
                    <p class="font-bold text-base text-gray-800 dark:text-white">${p.target_harga}</p>
                    <p class="text-xs text-gray-500 mt-1">${p.alasan}</p>
                </div>`;
        });
         projectionContainer.className = `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`;
    } else {
        projectionContainer.innerHTML = '<p class="text-xs text-gray-500 col-span-full">Proyeksi harga tidak tersedia.</p>';
    }

    // Tampilkan Saran Strategis
    document.getElementById('saran-buyer').textContent = data.saran_buyer || 'N/A';
    document.getElementById('alasan-buyer').innerHTML = (data.alasan_buyer || 'Tidak ada alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
    document.getElementById('saran-holder').textContent = data.saran_holder || 'N/A';
    document.getElementById('alasan-holder').innerHTML = (data.alasan_holder || 'Tidak ada alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
}

// ### AKHIR DARI BLOK KODE BARU ###
    function updateDashboardUI() {
        if (!analysisCache.tickerData) return;
        const navInfoContainer = document.getElementById('nav-info-container');
        const navStatsContainer = document.getElementById('nav-stats-container');
        const tradeLinkContainer = document.getElementById('trade-link');

        if (navInfoContainer) {
            navInfoContainer.classList.remove('hidden');
            navInfoContainer.classList.add('md:flex');
        }
        if (navStatsContainer) {
            navStatsContainer.classList.remove('hidden');
            navStatsContainer.classList.add('md:flex');
        }
        if (tradeLinkContainer) {
            tradeLinkContainer.classList.remove('hidden');
        }
        initialPlaceholder.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
        const navHeight = document.getElementById('sticky-nav-wrapper').offsetHeight;
        smoothScrollTo(document.getElementById('toggle-charts-btn'), 900, navHeight + 16); // 16px = margin tambahan
        
        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        populateCorrelationWidget(); 
        
        if (isChartsVisible) {
            renderAllCharts();
        } else {
            destroyCharts(); 
            toggleChartsBtn.textContent = 'SHOW CHART';
        }
        renderCvdChart();
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }

    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleChartsBtn.textContent = 'HIDE CHART';
            if (analysisCache.klines) {
                renderAllCharts();
            }
        } else {
            chartsWrapper.style.display = 'none';
            toggleChartsBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }
    
    /**
 * Menjalankan animasi scroll yang halus ke sebuah elemen dengan offset.
 * @param {HTMLElement} element - Elemen tujuan untuk scroll.
 * @param {number} duration - Durasi animasi dalam milidetik.
 * @param {number} offset - Jarak (dalam pixel) dari puncak layar.
 */
function smoothScrollTo(element, duration, offset = 0) {
    if (!element) return; // Pengaman jika elemen tidak ditemukan
    const targetPosition = element.getBoundingClientRect().top + window.pageYOffset - offset;
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    let startTime = null;

    const easeInOutQuad = (t, b, c, d) => {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        t--;
        return -c / 2 * (t * (t - 2) - 1) + b;
    };

    const animation = (currentTime) => {
        if (startTime === null) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const run = easeInOutQuad(timeElapsed, startPosition, distance, duration);
        window.scrollTo(0, run);
        if (timeElapsed < duration) requestAnimationFrame(animation);
    };

    requestAnimationFrame(animation);
}
    // =======================================================
    // == FUNGSI BARU UNTUK EFEK SCROLL HALUS (SELESAI) ==
    // =======================================================

    function startFundingRateTimer(nextFundingTime) {
        if (fundingRateTimer) clearInterval(fundingRateTimer);

        const updateTimer = () => {
            const timeRemaining = formatTimeRemaining(nextFundingTime);
            document.getElementById('funding-rate-interval').textContent = timeRemaining;

            // Jika waktu sudah habis, hentikan timer
            if (timeRemaining === '00:00:00') {
                clearInterval(fundingRateTimer);
                // Di sini, Anda bisa memicu pembaruan data funding rate dari API
            }
        };

        updateTimer(); // Panggil sekali untuk pembaruan instan
        fundingRateTimer = setInterval(updateTimer, 1000);
    }

    function formatTimeRemaining(timestamp) {
        const now = new Date().getTime();
        const nextFunding = new Date(timestamp);
        const diff = nextFunding - now;

        if (diff <= 0) return '00:00:00';

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        const pad = (num) => num.toString().padStart(2, '0');

        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }

    function populateConfluenceDetailsWidget() {  
        const { calculatedData, orderBookData, lsRatioUmumData, lsRatioTopData } = analysisCache;
        if (calculatedData.pivot?.data) {
            document.getElementById('pivot-p').textContent = formatPrice(calculatedData.pivot.data.P);
        }
        if (calculatedData.vwap) {
            document.getElementById('vwap-20d').textContent = formatPrice(calculatedData.vwap.value);
        }
        if (calculatedData.ichimoku) {
            const ichiBiasEl = document.getElementById('ichimoku-bias');
            ichiBiasEl.textContent = calculatedData.ichimoku.status;
            ichiBiasEl.className = `font-mono font-semibold ${calculatedData.ichimoku.status === 'Bullish' ? 'positive' : (calculatedData.ichimoku.status === 'Bearish' ? 'negative' : 'text-gray-500')}`;
        }
        document.getElementById('confluence-timeframe-display').textContent = timeframeSelect.value;
        document.getElementById('vpvr-vah').textContent = formatPrice(calculatedData.vpvr.vah);
        document.getElementById('vpvr-poc').textContent = formatPrice(calculatedData.vpvr.poc);
        document.getElementById('vpvr-val').textContent = formatPrice(calculatedData.vpvr.val);
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = calculatedData.ma.status;
        maStatusEl.className = `font-mono font-semibold ${calculatedData.ma.class}`;
        document.getElementById('ema-21-value').textContent = `EMA21: ${formatPrice(calculatedData.ma.value21)}`;
        document.getElementById('ema-50-value').textContent = `EMA50: ${formatPrice(calculatedData.ma.value50)}`;
        document.getElementById('rsi-value').textContent = calculatedData.rsi.last;
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = calculatedData.rsi.status;
        rsiStatusEl.className = `tag ${calculatedData.rsi.class}`;
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = calculatedData.rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${calculatedData.rsiDivergence.class}`;
        document.getElementById('stoch-value').textContent = `${calculatedData.stoch.k}/${calculatedData.stoch.d}`;
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = calculatedData.stoch.status;
        stochStatusEl.className = `tag ${calculatedData.stoch.class}`;
        document.getElementById('macd-status').textContent = calculatedData.macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${calculatedData.macd.class}`;
        document.getElementById('macd-hist').textContent = calculatedData.macd.hist;
        document.getElementById('bollinger-bands-status').textContent = calculatedData.bollingerBands.status;
        const bbData = calculatedData.bollingerBands;
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop();
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop();
        const lastLower = bbData.lower.filter(v => v !== undefined).pop();
        document.getElementById('bb-upper-value').textContent = `U: ${formatPrice(lastUpper)}`;
        document.getElementById('bb-middle-value').textContent = `M: ${formatPrice(lastMiddle)}`;
        document.getElementById('bb-lower-value').textContent = `L: ${formatPrice(lastLower)}`;
        document.getElementById('atr-status').textContent = `${calculatedData.atr.value.toFixed(6)} (${calculatedData.atr.status})`;
        const atrPercentValue = calculatedData.atrPercent;
        if (atrPercentValue !== undefined) {
            document.getElementById('atr-percent-status').textContent = `(${atrPercentValue.toFixed(2)}%)`;
        }
        // KODE BARU DAN FINAL untuk Tampilan Pola
        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const candleResult = calculatedData.candlePattern;

        // Tentukan kelas warna untuk label Bullish/Bearish
        let biasClass = '';
        if (candleResult.bias === 'BULLISH') biasClass = 'positive';
        if (candleResult.bias === 'BEARISH') biasClass = 'negative';

        // Format timestamp menjadi jam:menit yang mudah dibaca
        const formattedTime = candleResult.timestamp 
            ? new Date(candleResult.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) 
            : '';

        // Bangun HTML lengkap untuk ditampilkan
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Pola Candlestick</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            ${candleResult.svg}
            <p id="candlestick-pattern" class="font-semibold ${candleResult.class}">${candleResult.pattern}</p>
            ${candleResult.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candleResult.bias}</p>` : ''}
        `;
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = calculatedData.chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${calculatedData.chartPattern.class}`;
        const psarStatusEl = document.getElementById('psar-status');
        psarStatusEl.textContent = calculatedData.psar.status;
        psarStatusEl.className = `font-mono font-semibold ${calculatedData.psar.status === 'Bullish' ? 'positive' : 'negative'}`;

        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${calculatedData.roc.value.toFixed(2)}% (${calculatedData.roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${calculatedData.roc.status === 'Positif' ? 'positive' : 'negative'}`;

        document.getElementById('linreg-status').textContent = calculatedData.linreg.status;

        // KODE BARU (Logika Squeeze Pro)
        const bbWidth = calculatedData.bollingerBands.width.slice(-1)[0];
        const kcWidth = calculatedData.keltnerChannels.width.slice(-1)[0];
        const bbSqueezeEl = document.getElementById('bollinger-squeeze-status');

        if (bbWidth < kcWidth) {
            bbSqueezeEl.textContent = 'SQUEEZE PRO!';
            bbSqueezeEl.className = 'font-mono font-bold negative blinking-text-animation';
        } else if (calculatedData.bollingerBands.squeezeStatus === 'Squeeze!') {
            bbSqueezeEl.textContent = 'Squeeze!';
            bbSqueezeEl.className = 'font-mono font-bold text-yellow-500 blinking-text-animation';
        } else {
            bbSqueezeEl.textContent = 'Normal';
            bbSqueezeEl.className = 'font-mono text-gray-500';
        }

        document.getElementById('bollinger-rejection-status').textContent = calculatedData.bollingerBands.rejection;
        document.getElementById('bollinger-walk-status').textContent = calculatedData.bollingerBands.walkTheBands;
        
        if (calculatedData.adx) {
            document.getElementById('adx-value').textContent = calculatedData.adx.adx;
            document.getElementById('plus-di-value').textContent = calculatedData.adx.plusDI;
            document.getElementById('minus-di-value').textContent = calculatedData.adx.minusDI;
        }
        const lsUmumContainer = document.getElementById('ls-umum-container'), lsTopContainer = document.getElementById('ls-top-container');
        if (marketTypeSelect.value === 'futures' && lsRatioUmumData?.[0] && lsRatioTopData?.[0]) {
            lsUmumContainer.classList.remove('hidden');
            lsTopContainer.classList.remove('hidden');
            document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
        } else {
            lsUmumContainer.classList.add('hidden');
            lsTopContainer.classList.add('hidden');
        }
        if (orderBookData?.bids && orderBookData?.asks) {
            const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
            const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
            let biasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (Banyak Beli)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (Banyak Jual)' : 'Netral');
            document.getElementById('order-book-bias').textContent = biasText;
            analysisCache.orderBookBias = biasText;
        } else {
            document.getElementById('order-book-bias').textContent = 'N/A';
            analysisCache.orderBookBias = 'N/A';
        }

    }

    // Fungsi baru untuk mendeteksi "wall"
    function detectAndDisplayWall(bids, asks) {
        // Logika untuk mendeteksi cluster order
        const findWallCluster = (levels) => {
            if (!levels || levels.length < 5) return null;
            const numLevelsToCheck = 15;
            const topLevels = levels.slice(0, numLevelsToCheck).map(l => parseFloat(l[1]));
            
            const sortedVolumes = [...topLevels].sort((a,b) => b-a);
            const avgVolume = sortedVolumes.slice(1).reduce((sum, vol) => sum + vol, 0) / (numLevelsToCheck - 1);
            
            const maxVolume = sortedVolumes[0];
            const thinThreshold = Math.max(avgVolume * 2, maxVolume * 0.2); 
            const mediumThreshold = Math.max(avgVolume * 5, maxVolume * 0.5); 
            const thickThreshold = Math.max(avgVolume * 10, maxVolume * 0.7); 

            let currentWall = null;
            let walls = [];
            
            for (let i = 0; i < levels.length; i++) {
                const price = parseFloat(levels[i][0]);
                const volume = parseFloat(levels[i][1]);

                if (volume >= thinThreshold) {
                    if (!currentWall) {
                        currentWall = {
                            priceStart: price,
                            priceEnd: price,
                            totalVolume: volume,
                            levels: 1,
                            levelPrices: [price]
                        };
                    } else {
                        currentWall.priceEnd = price;
                        currentWall.totalVolume += volume;
                        currentWall.levels++;
                        currentWall.levelPrices.push(price);
                    }
                } else {
                    if (currentWall && currentWall.levels >= 3) {
                        let wallType = 'Thin';
                        if (currentWall.totalVolume >= thickThreshold * 3) {
                            wallType = 'Thick';
                        } else if (currentWall.totalVolume >= mediumThreshold * 3) {
                            wallType = 'Medium';
                        }
                        walls.push({...currentWall, wallType});
                    }
                    currentWall = null;
                }
            }

            if (currentWall && currentWall.levels >= 3) {
                let wallType = 'Thin';
                if (currentWall.totalVolume >= thickThreshold * 3) {
                    wallType = 'Thick';
                } else if (currentWall.totalVolume >= mediumThreshold * 3) {
                    wallType = 'Medium';
                }
                walls.push({...currentWall, wallType});
            }
            
            if (walls.length > 0) {
                return walls.reduce((max, current) => (current.totalVolume > max.totalVolume) ? current : max, walls[0]);
            }
            
            return null;
        };

        // Logika tambahan untuk mendeteksi satu order yang sangat besar
        const findSingleWall = (levels) => {
            if (!levels || levels.length === 0) return null;
            const volumes = levels.map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...volumes);
            
            // Jika volume terbesar lebih dari 10x rata-rata, deteksi sebagai dinding tunggal
            const avgVolume = volumes.reduce((a,b)=>a+b, 0) / volumes.length;
            if (maxVolume > avgVolume * 10) {
                const maxIndex = volumes.findIndex(v => v === maxVolume);
                return {
                    priceStart: parseFloat(levels[maxIndex][0]),
                    priceEnd: parseFloat(levels[maxIndex][0]),
                    totalVolume: maxVolume,
                    levels: 1,
                    wallType: 'Thick' // Anggap single wall yang sangat besar sebagai Thick
                };
            }
            return null;
        };
        
        const buyWallCluster = findWallCluster(bids);
        const sellWallCluster = findWallCluster(asks);
        const buyWallSingle = findSingleWall(bids);
        const sellWallSingle = findSingleWall(asks);
        
        // Prioritaskan cluster, jika tidak ada, gunakan single wall
        const finalBuyWall = buyWallCluster || buyWallSingle;
        const finalSellWall = sellWallCluster || sellWallSingle;
        
        return { buyWall: finalBuyWall, sellWall: finalSellWall };
    }
    // Fungsi baru untuk merender order book penuh
    // GANTI SELURUH FUNGSI LAMA DENGAN VERSI BARU INI
    function renderFullOrderBook(bids, asks, wallInfo, precision) {
        const numLevels = 10;

        // --- LOGIKA BARU: BANGUN KERANGKA HANYA SEKALI ---
        if (!orderBookDOMElements) {
            let asksHtml = '';
            for (let i = 0; i < numLevels; i++) {
                asksHtml += `
                    <div class="flex items-center text-xs mt-1 relative z-0">
                        <div class="ask-bar absolute inset-0 bg-red-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                        <span class="ask-price w-1/2 text-left font-mono"></span>
                        <span class="ask-qty w-1/2 text-right font-mono"></span>
                    </div>
                `;
            }
            let bidsHtml = '';
            for (let i = 0; i < numLevels; i++) {
                bidsHtml += `
                    <div class="flex items-center text-xs mt-1 relative z-0">
                        <div class="bid-bar absolute inset-0 bg-green-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                        <span class="bid-qty w-1/2 text-left font-mono"></span>
                        <span class="bid-price w-1/2 text-right font-mono"></span>
                    </div>
                `;
            }

            fullOrderBookContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-red-500 font-bold">ASKs (Jual)</h4>
                        <div id="asks-container">${asksHtml}</div>
                    </div>
                    <div>
                        <h4 class="text-green-500 font-bold">BIDs (Beli)</h4>
                        <div id="bids-container">${bidsHtml}</div>
                    </div>
                </div>
                <p id="wall-info-text" class="text-center text-xs mt-4 text-gray-500"></p>
            `;
            
            // Simpan referensi ke elemen DOM
            orderBookDOMElements = {
                asks: Array.from(document.querySelectorAll('#asks-container > div')).map(row => ({
                    row, bar: row.querySelector('.ask-bar'), price: row.querySelector('.ask-price'), qty: row.querySelector('.ask-qty')
                })).reverse(), // Reverse asks agar sesuai dengan data
                bids: Array.from(document.querySelectorAll('#bids-container > div')).map(row => ({
                    row, bar: row.querySelector('.bid-bar'), price: row.querySelector('.bid-price'), qty: row.querySelector('.bid-qty')
                })),
                wallInfo: document.getElementById('wall-info-text')
            };
        }

        // --- LOGIKA UPDATE: HANYA PERBARUI TEKS DAN STYLE ---
        const totalMaxVolume = Math.max(
            ...bids.slice(0, numLevels).map(b => parseFloat(b[1])), 
            ...asks.slice(0, numLevels).map(a => parseFloat(a[1]))
        );

        // Update Asks
        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.asks[i];
            const data = asks[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.sellWall && price >= wallInfo.sellWall.priceStart && price <= wallInfo.sellWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `ask-price w-1/2 text-left font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-red-500' : 'text-red-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        // Update Bids
        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.bids[i];
            const data = bids[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.buyWall && price >= wallInfo.buyWall.priceStart && price <= wallInfo.buyWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `bid-price w-1/2 text-right font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-green-500' : 'text-green-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        // Update Wall Info Text
        let wallText = '';
        if (wallInfo.buyWall) {
            wallText += `<span class="text-green-500 font-bold">Dinding Beli ${wallInfo.buyWall.wallType.toUpperCase()}</span> terdeteksi dari ${formatPrice(wallInfo.buyWall.priceStart)} ke ${formatPrice(wallInfo.buyWall.priceEnd)} (Volume: $${(wallInfo.buyWall.totalVolume * parseFloat(bids[0][0])).toLocaleString('en-US', {notation: 'compact'})}) `;
        }
        if (wallInfo.sellWall) {
            wallText += `<span class="text-red-500 font-bold">Dinding Jual ${wallInfo.sellWall.wallType.toUpperCase()}</span> terdeteksi dari ${formatPrice(wallInfo.sellWall.priceStart)} ke ${formatPrice(wallInfo.sellWall.priceEnd)} (Volume: $${(wallInfo.sellWall.totalVolume * parseFloat(asks[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        orderBookDOMElements.wallInfo.innerHTML = wallText;
    }

    // --- 7. CHART RENDERING ENGINE (REBUILT) ---
    
    function getChartBaseOptions(height) {
        const isDarkMode = document.documentElement.classList.contains('dark');
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 48, // Parent padding
            height: height,
            layout: { background: { color: isDarkMode ? '#0e0d0d' : '#FFFFFF' }, textColor: isDarkMode ? '#D1D5DB' : '#374151' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                secondsVisible: false, 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                // [PERBAIKAN] Mengoptimalkan drag untuk panning
                lockVisibleTimeRangeOnResize: true,
                rightOffset: 0,
                barSpacing: 6,
                minBarSpacing: 3,
                horzTouchDrag: true, 
                vertTouchDrag: false, 
                mouseScroll: false, // Menonaktifkan mouse scroll zoom
                pinchToZoom: true, // Membiarkan pinch-to-zoom di mobile
                tickMarkFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format ke jam:menit menggunakan timezone default browser pengguna
                    return date.toLocaleTimeString('id-ID', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
            },
            crosshair: { 
                mode: LightweightCharts.CrosshairMode.Normal,
                horzLine: {
                    visible: true,
                    labelVisible: true
                },
                vertLine: {
                    visible: true,
                    labelVisible: true
                }
            },
            rightPriceScale: { 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                visible: true,
                scaleMargins: {
                    top: 0.1,
                    bottom: 0.1
                }
            },
            localization: {
                timeFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format waktu yang lebih lengkap untuk tooltip, menggunakan timezone lokal
                    return date.toLocaleString('id-ID', {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        timeZone: 'Asia/Jakarta'
                    });
                }
            }
        };
    }

    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if(!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (chart !== otherChart && otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }
   
// [PERBAIKAN] FUNGSI renderAllCharts dengan logika perbaikan
    function renderAllCharts() {
        if (!analysisCache.klines) return;
        
        destroyCharts();

        const { klines, calculatedData } = analysisCache;
        const closes = klines.map(k => parseFloat(k[4]));
        
        const formattedKlines = klines
            .filter(k => k && k.length >= 5 && k.slice(1, 5).every(v => v !== null && !isNaN(parseFloat(v))))
            .map(d => ({ 
                time: d[0] / 1000,
                open: parseFloat(d[1]), 
                high: parseFloat(d[2]), 
                low: parseFloat(d[3]), 
                close: parseFloat(d[4]), 
                volume: parseFloat(d[5])
            }));
        
        if (formattedKlines.length === 0) return;

        const formatLineData = (data, klineData, offset = 0) => data
            .map((value, index) => {
                const klineIndex = index + offset;
                if (klineData[klineIndex]) {
                    const time = klineData[klineIndex][0] / 1000;
                    return { time, value };
                }
                return null;
            })
            .filter(d => d && d.value !== undefined && d.value !== null && !isNaN(d.value));

        const rocPlotData = calculateROC_forPlot(closes, 12);
        const ema50PlotData = formatLineData(calculateEMA(closes, 50), klines);
        const bbPlotData = calculateBollingerBands_forPlot(closes, 20, 2, klines);
        const macdData = calculatedData.macd;
        const macdLinePlotData = formatLineData(macdData.macdLine, klines);
        const signalLinePlotData = formatLineData(macdData.signalLine, klines, (userSettings.indicator.macd_slow - 1));
        const histogramPlotData = macdData.histogram
            .map((item, index) => {
                if (klines[index] && item !== undefined) {
                    return {
                        time: klines[index][0] / 1000, // <-- MENGGUNAKAN WAKTU UTC ASLI
                        value: item.value,
                        color: item.color
                    };
                }
                return null;
            })
            .filter(d => d);
        const volumePlotData = formattedKlines.map(d => ({
            time: d.time,
            value: d.volume,
            color: d.close >= d.open ? 'rgba(4, 150, 120, 0.5)' : 'rgba(220, 50, 80, 0.5)'
        }));

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);
        candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
        candlestickSeries.setData(formattedKlines);
        
        mainChart.addLineSeries({ color: 'yellow', lineWidth: 2, priceLineVisible: false, lastValueVisible: true, title: '' }).setData(ema50PlotData);
        mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.upper);
        mainChart.addLineSeries({ color: 'white', lineWidth: 2, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.middle);
        mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.lower);

        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100)); // Tinggi lebih kecil
        charts.push(volumeChart);
        volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } }).setData(volumePlotData);
        
        const vpvr = calculatedData.vpvr;
        if (vpvr.poc > 0) candlestickSeries.createPriceLine({ price: vpvr.poc, color: '#fbbf24', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Solid, axisLabelVisible: true, title: 'POC' });
        if (vpvr.vah > 0) candlestickSeries.createPriceLine({ price: vpvr.vah, color: '#F4511E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'H' });
        if (vpvr.val > 0) candlestickSeries.createPriceLine({ price: vpvr.val, color: '#399BC8', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'L' });
        
        const pivots = calculatedData.pivot.data;
        if (pivots) {
            candlestickSeries.createPriceLine({ price: pivots.P, color: '#ffc107', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Solid, axisLabelVisible: true, title: 'Pivot' });
            candlestickSeries.createPriceLine({ price: pivots.R1, color: '#f44336', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'R1' });
            candlestickSeries.createPriceLine({ price: pivots.S1, color: '#4caf50', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'S1' });
        }

        // 2. Tampilkan VWAP
        const vwapValue = calculatedData.vwap.value;
        if (vwapValue > 0) {
            candlestickSeries.createPriceLine({ price: vwapValue, color: '#03a9f4', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: 'VWAP' });
        }

        // 3. Tampilkan Ichimoku Cloud
        const ichimokuData = calculatedData.ichimoku.data;
        if (ichimokuData) {
            const KijunP = 26; // Periode Kijun untuk offset
            
            // Format data untuk Senkou A dan B yang digeser ke depan
            const senkouA_plot = ichimokuData.senkouA.map((val, idx) => klines[idx + KijunP] ? { time: klines[idx + KijunP][0] / 1000, value: val } : null).filter(Boolean);
            const senkouB_plot = ichimokuData.senkouB.map((val, idx) => klines[idx + KijunP] ? { time: klines[idx + KijunP][0] / 1000, value: val } : null).filter(Boolean);
            
            const cloudSeriesA = mainChart.addAreaSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, lineWidth: 1, color: 'rgba(38, 166, 154, 0.2)' });
            const cloudSeriesB = mainChart.addAreaSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, lineWidth: 1, color: 'rgba(239, 83, 80, 0.2)' });
            cloudSeriesA.setData(senkouA_plot);
            cloudSeriesB.setData(senkouB_plot);

            // Tampilkan Tenkan & Kijun
            mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false, lastValueVisible: false }).setData(formatLineData(ichimokuData.tenkan, klines));
            mainChart.addLineSeries({ color: '#D50000', lineWidth: 1, priceLineVisible: false, lastValueVisible: false }).setData(formatLineData(ichimokuData.kijun, klines));
        }
        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(150));
        charts.push(rsiChart);
        const rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2, lastValueVisible: false, priceLineVisible: false });
        rsiSeries.setData(formatLineData(calculatedData.rsi.values, klines));
        rsiSeries.createPriceLine({ price: 70, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: '' });
        rsiSeries.createPriceLine({ price: 30, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: '' });

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(150));
        charts.push(stochChart);
        const stochData = calculatedData.stoch;
        const stochKSeries = stochChart.addLineSeries({ color: '#2196F3', lineWidth: 2, title: '', lastValueVisible: true, priceLineVisible: false });
        stochKSeries.setData(formatLineData(stochData.kLine, klines, stochData.dOffset));
        stochChart.addLineSeries({ color: '#FF9800', lineWidth: 2, title: '', lastValueVisible: true, priceLineVisible: false }).setData(formatLineData(stochData.dLine, klines, stochData.dOffset));
        stochKSeries.createPriceLine({ price: 80, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: '' });
        stochKSeries.createPriceLine({ price: 20, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: '' });

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const rocChart = LightweightCharts.createChart(document.getElementById('roc-chart-container'), getChartBaseOptions(150));
        charts.push(rocChart);
        const rocSeries = rocChart.addLineSeries({ color: '#f472b6', lineWidth: 2, lastValueVisible: false, priceLineVisible: false });
        rocSeries.setData(rocPlotData);
        rocSeries.createPriceLine({ price: 0, color: '#9E9E9E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: '0' });
        
        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(150));
        charts.push(macdChart);
        macdChart.addHistogramSeries({ base: 0 }).setData(histogramPlotData);
        macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: 'MACD', lastValueVisible: false, priceLineVisible: false }).setData(macdLinePlotData);
        macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: 'Signal', lastValueVisible: false, priceLineVisible: false }).setData(signalLinePlotData);

        const allCharts = [mainChart, volumeChart, rsiChart, stochChart, macdChart, rocChart];
        
        // Sinkronisasi Crosshair dan Time Range
        syncCharts(...allCharts);

        const initialRange = mainChart.timeScale().getVisibleRange();
        if (initialRange) {
            allCharts.forEach(chart => {
                if (chart !== mainChart && chart) {
                    chart.timeScale().setVisibleRange(initialRange);
                }
            });
        }
    }
    
// [PERBAIKAN] Fungsi kalkulasi untuk plotting Bollinger Bands
    function calculateBollingerBands_forPlot(closes, period = 20, stdDev = 2, klines) {
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const middle = calculateSMA(closes, period);
        const upper = [], middleData = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                continue;
            }
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            const time = klines[i][0] / 1000;
            upper.push({ time, value: middle[i] + (stdev * stdDev) });
            lower.push({ time, value: middle[i] - (stdev * stdDev) });
            middleData.push({ time, value: middle[i] });
        }
        return { upper: upper.filter(d => d), middle: middleData.filter(d => d.value !== undefined), lower: lower.filter(d => d) };
    }
    function calculateROC_forPlot(closes, period = 12) {
        if (closes.length < period + 1) return [];
        const rocData = [];
        for (let i = period; i < closes.length; i++) {
            const currentClose = closes[i];
            const pastClose = closes[i - period];
            if (pastClose !== 0) {
                const roc = ((currentClose - pastClose) / pastClose) * 100;
                rocData.push({ time: analysisCache.klines[i][0] / 1000, value: roc });
            }
        }
        return rocData;
    }

    // [PERBAIKAN] Fungsi kalkulasi Linear Regression Channel
    function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
        const closes = klines.map(k => parseFloat(k[4]));
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const upper = [], middle = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            const y = closes.slice(i - period + 1, i + 1);
            const n = period; 
            const sumX = (n * (n - 1)) / 2;
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
            const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate Standard Deviation from regression error
            let sumErrSq = 0;
            for (let j = 0; j < n; j++) {
                const predictedY = intercept + slope * j;
                sumErrSq += Math.pow(y[j] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middleValue = intercept + slope * (n - 1);
            middle.push({ time: klines[i][0] / 1000, value: middleValue });
            upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
            lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) }); 
        }
        return { upper, middle, lower };
    }

    // Fungsi baru untuk mendeteksi pola harga pada Bollinger Bands
function analyzeBollingerBandsPriceAction(klines, bbData) {
    if (!klines || klines.length < 2 || !bbData || bbData.upper.length < 2) {
        return { rejection: 'Tidak Ada', walkTheBands: 'Tidak Ada' };
    }

    const lastKline = klines[klines.length - 1];
    const prevKline = klines[klines.length - 2];
    const lastUpper = bbData.upper.pop()?.value;
    const lastLower = bbData.lower.pop()?.value;
    const prevUpper = bbData.upper.pop()?.value;
    const prevLower = bbData.lower.pop()?.value;

    const lastClose = parseFloat(lastKline[4]);
    const prevClose = parseFloat(prevKline[4]);

    let rejection = 'Tidak Ada';
    // Logika Rejection Bullish
    if (prevClose < prevLower && lastClose > lastLower && lastClose > prevClose) {
        rejection = 'Bullish Rejection (Lower BB)';
    }
    // Logika Rejection Bearish
    if (prevClose > prevUpper && lastClose < lastUpper && lastClose < prevClose) {
        rejection = 'Bearish Rejection (Upper BB)';
    }

    let walkTheBands = 'Tidak Ada';
    // Logika Walk the Bands Bullish
    if (lastClose >= lastUpper && prevClose >= prevUpper) {
        walkTheBands = 'Bullish (Upper BB)';
    }
    // Logika Walk the Bands Bearish
    if (lastClose <= lastLower && prevClose <= prevLower) {
        walkTheBands = 'Bearish (Lower BB)';
    }
    
    return { rejection, walkTheBands };
}

    function destroyCharts() {
    // 1. Hapus semua chart utama (LightweightCharts)
        charts.forEach(chart => {
            if (chart) {
                chart.remove();
            }
        });
        charts = [];
        candlestickSeries = null;
        
        // 2. Kosongkan HANYA kontainer chart utama
        const mainChartContainers = [
            'main-chart-container', 
            'rsi-chart-container', 
            'stoch-chart-container', 
            'macd-chart-container',
            'roc-chart-container'
        ];
        mainChartContainers.forEach(id => {
            const container = document.getElementById(id);
            if (container) {
                container.innerHTML = '';
            }
        });
    }
    
function processQueues() {
    // 1. Proses Antrian KLINE (untuk Chart)
    // Bagian ini sekarang hanya untuk update chart dan indikator, bukan harga live.
    if (klineQueue.length > 0) {
        const latestKlineMessage = klineQueue.pop();
        if (candlestickSeries) {
            const candle = latestKlineMessage.k;
            const formattedCandle = {
               time: timeToLocal(candle.t / 1000), 
                open: parseFloat(candle.o),
                high: parseFloat(candle.h),
                low: parseFloat(candle.l),
                close: parseFloat(candle.c)
            };
            candlestickSeries.update(formattedCandle);
            if (candle.x) {
                if (analysisCache.klines && analysisCache.klines.length > 0) {
                    analysisCache.klines.shift();
                    analysisCache.klines.push([candle.t, candle.o, candle.h, candle.l, candle.c, candle.v, candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B]);
                }
                updateRealTimeIndicators(analysisCache.klines);
            }
        }
    }
    
    // 2. Proses Antrian Trade (untuk CVD dan HARGA LIVE)
    if (tradeQueue.length > 0) {
        const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
        tradesToProcess.forEach(trade => {
            const quantity = parseFloat(trade.q);
            const price = parseFloat(trade.p); // <-- Harga transaksi

            // PERBARUI HARGA LIVE DENGAN HARGA TRANSAKSI
            const navPriceEl = document.getElementById('nav-price');
            const navIdrEl = document.getElementById('nav-price-idr');
            if (navPriceEl && navIdrEl) {
                navPriceEl.textContent = formatPrice(price);
                navIdrEl.textContent = `Rp ${(price * (analysisCache.usdToIdrRate || 0)).toLocaleString('id-ID', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
            }
            //document.getElementById('current-price').textContent = formatPrice(price);
            //document.getElementById('current-price-idr').textContent = `Rp ${(price * (analysisCache.usdToIdrRate || 0)).toLocaleString('id-ID')}`;

            // Logika CVD
            if (cvdChartInstance) {
                if (isNaN(quantity) || quantity === 0) return;
                const sign = trade.m ? -1 : 1;
                liveCvdValue += quantity * sign;
                liveCvdValueUsdt += (quantity * price) * sign;
                const newPoint = { x: trade.T, y_coin: liveCvdValue, y_usdt: liveCvdValueUsdt };
                cvdChartInstance.data.datasets[0].data.push(newPoint);
                liveCvdData.push(newPoint);
                while (cvdChartInstance.data.datasets[0].data.length > 300) {
                    cvdChartInstance.data.datasets[0].data.shift();
                    liveCvdData.shift();
                }
                cvdChartInstance.update('none');
                updateCvdTableLive();
            }
        });
    }
    
    // 3. Proses Antrian Depth (untuk Order Book Penuh dan Wall Detection)
    if (depthQueue.length > 0) {
        const updatesToProcess = depthQueue.splice(0, depthQueue.length);
        updatesToProcess.forEach(update => {
            if (update.b) {
                update.b.forEach(([price, qty]) => {
                    const existingIndex = latestBids.findIndex(bid => bid[0] === price);
                    if (parseFloat(qty) === 0) {
                        if (existingIndex !== -1) {
                            latestBids.splice(existingIndex, 1);
                        }
                    } else {
                        if (existingIndex !== -1) {
                            latestBids[existingIndex] = [price, qty];
                        } else {
                            latestBids.push([price, qty]);
                        }
                    }
                });
            }
            if (update.a) {
                update.a.forEach(([price, qty]) => {
                    const existingIndex = latestAsks.findIndex(ask => ask[0] === price);
                    if (parseFloat(qty) === 0) {
                        if (existingIndex !== -1) {
                            latestAsks.splice(existingIndex, 1);
                        }
                    } else {
                        if (existingIndex !== -1) {
                            latestAsks[existingIndex] = [price, qty];
                        } else {
                            latestAsks.push([price, qty]);
                        }
                    }
                });
            }
        });

        latestBids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
        latestAsks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
        
        const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
        const precision = getPrecisionForAsset(parseFloat(latestPrice));

        const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
        renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
    }
}

function populateCurrentStateWidget() {
    const { tickerData, coinGeckoData, usdToIdrRate, globalData, openInterestData, fundingRateData, binanceSymbol } = analysisCache;
    
    // Mengisi Navigasi Atas
    document.getElementById('nav-symbol').textContent = binanceSymbol;
    const navChange24hEl = document.getElementById('nav-change-24h');
    const navChange1hEl = document.getElementById('nav-change-1h');
    
    const change24h = parseFloat(tickerData.priceChangePercent);
    if (navChange24hEl) {
        navChange24hEl.textContent = `${change24h.toFixed(2)}%`;
        navChange24hEl.className = `font-semibold ${change24h >= 0 ? 'positive' : 'negative'}`;
    }
    
    if (navChange1hEl && coinGeckoData?.market_data) {
        const change1h = coinGeckoData.market_data.price_change_percentage_1h_in_currency.usd || 0;
        navChange1hEl.textContent = `${change1h.toFixed(2)}%`;
        navChange1hEl.className = `font-semibold ${change1h >= 0 ? 'positive' : 'negative'}`;
    }
    navVolume24h.textContent = `$${parseFloat(tickerData.quoteVolume).toLocaleString('en-US', { notation: 'compact' })}`;
    if (coinGeckoData?.market_data) {
        navAth.textContent = formatPrice(coinGeckoData.market_data.ath.usd);
        navAtl.textContent = formatPrice(coinGeckoData.market_data.atl.usd);
    }

    // Mengisi Kartu DATA DASAR yang Disederhanakan
    if (coinGeckoData?.market_data) {
        document.getElementById('market-cap').textContent = formatPrice(coinGeckoData.market_data.market_cap.usd);
    }
    if (globalData?.data) {
        document.getElementById('btc-dominance').textContent = `${globalData.data.market_cap_percentage.btc.toFixed(2)}%`;
    }

    // Mengisi Bagian Lain yang Masih Ada di Dasbor
    document.getElementById('current-state-title').innerHTML = `<span class="text-yellow-500 font-semibold">💲 ${binanceSymbol}</span>`;
    document.getElementById('range-24h').textContent = `${formatPrice(parseFloat(tickerData.lowPrice)).replace('$', '')} - ${formatPrice(parseFloat(tickerData.highPrice)).replace('$', '')}`;
    
    const futuresContainer = document.getElementById('futures-data-container');
    const price = parseFloat(tickerData.lastPrice);
    if (marketTypeSelect.value === 'futures' && openInterestData && fundingRateData) {
        futuresContainer.classList.remove('hidden');
        document.getElementById('open-interest').textContent = `$${(parseFloat(openInterestData.openInterest) * price).toLocaleString('en-US', { notation: 'compact' })}`;
        document.getElementById('funding-rate').textContent = `${(parseFloat(fundingRateData.lastFundingRate) * 100).toFixed(4)}%`;
        if (fundingRateData.nextFundingTime) {
            startFundingRateTimer(fundingRateData.nextFundingTime);
        } else {
            document.getElementById('funding-rate-interval').textContent = '-';
        }
    } else {
        futuresContainer.classList.add('hidden');
    }
}
    function renderCvdChart() {
        const { cvdData } = analysisCache;
        if (!cvdData || cvdData.length === 0) return;

        // Inisialisasi data live dengan format baru yang lengkap
        liveCvdData = cvdData.map(d => ({ 
            x: d.time * 1000, 
            y_coin: d.cvd_coin,
            y_usdt: d.cvd_usdt 
        }));
        
        // Inisialisasi nilai kumulatif terakhir
        if (liveCvdData.length > 0) {
            const lastPoint = liveCvdData[liveCvdData.length - 1];
            liveCvdValue = lastPoint.y_coin;
            liveCvdValueUsdt = lastPoint.y_usdt;
        }

        const ctx = document.getElementById('cvdChart').getContext('2d');
        if (cvdChartInstance) cvdChartInstance.destroy();
        
        const isDarkMode = document.documentElement.classList.contains('dark');
        const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
        const negativeColor = isDarkMode ? '#f87171' : '#dc2626';

        cvdChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'CVD (USDT)',
                    data: liveCvdData,
                    parsing: {
                        yAxisKey: 'y_usdt' // <-- PENTING: Memberitahu chart untuk menggunakan nilai USDT
                    },
                    fill: false, tension: 0.1, pointRadius: 0, borderWidth: 2,
                    segment: {
                        borderColor: ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor,
                    }
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'time', time: { tooltipFormat: 'MMM dd, HH:mm:ss', unit: 'second' }, grid: { display: false }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563', source: 'auto', maxRotation: 0, autoSkip: true } },
                    y: { grid: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563' } }
                },
                plugins: { legend: { display: false } },
                interaction: { mode: 'index', intersect: false }
            }
        });

        // Perbarui tabel dengan data awal
        updateCvdTableLive(liveCvdData);
    }
    
    const reconnectDelay = 5000; // Coba sambung kembali setiap 5 detik

// --- FUNGSI KALKULASI BARU ---

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { value: 0, status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { value: 0, status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { value: roc, status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { value: 0, status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { value: sar, status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }

    function calculateLinearRegressionChannel(closes, period = 14, stdDev = 2) {
        if (closes.length < period) return { upper: 0, middle: 0, lower: 0, status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Calculate Standard Deviation from regression error
        let sumErrSq = 0;
        for (let i = 0; i < n; i++) {
            const predictedY = intercept + slope * i;
            sumErrSq += Math.pow(y[i] - predictedY, 2);
        }
        const stdErr = Math.sqrt(sumErrSq / (n - 2));

        const middle = intercept + slope * (n - 1);
        const upper = middle + (stdDev * stdErr);
        const lower = middle - (stdDev * stdErr);
        
        const lastClose = closes[closes.length - 1];
        let status = "In Channel";
        if(lastClose > upper) status = "Upper Line Channel";
        if(lastClose < lower) status = "Lower Line Channel";

        return { upper, middle, lower, status };
    }
// [BARU] Tambahkan fungsi yang hilang ini untuk plot PSAR
    function calculateParabolicSAR_forPlot(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return [];
        let sar = parseFloat(klines[0][3]);
        let ep = parseFloat(klines[0][2]);
        let af = step;
        let isUptrend = true;
        const sarData = [];

        for (let i = 1; i < klines.length; i++) {
            const time = klines[i][0] / 1000;
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevSar = sar;

            if (isUptrend) {
                sar = prevSar + af * (ep - prevSar);
                if (low < sar) {
                    isUptrend = false;
                    sar = ep;
                    ep = low;
                    af = step;
                } else {
                    if (high > ep) {
                        ep = high;
                        af = Math.min(max, af + step);
                    }
                }
            } else { // Downtrend
                sar = prevSar - af * (prevSar - ep);
                if (high > sar) {
                    isUptrend = true;
                    sar = ep;
                    ep = high;
                    af = step;
                } else {
                    if (low < ep) {
                        ep = low;
                        af = Math.min(max, af + step);
                    }
                }
            }
            sarData.push({ time, value: sar });
        }
        return sarData;
    }
 
    // Salin dan tempel fungsi utilitas dan kalkulasi yang dibutuhkan dari projector.html
    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) {
                obv.push(obv[i - 1] + volume);
            } else if (close < prevClose) {
                obv.push(obv[i - 1] - volume);
            } else {
                obv.push(obv[i - 1]);
            }
        }
        return obv;
    };

    const calculateVWAP = (klines, period = 20) => {
        if (!klines || klines.length < period) return 0;
        const recentKlines = klines.slice(-period);
        let totalTypicalPriceVolume = 0;
        let totalVolume = 0;
        recentKlines.forEach(k => {
            const high = parseFloat(k[2]);
            const low = parseFloat(k[3]);
            const close = parseFloat(k[4]);
            const volume = parseFloat(k[5]);
            const typicalPrice = (high + low + close) / 3;
            totalTypicalPriceVolume += typicalPrice * volume;
            totalVolume += volume;
        });
        return totalVolume > 0 ? totalTypicalPriceVolume / totalVolume : 0;
    };
    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR KORELASI (MULAI) ==
    // =======================================================
    
    /**
     * Menghitung koefisien korelasi Pearson antara dua set data.
     * @param {number[]} dataX - Array harga penutupan aset utama.
     * @param {number[]} dataY - Array harga penutupan aset pembanding (BTC).
     * @returns {number|null} - Nilai korelasi antara -1 dan 1, atau null jika data tidak valid.
     */
    function calculateCorrelation(dataX, dataY) {
        if (dataX.length !== dataY.length || dataX.length === 0) {
            return null;
        }
        const n = dataX.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += dataX[i];
            sumY += dataY[i];
            sumXY += dataX[i] * dataY[i];
            sumX2 += dataX[i] * dataX[i];
            sumY2 += dataY[i] * dataY[i];
        }

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        if (denominator === 0) {
            return 0; // Tidak ada variasi, korelasi netral
        }
        
        return numerator / denominator;
    }

    /**
     * Mengisi widget korelasi dengan data dari analysisCache.
     */
    function populateCorrelationWidget() {
        const valueEl = document.getElementById('correlation-value');
        const textEl = document.getElementById('correlation-text');
        
        const correlationData = analysisCache.correlationData;

        if (correlationData === null || correlationData === undefined) {
            valueEl.textContent = '-';
            textEl.textContent = 'Data tidak cukup untuk menghitung korelasi.';
            valueEl.className = 'text-lg font-sbold text-gray-400 dark:text-gray-500';
            return;
        }

        const value = correlationData;
        valueEl.textContent = value.toFixed(2);

        let text = 'Tidak Ada Korelasi';
        let colorClass = 'text-gray-400 dark:text-gray-500';

        if (value >= 0.7) { text = 'Korelasi Positif Kuat'; colorClass = 'positive'; } 
        else if (value >= 0.4) { text = 'Korelasi Positif Sedang'; colorClass = 'positive'; } 
        else if (value >= 0.1) { text = 'Korelasi Positif Lemah'; colorClass = 'text-yellow-400'; } 
        else if (value <= -0.7) { text = 'Korelasi Negatif Kuat'; colorClass = 'negative'; } 
        else if (value <= -0.4) { text = 'Korelasi Negatif Sedang'; colorClass = 'negative'; } 
        else if (value <= -0.1) { text = 'Korelasi Negatif Lemah'; colorClass = 'text-yellow-400'; }
        
        textEl.textContent = text;
        valueEl.className = `text-lg font-semibold ${colorClass}`;
    }

    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR KORELASI (SELESAI) ==
    // =======================================================
    // === FUNGSI RESET BARU ===
    function resetDashboard() {
        console.log("Mereset dasbor...");
        // Hentikan semua proses real-time
        WebSocketManager.resetSubscriptions();
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (fundingRateTimer) clearInterval(fundingRateTimer);
        
        // Sembunyikan dasbor & tampilkan placeholder
        dashboardContent.classList.add('hidden');
        initialPlaceholder.classList.remove('hidden');

        // Sembunyikan elemen navigasi
        document.getElementById('nav-info-container').classList.add('hidden');
        document.getElementById('nav-stats-container').classList.add('hidden');
        document.getElementById('trade-link').classList.add('hidden');
        
        // Hancurkan chart & reset state
        destroyCharts();
        analysisCache = {};
        klineCache = {}; // Kosongkan juga cache kline
        
        // Gulir kembali ke atas
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    // BAGIAN 5: EVENT LISTENER UTAMA    
    document.addEventListener('DOMContentLoaded', () => {
        fetchTopMovers();
        loadSettings();
        loadWatchlist();
        scanWatchlist();
        adjustContentPadding();
        setupToggle('toggle-market-state-btn', 'current-state-content-wrapper', 'toggle-market-state-icon', true);
        setupToggle('toggle-confluence-btn', 'confluence-content-wrapper', 'toggle-confluence-icon', false);
        setupToggle('toggle-onchain-btn', 'onchain-content-wrapper', 'toggle-onchain-icon', false);        
        setupToggle('toggle-settings-btn', 'settings-content-wrapper', 'toggle-settings-icon', false); // Mulai dalam keadaan tertutup
        window.addEventListener('resize', adjustContentPadding); 
        document.getElementById('save-settings-btn').addEventListener('click', saveSettings);
            //alert("Pengaturan disimpan. Jalankan ulang analisa untuk menerapkan perubahan.");
        
        
    themeToggleBtn.addEventListener('click', () => {
        document.documentElement.classList.toggle('dark');
        darkIcon.classList.toggle('hidden');
        lightIcon.classList.toggle('hidden');
        localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
        if (isChartsVisible) { 
            destroyCharts();
            renderAllCharts();
        }
        if (cvdChartInstance) cvdChartInstance.update();
    });

    if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
        darkIcon.classList.remove('hidden');
    } else {
        lightIcon.classList.remove('hidden');
    }

    apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
    apiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', apiKeyInput.value));

    analyzeBtn.addEventListener('click', runFullAnalysis);
    assetInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') runFullAnalysis(); });

    document.getElementById('run-comprehensive-ai-btn').addEventListener('click', runComprehensiveAIAnalysis);
    
    tradeLink.addEventListener('click', (e) => {
            e.preventDefault();
            const binanceSymbol = analysisCache.binanceSymbol;
            if (!binanceSymbol) return;
            const marketType = marketTypeSelect.value;
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            const desktopUrl = marketType === 'futures' ? `https://www.binance.com/en/futures/${binanceSymbol}` : `https://www.binance.com/en/trade/${binanceSymbol}`;
            const mobileUrl = marketType === 'futures' ? `binance://futures/trade?symbol=${binanceSymbol}` : `binance://trade?symbol=${binanceSymbol}`;
            if (isMobile) {
                window.location.href = mobileUrl;
                setTimeout(() => { window.location.href = desktopUrl; }, 1500);
            } else {
                window.open(desktopUrl, '_blank');
            }
        });

        marketTypeSelect.addEventListener('change', () => initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message)));
        initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message));
        toggleChartsBtn.addEventListener('click', () => toggleChartsVisibility());
        saveWatchlistBtn.addEventListener('click', saveWatchlist);
        scanWatchlistBtn.addEventListener('click', scanWatchlist);
        resetBtn.addEventListener('click', resetDashboard);
});
</script>
</body>
</html>