<!DOCTYPE html>
<html lang="id" class="">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASHBOARD</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>

    <style>
        /* --- PREMIUM DARK THEME --- */
        :root {
            --bg-dark: #0a0a0a;
            --card-dark: #171717;
            --border-dark: #262626;
            --text-primary: #ededed;
            --text-secondary: #a1a1aa;
            --accent-gold: #d4af37;
            /* Premium Gold */
            --accent-gold-hover: #b5952f;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-blue: #3b82f6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .card {
            background-color: var(--card-dark);
            border: 1px solid var(--border-dark);
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
        }

        /* Button Styles */
        .btn-primary {
            background-color: var(--accent-gold);
            color: #000000;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: none;
        }

        .btn-primary:hover {
            background-color: var(--accent-gold-hover);
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            background-color: #333333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background-color: #262626;
            color: var(--text-primary);
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border: 1px solid var(--border-dark);
        }

        .btn-secondary:hover {
            background-color: #404040;
        }

        /* Inputs */
        .input-primary {
            background-color: #000000;
            border: 1px solid var(--border-dark);
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: var(--text-primary);
        }

        .input-primary:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
        }

        /* Tags */
        .tag {
            padding: 0.25rem 0.625rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .tag-green {
            background-color: rgba(16, 185, 129, 0.2);
            color: #34d399;
        }

        .tag-red {
            background-color: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .tag-yellow {
            background-color: rgba(212, 175, 55, 0.2);
            color: #fcd34d;
        }

        .tag-gray {
            background-color: rgba(113, 113, 122, 0.2);
            color: #a1a1aa;
        }

        /* Text Colors */
        .text-gray-500,
        .text-gray-600 {
            color: var(--text-secondary) !important;
        }

        .text-gray-700,
        .text-gray-800,
        .text-gray-900 {
            color: var(--text-primary) !important;
        }

        hr {
            border-color: var(--border-dark);
        }

        .positive {
            color: var(--accent-green);
        }

        .negative {
            color: var(--accent-red);
        }

        /* Toggle Button */
        .toggle-btn {
            background-color: #262626;
            color: var(--text-secondary);
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--border-dark);
        }

        .toggle-btn:hover {
            background-color: #404040;
        }

        .toggle-btn.active {
            background-color: rgba(212, 175, 55, 0.15);
            color: var(--accent-gold);
            border-color: var(--accent-gold);
        }

        .projection-results-container .card {
            background-color: #1c1b1b;
            border-color: #444;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .projection-results-container h4 {
            font-size: 1rem;
            color: #008c38;
        }

        .projection-results-container p {
            color: #e0e0e0;
        }

        .btn-yellow {
            background-color: #f59e0b;
            color: #1f2937;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-yellow:hover {
            background-color: #b5a38d;
        }

        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }

        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }

        .collapsible-content>div {
            overflow: hidden;
        }

        #trade-link:hover {
            text-decoration: none;
        }

        /* === CSS BARU UNTUK KONFLUENSI CEPAT (MULAI) === */
        .status-uptrend {
            color: #34d399;
        }

        .dark .status-uptrend {
            color: #4ade80;
        }

        .status-downtrend {
            color: #ef4444;
        }

        .dark .status-downtrend {
            color: #f87171;
        }

        .status-chop {
            color: #fbbf24;
        }

        .dark .status-chop {
            color: #fcd34d;
        }

        .confluence-bar-container {
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            height: 30px;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .dark .confluence-bar-container {
            background-color: #374151;
        }

        .confluence-bar {
            height: 100%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
            color: #111827;
        }

        .confluence-bar-bullish {
            background: linear-gradient(to right, #22c55e, #86efac);
        }

        .confluence-bar-bearish {
            background: linear-gradient(to right, #ef4444, #fca5a5);
        }

        /* === CSS BARU UNTUK KONFLUENSI CEPAT (SELESAI) === */
        .dark .btn-yellow {
            color: #120f0f;
        }

        /* === TAMBAHKAN BLOK CSS DI BAWAH INI === */
        .btn-secondary {
            background-color: #ff1869;
            /* gray-500 */
            color: #070707;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .btn-secondary:hover {
            background-color: #226756;
            /* gray-600 */
        }

        .dark .btn-secondary {
            background-color: lab(42.97% -24.5 -10.46);
            /* gray-600 */
        }

        .dark .btn-secondary:hover {
            background-color: hsl(189, 95%, 25%);
            /* gray-700 */
        }

        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dashed rgba(128, 128, 128, 0.5);
        }

        #ai-narrative-content .prose h3 {
            margin-top: 1.25rem;
            /* Beri jarak di atas setiap judul (###) */
            margin-bottom: 0.5rem;
        }

        #ai-narrative-content .prose ul {
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        #ai-narrative-content .prose li {
            margin-bottom: 0.5rem;
            /* Beri jarak antar poin-poin (*) */
        }

        .vwap-mode-btn {
            background-color: #4a5568;
            /* gray-600 */
            color: #e2e8f0;
            /* gray-200 */
            border: 1px solid #718096;
            /* gray-500 */
            opacity: 0.6;
        }

        .vwap-mode-btn.active {
            background-color: #f59e0b;
            /* yellow-500 */
            color: #1f2937;
            /* gray-800 */
            opacity: 1;
            font-weight: bold;
        }

        .hybrid-bar {
            background-color: #2d3748;
            border-radius: 4px;
            height: 12px;
            width: 100px;
            position: relative;
            overflow: hidden;
            border: 1px solid #4a5568;
        }

        .pump-strength {
            background-color: #48bb78;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }

        .dump-risk {
            background-color: #f56565;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }

        /* === CSS BARU UNTUK SKOR TENSI (MULAI) === */
        .tension-bar-bg {
            background-color: #374151;
            /* dark:bg-gray-700 */
            border-radius: 9999px;
            height: 8px;
            width: 100%;
            margin: 4px auto 0;
            overflow: hidden;
            border: 1px solid #4b5563;
        }

        .tension-bar-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
            background: linear-gradient(to right, #fcd34d, #f59e0b, #ef4444);
            /* yellow to orange to red */
        }

        /* === CSS BARU UNTUK SKOR TENSI (SELESAI) === */
        /* === CSS BARU UNTUK KALKULATOR BINANCE STYLE (MULAI) === */
        .calc-binance-style .btn-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 1.5rem;
        }

        .calc-binance-style .btn-group button {
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            color: #e0e0e0;
            font-weight: 500;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .calc-binance-style .btn-group button:hover {
            background-color: #3a3f4a;
        }

        .calc-binance-style .btn-group button.active {
            background-color: #f0b90b;
            color: #14151a;
            border-color: #f0b90b;
        }

        .calc-binance-style .input-group {
            position: relative;
            margin-bottom: 1rem;
        }

        .calc-binance-style .input-field {
            width: 100%;
            padding: 12px 12px 12px 12px;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1.1em;
        }

        .calc-binance-style .input-label-top {
            font-size: 0.8em;
            color: #848e9c;
            margin-bottom: 8px;
        }

        .calc-binance-style .input-suffix {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #848e9c;
            font-weight: 600;
        }

        .calc-binance-style .margin-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #3a3f4a;
            outline: none;
            border-radius: 2px;
            margin: 1.5rem 0;
        }

        .calc-binance-style .margin-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #f0b90b;
            cursor: pointer;
            border-radius: 50%;
        }

        .calc-binance-style .slider-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #848e9c;
            padding: 0 2px;
        }

        .calc-binance-style .tpsl-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #3a3f4a;
        }

        .calc-binance-style .exec-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 1.5rem;
        }

        .calc-binance-style .exec-buttons button {
            padding: 14px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .calc-binance-style .btn-buy {
            background-color: #2ebd85;
            color: white;
        }

        .calc-binance-style .btn-sell {
            background-color: #f6465d;
            color: white;
        }

        .calc-binance-style .calc-result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 1rem;
            font-size: 0.85em;
            color: #848e9c;
        }

        .calc-binance-style .calc-result-grid span:nth-child(even) {
            text-align: right;
            font-weight: 600;
            color: #e0e0e0;
        }

        /* === CSS BARU UNTUK KALKULATOR BINANCE STYLE (SELESAI) === */
        /* === CSS UNTUK MODAL TRAILING STOP === */
        #ts-modal-content .input-field {
            width: 100%;
            padding: 12px;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1.1em;
        }

        #ts-modal-close-btn {
            font-size: 2rem;
            line-height: 1;
        }

        .mtf-clickable-box {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }

        .mtf-clickable-box:hover {
            background-color: #4b5563;
            /* Sesuaikan warna hover jika perlu */
        }

        /* Dark Mode Styles */
        .dark .positive {
            color: #4ade80;
        }

        .dark .negative {
            color: #f87171;
        }

        .dark .text-gray-800 {
            color: #E0E0E0;
        }

        .dark .text-gray-500 {
            color: #d8d2d2;
        }

        .dark .text-gray-600 {
            color: #dddddd;
        }

        .dark .text-gray-700 {
            color: #e0e0e0;
        }

        /* Chart Container Styles */
        .chart-container {
            position: relative;
            width: 100%;
        }

        #main-chart-container {
            height: 450px;
        }

        .pane-chart-container {
            height: 150px;
            margin-top: 8px;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            padding-top: 8px;
        }

        .pane-title {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            font-size: 12px;
            font-weight: bold;
            color: #dddddd;
        }

        .dark .pane-title {
            color: #d9d5d5;
        }

        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }

        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }

        .collapsible-content>div {
            overflow: hidden;
        }

        /* Blinking Green Slow */
        .blinking-green-slow {
            animation: blinking-green-slow-animation 0.5s infinite;
        }

        @keyframes blinking-green-slow-animation {

            0%,
            100% {
                color: #16a34a;
                /* Warna hijau solid */
                opacity: 1;
            }

            50% {
                color: #4ade80;
                /* Warna hijau terang saat berkedip */
                opacity: 0.7;
            }
        }

        .dark .blinking-green-slow {
            animation: blinking-green-slow-animation-dark 1s infinite;
        }

        @keyframes blinking-green-slow-animation-dark {

            0%,
            100% {
                color: #4ade80;
                opacity: 1;
            }

            50% {
                color: #16a34a;
                opacity: 0.6;
            }
        }

        /* Blinking Yellow Slow */
        .blinking-yellow-slow {
            animation: blinking-yellow-slow-animation 0.5s infinite;
        }

        @keyframes blinking-yellow-slow-animation {

            0%,
            100% {
                color: #f59e0b;
                /* Warna kuning solid (yellow-500) */
                opacity: 1;
            }

            50% {
                color: #fcd34d;
                /* Warna kuning terang (yellow-300) */
                opacity: 0.6;
            }
        }

        .dark .blinking-yellow-slow {
            animation: blinking-yellow-slow-animation-dark 1s infinite;
        }

        @keyframes blinking-yellow-slow-animation-dark {

            0%,
            100% {
                color: #fcd34d;
                opacity: 1;
            }

            50% {
                color: #f59e0b;
                opacity: 0.7;
            }
        }

        /* ... CSS yang sudah ada ... */
        .status-chop {
            color: #fbbf24;
        }

        .dark .status-chop {
            color: #fcd34d;
        }

        /* ‚ñº‚ñº‚ñº TAMBAHKAN STYLE BARU INI ‚ñº‚ñº‚ñº */
        .status-lowvolatility {
            color: #a78bfa;
        }

        /* ungu muda */
        .dark .status-lowvolatility {
            color: #c4b5fd;
        }

        /* Tambahkan/Ubah Style ini di bagian bawah <style> */
        .dark #dna-details {
            background-color: #1c1b1b;
            /* Gunakan warna gelap yang konsisten */
            border: 1px solid #333;
            color: #E0E0E0;
            /* Pastikan warna teks terang */
        }

        .dark #dna-details h4 {
            color: #F59E0B;
            /* Warna judul/header di DNA Details */
        }

        .blinking-live-bg {
            animation: blinking-live-animation 1.5s infinite;
        }

        @keyframes blinking-live-animation {

            0%,
            100% {
                background-color: #ef4444;
                color: white;
                box-shadow: 0 0 8px 2px rgba(239, 68, 68, 0.7);
            }

            50% {
                background-color: #b91c1c;
                color: #fecaca;
                box-shadow: none;
            }
        }
    </style>
</head>

<body class="antialiased">

    <div id="sticky-nav-wrapper"
        class="sticky top-0 z-50 bg-[#FDFBF7]/80 dark:bg-[#121212]/80 backdrop-blur-lg border-b border-gray-200/50 dark:border-gray-700/50 shadow-sm">
        <div class="relative flex items-center justify-between py-2 px-4 sm:px-6 lg:px-8">

            <!-- Centered Status Indicator -->
            <div id="trading-mode-status"
                class="absolute left-1/2 -translate-x-1/2 px-3 py-1 text-base rounded-full font-bold transition-all duration-300 hidden md:block">
            </div>

            <div class="flex items-center gap-3">

                <div class="flex items-center gap-3">
                    <div id="nav-info-container" class="items-center gap-2 hidden md:flex">
                        <div class="flex flex-col">
                            <div class="font-mono text-[10px]">
                                <span class="text-gray-400">VOL 24H:</span>
                                <span id="nav-volume-24h"
                                    class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                            </div>
                        </div>
                        <div class="flex flex-col text-left text-xs">
                            <span id="nav-change-24h" class="font-semibold positive">-</span>
                            <span id="nav-change-1h" class="font-semibold positive">-</span>
                        </div>
                    </div>
                </div>

                <div id="nav-stats-container" class="items-center gap-3 font-mono text-[10px] hidden md:flex">
                    <div class="flex flex-col text-left">
                        <div>
                            <span class="text-gray-400">ATH:</span>
                            <span id="nav-ath" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">ATL:</span>
                            <span id="nav-atl" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                    </div>
                </div>
            </div>
            <a href="#" id="trade-link" class="text-right no-underline hidden flex items-baseline gap-2">
                <span id="nav-timeframe" class="text-base font-semibold blinking-yellow-slow mr-2">TIMEFRAME</span>
                <span id="nav-symbol" class="text-base font-bold text-blue-500 dark:text-green-500"></span>
                <span id="nav-price" class="text-yellow-500 text-lg">-</span>
            </a>
        </div>
        <div id="candle-countdown-container" class="w-full h-1 bg-gray-200 dark:bg-gray-700 hidden">
            <div id="candle-countdown-bar" class="h-full bg-yellow-500" style="width: 0%; transition: width 1s linear;">
            </div>
        </div>
    </div>

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <header class="py-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-gray-800">DASHBOARD</h1>
                <p class="text-yellow-500 font-mono mt-1 text-sm">üèÅ</p>
            </div>
            <button id="theme-toggle"
                class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none">
                <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path>
                </svg>
                <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20">
                    <path
                        d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414 1.414zM-.707 7.072l.707-.707a1 1 0 10-1.414-1.414l-.707.707a1 1 0 001.414 1.414zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z">
                    </path>
                </svg>
            </button>
        </header>

        <main>

            <div class="space-y-6 mb-8">
                <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-3 items-start">
                    <div>
                        <input type="password" id="gemini-api-key" class="input-primary" placeholder="Your API Key...">
                        <p class="text-sm text-gray-400 mt-1">API üîë <a href="https://aistudio.google.com/app/apikey"
                                target="_blank" class="underline hover:text-blue-500">GET KEY üëÜüèª</a>.</p>
                    </div>
                </section>

                <section id="settings-card" class="card p-4">
                    <button id="toggle-settings-btn" class="w-full flex justify-between items-center text-left">
                        <h2 class="text-lg font-bold">Indicators Settings</h2>
                        <svg id="toggle-settings-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                            viewBox="0 0 20 20">
                            <path fill-rule="evenodd"
                                d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                clip-rule="evenodd"></path>
                        </svg>
                    </button>
                    <div id="settings-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Parameter Indikator
                                    </h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between">
                                            <label for="setting-rsi-period" class="text-gray-500">Periode RSI</label>
                                            <input type="number" id="setting-rsi-period"
                                                class="input-primary !w-20 text-center" value="14">
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-stoch-rsi-period" class="text-gray-500">Stoch RSI
                                                (RSI/Stoch/K/D)</label>
                                            <div class="flex gap-1">
                                                <input type="number" id="setting-stoch-rsi-period"
                                                    class="input-primary !w-12 text-center" value="14">
                                                <input type="number" id="setting-stoch-stoch-period"
                                                    class="input-primary !w-12 text-center" value="14">
                                                <input type="number" id="setting-stoch-k-smooth"
                                                    class="input-primary !w-12 text-center" value="3">
                                                <input type="number" id="setting-stoch-d-smooth"
                                                    class="input-primary !w-12 text-center" value="3">
                                            </div>
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-macd-fast" class="text-gray-500">MACD
                                                Fast/Slow/Signal</label>
                                            <div class="flex gap-1">
                                                <input type="number" id="setting-macd-fast"
                                                    class="input-primary !w-16 text-center" value="12">
                                                <input type="number" id="setting-macd-slow"
                                                    class="input-primary !w-16 text-center" value="26">
                                                <input type="number" id="setting-macd-signal"
                                                    class="input-primary !w-16 text-center" value="9">
                                            </div>
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-weight-obv-divergence" class="text-gray-500">Bobot
                                                Divergensi OBV</label>
                                            <input type="number" step="0.1" id="setting-weight-obv-divergence"
                                                class="input-primary !w-20 text-center" value="3.0">
                                        </div>
                                    </div>
                                </div>

                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Bobot Skor
                                        Konfluensi</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between">
                                            <label for="setting-weight-divergence" class="text-gray-500">Bobot
                                                Divergensi RSI</label>
                                            <input type="number" step="0.1" id="setting-weight-divergence"
                                                class="input-primary !w-20 text-center" value="2.5">
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-weight-macd" class="text-gray-500">Bobot MACD
                                                Cross</label>
                                            <input type="number" step="0.1" id="setting-weight-macd"
                                                class="input-primary !w-20 text-center" value="2.0">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                                <div class="flex items-center justify-between">
                                    <label for="preset-select"
                                        class="font-semibold text-gray-700 dark:text-gray-300">TradingStyle</label>
                                    <select id="preset-select" class="input-primary !w-auto text-sm">
                                        <option value="default">Default</option>
                                        <option value="scalper" checked>Scalper</option>
                                        <option value="dayTrader">Day Trader</option>
                                        <option value="swingTrader">Swing Trader</option>
                                    </select>
                                </div>
                            </div>
                            <div class="text-right mt-4">
                                <button id="save-settings-btn" class="btn-primary">üíæ</button>
                            </div>
                            <p id="settings-saved-msg" class="text-green-500 text-sm mt-2 text-center hidden">SAVED!</p>
                        </div>
                    </div>
                </section>

                <div id="initial-placeholder" class="text-center py-5"></div>

                <div id="loader-overlay" class="... flex-col ...">
                    <div class="loader">
                        <div class="dot"></div>
                        <p class="text-4xl font-mono text-gray-500">SPOT</p>
                        <div class="dot"></div>
                        <p class="text-4xl font-mono text-gray-500">PERPETUAL</p>
                        <div class="dot"></div>
                    </div>
                    <p id="loader-text" class="text-white font-semibold mt-4 text-center blinking-text-animation">Let's
                        Go........</p>
                </div>

                <section id="top-movers-section" class="card p-6">
                    <button id="toggle-top-movers-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-2xl font-semibold blinking-green-slow">MARKET SCANNER ü¶ñ</h2>
                        <svg id="toggle-top-movers-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                            viewBox="0 0 20 20">
                            <path fill-rule="evenodd"
                                d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                clip-rule="evenodd"></path>
                        </svg>
                    </button>

                    <div id="top-movers-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div
                                class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2">
                                <div id="top-movers-controls"
                                    class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                                    <div class="flex gap-2 items-center" id="top-movers-tf-options">
                                        <button data-timeframe="4h"
                                            class="top-movers-tf-btn toggle-btn text-xs !p-1.5 active">4H</button>
                                        <button data-timeframe="1d"
                                            class="top-movers-tf-btn toggle-btn text-xs !p-1.5">1D</button>
                                        <button data-timeframe="1w"
                                            class="top-movers-tf-btn toggle-btn text-xs !p-1.5">1W</button>
                                        <button data-timeframe="1M"
                                            class="top-movers-tf-btn toggle-btn text-xs !p-1.5">30D</button>
                                    </div>
                                    <div class="flex gap-2 items-center">
                                        <select id="refresh-interval-select" class="input-primary text-xs !w-auto !p-1">
                                            <option value="5000">5s</option>
                                            <option value="10000">10s</option>
                                            <option value="30000">30s</option>
                                            <option value="60000">60s</option>
                                            <option value="120000" selected>120s</option>
                                        </select>
                                        <span id="refresh-countdown"
                                            class="text-xs text-gray-500 w-24 text-center"></span>
                                    </div>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 gap-3">
                                <div>
                                    <div class="flex gap-4 mb-2 border-b border-gray-700 pb-1">
                                        <button id="tab-pump-hunter"
                                            class="text-sm font-semibold text-gray-400 hover:text-white border-b-2 border-transparent transition-colors"
                                            onclick="switchTab('pump-hunter')">Pump
                                            Hunter üöÄ</button>
                                        <button id="tab-dip-hunter"
                                            class="text-sm font-semibold text-gray-400 hover:text-white border-b-2 border-transparent transition-colors"
                                            onclick="switchTab('dip-hunter')">Dip
                                            Hunter ü¶ñ</button>
                                    </div>
                                    <div id="pump-hunter-list"
                                        class="space-y-2 max-h-[600px] overflow-y-auto custom-scrollbar hidden">
                                        <div class="text-center text-gray-500 text-xs py-4">Click tab to scan...</div>
                                    </div>
                                    <div id="dip-hunter-list"
                                        class="space-y-2 max-h-[600px] overflow-y-auto custom-scrollbar hidden">
                                        <div class="text-center text-gray-500 text-xs py-4">Click tab to scan...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-3 items-start">
                    <div>
                        <div class="flex flex-col sm:flex-row gap-3">
                            <input type="text" id="asset-input" list="asset-list"
                                class="input-primary text-sm flex-grow uppercase"
                                placeholder="Ketik Simbol Aset (cth: BTCUSDT)" value="BTCUSDT">
                            <datalist id="asset-list"></datalist>
                            <select id="market-type-select" class="input-primary text-sm !w-auto">
                                <option value="spot">Spot</option>
                                <option value="futures" selected>Perp</option>
                            </select>
                            <select id="timeframe-select" class="input-primary text-sm !w-auto">
                                <option value="1m">1m</option>
                                <option value="3m">3m</option>
                                <option value="5m" selected>5m</option>
                                <option value="15m">15m</option>
                                <option value="30m">30m</option>
                                <option value="1h">1h</option>
                                <option value="2h">2h</option>
                                <option value="4h">4h</option>
                                <option value="1d">1d</option>
                                <option value="1w">W</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-span-12 lg:col-span-4 xl:col-span-3">
                        <div class="card p-4 h-full flex flex-col">
                            <h3 class="text-lg font-semibold mb-3 border-b border-gray-200 pb-2">‚öôÔ∏è DNA Juara (Import &
                                Detail)</h3>

                            <label for="dna-file-input" class="block text-sm font-medium text-gray-700 mb-2">Import File
                                DNA (.json)</label>
                            <input type="file" id="dna-file-input" accept=".json" class="w-full text-sm text-gray-700
                            file:mr-4 file:py-2 file:px-4
                            file:rounded-full file:border-0
                            file:text-sm file:font-semibold
                            file:bg-[#F2D7B4] file:text-[#342d27]
                            hover:file:bg-[#EAE5E0] cursor-pointer
                        ">

                            <p id="dna-status" class="mt-2 text-sm text-gray-500">Status: Belum ada DNA yang dimuat.</p>

                            <div id="dna-details" class="mt-4 p-3 bg-[#F7F5F3] rounded-lg flex-grow">
                                <h4 class="font-bold text-gray-900 mb-2 text-base">Metadata DNA:</h4>
                                <p class="text-xs">Tipe: <span id="dna-type-display" class="font-medium">-</span></p>
                                <p class="text-xs">Aset: <span id="dna-asset-display" class="font-medium">-</span></p>
                                <p class="text-xs">Timeframe: <span id="dna-tf-display" class="font-medium">-</span></p>
                                <hr class="my-2 border-gray-200">
                                <h4 class="font-bold text-gray-900 mb-2 text-sm">QC Validation:</h4>
                                <p class="text-xs">PNL Rata-rata: <span id="dna-pnl-avg-display"
                                        class="font-medium">-</span></p>
                                <p class="text-xs">Prob. Loss: <span id="dna-loss-prob-display"
                                        class="font-medium">-</span></p>
                                <p class="text-xs">Threshold Bias: <span id="dna-threshold-display"
                                        class="font-medium">-</span></p>
                            </div>
                        </div>
                    </div>
                    <div class="md:col-span-2 flex gap-3">
                        <button id="analyze-asset-btn" class="btn-primary w-full font-bold text-xl">
                            <span id="button-text">GET DATA</span>
                            <div id="button-loader" class="loader hidden">
                                <div class="dot"></div>
                            </div>
                        </button>
                        <button id="stop-analysis-btn" class="btn-secondary w-full font-bold text-xl ml-2 hidden">
                            STOP
                        </button>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                    </button>
                    <p id="asset-error" class="text-red-600 text-sm mt-2 text-center hidden"></p>
                    <button id="reset-btn" class="btn-secondary !w-auto">RESET</button>
            </div>
            </section>
    </div>

    <div id="dashboard-content" class="hidden">
        <div class="space-y-8">
            <div class="flex flex-col gap-3">
                <section id="charts-wrapper" class="card p-6" style="display: none;">
                    <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                    <div class="chart-container relative">
                        <div class="pane-title">Price</div>
                        <div id="main-chart-container"></div>
                    </div>
                    <div class="chart-container pane-chart-container relative">
                        <div class="pane-title">Volume</div>
                        <div id="volume-chart-container"></div>
                    </div>
                    <div class="chart-container pane-chart-container relative">
                        <div class="pane-title">RSI (14)</div>
                        <div id="rsi-chart-container"></div>
                    </div>
                    <div class="chart-container pane-chart-container relative">
                        <div class="pane-title">Stochastic RSI</div>
                        <div id="stoch-chart-container"></div>
                    </div>
                    <div class="chart-container pane-chart-container relative">
                        <div class="pane-title">MACD</div>
                        <div id="macd-chart-container"></div>
                    </div>
                    <div class="chart-container pane-chart-container relative">
                        <div class="pane-title">Rate of Change (ROC)</div>
                        <div id="roc-chart-container"></div>
                    </div>
                </section>
                <button id="toggle-charts-btn" class="btn-yellow w-full">SHOW CHART</button>

                <section id="onchain-card" class="card p-6">
                    <button id="toggle-onchain-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">On-Chain</h2>
                        <svg id="toggle-onchain-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                            viewBox="0 0 20 20">
                            <path fill-rule="evenodd"
                                d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                clip-rule="evenodd"></path>
                        </svg>
                    </button>
                    <div id="onchain-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div id="specific-token-analysis" class="mb-4">
                                <h3 id="specific-token-title"
                                    class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">
                                    Analisis Token Spesifik</h3>
                                <div id="specific-token-content" class="text-sm space-y-1">
                                    <p class="text-xs text-gray-500 text-center">SEARCHING...</p>
                                </div>
                            </div>
                            <div>
                                <h3
                                    class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">
                                    Pool Trending Teratas</h3>
                                <div id="trending-pools-content" class="text-sm space-y-2">
                                    <div class="text-center py-2">
                                        <div class="loader mx-auto h-6 w-6"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>



                <section id="ai-analysis-section" class="card p-6 relative">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold">AI ANALYZER</h2>
                    </div>

                    <div id="ai-content-container" class="hidden space-y-6">
                        <div id="ai-narrative-content"
                            class="prose prose-sm dark:prose-invert max-w-none text-gray-600 space-y-4"></div>
                        <div>
                            <h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">üîÆ Proyeksi Harga
                            </h3>
                            <div id="projection-results-container" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
                        </div>
                        <div>
                            <h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">‚ôüÔ∏è Saran Strategis
                            </h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                <div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg">
                                    <h4 class="font-semibold text-green-500 mb-2">Untuk Calon Buyer</h4>
                                    <p id="saran-buyer" class="text-lg font-bold"></p>
                                    <p id="alasan-buyer" class="text-sm text-gray-500 mt-1"></p>
                                </div>
                                <div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg">
                                    <h4 class="font-semibold text-blue-500 mb-2">Untuk Holder</h4>
                                    <p id="saran-holder" class="text-lg font-bold"></p>
                                    <p id="alasan-holder" class="text-sm text-gray-500 mt-1"></p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <button id="toggle-ai-btn" class="btn-primary w-full mb-4">
                    <span>ASK AI</span>
                    <div class="loader w-5 h-5 hidden">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </button>

                <section id="sentiment-display-container" class="card p-6">
                    <button id="toggle-sentiment-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">Bitcoin Sentiment</h2>
                        <svg id="toggle-sentiment-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                            viewBox="0 0 20 20">
                            <path fill-rule="evenodd"
                                d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                clip-rule="evenodd"></path>
                        </svg>
                    </button>
                    <div id="sentiment-content-wrapper" class="collapsible-content">
                        <p class="text-center text-gray-500"></p>
                    </div>
                </section>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-3">
                <div class="flex flex-col gap-3">
                    <section id="current-state-section" class="card p-6">
                        <button id="toggle-market-state-btn"
                            class="w-full flex justify-between items-center text-left mb-4">
                            <h2 id="current-state-title" class="text-xl font-semibold">Current Market</h2>
                            <svg id="toggle-market-state-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                                viewBox="0 0 20 20">
                                <path fill-rule="evenodd"
                                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                    clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="current-state-content-wrapper" class="collapsible-content expanded">
                            <div class="space-y-6">
                                <h2 class="text-lg font-semibold text-center">Calculated Timeframe <span
                                        id="quick-confluence-timeframe"></span></h2>
                                <div class="flex items-center gap-3 my-2">
                                    <div id="quick-finalBearishScore"
                                        class="text-2xl font-bold status-downtrend text-right w-1/5">üêª 0%</div>
                                    <div class="confluence-bar-container w-3/5">
                                        <div id="quick-confluenceBarBearish"
                                            class="confluence-bar confluence-bar-bearish" style="width: 50%;"></div>
                                        <div id="quick-confluenceBarBullish"
                                            class="confluence-bar confluence-bar-bullish" style="width: 50%;"></div>
                                    </div>
                                    <div id="quick-finalBullishScore"
                                        class="text-2xl font-bold status-uptrend text-left w-1/5">0% üêÇ</div>
                                </div>
                                <div id="verdict-and-regime-container" class="text-center space-y-3 mt-3">
                                </div>
                                <div id="confluence-breakdown-container"
                                    class="mt-4 text-xs text-center space-y-2 hidden">
                                    <div class="grid grid-cols-2 gap-2 text-left">
                                        <div id="top-bullish-contributors"></div>
                                        <div id="top-bearish-contributors"></div>
                                    </div>
                                </div>
                                <div class="space-y-2 pt-6 border-t border-gray-200 dark:border-gray-700">
                                    <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                        <div class="h-16 flex items-center justify-center my-2"></div>
                                        <p id="candlestick-pattern" class="font-semibold">NONE</p>
                                    </div>
                                    <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                        <p id="chart-pattern-label" class="text-xs text-gray-500">Chart Pattern</p>
                                        <p id="chart-pattern" class="font-semibold">NONE</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="confluence-details-section" class="card p-6">
                        <button id="toggle-confluence-btn"
                            class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-lg font-bold">Timeframe [ NOW ] -<span id="confluence-timeframe-display">
                                    5m</span></h2>
                            <svg id="toggle-confluence-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                                viewBox="0 0 20 20">
                                <path fill-rule="evenodd"
                                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                    clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="confluence-content-wrapper" class="collapsible-content">
                            <div>
                                <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                    <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">KEY LEVEL</h3>
                                    <div class="space-y-1 text-sm">
                                        <div class="flex justify-between">
                                            <span class="text-red-500">VAH</span>
                                            <span id="vpvr-vah" class="font-mono">-</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="font-bold text-blue-500"
                                                data-tooltip="Point of Control (POC)|...">Point of Control (POC)</span>
                                            <span id="vpvr-poc" class="font-mono font-bold">-</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-green-500">VAL</span>
                                            <span id="vpvr-val" class="font-mono">-</span>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500">24H</span>
                                            <span id="range-24h" class="font-mono font-semibold">-</span>
                                        </div>

                                        <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500" data-tooltip="Daily Pivot (P)|...">Daily
                                                    Pivot (P)</span>
                                                <span id="pivot-p"
                                                    class="font-mono font-semibold text-blue-500">-</span>
                                            </div>
                                            <div id="pivot-levels-container"
                                                class="text-xs text-gray-400 space-y-1 mt-1 pl-4 hidden">
                                                <div class="flex justify-between">
                                                    <span>R1 / S1</span>
                                                    <span id="pivot-r1s1" class="font-mono">-</span>
                                                </div>
                                                <div class="flex justify-between">
                                                    <span>R2 / S2</span>
                                                    <span id="pivot-r2s2" class="font-mono">-</span>
                                                </div>
                                                <div class="flex justify-between">
                                                    <span>R3 / S3</span>
                                                    <span id="pivot-r3s3" class="font-mono">-</span>
                                                </div>
                                            </div>
                                        </div>

                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500"
                                                data-tooltip="VWAP (Volume-Weighted Average Price)|...">VWAP</span>
                                            <div class="flex items-center gap-2">
                                                <div id="vwap-mode-buttons" class="flex text-xs">
                                                    <button data-mode="rolling"
                                                        class="vwap-mode-btn active px-2 py-0.5 rounded-l-md"
                                                        data-tooltip="Rolling VWAP|...">R</button>
                                                    <button data-mode="session" class="vwap-mode-btn px-2 py-0.5"
                                                        data-tooltip="Session VWAP|...">S</button>
                                                    <button data-mode="anchored"
                                                        class="vwap-mode-btn px-2 py-0.5 rounded-r-md"
                                                        data-tooltip="Anchored VWAP|...">A</button>
                                                </div>
                                                <span id="vwap-20d" class="font-mono text-yellow-500">-</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                    <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">MOMENTUM</h3>
                                    <div class="space-y-1 text-sm">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500">RSI (14)</span>
                                            <div>
                                                <span id="rsi-value" class="font-mono text-xs">-</span>
                                                <span id="rsi-status" class="tag tag-gray"></span>
                                            </div>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500">Stoch RSI (%K/%D)</span>
                                            <div>
                                                <span id="stoch-value" class="font-mono text-xs">-</span>
                                                <span id="stoch-status" class="tag tag-gray"></span>
                                            </div>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500">MACD</span>
                                            <div>
                                                <span id="macd-status" class="font-mono font-semibold">-</span>
                                                <span id="macd-hist" class="font-mono text-xs ml-1">-</span>
                                            </div>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-blue-500" data-tooltip="Bollinger Squeeze|...">Bollinger
                                                Squeeze</span>
                                            <span id="bollinger-squeeze-status" class="font-mono">-</span>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-yellow-500">BB Reversal</span>
                                            <span id="bollinger-rejection-status" class="font-mono">-</span>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500">BB Walk the Bands</span>
                                            <span id="bollinger-walk-status" class="font-mono">-</span>
                                        </div>
                                        <div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">Bollinger Bands</span>
                                                <span id="bollinger-bands-status" class="font-mono">-</span>
                                            </div>
                                            <div class="text-right text-xs text-gray-400 font-mono">
                                                <span id="bb-upper-value">-</span> / <span id="bb-middle-value">-</span>
                                                / <span id="bb-lower-value">-</span>
                                            </div>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500" data-tooltip="RSI Divergence|...">RSI
                                                Divergence</span>
                                            <span id="rsi-divergence" class="font-mono font-semibold text-xs">-</span>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500"
                                                data-tooltip="Linear Regression Channel|...">LinReg Channel</span>
                                            <span id="linreg-status" class="font-mono">-</span>
                                        </div>
                                        <div
                                            class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                            <span class="text-gray-500"
                                                data-tooltip="On-Balance Volume|Indikator momentum yang menggunakan volume untuk memprediksi perubahan harga.">OBV</span>
                                            <span id="obv-value" class="font-mono font-semibold">-</span>
                                        </div>
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500" data-tooltip="Ichimoku Bias|...">Ichimoku
                                                Bias</span>
                                            <span id="ichimoku-bias" class="font-mono font-semibold">-</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                    <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Asset Info</h3>
                                    <div class="hidden">
                                        <input type="text" id="correlation-asset-input" class="input-primary"
                                            value="BTCUSDT">
                                    </div>
                                    <div class="space-y-1 text-sm">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500">BTC Correlation (30D)</span>
                                            <div>
                                                <span id="correlation-value"
                                                    class="font-mono font-semibold text-gray-300">-</span>
                                                <span id="correlation-text"
                                                    class="text-xs text-gray-500 ml-1">...</span>
                                            </div>
                                        </div>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">BTC Dominance</span>
                                                <span id="btc-dominance" class="font-mono">-</span>
                                            </div>
                                            <div
                                                class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                <span class="text-gray-500">Market Cap</span>
                                                <span id="market-cap" class="font-mono">-</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="order-book-cvd-section" class="card p-6">
                        <button id="toggle-order-book-cvd-btn"
                            class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-sm font-bold linking-text-animation">Order Book & CVD</h2>
                            <svg id="toggle-order-book-cvd-icon" class="w-6 h-6 transition-transform"
                                fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd"
                                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                    clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="order-book-cvd-content-wrapper" class="collapsible-content">
                            <div>
                                <hr class="border-gray-200 dark:border-gray-700/50 my-4">
                                <div>
                                    <h3 class="text-xl font-bold mb-4 text-center">Order Book</h3>
                                    <div id="full-order-book-container" class="space-y-2 text-sm">
                                        <p class="text-center text-gray-500">FETCHING DATA...</p>
                                    </div>
                                    <div
                                        class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                        <span class="text-gray-500">Order Book Bias</span>
                                        <span id="order-book-bias" class="font-mono">-</span>
                                    </div>
                                </div>
                                <hr class="border-gray-200 dark:border-gray-700/50 my-4">
                                <div>
                                    <h3 class="text-lg font-bold mb-4 text-center">CVD Order Flow</h3>
                                    <div class="chart-container" style="height: 150px;">
                                        <canvas id="cvdChart"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>

                <div class="flex flex-col gap-3">
                    <section id="scalping-setup-section" class="card p-6">
                        <button id="toggle-scalping-btn"
                            class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-xl font-bold">Scalping <span id="scalping-timeframe-display"></span></h2>
                            <svg id="toggle-scalping-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                                viewBox="0 0 20 20">
                                <path fill-rule="evenodd"
                                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                    clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="scalping-content-wrapper" class="collapsible-content expanded">
                            <div>
                                <section id="current-regime-status-container" class="card p-4">

                                    <div class="space-y-1 text-sm">
                                        <p class="flex justify-between">
                                            <span>Status AI (Sensor):</span>
                                            <span id="ai-status" class="font-medium text-gray-400">MEMUAT...</span>
                                        </p>
                                        <p class="flex justify-between !mt-2 border-t border-gray-700 pt-2">
                                            <span class="font-bold text-base">Market Regime:</span>
                                            <span id="active-regime-display"
                                                class="font-bold text-base text-gray-500">MENUNGGU DATA...</span>
                                        </p>
                                    </div>
                                </section>
                                <div id="hybrid-breakdown-module" class="mb-4">
                                    <div class="flex items-center justify-between text-xs text-gray-400">
                                        <span>Bullish Momentum</span>
                                        <span>Bearish Pressure Score</span>
                                    </div>
                                    <div class="confluence-bar-container w-full h-8 mt-1">
                                        <div id="main-pump-bar" class="confluence-bar confluence-bar-bullish"
                                            style="width: 0%;"></div>
                                        <div id="main-dump-bar" class="confluence-bar confluence-bar-bearish"
                                            style="width: 0%;"></div>
                                    </div>
                                    <div class="flex items-center justify-between text-sm mt-1">
                                        <span id="main-pump-score" class="positive font-bold">0%</span>
                                        <span id="main-dump-score" class="negative font-bold">0/10</span>
                                    </div>
                                    <p class="text-center text-[10px] text-gray-500 mt-1 blinking-yellow-slow">‚ö† PLEASE
                                        CHECK YOU ARE IN THE RIGHT TIMEFRAME ‚ö†Ô∏è</p>
                                    <details>
                                        <summary
                                            class="cursor-pointer text-xs text-gray-400 hover:text-white transition-colors flex justify-between items-center border-b border-gray-500">
                                            <span>Bearish Pressure Score Trigger‚ñæ</span>
                                            <select id="dump-trigger-timeframe-select"
                                                class="input-primary !text-xs !w-auto !p-1 bg-gray-900/50 border-gray-600"
                                                onclick="event.stopPropagation()">
                                                <option value="1m">1m</option>
                                                <option value="3m">3m</option>
                                                <option value="5m" selected="">5m</option>
                                                <option value="15m">15m</option>
                                                <option value="30m">30m</option>
                                                <option value="1h">1h</option>
                                            </select>
                                        </summary>
                                        <div id="trigger-breakdown-list"
                                            class="mt-2 pt-2 border-t border-gray-700/50 text-sm space-y-1">
                                            <p class="text-xs text-center text-gray-600">Pilih timeframe...</p>
                                        </div>
                                    </details>
                                </div>
                                <div class="pt-2 mt-2 border-t border-dashed border-gray-700/50">
                                    <div id="scalping-resistance-info"
                                        class="flex justify-between items-center text-sm">
                                        <span class="text-gray-500">Nearest Resistance</span>
                                        <span class="font-mono font-semibold text-red-400">-</span>
                                    </div>
                                    <div id="scalping-wall-container" class="text-center text-xs pt-2 space-y-1">
                                        <div id="buy-wall-display" class="text-green-500 font-semibold">‚Äî No Buy Wall
                                            Detected ‚Äî</div>
                                        <div id="sell-wall-display" class="text-red-500 font-semibold">‚Äî No Sell Wall
                                            Detected ‚Äî</div>
                                    </div>
                                </div>
                                <div id="tf-alignment-summary"
                                    class="pt-2 mt-2 border-t border-dashed border-gray-600/50"></div>
                                <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                    <div class="flex justify-between items-center text-xs">
                                        <span class="text-gray-500">EMA 21/50</span>
                                        <span id="ma-status" class="font-mono font-semibold">-</span>
                                    </div>
                                    <div class="text-right text-xs text-gray-400 font-mono">
                                        <span id="ema-21-value">-</span> / <span id="ema-50-value">-</span>
                                    </div>
                                </div>
                                <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50 text-sm">
                                    <details>
                                        <summary class="cursor-pointer text-gray-500 text-sm mb-2 list-none underline">‚Üï
                                            More Indicator</summary>
                                        <div class="mt-2">
                                            <div class="space-y-1">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500">Parabolic SAR</span>
                                                    <span id="psar-status" class="font-mono text-sm">-</span>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500"
                                                        data-tooltip="Rate of Change (ROC)|...">Rate of Change
                                                        (ROC)</span>
                                                    <span id="roc-status" class="font-mono text-sm">-</span>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500 text-sm"
                                                        data-tooltip="Kekuatan Tren (ADX)|...">ADX 14</span>
                                                    <div>
                                                        <span id="adx-value"
                                                            class="font-mono font-semibold text-sm">-</span>
                                                        <span class="text-xs positive" id="plus-di-value"></span> /
                                                        <span class="text-xs negative" id="minus-di-value"></span>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="mt-2 pt-2 border-t border-dashed border-gray-700/20 space-y-1">
                                                <div class="flex justify-between items-start">
                                                    <div>
                                                        <span class="text-gray-500 text-sm">A T R</span>
                                                        <span id="atr-status-badge" class="tag tag-gray ml-2">...</span>
                                                    </div>
                                                    <div class="text-right">
                                                        <p id="atr-percent-value"
                                                            class="font-mono text-blue-500 font-semibold">-</p>
                                                        <p id="atr-absolute-value"
                                                            class="font-mono text-xs text-gray-400">-</p>
                                                    </div>
                                                </div>
                                                <div id="ls-umum-container" class="flex justify-between items-center">
                                                    <span class="text-gray-500">L/S Ratio</span>
                                                    <span id="ls-ratio-umum" class="font-mono">-</span>
                                                </div>
                                                <div id="ls-top-container" class="flex justify-between items-center">
                                                    <span class="text-gray-500">L/S Ratio (Top)</span>
                                                    <span id="ls-ratio-top" class="font-mono">-</span>
                                                </div>
                                                <div id="futures-data-container" class="hidden space-y-1">
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500">Funding Interval</span>
                                                        <span id="funding-rate-interval" class="font-mono">-</span>
                                                    </div>
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-yellow-500">Funding Rate</span>
                                                        <span id="funding-rate"
                                                            class="font-mono text-yellow-500">-</span>
                                                    </div>
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500">Open Interest</span>
                                                        <span id="open-interest">-</span>
                                                    </div>
                                                    <div id="fib-targets-container"
                                                        class="mt-4 pt-4 border-t border-dashed border-gray-700">
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </details>
                                </div>
                                <div id="scalping-setup-content"
                                    class="text-center mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                    <p class="text-sm text-gray-500">FETCHING DATA...</p>
                                </div>

                            </div>
                        </div>

                    </section>

                    <section id="trailing-stop-calc-section" class="card p-6">
                        <button id="toggle-ts-calc-btn" class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-xl font-bold">Kalkulator Eksekusi</h2>
                            <svg id="toggle-ts-calc-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                                viewBox="0 0 20 20">
                                <path fill-rule="evenodd"
                                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                    clip-rule="evenodd"></path>
                            </svg>
                        </button>

                        <div id="ts-calc-content-wrapper" class="collapsible-content">
                            <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 calc-binance-style">
                                <button id="autofill-ts-btn" class="btn-primary w-full mb-4">
                                    ‚ö°Ô∏è Auto-fill dari Setup Scalping
                                </button>
                                <div class="btn-group">
                                    <button id="ts-mode-cross" class="active">Cross</button>
                                    <input type="number" id="ts-leverage" value="20" class="input-field text-center"
                                        style="padding-right: 2.5rem;">
                                    <button id="ts-mode-isolated" class="">Isolated</button>
                                    <button id="ts-trailing-stop-options">‚öôÔ∏è TS</button>
                                </div>

                                <div class="grid grid-cols-2 gap-3">
                                    <div class="input-group">
                                        <label for="ts-wallet-balance" class="input-label-top">Available Balance
                                            ($)</label>
                                        <input type="number" id="ts-wallet-balance" class="input-field" value="1000">
                                    </div>
                                    <div class="input-group">
                                        <label for="ts-cost" class="input-label-top">Cost / Modal ($)</label>
                                        <input type="number" id="ts-cost" class="input-field" placeholder="0.00">
                                    </div>
                                </div>

                                <div>
                                    <input type="range" min="0" max="100" value="0" class="margin-slider"
                                        id="ts-margin-slider">
                                    <div class="slider-ticks">
                                        <span>0%</span>
                                        <span>25%</span>
                                        <span>50%</span>
                                        <span>75%</span>
                                        <span>100%</span>
                                    </div>
                                </div>

                                <div class="input-group mt-6">
                                    <label for="ts-market-price" class="input-label-top">Harga Pasar Saat Ini
                                        ($)</label>
                                    <input type="number" id="ts-market-price" class="input-field"
                                        placeholder="Harga market saat ini...">
                                </div>

                                <div class="tpsl-section">
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" id="ts-tpsl-toggle"
                                            class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 text-yellow-500">
                                        <label for="ts-tpsl-toggle" class="text-sm">TP/SL</label>
                                    </div>
                                    <div id="ts-tpsl-inputs" class="hidden mt-4 space-y-4">
                                        <div class="input-group">
                                            <label for="ts-take-profit" class="input-label-top">Take Profit</label>
                                            <input type="number" id="ts-take-profit" class="input-field"
                                                placeholder="Mark">
                                        </div>
                                        <div class="input-group">
                                            <label for="ts-stop-loss" class="input-label-top">Stop Loss</label>
                                            <input type="number" id="ts-stop-loss" class="input-field"
                                                placeholder="Mark">
                                        </div>
                                    </div>
                                </div>

                                <div class="exec-buttons">
                                    <button class="btn-buy" id="ts-buy-long-btn">Buy/Long</button>
                                    <button class="btn-sell" id="ts-sell-short-btn">Sell/Short</button>
                                </div>

                                <div class="calc-result-grid">
                                    <span>Cost</span>
                                    <span id="ts-result-cost">--</span>
                                    <span>Max</span>
                                    <span id="ts-result-max">--</span>
                                    <span>Position Size</span>
                                    <span id="ts-result-position-size">--</span>
                                    <span>Liq. Price</span>
                                    <span id="ts-result-liq-price">--</span>
                                    <span class="pt-2 border-t border-dashed border-gray-700">Status TS</span>
                                    <span id="ts-result-status"
                                        class="pt-2 border-t border-dashed border-gray-700">--</span>
                                    <span>Harga Stop Loss TS</span>
                                    <span id="ts-result-sl-price">--</span>
                                    <span>Potensi ROE</span>
                                    <span id="ts-result-roe">--</span>
                                </div>
                            </div>
                        </div>

                        <div id="ts-modal-container"
                            class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
                            <div id="ts-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md">
                                <div class="flex justify-between items-center mb-4">
                                    <h3 class="text-lg font-bold">Pengaturan Trailing Stop</h3>
                                    <button id="ts-modal-close-btn"
                                        class="text-gray-400 hover:text-white">&times;</button>
                                </div>
                                <div class="space-y-4">
                                    <div class="form-group">
                                        <label for="ts-modal-callback-rate">Callback Rate (%)</label>
                                        <input type="number" id="ts-modal-callback-rate" class="input-field"
                                            placeholder="cth: 0.5">
                                    </div>
                                    <div class="form-group">
                                        <label for="ts-modal-activation-price">Harga Aktivasi ($)</label>
                                        <input type="number" id="ts-modal-activation-price" class="input-field"
                                            placeholder="cth: 65000">
                                    </div>
                                </div>
                                <div class="mt-6 text-right">
                                    <button id="ts-modal-save-btn" class="btn-primary">Simpan Pengaturan</button>
                                </div>
                            </div>
                        </div>
                    </section>

                    <div class="flex justify-center space-x-2 mb-4">
                        <button id="mode-simulation-btn" class="btn-primary !py-2 !px-4">Simulation Mode</button>
                        <button id="mode-live-btn" class="btn-secondary !py-2 !px-4">Live Trade Mode</button>
                    </div>
                    <section id="paper-trading-section" class="card p-6">
                        <button id="toggle-paper-trading-btn"
                            class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-xl font-bold">Trading Simulation</h2>
                            <svg id="toggle-paper-trading-icon" class="w-6 h-6 transition-transform" fill="currentColor"
                                viewBox="0 0 20 20">
                                <path fill-rule="evenodd"
                                    d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                                    clip-rule="evenodd"></path>
                            </svg>
                        </button>

                        <div id="paper-trading-content-wrapper" class="collapsible-content">
                            <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-center">
                                    <div>
                                        <p class="text-xs text-gray-500">Equity</p>
                                        <p id="sim-equity" class="font-mono font-bold text-lg text-blue-400">$1,000.00
                                        </p>
                                    </div>
                                    <div>
                                        <p class="text-xs text-gray-500">Unrealized PNL</p>
                                        <p id="sim-unrealized-pnl" class="font-mono font-bold text-lg text-gray-400">
                                            $0.00</p>
                                    </div>
                                    <div>
                                        <p class="text-xs text-gray-500">Available Margin</p>
                                        <p id="sim-available-margin" class="font-mono font-bold text-lg text-gray-400">
                                            $1,000.00</p>
                                    </div>
                                    <div class="flex items-center justify-center">
                                        <button id="sim-reset-account-btn"
                                            class="btn-secondary !text-xs !py-1 !px-2">Reset Account</button>
                                    </div>
                                    <div class="flex items-center justify-center">
                                        <button id="toggle-auto-trade-btn"
                                            class="btn-primary !text-xs !py-1 !px-2 !bg-gray-600 hover:!bg-gray-500">
                                            <span id="auto-trade-status-text">‚ñ∂Ô∏è ENABLE AUTO-TRADE</span>
                                        </button>
                                    </div>
                                </div>

                                <div id="sim-active-position-container" class="hidden">
                                    <h3 class="font-semibold text-yellow-400 mb-2">Active Position</h3>
                                    <div class="p-3 rounded-md bg-gray-800/50 text-sm space-y-2">
                                        <div class="flex justify-between items-center">
                                            <span id="sim-position-header" class="font-bold text-lg">LONG / 20x</span>
                                            <button id="sim-close-position-btn"
                                                class="btn-primary !bg-red-600 !text-xs !py-1 !px-3">Close
                                                Position</button>
                                        </div>
                                        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                            <div>
                                                <span class="text-gray-400">Size:</span>
                                                <span id="sim-position-size" class="font-mono"></span>
                                            </div>
                                            <div>
                                                <span class="text-gray-400">Entry:</span>
                                                <span id="sim-position-entry" class="font-mono"></span>
                                            </div>
                                            <div>
                                                <span class="text-gray-400">Mark:</span>
                                                <span id="sim-position-mark" class="font-mono"></span>
                                            </div>
                                            <div>
                                                <span class="text-gray-400">Liq:</span>
                                                <span id="sim-position-liq" class="font-mono"></span>
                                            </div>
                                        </div>
                                        <div class="pt-2 border-t border-dashed border-gray-700">
                                            <span class="text-gray-400">PNL (ROE %):</span>
                                            <span id="sim-position-pnl" class="font-mono font-bold text-lg ml-2"></span>
                                        </div>
                                    </div>
                                </div>

                                <div>
                                    <div class="flex justify-between items-center mb-2">
                                        <h3 class="font-semibold text-gray-400">Trade History</h3>
                                        <div class="flex gap-2">
                                            <button id="sim-export-btn"
                                                class="btn-secondary !text-[10px] !py-0.5 !px-2">Export CSV</button>
                                            <button id="sim-import-btn"
                                                class="btn-secondary !text-[10px] !py-0.5 !px-2">Import CSV</button>
                                            <input type="file" id="sim-import-input" class="hidden" accept=".csv">
                                        </div>
                                    </div>
                                    <div id="sim-trade-history-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                                        <p class="text-center text-gray-600">No trade history yet.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </div>
    </div>
    </main>

    <script>
        // ===================================================================
        let regimeSensorModel = null;
        let userSettings = {
            active: {
                weights: {},
                indicatorParams: {}
            },
            presets: {
                'default': {
                    weights: {
                        ma: 2,
                        pivot: 2,
                        vwap: 2,
                        ichimoku: 3,
                        rsi: 1.5,
                        stoch: 1,
                        macd: 2,
                        candlePattern: 1.5,
                        psar: 1,
                        linreg: 1,
                        roc: 1,
                        bollingerBands: 1,
                        rsiDivergence: 2.5,
                        obvDivergence: 3.0,
                        openInterest: 1,
                        fundingRate: 1,
                        lsRatio: 1,
                        orderBookBias: 1,
                        bbSqueeze: 1.5
                    },
                    indicatorParams: {
                        rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9,
                        stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3
                    }
                },

                // ===== PRESET BARU UNTUK REZIM PASAR =====
                'bullTrend': {
                    weights: {
                        ma: 3.0,          // Sangat penting dalam tren
                        ichimoku: 3.0,    // Sangat penting dalam tren
                        psar: 2.5,        // Sangat penting dalam tren
                        vwap: 2.5,
                        rsiDivergence: 1.0, // Kurang relevan saat tren kuat
                        stoch: 0.5,       // Osilator kurang berguna
                        bbSqueeze: 0.5   // Tidak relevan
                    }
                },
                'bearTrend': {
                    weights: {
                        ma: 3.0,
                        ichimoku: 3.0,
                        psar: 2.5,
                        vwap: 2.5,
                        rsiDivergence: 1.0,
                        stoch: 0.5,
                        bbSqueeze: 0.5
                    }
                },
                'lowVolatility': {
                    weights: {
                        bbSqueeze: 3.5,   // Sinyal paling penting!
                        rsi: 2.0,         // Berguna untuk melihat momentum yang mulai terbentuk
                        macd: 2.0,        // Cross MACD bisa jadi konfirmasi awal breakout
                        ma: 1.0,          // MA kurang relevan saat sideways
                        ichimoku: 1.0     // Awan Ichimoku biasanya datar dan tidak informatif
                    }
                },
                'ranging': {
                    weights: {
                        rsi: 2.5,         // Osilator sangat berguna
                        stoch: 2.0,       // Sangat berguna untuk kondisi overbought/oversold
                        rsiDivergence: 3.0, // Divergensi adalah sinyal pembalikan yang kuat di pasar ranging
                        bollingerBands: 2.5, // Pantulan dari batas atas/bawah BB sangat relevan
                        ma: 1.0,          // Kurang relevan
                        psar: 1.0         // Kurang relevan
                    }
                }
            }
        };
        let candleCountdownInterval = null;
        let newCandleJustStarted = false;
        let klineCache = {};
        let latestBids = [];
        let latestAsks = [];
        let liveAnalysisScores = {};
        let coinListCache = null;
        let exchangeInfoCache = { spot: null, futures: null };
        let cvdChartInstance = null;
        let liveCvdValue = 0;
        let liveCvdData = [];
        let liveCvdValueUsdt = 0;
        let periodicUpdateInterval = null;
        let latestCalculatedData = {};
        let lastUiUpdateTime = 0;
        let tradeQueue = [];
        let depthQueue = [];
        let klineQueue = [];
        let processingInterval = null;
        let fundingRateTimer = null;
        let orderBookDOMElements = null;
        let orderBookHistory = {
            avgVolumes: [],
            maxSize: 50
        };
        let topMoversInterval = null;
        let topMoversCountdown = null;
        let currentTimeframe = "1h";
        let currentInterval = 60000; // default 10 detik
        let remainingTime = currentInterval / 1000;
        let isTooltipActive = false;
        let lastCvdDipCalculationTime = 0;
        let lastCvdDipResult = { triggered: false, points: 0 };
        let cvdAggregator = {
            currentBucketTimestamp: 0,
            currentBucketDelta: 0,
            history: [], // Akan berisi [timestamp, totalDelta]
            lastTriggerResult: { triggered: false, points: 0 }
        };
        let charts = [];
        let candlestickSeries = null;
        let isChartsVisible = false;
        let activeStrategy = null;
        let chartSeries = {
            candlestick: null, volume: null, rsi: null, stochK: null, stochD: null,
            ema50: null, bbUpper: null, bbMiddle: null, bbLower: null,
            macdLine: null, signalLine: null, macdHist: null, roc: null
        };
        let currentFibMode = 'extension';
        // 
        // BAGIAN 1: DEKLARASI SEMUA ELEMEN DOM
        // 
        const gainersList = document.getElementById('gainers-list');
        const losersList = document.getElementById('losers-list');
        const navWrapper = document.getElementById('sticky-nav-wrapper');
        const mainContent = document.getElementById('main-content-container');
        const toggleAiVerdictBtn = document.getElementById('toggle-ai-verdict-btn');
        const toggleAiVerdictIcon = document.getElementById('toggle-ai-verdict-icon');
        const aiVerdictContentWrapper = document.getElementById('ai-verdict-content-wrapper');
        const assetInput = document.getElementById('asset-input');
        const apiKeyInput = document.getElementById('gemini-api-key');
        const timeframeSelect = document.getElementById('timeframe-select');
        const marketTypeSelect = document.getElementById('market-type-select');
        const analyzeBtn = document.getElementById('analyze-asset-btn');
        const buttonText = document.getElementById('button-text');
        const buttonLoader = document.getElementById('button-loader');
        const assetError = document.getElementById('asset-error');
        const dashboardContent = document.getElementById('dashboard-content');
        const initialPlaceholder = document.getElementById('initial-placeholder');
        const loaderOverlay = document.getElementById('loader-overlay');
        const loaderText = document.getElementById('loader-text');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const darkIcon = document.getElementById('theme-toggle-dark-icon');
        const lightIcon = document.getElementById('theme-toggle-light-icon');
        const projectionResultsContainer = document.getElementById('projection-results-container');
        const specificTokenTitle = document.getElementById('specific-token-title');
        const specificTokenContent = document.getElementById('specific-token-content');
        const trendingPoolsContent = document.getElementById('trending-pools-content');
        const fullOrderBookContainer = document.getElementById('full-order-book-container');
        const tradeLink = document.getElementById('trade-link');
        const navVolume24h = document.getElementById('nav-volume-24h');
        const navAth = document.getElementById('nav-ath');
        const navAtl = document.getElementById('nav-atl');
        const resetBtn = document.getElementById('reset-btn');
        const toggleChartsBtn = document.getElementById('toggle-charts-btn');
        const chartsWrapper = document.getElementById('charts-wrapper');
        const WebSocketManager = {
            ws: null,
            mainSubscriptions: new Set(),
            moverSubscriptions: new Set(),
            messageHandlers: {},
            reconnectBaseDelay: 5000,
            reconnectAttempts: 0,
            maxReconnectDelay: 60000,
            isConnecting: false,

            handleOpen() {
                this.isConnecting = false;
                this.reconnectAttempts = 0;
            },

            handleMessage(event) {
                const message = JSON.parse(event.data);
                if (message.result !== undefined) return;

                if (message.stream && message.data) {
                    const streamName = message.stream;
                    const payload = message.data;
                    const symbol = streamName.split('@')[0].toUpperCase();


                    if (this.moverSubscriptions.has(symbol)) {
                        onNewMoverData(symbol, streamName, payload);
                    }

                    if (realtimeCache.main.symbol && realtimeCache.main.symbol === symbol) {
                        if (streamName.includes('@kline')) {
                            if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                        } else if (streamName.includes('@aggTrade')) {
                            if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                        } else if (streamName.includes('@depth')) {
                            if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                        } else if (streamName.includes('@bookTicker')) {
                            if (this.messageHandlers['bookTicker']) this.messageHandlers['bookTicker'](payload);
                        }
                    }
                }
            },

            handleClose() {
                this.isConnecting = false;
                if (this.mainSubscriptions.size > 0 || this.moverSubscriptions.size > 0) {
                    this.reconnectAttempts++;
                    const delay = Math.min(this.reconnectBaseDelay * (2 ** this.reconnectAttempts), this.maxReconnectDelay);
                    setTimeout(() => this.connect(), delay);
                }
            },

            handleError(error) {
                console.error("Kesalahan WebSocket:", error);
                this.isConnecting = false;
                if (this.ws) this.ws.close();
            },

            connect() {
                if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) return;
                this.isConnecting = true;

                const moverStreams = Array.from(this.moverSubscriptions).flatMap(s => [`${s.toLowerCase()}@kline_1h`, `${s.toLowerCase()}@aggTrade`, `${s.toLowerCase()}@depth20`]);
                const mainStreams = Array.from(this.mainSubscriptions);
                const allSubscriptions = new Set([...mainStreams, ...moverStreams]);

                const streamNames = Array.from(allSubscriptions).join('/');

                if (streamNames.length === 0) {
                    this.isConnecting = false;
                    return;
                }
                const url = `wss://fstream.binance.com/stream?streams=${streamNames}`;
                this.ws = new WebSocket(url);
                this.ws.onopen = this.handleOpen.bind(this);
                this.ws.onmessage = this.handleMessage.bind(this);
                this.ws.onclose = this.handleClose.bind(this);
                this.ws.onerror = this.handleError.bind(this);
            },

            subscribe(streams) { // Hanya untuk panel utama
                this.mainSubscriptions.clear();
                streams.forEach(stream => this.mainSubscriptions.add(stream));
                this.reconnect();
            },

            // NEW CODE (AFTER PATCH)
            resetSubscriptions() { // Sekarang mereset SEMUA langganan
                this.mainSubscriptions.clear();
                this.moverSubscriptions.clear();
                this.reconnect();
            },

            subscribeToMovers(symbols) {
                const newSubs = new Set(symbols);
                if (new Set([...newSubs]).size === this.moverSubscriptions.size && [...newSubs].every(s => this.moverSubscriptions.has(s))) {
                    return; // NONE perubahan, tidak perlu reconnect
                }
                this.moverSubscriptions = newSubs;
                this.reconnect();
            },

            reconnect() {
                if (this.ws) {
                    this.ws.onclose = null;
                    this.ws.close();
                }
                this.connect();
            },

            registerHandler(streamName, handler) {
                this.messageHandlers[streamName] = handler;
            }
        };
        // 
        // BAGIAN 2: KONSTANTA KONFIGURASI
        // 
        const UI_UPDATE_INTERVAL = 500;
        const TAKER_FEE_NOTIONAL = 0.0005;
        const KLINE_CACHE_DURATION = 5 * 60 * 1000; // Cache berlaku 5 menit
        const CVD_DIP_DEBOUNCE_MS = 5000;
        const timeframeParameterMap = {
            // Kategori Scalping (Timeframe <= 15m) -> Stoch RSI lebih sensitif
            '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            // Kategori Day Trading (Timeframe > 15m dan <= 4h) -> Stoch RSI standar
            '30m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '2h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            // Kategori Swing Trading (Timeframe > 4h) -> Stoch RSI lebih stabil
            '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '1w': { rsi_period: 25, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 25, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
        };
        const CVD_AGGREGATION_INTERVAL_MS = 10000; // Agregasi data setiap 5 detik
        const CVD_HISTORY_LENGTH = 50; // Menyimpan histori 50 keranjang data (50 * 5 detik = 250 detik)
        const DEFAULT_WEIGHTS = {
            // Bobot utama yang sering disetel
            "ma": 2.0,
            "macd": 2.0,
            "rsi": 1.5,
            "stoch": 1.0,

            // Bobot Konfluensi & Divergensi
            "rsiDivergence": 2.5,
            "obvDivergence": 3.0, // Ditemukan di DNA Generik
            "candlePattern": 1.5,
            "bollingerBands": 1.0,
            "bbSqueeze": 1.5,

            // Bobot Level/Support/Resistance
            "pivot": 2.0,
            "vwap": 2.0,
            "ichimoku": 1.5,
            "psar": 1.0,

            // Bobot Momentum
            "roc": 1.0,
            "linreg": 1.0,

            // *Tambahan Opsional yang tidak ditemukan di DNA Anda, tapi standar*
            // "openInterest": 0, 
            // "fundingRate": 0
        };
        // 
        // BAGIAN 3: DEKLARASI STATE & VARIABEL GLOBAL
        // 
        const realtimeCache = {
            main: {
                symbol: null,
                tickerData: {},
                klines: [],
                calculatedData: {},
                // === TAMBAHAN KRITIS FINAL INI ===
                liveScores: { pumpStrength: 0, dumpRisk: 0 },
                // =================================
            },
            movers: {}
        };
        const reconnectDelay = 5000; // Coba sambung kembali setiap 5 detik
        const REGIME_LABELS = ['BULL_TREND', 'BEAR_TREND', 'RANGING', 'LOW_VOLATILITY'];
        const MODEL_ARTIFACTS_JSON_STRING = `
            {
                "format": "layers-model",
                "generatedBy": "TensorFlow.js tfjs-layers v4.2.0",
                "convertedBy": null,
                "modelTopology": {"class_name":"Sequential","config":{"name":"sequential_1","layers":[{"class_name":"LSTM","config":{"name":"lstm_LSTM1","trainable":true,"batch_input_shape":[null,10,12],"dtype":"float32","units":64,"activation":"relu","recurrent_activation":"hard_sigmoid","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"recurrent_initializer":{"class_name":"Orthogonal","config":{"gain":1,"seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"unit_forget_bias":null,"kernel_regularizer":null,"recurrent_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"recurrent_constraint":null,"bias_constraint":null,"dropout":0,"recurrent_dropout":0,"implementation":null,"return_sequences":false,"return_state":false,"go_backwards":false,"stateful":false,"unroll":false}},{"class_name":"Dropout","config":{"rate":0.2,"noise_shape":null,"seed":null,"name":"dropout_Dropout1","trainable":true}},{"class_name":"Dense","config":{"units":32,"activation":"relu","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense1","trainable":true}},{"class_name":"Dense","config":{"units":4,"activation":"softmax","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense2","trainable":true}}]},"keras_version":"tfjs-layers 4.2.0","backend":"tensor_flow.js"},
                    "weightsManifest": [
                        {
                            "paths": ["weights.bin"],
                            "weights": [
                                {"name": "lstm_LSTM1/kernel", "shape": [12, 256], "dtype": "float32"},
                                {"name": "lstm_LSTM1/recurrent_kernel", "shape": [64, 256], "dtype": "float32"}, 
                                {"name": "lstm_LSTM1/bias", "shape": [256], "dtype": "float32"},
                                {"name": "dense_Dense1/kernel", "shape": [64, 32], "dtype": "float32"},
                                {"name": "dense_Dense1/bias", "shape": [32], "dtype": "float32"},
                                {"name": "dense_Dense2/kernel", "shape": [32, 4], "dtype": "float32"},
                                {"name": "dense_Dense2/bias", "shape": [4], "dtype": "float32"}
                            ]
                        }
                    ]
            }
    `;
        const WEIGHTS_BASE64_STRING = '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'; // <--- PASTIKAN TANDA INI ADA
        // 
        const processQueues = async () => {
            let shouldUpdateMainUI = false;
            let shouldUpdateScalpingUI = false;

            // 1. Proses antrean KLINE (Logika Baru)
            if (klineQueue.length > 0) {
                const klinesToProcess = klineQueue.splice(0, klineQueue.length);

                klinesToProcess.forEach(message => {
                    const candle = message.k;
                    const timeframe = candle.i; // Timeframe dari pesan (cth: '5m', '1h')
                    const mainTimeframe = timeframeSelect.value;
                    const dumpTimeframe = document.getElementById('dump-trigger-timeframe-select').value;

                    const formattedCandle = [
                        candle.t, candle.o, candle.h, candle.l, candle.c, candle.v,
                        candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B
                    ];

                    // Cek apakah ini untuk timeframe utama
                    if (timeframe === mainTimeframe && realtimeCache.main.klines) {
                        const klinesCache = realtimeCache.main.klines;
                        if (candle.x) {
                            klinesCache.shift();
                            klinesCache.push(formattedCandle);
                            newCandleJustStarted = true;
                        } else {
                            klinesCache[klinesCache.length - 1] = formattedCandle;
                            if (newCandleJustStarted) {
                                startCandleCountdown();
                                newCandleJustStarted = false;
                            }
                        }
                        shouldUpdateMainUI = true;
                        updateLiveCharts(candle);
                    }

                    else if (timeframe === dumpTimeframe && realtimeCache.main.multiTfKlines[dumpTimeframe]) {
                        const klinesCache = realtimeCache.main.multiTfKlines[dumpTimeframe];
                        if (candle.x) {
                            klinesCache.shift();
                            klinesCache.push(formattedCandle);
                        } else {
                            klinesCache[klinesCache.length - 1] = formattedCandle;
                        }
                        shouldUpdateScalpingUI = true;
                    }
                });
            }
            // 2. Proses antrean TRADE (Logika Lama yang Dikembalikan)
            if (tradeQueue.length > 0) {
                try {
                    const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
                    tradesToProcess.forEach(trade => {
                        const quantity = parseFloat(trade.q);
                        const price = parseFloat(trade.p);


                        // 1. Perbarui harga di cache utama agar simulasi bisa membacanya
                        if (realtimeCache.main.tickerData) {
                            realtimeCache.main.tickerData.lastPrice = price;
                        }

                        // 2. Perbarui harga di input kalkulator secara real-time
                        const marketPriceInput = tsCalc.elements.marketPrice;
                        // Hanya update jika pengguna tidak sedang mengetik di dalamnya
                        if (document.activeElement !== marketPriceInput) {
                            marketPriceInput.value = price.toFixed(getPrecisionForAsset(price));
                        }

                        // 3. Perbarui harga di header navigasi (kode lama yang dipertahankan)
                        const navPriceEl = document.getElementById('nav-price');
                        if (navPriceEl) {
                            navPriceEl.textContent = formatPrice(price);
                        }

                        const now = trade.T;
                        const bucketTimestamp = Math.floor(now / CVD_AGGREGATION_INTERVAL_MS) * CVD_AGGREGATION_INTERVAL_MS;
                        if (bucketTimestamp > cvdAggregator.currentBucketTimestamp) {
                            if (cvdAggregator.currentBucketTimestamp > 0) {
                                cvdAggregator.history.push({
                                    time: cvdAggregator.currentBucketTimestamp,
                                    delta: cvdAggregator.currentBucketDelta
                                });
                                if (cvdAggregator.history.length > CVD_HISTORY_LENGTH) {
                                    cvdAggregator.history.shift();
                                }
                            }
                            cvdAggregator.currentBucketTimestamp = bucketTimestamp;
                            cvdAggregator.currentBucketDelta = 0;
                        }
                        const sign = trade.m ? -1 : 1;
                        cvdAggregator.currentBucketDelta += (quantity * price * sign);

                        if (cvdChartInstance) {
                            if (isNaN(quantity) || quantity === 0) return;
                            liveCvdValue += quantity * sign;
                            liveCvdValueUsdt += (quantity * price) * sign;
                            const newPoint = { x: trade.T, y_coin: liveCvdValue, y_usdt: liveCvdValueUsdt };
                            cvdChartInstance.data.datasets[0].data.push(newPoint);
                            liveCvdData.push(newPoint);
                            while (cvdChartInstance.data.datasets[0].data.length > 300) {
                                cvdChartInstance.data.datasets[0].data.shift();
                                liveCvdData.shift();
                            }
                            cvdChartInstance.update('none');
                            updateCvdTableLive();
                        }
                    });
                } catch (error) {
                    console.error("Error saat memproses trade:", error);
                }
            }

            // 3. Proses antrean DEPTH/Order Book (Logika Lama yang Dikembalikan)
            if (depthQueue.length > 0) {
                try {
                    const updatesToProcess = depthQueue.splice(0, depthQueue.length);
                    updatesToProcess.forEach(update => {
                        if (update.b) {
                            update.b.forEach(([price, qty]) => {
                                const existingIndex = latestBids.findIndex(bid => bid[0] === price);
                                if (parseFloat(qty) === 0) {
                                    if (existingIndex !== -1) latestBids.splice(existingIndex, 1);
                                } else {
                                    if (existingIndex !== -1) latestBids[existingIndex] = [price, qty];
                                    else latestBids.push([price, qty]);
                                }
                            });
                        }
                        if (update.a) {
                            update.a.forEach(([price, qty]) => {
                                const existingIndex = latestAsks.findIndex(ask => ask[0] === price);
                                if (parseFloat(qty) === 0) {
                                    if (existingIndex !== -1) latestAsks.splice(existingIndex, 1);
                                } else {
                                    if (existingIndex !== -1) latestAsks[existingIndex] = [price, qty];
                                    else latestAsks.push([price, qty]);
                                }
                            });
                        }
                    });
                    latestBids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
                    latestAsks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
                    const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
                    const precision = getPrecisionForAsset(parseFloat(latestPrice));
                    const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
                    renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
                } catch (error) {
                    console.error("Error saat memproses depth:", error);
                }
            }

            // 4. Panggil fungsi update UI berdasarkan data mana yang baru (Logika Baru)
            const now = Date.now();
            if (shouldUpdateMainUI && (now - lastUiUpdateTime > 3000)) {
                lastUiUpdateTime = now;
                await updateRealTimeIndicators(realtimeCache.main.klines);
            } else if (shouldUpdateScalpingUI) {
                // Jika hanya data scalping yang berubah, cukup update panel scalping
                calculateAndDisplayScalpingSetup();
            }
        };
        // == BLOK FUNGSI KALKULASI INDIKATOR 
        // 
        const calculateEMA = (data, period) => {
            if (!data || data.length < period) return [];
            const k = 2 / (period + 1);
            let emaArray = Array(period - 1).fill(undefined);
            let sum = 0;
            for (let i = 0; i < period; i++) sum += data[i];
            let currentEma = sum / period;
            emaArray.push(currentEma);
            for (let i = period; i < data.length; i++) {
                currentEma = (data[i] * k) + (currentEma * (1 - k));
                emaArray.push(currentEma);
            }
            return emaArray;
        };
        // 
        const calculateSMA = (data, period) => {
            if (!data || data.length < period) return [];
            let sma = Array(period - 1).fill(undefined);
            for (let i = period - 1; i < data.length; i++) {
                const slice = data.slice(i - period + 1, i + 1);
                sma.push(slice.reduce((a, b) => a + b, 0) / period);
            }
            return sma;
        };

        const calculateRSI = (closes, period = userSettings.active.indicatorParams.rsi_period) => {
            if (!closes || closes.length <= period) return Array(closes?.length || 0).fill(undefined);
            let gains = [], losses = [];
            for (let i = 1; i < closes.length; i++) {
                const diff = closes[i] - closes[i - 1];
                gains.push(diff > 0 ? diff : 0);
                losses.push(diff < 0 ? -diff : 0);
            }
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            if (avgLoss === 0) return Array(closes.length).fill(100);
            let rsi = [100 - (100 / (1 + (avgGain / avgLoss)))];
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                if (avgLoss === 0) { rsi.push(100); }
                else { rsi.push(100 - (100 / (1 + (avgGain / avgLoss)))); }
            }
            return Array(period).fill(undefined).concat(rsi);
        };
        // 
        const calculateMACD = (closes, fast = userSettings.active.indicatorParams.macd_fast, slow = userSettings.active.indicatorParams.macd_slow, signal = userSettings.active.indicatorParams.macd_signal) => {
            if (closes.length < slow + signal) {
                return { status: 'Netral', hist: 'Netral', class: 'text-gray-500', macdLine: [], signalLine: [], histogram: [] };
            }
            const emaFast = calculateEMA(closes, fast);
            const emaSlow = calculateEMA(closes, slow);

            const macdLine = emaSlow.map((slowVal, i) => {
                if (slowVal !== undefined && emaFast[i] !== undefined) {
                    return emaFast[i] - slowVal;
                }
                return undefined;
            });

            const signalLine = calculateEMA(macdLine.filter(v => v !== undefined), signal);
            const histogram = macdLine.map((macdVal, i) => {
                const signalIndex = i - (slow - 1);
                if (macdVal !== undefined && signalLine[signalIndex] !== undefined) {
                    const histValue = macdVal - signalLine[signalIndex];
                    const prevHistValue = (i > 0 && macdLine[i - 1] !== undefined && signalLine[signalIndex - 1] !== undefined)
                        ? (macdLine[i - 1] - signalLine[signalIndex - 1]) : 0;
                    return {
                        value: histValue,
                        color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                    };
                }
                return undefined;
            });

            const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
            const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
            const lastHist = histogram.filter(v => v !== undefined).pop()?.value || 0;
            const prevMacdLine = macdLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
            const prevSignalLine = signalLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;

            let status = 'Netral', macdClass = 'text-gray-500';
            if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) {
                status = 'Bullish Cross';
                macdClass = 'positive';
            } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) {
                status = 'Bearish Cross';
                macdClass = 'negative';
            }

            return {
                status,
                hist: lastHist > 0 ? '(Naik)' : '(Turun)',
                class: macdClass,
                macdLine,
                signalLine,
                histogram
            };
        };
        // 
        const calculateStochasticRSI = (closes,
            rsiPeriod = userSettings.active.indicatorParams.stoch_rsi_period,
            stochPeriod = userSettings.active.indicatorParams.stoch_stoch_period,
            kSmooth = userSettings.active.indicatorParams.stoch_k_smooth,
            dSmooth = userSettings.active.indicatorParams.stoch_d_smooth
        ) => {
            const rsiValues = calculateRSI(closes, rsiPeriod).filter(v => v !== undefined);
            if (rsiValues.length < stochPeriod) {
                return { k: 50, d: 50, status: 'Netral', class: 'tag-gray', kLine: [], dLine: [], kOffset: 0, dOffset: 0 };
            }
            const stochArr = [];
            for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
                const window = rsiValues.slice(i - stochPeriod + 1, i + 1);
                const minR = Math.min(...window);
                const maxR = Math.max(...window);
                const denom = maxR - minR;
                stochArr.push(denom === 0 ? 0 : ((rsiValues[i] - minR) / denom) * 100);
            }
            const kLine = calculateSMA(stochArr, kSmooth);
            const dLine = calculateSMA(kLine.filter(v => v !== undefined), dSmooth);
            const lastK = kLine.filter(v => v !== undefined).pop() || 50;
            const lastD = dLine.filter(v => v !== undefined).pop() || 50;
            let status = 'Netral', stochClass = 'tag-yellow';
            if (lastK > 80 && lastD > 80) { status = 'Overbought'; stochClass = 'tag-red'; }
            else if (lastK < 20 && lastD < 20) { status = 'Oversold'; stochClass = 'tag-green'; }
            const kOffset = closes.length - kLine.length;
            const dOffset = closes.length - dLine.length;
            return {
                k: lastK.toFixed(2), d: lastD.toFixed(2), status, class: stochClass,
                kLine, dLine, kOffset, dOffset
            };
        };
        // 
        const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
            if (closes.length < period) return { upper: [], middle: [], lower: [], width: [], status: 'N/A' };
            const middle = calculateSMA(closes, period);
            let upper = Array(period - 1).fill(undefined);
            let lower = Array(period - 1).fill(undefined);
            let width = Array(period - 1).fill(undefined);

            for (let i = period - 1; i < closes.length; i++) {
                if (middle[i] === undefined) {
                    upper.push(undefined);
                    lower.push(undefined);
                    width.push(undefined);
                    continue;
                };
                const slice = closes.slice(i - period + 1, i + 1);
                const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
                const stdev = Math.sqrt(sumSquaredDiff / period);
                upper.push(middle[i] + (stdev * stdDev));
                lower.push(middle[i] - (stdev * stdDev));
                width.push((middle[i] + (stdev * stdDev)) - (middle[i] - (stdev * stdDev)));
            }

            const lastClose = closes[closes.length - 1];
            const lastUpper = upper.filter(v => v !== undefined).pop();
            const lastLower = lower.filter(v => v !== undefined).pop();
            const lastWidth = width.filter(v => v !== undefined).pop();

            let status = 'INSIDE';
            if (lastClose > lastUpper) status = 'Above';
            if (lastClose < lastLower) status = 'Below';

            let squeezeStatus = 'Normal';
            if (width.length > 50) {
                const recentWidths = width.slice(-50);
                const minWidth = Math.min(...recentWidths);
                const avgWidth = recentWidths.reduce((a, b) => a + b, 0) / recentWidths.length;
                if (lastWidth < avgWidth * 0.7) {
                    squeezeStatus = 'Squeeze!';
                }
            }

            return { upper, middle, lower, width, status, squeezeStatus };
        };
        // 
        const calculateVPVR = (klines, numRows = 70, valueAreaPercent = 0.70) => {
            if (!klines || klines.length === 0) return { poc: 0, vah: 0, val: 0 };
            let overallLow = Infinity, overallHigh = -Infinity;
            const candles = klines.map(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]);
                if (high > overallHigh) overallHigh = high;
                if (low < overallLow) overallLow = low;
                return { high, low, volume: parseFloat(k[5]) };
            });
            const rowSize = (overallHigh - overallLow) / numRows;
            let profile = Array.from({ length: numRows }, (_, i) => ({ price: overallLow + (i * rowSize), volume: 0 }));
            let totalVolume = 0;
            candles.forEach(c => {
                totalVolume += c.volume;
                const startIdx = Math.max(0, Math.floor((c.low - overallLow) / rowSize));
                const endIdx = Math.min(numRows - 1, Math.floor((c.high - overallLow) / rowSize));
                const volPerRow = c.volume / (endIdx - startIdx + 1);
                for (let i = startIdx; i <= endIdx; i++) profile[i].volume += volPerRow;
            });
            if (totalVolume === 0) return { poc: 0, vah: 0, val: 0 };
            let pocIndex = profile.reduce((maxIdx, row, idx, arr) => row.volume > arr[maxIdx].volume ? idx : maxIdx, 0);
            const poc = profile[pocIndex].price + (rowSize / 2);
            const targetVolume = totalVolume * valueAreaPercent;
            let vaVolume = profile[pocIndex].volume;
            let upperIdx = pocIndex, lowerIdx = pocIndex;
            while (vaVolume < targetVolume) {
                const volAbove = (upperIdx + 1 < numRows) ? profile[upperIdx + 1].volume : -1;
                const volBelow = (lowerIdx - 1 >= 0) ? profile[lowerIdx - 1].volume : -1;
                if (volAbove === -1 && volBelow === -1) break;
                if (volAbove > volBelow) {
                    upperIdx++;
                    vaVolume += profile[upperIdx].volume;
                } else {
                    lowerIdx--;
                    vaVolume += profile[lowerIdx].volume;
                }
            }
            return { poc, vah: profile[upperIdx].price + rowSize, val: profile[lowerIdx].price };
        };
        // 
        const calculateADX = (klines, period = 14) => {
            if (!klines || klines.length < period * 2) return { adx: 'N/A', plusDI: 'N/A', minusDI: 'N/A' };
            let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
            let trs = [], plusDMs = [], minusDMs = [];
            for (let i = 1; i < highs.length; i++) {
                trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
                let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
                plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
                minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
            }
            // =============================================
            const rma = (data, p) => {
                let rma = [], sum = 0;
                for (let i = 0; i < data.length; i++) {
                    if (i < p) {
                        sum += data[i];
                        rma.push(i === p - 1 ? sum / p : undefined);
                    } else if (rma[i - 1] !== undefined) {
                        rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                    }
                }
                return rma;
            };
            let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
            let plusDIs = [], minusDIs = [], dxs = [];
            for (let i = 0; i < smoothedTR.length; i++) {
                if (smoothedTR[i] === undefined) continue;
                let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
                let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
                plusDIs.push(plusDI);
                minusDIs.push(minusDI);
                let diSum = plusDI + minusDI;
                dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
            }
            let adxValues = rma(dxs, period);
            return { adx: adxValues.filter(v => v !== undefined).pop()?.toFixed(2) || 'N/A', plusDI: plusDIs.pop()?.toFixed(2) || 'N/A', minusDI: minusDIs.pop()?.toFixed(2) || 'N/A' };
        };
        // 
        const findCandlestickPatterns = (klines) => {
            if (!klines || klines.length < 3) {
                return { pattern: 'NONE', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: null };
            }

            const lastCandleTimestamp = klines[klines.length - 1][0];
            const getCandleDetails = (k) => {
                const [open, high, low, close] = k.slice(1, 5).map(parseFloat);
                return { open, high, low, close, body: Math.abs(close - open), isGreen: close > open, isRed: close < open };
            };

            const c1 = getCandleDetails(klines[klines.length - 1]);
            const c2 = getCandleDetails(klines[klines.length - 2]);
            const c3 = getCandleDetails(klines[klines.length - 3]);


            let result = { pattern: 'NONE', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: lastCandleTimestamp };

            if (c3.isGreen && c2.isGreen && c1.isGreen && c1.close > c2.close && c2.close > c3.close) {
                result = { pattern: 'THREE WHITE SOLDIERS', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('THREE_WHITE_SOLDIERS'), timestamp: lastCandleTimestamp };
            } else if (c3.isRed && c2.isRed && c1.isRed && c1.close < c2.close && c2.close < c3.close) {
                result = { pattern: 'THREE BLACK CROWS', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('THREE_BLACK_CROWS'), timestamp: lastCandleTimestamp };
            } else if (c3.isRed && c2.body < c3.body * 0.3 && c1.isGreen && c1.close > c3.open) {
                result = { pattern: 'MORNING STAR', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('MORNING_STAR'), timestamp: lastCandleTimestamp };
            } else if (c3.isGreen && c2.body < c3.body * 0.3 && c1.isRed && c1.close < c3.open) {
                result = { pattern: 'EVENING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('EVENING_STAR'), timestamp: lastCandleTimestamp };
            }

            if (result.pattern === 'NONE') {
                if (c2.isRed && c1.isGreen && c1.close > c2.open && c1.open < c2.close) {
                    result = { pattern: 'BULLISH ENGULFING', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_ENGULFING'), timestamp: lastCandleTimestamp };
                } else if (c2.isGreen && c1.isRed && c1.close < c2.open && c1.open > c2.close) {
                    result = { pattern: 'BEARISH ENGULFING', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_ENGULFING'), timestamp: lastCandleTimestamp };
                } else if (c2.isGreen && c1.isRed && c1.open > c2.close && c1.close < c2.open && c1.close > (c2.open + c2.body / 2)) {
                    result = { pattern: 'DARK CLOUD COVER', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('DARK_CLOUD_COVER'), timestamp: lastCandleTimestamp };
                } else if (c2.isRed && c1.isGreen && c1.open < c2.close && c1.close > c2.open && c1.close < (c2.open - c2.body / 2)) {
                    result = { pattern: 'PIERCING LINE', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('PIERCING_LINE'), timestamp: lastCandleTimestamp };
                } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close) {
                    result = { pattern: 'BEARISH HARAMI', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_HARAMI'), timestamp: lastCandleTimestamp };
                } else if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close) {
                    result = { pattern: 'BULLISH HARAMI', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_HARAMI'), timestamp: lastCandleTimestamp };
                } else if (Math.abs(c1.high - c2.high) < (c1.range * 0.05)) {
                    result = { pattern: 'TWEEZER TOP', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('TWEEZER_TOP'), timestamp: lastCandleTimestamp };
                } else if (Math.abs(c1.low - c2.low) < (c1.range * 0.05)) {
                    result = { pattern: 'TWEEZER BOTTOM', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('TWEEZER_BOTTOM'), timestamp: lastCandleTimestamp };
                }
            }

            if (result.pattern === 'NONE') {
                const lowerWick = Math.min(c1.open, c1.close) - c1.low;
                const upperWick = c1.high - Math.max(c1.open, c1.close);
                if (lowerWick > c1.body * 2 && upperWick < c1.body * 0.5) {
                    result = { pattern: 'HAMMER', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('HAMMER'), timestamp: lastCandleTimestamp };
                } else if (upperWick > c1.body * 2 && lowerWick < c1.body * 0.5) {
                    result = { pattern: 'SHOOTING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('SHOOTING_STAR'), timestamp: lastCandleTimestamp };
                }
            }

            return result;
        };
        // 
        const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
            if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE', class: 'text-gray-500' };
            const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
            const findPeaks = (data, isHigh) => {
                let peaks = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                        peaks.push({ index: i, value: data[i] });
                    }
                }
                return peaks;
            };
            const priceLows = findPeaks(recentCloses, false), priceHighs = findPeaks(recentCloses, true);
            const rsiLows = findPeaks(recentRSI, false), rsiHighs = findPeaks(recentRSI, true);
            if (priceLows.length >= 2 && rsiLows.length >= 2) {
                const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
                const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
                if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
            }
            if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
                const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
                const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
                if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
            }
            return { status: 'NONE', class: 'text-gray-500' };
        };
        // 
        const detectOBVDivergence = (closes, klines, lookback = 30) => {
            if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

            const obvValues = calculateOBV(klines);
            const recentCloses = closes.slice(-lookback);
            const recentOBV = obvValues.slice(-lookback);

            const findPivots = (data, isHigh) => {
                let pivots = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                        pivots.push({ index: i, value: data[i] });
                    }
                }
                return pivots;
            };

            const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
            const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

            if (priceLows.length >= 2 && obvLows.length >= 2) {
                const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
                const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
                if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
            }
            if (priceHighs.length >= 2 && obvHighs.length >= 2) {
                const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
                const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
                if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
            }
            return { status: 'NONE', class: 'text-gray-500' };
        };

        const calculateCVD = (trades) => {
            let cumulativeDeltaCoin = 0;
            let cumulativeDeltaUsdt = 0;
            return trades.map(t => {
                const quantity = parseFloat(t.q);
                const price = parseFloat(t.p);
                const sign = t.m ? -1 : 1;

                cumulativeDeltaCoin += quantity * sign;
                cumulativeDeltaUsdt += (quantity * price) * sign;

                return {
                    time: t.T / 1000,
                    cvd_coin: cumulativeDeltaCoin,
                    cvd_usdt: cumulativeDeltaUsdt
                };
            });
        };

        const calculateOBV = (klines) => {
            if (!klines || klines.length < 2) return [];
            let obv = [0];
            for (let i = 1; i < klines.length; i++) {
                const close = parseFloat(klines[i][4]);
                const prevClose = parseFloat(klines[i - 1][4]);
                const volume = parseFloat(klines[i][5]);
                if (close > prevClose) {
                    obv.push(obv[i - 1] + volume);
                } else if (close < prevClose) {
                    obv.push(obv[i - 1] - volume);
                } else {
                    obv.push(obv[i - 1]);
                }
            }
            return obv;
        };

        function CVDanalyze(klines, cvdData) {
            if (!klines || klines.length < 2 || !cvdData || cvdData.length < 2) {
                return { trend: 'N/A', divergence: 'N/A', summary: 'Data tidak cukup untuk analisa CVD.' };
            }

            const firstPrice = parseFloat(klines[0][4]);
            const lastPrice = parseFloat(klines[klines.length - 1][4]);
            const priceTrend = lastPrice > firstPrice ? 'Naik' : (lastPrice < firstPrice ? 'Turun' : 'Datar');

            const firstCvd = cvdData[0].cvd_usdt;
            const lastCvd = cvdData[cvdData.length - 1].cvd_usdt;
            const cvdTrend = lastCvd > firstCvd ? 'Naik' : (lastCvd < firstCvd ? 'Turun' : 'Datar');

            let divergence = 'NONE';
            let summary = `Tren harga dan CVD bergerak selaras (${priceTrend}).`;

            if (priceTrend === 'Naik' && cvdTrend === 'Turun') {
                divergence = 'Bearish üëé';
                summary = 'Harga naik tetapi tekanan beli melemah. Hati-hati, ini adalah sinyal divergensi bearish.';
            } else if (priceTrend === 'Turun' && cvdTrend === 'Naik') {
                divergence = 'Bullish üëç';
                summary = 'Harga turun tetapi tekanan beli menguat. Ini adalah sinyal divergensi bullish yang potensial.';
            }

            return {
                trend: cvdTrend,
                divergence: divergence,
                summary: summary
            };
        }

        function calculatePivotPoints(prevDayKline) {
            if (!prevDayKline || prevDayKline.length < 5) return null;
            const high = parseFloat(prevDayKline[2]);
            const low = parseFloat(prevDayKline[3]);
            const close = parseFloat(prevDayKline[4]);

            if (isNaN(high) || isNaN(low) || isNaN(close)) {
                console.error("Gagal menghitung Pivot: Salah satu data (H, L, C) bukan angka yang valid.", { high, low, close });
                return null;
            }

            const P = (high + low + close) / 3;
            const R1 = (2 * P) - low;
            const S1 = (2 * P) - high;
            const R2 = P + (high - low);
            const S2 = P - (high - low);
            const R3 = high + 2 * (P - low);
            const S3 = low - 2 * (high - P);

            return { P, R1, S1, R2, S2, R3, S3 };
        }
        // 
        function calculateKeltnerChannels(klines, period = 20, multiplier = 2, atrPeriod = 10) {
            if (!klines || klines.length < period) return { upper: [], middle: [], lower: [], width: [] };
            const closes = klines.map(k => parseFloat(k[4]));
            const emaMiddle = calculateEMA(closes, period);
            const atr = calculateATR(klines, atrPeriod).value;

            const upper = emaMiddle.map(val => val !== undefined ? val + (atr * multiplier) : undefined);
            const lower = emaMiddle.map(val => val !== undefined ? val - (atr * multiplier) : undefined);
            const width = upper.map((u, i) => (u !== undefined && lower[i] !== undefined) ? u - lower[i] : undefined);

            return { upper, middle: emaMiddle, lower, width };
        }
        // 
        function calculateIchimokuCloud(klines, tenkanP = 9, kijunP = 26, senkouP = 52) {
            if (klines.length < senkouP) return null;

            const result = { tenkan: [], kijun: [], senkouA: [], senkouB: [], chikou: [], status: 'Netral' };
            const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
            for (let i = 0; i < klines.length; i++) {
                const tenkanHighLow = i >= tenkanP - 1 ? getHighLow(klines.slice(i - tenkanP + 1, i + 1)) : { high: 0, low: 0 };
                result.tenkan.push(i >= tenkanP - 1 ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
                const kijunHighLow = i >= kijunP - 1 ? getHighLow(klines.slice(i - kijunP + 1, i + 1)) : { high: 0, low: 0 };
                result.kijun.push(i >= kijunP - 1 ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
                result.chikou.push(parseFloat(klines[i][4]));
            }
            for (let i = 0; i < klines.length; i++) {
                const senkouA_val = (result.tenkan[i] !== undefined && result.kijun[i] !== undefined) ? (result.tenkan[i] + result.kijun[i]) / 2 : undefined;
                result.senkouA.push(senkouA_val);
                const senkouB_HighLow = i >= senkouP - 1 ? getHighLow(klines.slice(i - senkouP + 1, i + 1)) : { high: 0, low: 0 };
                result.senkouB.push(i >= senkouP - 1 ? (senkouB_HighLow.high + senkouB_HighLow.low) / 2 : undefined);
            }

            const lastPrice = parseFloat(klines[klines.length - 1][4]);
            const lastTenkan = result.tenkan[result.tenkan.length - 1];
            const lastKijun = result.kijun[result.kijun.length - 1];

            const currentSenkouA = result.senkouA[klines.length - 1 - kijunP];
            const currentSenkouB = result.senkouB[klines.length - 1 - kijunP];

            const pastPriceForChikou = parseFloat(klines[klines.length - 1 - kijunP][4]);

            const isBullish = lastPrice > currentSenkouA && lastPrice > currentSenkouB &&
                lastTenkan > lastKijun &&
                lastPrice > pastPriceForChikou;

            const isBearish = lastPrice < currentSenkouA && lastPrice < currentSenkouB &&
                lastTenkan < lastKijun &&
                lastPrice < pastPriceForChikou;

            if (isBullish) {
                result.status = "Bullish";
            } else if (isBearish) {
                result.status = "Bearish";
            }

            return result;
        }
        // 
        function calculateATR(klines, period = 14) {
            if (!klines || klines.length < period + 1) {
                return { value: 0, status: 'N/A', atrPercent: 0 };
            }

            let trs = [];
            for (let i = 1; i < klines.length; i++) {
                const high = parseFloat(klines[i][2]);
                const low = parseFloat(klines[i][3]);
                const prevClose = parseFloat(klines[i - 1][4]);
                trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
            }

            const rma = (data, p) => {
                let smoothed = [];
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    if (i < p) {
                        sum += data[i];
                        if (i === p - 1) smoothed.push(sum / p);
                        else smoothed.push(undefined);
                    } else if (smoothed[i - 1] !== undefined) {
                        smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                    }
                }
                return smoothed;
            };

            const atrValues = rma(trs, period);
            const atr = atrValues.pop() || 0;
            const lastClose = parseFloat(klines[klines.length - 1][4]);
            const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;

            let status;
            if (atrPercent > 5) {
                status = 'Very High';
            } else if (atrPercent > 2.5) {
                status = 'High';
            } else if (atrPercent < 1) {
                status = 'Low';
            } else {
                status = 'Normal';
            }

            return { value: atr, status: status, atrPercent: atrPercent };
        }

        function calculateATRPercentage(klines, period = 14) {
            if (!klines || klines.length === 0) {
                return 0;
            }
            const atrResult = calculateATR(klines, period);
            return atrResult.atrPercent;
        }

        function calculateROC(closes, period = 12) {
            if (!closes || closes.length < period + 1) {
                return { values: [], value: 0, status: 'N/A' };
            }

            const rocValues = [];

            for (let i = period; i < closes.length; i++) {
                const currentClose = closes[i];
                const pastClose = closes[i - period];
                rocValues.push(pastClose !== 0 ? ((currentClose - pastClose) / pastClose) * 100 : 0);
            }

            const lastRoc = rocValues[rocValues.length - 1] || 0;
            const status = lastRoc > 0 ? 'Positif' : 'Negatif';

            return { values: rocValues, value: lastRoc, status: status };
        }
        // 
        function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
            if (klines.length < 2) return { value: 0, status: 'N/A' };
            let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
            for (let i = 1; i < klines.length; i++) {
                const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
                if (isUptrend) {
                    sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
                } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
            }
            const lastClose = parseFloat(klines[klines.length - 1][4]);
            return { value: sar, status: lastClose > sar ? 'Bullish' : 'Bearish' };
        }
        // 
        function calculateLinearRegressionChannel(closes, period = 14, stdDev = 2) {
            if (closes.length < period) return { upper: 0, middle: 0, lower: 0, status: 'N/A' };
            const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            let sumErrSq = 0;
            for (let i = 0; i < n; i++) {
                const predictedY = intercept + slope * i;
                sumErrSq += Math.pow(y[i] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middle = intercept + slope * (n - 1);
            const upper = middle + (stdDev * stdErr);
            const lower = middle - (stdDev * stdErr);

            const lastClose = closes[closes.length - 1];
            let status = "In Channel";
            if (lastClose > upper) status = "Upper Line Channel";
            if (lastClose < lower) status = "Lower Line Channel";

            return { upper, middle, lower, status };
        }
        // 
        function calculateVWAP(klines, mode = 'rolling', period = 20) {
            if (!klines || klines.length === 0) return 0;

            let sumPV = 0; // sum(Price * Volume)
            let sumV = 0;  // sum(Volume)
            let vwapValues = [];

            if (mode === 'rolling') {
                const recentKlines = klines.slice(-period);
                recentKlines.forEach(k => {
                    const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                    sumPV += ((high + low + close) / 3) * vol;
                    sumV += vol;
                });
                return sumV > 0 ? sumPV / sumV : 0;

            } else if (mode === 'session') {
                const todayUTC = new Date().toISOString().slice(0, 10);
                const sessionKlines = klines.filter(k => new Date(k[0]).toISOString().slice(0, 10) === todayUTC);
                if (sessionKlines.length === 0) return 0; // NONE data untuk sesi hari ini

                sessionKlines.forEach(k => {
                    const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                    sumPV += ((high + low + close) / 3) * vol;
                    sumV += vol;
                });
                return sumV > 0 ? sumPV / sumV : 0;

            } else if (mode === 'anchored') {
                const anchorLookback = 200; // Mencari titik terendah dalam 200 candle terakhir
                const recentSlice = klines.slice(-anchorLookback);
                if (recentSlice.length === 0) return 0;

                let lowestLow = Infinity;
                let anchorIndex = -1;

                recentSlice.forEach((k, index) => {
                    const low = parseFloat(k[3]);
                    if (low < lowestLow) {
                        lowestLow = low;
                        anchorIndex = klines.length - anchorLookback + index;
                    }
                });

                const anchoredKlines = klines.slice(anchorIndex);
                anchoredKlines.forEach(k => {
                    const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                    sumPV += ((high + low + close) / 3) * vol;
                    sumV += vol;
                });
                return sumV > 0 ? sumPV / sumV : 0;
            }
            return 0; // Fallback
        }

        function analyzeBollingerBandsPriceAction(klines, bbData) {
            if (!klines || klines.length < 2 || !bbData || bbData.upper.length < 2) {
                return { rejection: 'NONE', walkTheBands: 'NONE' };
            }

            const lastKline = klines[klines.length - 1];
            const prevKline = klines[klines.length - 2];
            const lastUpper = bbData.upper.pop()?.value;
            const lastLower = bbData.lower.pop()?.value;
            const prevUpper = bbData.upper.pop()?.value;
            const prevLower = bbData.lower.pop()?.value;
            const lastClose = parseFloat(lastKline[4]);
            const prevClose = parseFloat(prevKline[4]);

            let rejection = 'NONE';
            if (prevClose < prevLower && lastClose > lastLower && lastClose > prevClose) {
                rejection = 'Bullish Rejection (Lower BB)';
            }
            if (prevClose > prevUpper && lastClose < lastUpper && lastClose < prevClose) {
                rejection = 'Bearish Rejection (Upper BB)';
            }

            let walkTheBands = 'NONE';
            if (lastClose >= lastUpper && prevClose >= prevUpper) {
                walkTheBands = 'Bullish (Upper BB)';
            }
            if (lastClose <= lastLower && prevClose <= prevLower) {
                walkTheBands = 'Bearish (Lower BB)';
            }

            return { rejection, walkTheBands };
        }

        function getPatternSVG(patternName) {
            const svgHeader = `<svg viewBox="0 0 110 60" class="w-24 h-auto mx-auto my-2">`;
            const svgFooter = `</svg>`;
            const green = '#26a69a', red = '#ef5350', gray = '#2A1E27';

            let content = '';

            const createCandle = (x, open, high, low, close, color) => {
                const bodyY = Math.min(open, close);
                const bodyHeight = Math.abs(open - close);
                return `
                <line x1="${x + 10}" y1="${high}" x2="${x + 10}" y2="${low}" stroke="${color}" stroke-width="1"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" fill="${color}"/>
            `;
            };

            switch (patternName) {
                // --- POLA BULLISH ---
                case 'BULLISH_ENGULFING':
                    content = createCandle(20, 40, 45, 25, 30, red) + createCandle(50, 28, 55, 10, 50, green);
                    break;
                case 'HAMMER':
                    content = createCandle(40, 50, 52, 10, 48, red);
                    break;
                case 'MORNING_STAR':
                    content = createCandle(10, 50, 55, 15, 20, red) + createCandle(40, 15, 20, 5, 12, gray) + createCandle(70, 18, 50, 15, 45, green);
                    break;
                case 'THREE_WHITE_SOLDIERS':
                    content = createCandle(10, 25, 35, 10, 30, green) + createCandle(40, 32, 45, 28, 40, green) + createCandle(70, 42, 55, 38, 50, green);
                    break;
                case 'BULLISH_HARAMI':
                    content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                    break;
                case 'TWEEZER_BOTTOM':
                    content = createCandle(20, 40, 45, 10, 20, red) + createCandle(50, 22, 48, 10, 35, green);
                    break;
                // --- POLA BEARISH ---
                case 'BEARISH_ENGULFING':
                    content = createCandle(20, 20, 45, 15, 40, green) + createCandle(50, 42, 55, 10, 15, red);
                    break;
                case 'SHOOTING_STAR':
                    content = createCandle(40, 12, 50, 10, 15, green);
                    break;
                case 'EVENING_STAR':
                    content = createCandle(10, 15, 50, 10, 45, green) + createCandle(40, 52, 58, 48, 50, gray) + createCandle(70, 48, 50, 15, 20, red);
                    break;
                case 'THREE_BLACK_CROWS':
                    content = createCandle(10, 50, 55, 30, 45, red) + createCandle(40, 42, 48, 20, 25, red) + createCandle(70, 22, 28, 5, 10, red);
                    break;
                case 'BEARISH_HARAMI':
                    content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                    break;
                case 'TWEEZER_TOP':
                    content = createCandle(20, 20, 55, 15, 40, green) + createCandle(50, 38, 55, 18, 25, red);
                    break;
                default:
                    return '';
            }

            return svgHeader + content + svgFooter;
        }
        // 
        function findPivots(klines, lookback = 10) {
            const pivots = [];
            if (klines.length < lookback * 2 + 1) return [];

            for (let i = lookback; i < klines.length - lookback; i++) {
                const high = parseFloat(klines[i][2]);
                const low = parseFloat(klines[i][3]);
                let isHigh = true, isLow = true;

                for (let j = 1; j <= lookback; j++) {
                    if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                    if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
                }
                if (isHigh) pivots.push({ type: 'high', price: high, index: i });
                else if (isLow) pivots.push({ type: 'low', price: low, index: i });
            }
            return pivots;
        }
        // 
        function calculateSlope(p1, p2) {
            if (p2.index === p1.index) return Infinity;
            return (p2.price - p1.price) / (p2.index - p1.index);
        }
        // 
        function detectHeadAndShoulders(pivots) {
            for (let i = 4; i < pivots.length; i++) {
                const p1 = pivots[i - 4], p2 = pivots[i - 3], p3 = pivots[i - 2], p4 = pivots[i - 1], p5 = pivots[i];
                if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high' && p4.type === 'low' && p5.type === 'high') {
                    if (p3.price > p1.price && p3.price > p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                        return { pattern: 'HEAD & SHOULDERS', class: 'negative blinking-text-animation' };
                    }
                }

                if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low' && p4.type === 'high' && p5.type === 'low') {
                    if (p3.price < p1.price && p3.price < p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                        return { pattern: 'INVERSE H&S', class: 'positive blinking-text-animation' };
                    }
                }
            }
            return null;
        }
        // 
        function detectDoubles(pivots) {
            for (let i = 2; i < pivots.length; i++) {
                // Cek Double Top: H, L, H
                const p1_dt = pivots[i - 2], p2_dt = pivots[i - 1], p3_dt = pivots[i];
                if (p1_dt.type === 'high' && p2_dt.type === 'low' && p3_dt.type === 'high') {
                    if (Math.abs(p1_dt.price - p3_dt.price) / p3_dt.price < 0.03 && p2_dt.price < p1_dt.price) {
                        return { pattern: 'DOUBLE TOP', class: 'negative blinking-text-animation' };
                    }
                }
                // Cek Double Bottom: L, H, L
                const p1_db = pivots[i - 2], p2_db = pivots[i - 1], p3_db = pivots[i];
                if (p1_db.type === 'low' && p2_db.type === 'high' && p3_db.type === 'low') {
                    if (Math.abs(p1_db.price - p3_db.price) / p3_db.price < 0.03 && p2_db.price > p1_db.price) {
                        return { pattern: 'DOUBLE BOTTOM', class: 'positive blinking-text-animation' };
                    }
                }
            }
            return null;
        }
        // 
        function detectTriangles(pivots) {
            const recentPivots = pivots.slice(-7);
            const highs = recentPivots.filter(p => p.type === 'high');
            const lows = recentPivots.filter(p => p.type === 'low');

            if (lows.length >= 2 && highs.length >= 2) {
                const lastLow = lows[lows.length - 1], prevLow = lows[lows.length - 2];
                const lastHigh = highs[highs.length - 1], prevHigh = highs[highs.length - 2];

                const isLowsAscending = lastLow.price > prevLow.price;
                const isHighsFlat = Math.abs(lastHigh.price - prevHigh.price) / prevHigh.price < 0.015; // Toleransi 1.5%
                if (isLowsAscending && isHighsFlat) return { pattern: 'ASCENDING TRIANGLE', class: 'positive' };

                const isHighsDescending = lastHigh.price < prevHigh.price;
                const isLowsFlat = Math.abs(lastLow.price - prevLow.price) / prevLow.price < 0.015; // Toleransi 1.5%
                if (isHighsDescending && isLowsFlat) return { pattern: 'DESCENDING TRIANGLE', class: 'negative' };

                if (isLowsAscending && isHighsDescending) return { pattern: 'SYMMETRICAL TRIANGLE', class: 'text-yellow-400' };
            }
            return null;
        }
        // 
        function detectWedges(pivots) {
            const recentPivots = pivots.slice(-7);
            const highs = recentPivots.filter(p => p.type === 'high');
            const lows = recentPivots.filter(p => p.type === 'low');

            if (lows.length >= 2 && highs.length >= 2) {
                const lowSlope = calculateSlope(lows[lows.length - 2], lows[lows.length - 1]);
                const highSlope = calculateSlope(highs[highs.length - 2], highs[highs.length - 1]);


                if (lowSlope > 0 && highSlope > 0 && lowSlope > highSlope) {
                    return { pattern: 'RISING WEDGE', class: 'negative blinking-text-animation' };
                }

                if (lowSlope < 0 && highSlope < 0 && Math.abs(highSlope) > Math.abs(lowSlope)) {
                    return { pattern: 'FALLING WEDGE', class: 'positive blinking-text-animation' };
                }
            }
            return null;
        }
        // 
        function detectFlags(klines) {
            const lookback = 30;
            const flagLength = 10;
            if (klines.length < lookback + flagLength) return null;

            const closes = klines.map(k => parseFloat(k[4]));
            const poleStartPrice = closes[closes.length - flagLength - lookback];
            const poleEndPrice = closes[closes.length - flagLength];
            const priceChange = (poleEndPrice - poleStartPrice) / poleStartPrice;


            if (priceChange > 0.05) {
                const flagCloses = closes.slice(-flagLength);
                const flagHigh = Math.max(...flagCloses);
                const flagLow = Math.min(...flagCloses);

                if (flagLow > poleStartPrice + (poleEndPrice - poleStartPrice) * 0.5) {
                    return { pattern: 'BULL FLAG', class: 'positive' };
                }
            }

            if (priceChange < -0.05) {
                const flagCloses = closes.slice(-flagLength);
                const flagHigh = Math.max(...flagCloses);
                const flagLow = Math.min(...flagCloses);

                if (flagHigh < poleStartPrice - (poleStartPrice - poleEndPrice) * 0.5) {
                    return { pattern: 'BEAR FLAG', class: 'negative' };
                }
            }
            return null;
        }
        // 
        function findChartPatterns(klines) {
            if (!klines || klines.length < 50) {
                return { pattern: 'Data Kurang', class: 'text-gray-500' };
            }

            const pivots = findPivots(klines, 10);
            let pattern;

            pattern = detectHeadAndShoulders(pivots);
            if (pattern) return pattern;

            pattern = detectDoubles(pivots);
            if (pattern) return pattern;

            pattern = detectWedges(pivots);
            if (pattern) return pattern;

            pattern = detectTriangles(pivots);
            if (pattern) return pattern;

            pattern = detectFlags(klines);
            if (pattern) return pattern;

            return { pattern: 'Tidak Terdeteksi', class: 'text-gray-500' };
        }

        function findLastSignificantSwing(klines) {

            const pivots = findPivots(klines.slice(-300), 5);

            if (pivots.length < 3) return null;

            // Loop mundur dari pivot paling akhir untuk mencari pola yang valid
            for (let i = pivots.length - 1; i >= 2; i--) {
                const p3 = pivots[i];     // Ini adalah kandidat titik C
                const p2 = pivots[i - 1]; // Ini adalah kandidat titik B
                const p1 = pivots[i - 2]; // Ini adalah kandidat titik A

                // Mencari pola NAIK (Low -> High -> Higher Low)
                if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low') {
                    // Kondisi krusial: Titik C harus lebih tinggi dari A
                    if (p3.price > p1.price) {
                        // Pola valid ditemukan! Langsung kembalikan hasilnya.
                        return { A: p1, B: p2, C: p3, type: 'UP' };
                    }
                }

                // Mencari pola TURUN (High -> Low -> Lower High)
                if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high') {
                    // Kondisi krusial: Titik C harus lebih rendah dari A
                    if (p3.price < p1.price) {
                        return { A: p1, B: p2, C: p3, type: 'DOWN' };
                    }
                }
            }

            return null;
        }

        function calculateAdvancedFibonacciExtension(swing) {
            if (!swing || !swing.A?.price || !swing.B?.price || !swing.C?.price || !swing.type) {
                return null;
            }

            const priceA = parseFloat(swing.A.price);
            const priceB = parseFloat(swing.B.price);
            const priceC = parseFloat(swing.C.price);

            if (isNaN(priceA) || isNaN(priceB) || isNaN(priceC)) {
                return null;
            }

            const impulseMove = Math.abs(priceB - priceA);
            const fibLevels = [0, 0.618, 1.0, 1.272, 1.618, 2.618];
            const calculatedLevels = {};

            fibLevels.forEach(level => {
                let targetPrice;
                if (swing.type === 'UP') {
                    targetPrice = priceC + (impulseMove * level);
                } else {
                    targetPrice = priceC - (impulseMove * level);
                }
                calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
            });

            return {
                swingPoints: { A: priceA, B: priceB, C: priceC },
                type: swing.type,
                levels: calculatedLevels
            };
        }
        // 
        function displayFibonacciTargets() {
            const extData = realtimeCache.main.fibExtensions;
            const retData = realtimeCache.main.fibRetracements;
            const container = document.getElementById('fib-targets-container');

            if (!container) return;

            const fibData = (currentFibMode === 'extension') ? extData : retData;
            const modeTitle = (currentFibMode === 'extension') ? 'Extension' : 'Retracement';

            if (!fibData || !fibData.levels) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            const isUptrend = fibData.type === 'UP';
            const titleColor = isUptrend ? 'positive' : 'negative';

            let html = `
            <div class="flex justify-between items-center mb-2">
                <h4 class="text-sm font-semibold ${titleColor}">üéØ Fibonacci ${modeTitle} Targets (${fibData.type})</h4>
                <button id="toggle-fibo-mode-btn" class="btn-secondary !text-xs !py-1 !px-3">
                    ${currentFibMode === 'extension' ? 'Show Retracement' : 'Show Extension'}
                </button>
            </div>
        `;

            html += '<div class="grid grid-cols-2 md:grid-cols-3 gap-2 text-xs">';

            for (const key in fibData.levels) {
                const levelName = key.replace('level_', '').replace('.', '_');
                const price = fibData.levels[key];

                html += `
                <div class="flex justify-between items-center p-1 bg-gray-800/50 rounded">
                    <span class="font-semibold text-gray-300">${levelName.replace('_', '.')}</span>
                    <span class="font-mono ${titleColor}">${formatPrice(price)}</span>
                </div>
            `;
            }

            html += '</div>';
            container.innerHTML = html;

            const toggleBtn = document.getElementById('toggle-fibo-mode-btn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    currentFibMode = (currentFibMode === 'extension') ? 'retracement' : 'extension';
                    displayFibonacciTargets();
                    renderAllCharts();
                });
            }
        }

        function calculateFibonacciRetracement(swing) {
            if (!swing || !swing.A?.price || !swing.B?.price) {
                return null;
            }

            const priceA = parseFloat(swing.A.price);
            const priceB = parseFloat(swing.B.price);

            if (isNaN(priceA) || isNaN(priceB)) {
                return null;
            }

            const impulseMove = Math.abs(priceB - priceA);
            const retracementLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
            const calculatedLevels = {};

            retracementLevels.forEach(level => {
                let targetPrice;
                // Untuk tren NAIK (A rendah, B tinggi), retracement dihitung turun dari B.
                if (swing.type === 'UP') {
                    targetPrice = priceB - (impulseMove * level);
                } else { // 'DOWN' (A tinggi, B rendah), retracement dihitung naik dari B.
                    targetPrice = priceB + (impulseMove * level);
                }
                calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
            });

            return {
                swingPoints: { A: priceA, B: priceB },
                type: swing.type,
                levels: calculatedLevels
            };
        }
        // ===============================================================
        // --- FUNGSI UTAMA AI ---
        // ===============================================================
        function extractLSTMFeatures(klines) {
            const LSTM_LOOKBACK_WINDOW = 10;
            const NUM_FEATURES = 12;

            // Pastikan kita punya cukup data historis sebelum window yang kita analisis
            if (!klines || klines.length < LSTM_LOOKBACK_WINDOW + 15) { // Ditambah buffer untuk kalkulasi indikator awal
                console.warn(`[AI PREP] Data tidak cukup untuk ekstraksi fitur LSTM. Perlu > ${LSTM_LOOKBACK_WINDOW + 15}, tersedia: ${klines.length}`);
                return null;
            }

            // Ambil 10 kline terakhir untuk dianalisis sebagai sequence
            const sequenceKlines = klines.slice(-LSTM_LOOKBACK_WINDOW);
            if (sequenceKlines.length !== LSTM_LOOKBACK_WINDOW) return null;

            // Ambil data historis yang lebih panjang untuk kalkulasi indikator yang akurat
            const historicalKlines = klines.slice(-(LSTM_LOOKBACK_WINDOW + 20)); // Ambil 30 candle terakhir
            const historicalCloses = historicalKlines.map(k => parseFloat(k[4]));

            // --- PERBAIKAN UTAMA: Hitung semua indikator SEKALI saja pada data historis ---
            const rsiValues = calculateRSI(historicalCloses, 5);
            const macdData = calculateMACD(historicalCloses, 5, 8, 3);
            const bbData = calculateBollingerBands(historicalCloses, 5);
            const emaValues = calculateEMA(historicalCloses, 5);
            const stochRsiData = calculateStochasticRSI(rsiValues, 5, 5, 3, 3);

            // Ambil 10 nilai terakhir dari setiap hasil indikator
            const last10_RSI = rsiValues.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_MACD_Line = macdData.macdLine.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_MACD_Sig = macdData.signalLine.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_MACD_Hist = macdData.histogram.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_BB_Upper = bbData.upper.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_BB_Lower = bbData.lower.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_BB_Middle = bbData.middle.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_EMA = emaValues.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_StochK = stochRsiData.kLine.slice(-LSTM_LOOKBACK_WINDOW);
            const last10_StochD = stochRsiData.dLine.slice(-LSTM_LOOKBACK_WINDOW);

            let sequenceData = [];

            // Loop 10 kali untuk membangun setiap langkah dalam sequence
            for (let j = 0; j < LSTM_LOOKBACK_WINDOW; j++) {
                const klineForJ = sequenceKlines[j];
                const closeJ = parseFloat(klineForJ[4]);

                // Kalkulasi ATR & VWAP pada snapshot yang relevan hingga titik 'j'
                const klinesUpToJ = klines.slice(0, klines.length - LSTM_LOOKBACK_WINDOW + j + 1);
                const vwap_j = calculateVWAP(klinesUpToJ, 5);
                const atr_j = calculateATR(klinesUpToJ, 5).atrPercent;

                // Ambil nilai indikator yang sudah dihitung sebelumnya
                const rsi_j = last10_RSI[j] || 0;
                const ema_j = last10_EMA[j] || 0;
                const macd_line_j = last10_MACD_Line[j] || 0;
                const signal_line_j = last10_MACD_Sig[j] || 0;
                const macd_hist_j = last10_MACD_Hist[j]?.value || 0;
                const bb_upper_j = last10_BB_Upper[j] || closeJ;
                const bb_lower_j = last10_BB_Lower[j] || closeJ;
                const bb_middle_j = last10_BB_Middle[j] || closeJ;
                const k_j = last10_StochK[j] || 0;
                const d_j = last10_StochD[j] || 0;

                // --- Fitur Turunan (Derived Features) ---
                const macd_cross_j = (macd_line_j > signal_line_j) ? 1 : -1;
                const ema_dist_j = (ema_j > 0) ? (closeJ - ema_j) / ema_j : 0;
                const bb_width_j = (bb_middle_j > 0) ? (bb_upper_j - bb_lower_j) / bb_middle_j : 0;
                const bb_pos_j = (bb_upper_j - bb_lower_j) > 0 ? (closeJ - bb_lower_j) / (bb_upper_j - bb_lower_j) : 0.5;
                const vwap_dist_j = (vwap_j > 0) ? (closeJ - vwap_j) / vwap_j : 0;

                const prev_k = (j > 0) ? last10_StochK[j - 1] || 0 : 0;
                const prev_d = (j > 0) ? last10_StochD[j - 1] || 0 : 0;
                const stoch_cross_j = (prev_k <= prev_d && k_j > d_j) ? 1 : ((prev_k >= prev_d && k_j < d_j) ? -1 : 0);
                const stoch_state_j = (k_j > 80 && d_j > 80) ? 1 : ((k_j < 20 && d_j < 20) ? -1 : 0);

                // Kumpulkan semua 12 fitur menjadi satu array
                const featureArray = [
                    rsi_j, macd_cross_j, macd_hist_j, ema_dist_j,
                    bb_width_j, bb_pos_j, vwap_dist_j, atr_j,
                    k_j, d_j, stoch_cross_j, stoch_state_j
                ].map(v => isFinite(v) ? v : 0); // Pastikan tidak ada nilai non-numerik

                if (featureArray.length === NUM_FEATURES) {
                    sequenceData.push(featureArray);
                }
            }

            // Hanya kembalikan jika sequence lengkap (10 langkah)
            if (sequenceData.length === LSTM_LOOKBACK_WINDOW) {
                return sequenceData;
            }

            return null; // Kembalikan null jika gagal, ini akan memicu FALLBACK
        }

        async function loadRegimeSensorModel() {
            if (regimeSensorModel || typeof tf === 'undefined') {
                document.getElementById('ai-status').textContent = 'SIAP (Bunglon)';
                return;
            }

            console.log("üß† Memuat Model Sensor Rezim (vFinal)...");
            try {
                const base64Handler = {
                    load: async () => {
                        const modelArtifacts = JSON.parse(MODEL_ARTIFACTS_JSON_STRING);
                        const binaryString = window.atob(WEIGHTS_BASE64_STRING);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const weightData = bytes.buffer;

                        return {
                            modelTopology: modelArtifacts.modelTopology,
                            weightSpecs: modelArtifacts.weightsManifest[0].weights,
                            weightData: weightData
                        };
                    }
                };

                regimeSensorModel = await tf.loadLayersModel(base64Handler);
                console.log('‚úÖ Model Sensor Rezim berhasil dimuat dan siap bekerja!');
                document.getElementById('ai-status').textContent = 'SIAP (TF.js)';

            } catch (error) {
                console.error("‚ùå GAGAL memuat Model Sensor Rezim:", error);
                document.getElementById('ai-status').textContent = 'ERROR';
                regimeSensorModel = null;
            }
        }

        function calculatePredictionInput(klinesSnapshot) {
            if (klinesSnapshot.length < 50 || typeof tf === 'undefined') return null;
            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            const currentClose = closes[closes.length - 1];
            const rsiValues = calculateRSI(closes, 14);
            const stochRsiData = calculateStochasticRSI(closes);
            const macdData = calculateMACD(closes);
            const bbData = calculateBollingerBands(closes);
            const vwap = calculateVWAP(klinesSnapshot, 20);
            const atrData = calculateATR(klinesSnapshot);
            const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
            const lastK = stochRsiData.kLine.filter(v => v !== undefined).pop() || 50;
            const lastD = stochRsiData.dLine.filter(v => v !== undefined).pop() || 50;
            const prevK = stochRsiData.kLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
            const prevD = stochRsiData.dLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
            const macdLine = macdData.macdLine.filter(v => v !== undefined).pop() || 0;
            const signalLine = macdData.signalLine.filter(v => v !== undefined).pop() || 0;
            const macdHist = macdData.histogram.filter(v => v !== undefined).pop()?.value || 0;
            const ema50 = calculateEMA(closes, 50).pop() || currentClose;
            const bbUpper = bbData.upper.filter(v => v !== undefined).pop() || currentClose;
            const bbLower = bbData.lower.filter(v => v !== undefined).pop() || currentClose;
            const bbMiddle = bbData.middle.filter(v => v !== undefined).pop() || currentClose; // Perlu untuk BB width

            const features = {
                rsi: lastRsi,
                macd_cross: macdLine > signalLine ? 1 : -1,
                macd_hist: macdHist,
                ema_dist: (currentClose - ema50) / ema50,
                bb_width: (bbUpper - bbLower) / bbMiddle,
                bb_pos: (bbUpper - bbLower) > 0 ? (currentClose - bbLower) / (bbUpper - bbLower) : 0.5,
                vwap_dist: vwap > 0 ? (currentClose - vwap) / vwap : 0,
                atr_percent: atrData.atrPercent,
                stoch_rsi_k: lastK,
                stoch_rsi_d: lastD,
                stoch_rsi_cross: (prevK <= prevD && lastK > lastD) ? 1 : ((prevK >= prevD && lastK < lastD) ? -1 : 0),
                stoch_rsi_state: (lastK > 80 && lastD > 80) ? 1 : ((lastK < 20 && lastD < 20) ? -1 : 0)
            };

            const featureOrder = ['rsi', 'macd_cross', 'macd_hist', 'ema_dist', 'bb_width', 'bb_pos', 'vwap_dist', 'atr_percent', 'stoch_rsi_k', 'stoch_rsi_d', 'stoch_rsi_cross', 'stoch_rsi_state'];
            const inputArray = featureOrder.map(key => features[key] || 0);

            if (inputArray.some(val => !isFinite(val))) {
                return null;
            }
            return inputArray;
        }

        async function predictMarketRegime(klinesSnapshot) {
            const featureSequence = extractLSTMFeatures(klinesSnapshot);
            const LSTM_LOOKBACK_WINDOW = 10;
            const NUM_FEATURES = 12;

            if (!regimeSensorModel || !featureSequence || featureSequence.length !== LSTM_LOOKBACK_WINDOW) {
                return 'RANGING'; // Fallback aman
            }

            // Mengubah array 2D [10, 12] menjadi Tensor 3D [1, 10, 12]
            return tf.tidy(() => {
                const inputTensor = tf.tensor3d([featureSequence], [1, LSTM_LOOKBACK_WINDOW, NUM_FEATURES]);
                const prediction = regimeSensorModel.predict(inputTensor);
                const predictedClassIndex = prediction.argMax(-1).dataSync()[0];
                const predictedLabel = REGIME_LABELS[predictedClassIndex];
                return predictedLabel || 'RANGING';
            });
        }

        function getRegimeColorClass(key) {
            switch (key) {
                case 'BULL_TREND': return 'text-green-400';
                case 'BEAR_TREND': return 'text-red-400';
                case 'RANGING': return 'text-yellow-400';
                case 'LOW_VOLATILITY': return 'text-blue-400';
                default: return 'text-gray-500';
            }
        }
        // BAGIAN 4: DEFINISI FUNGSI-FUNGSI
        // 
        function getTimeAgo(date) {
            if (!(date instanceof Date) || isNaN(date)) {
                return 'beberapa saat lalu';
            }
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 0) return 'baru saja';
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " tahun lalu";
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " bulan lalu";
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " hari lalu";
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " jam lalu";
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " menit lalu";
            return Math.floor(seconds) + " detik lalu";
        }
        // 
        function getExplorerUrl(networkName) {
            const explorerMap = {
                'eth': 'https://etherscan.io',
                'ethereum': 'https://etherscan.io',
                'solana': 'https://solscan.io',
                'bsc': 'https://bscscan.com',
                'arbitrum': 'https://arbiscan.io',
                'base': 'https://basescan.org'
            };
            const baseUrl = explorerMap[networkName] || `https://${networkName}.info`;
            // Kembalikan URL terpisah untuk dompet dan transaksi
            return {
                address: `${baseUrl}/address/`,
                tx: `${baseUrl}/tx/`
            };
        }
        // 
        function getHolderCategory(usdValue) {
            if (usdValue >= 500000) return { name: 'Humpback', class: 'text-purple-400' };
            if (usdValue >= 100000) return { name: 'Whale', class: 'text-blue-400' };
            if (usdValue >= 50000) return { name: 'Tuna', class: 'text-teal-400' };
            if (usdValue >= 10000) return { name: 'Dolphin', class: 'text-cyan-400' };
            if (usdValue >= 1000) return { name: 'Crab', class: 'text-yellow-400' };
            return { name: 'Shrimp', class: 'text-gray-400' };
        }

        function setButtonState(button, isLoading, text = null) {
            const btnText = button.querySelector('span');
            const btnLoader = button.querySelector('.loader');

            button.disabled = isLoading;
            if (btnText) btnText.classList.toggle('hidden', isLoading);
            if (btnLoader) btnLoader.classList.toggle('hidden', !isLoading);

            if (text && btnText && !isLoading) {
                btnText.textContent = text;
            }
        }
        // 
        function getSignClass(value, positiveClass = 'positive', negativeClass = 'negative') {
            return value >= 0 ? positiveClass : negativeClass;
        }
        //        
        function startCandleCountdown() {
            if (candleCountdownInterval) clearInterval(candleCountdownInterval);

            const countdownContainer = document.getElementById('candle-countdown-container');
            const countdownBar = document.getElementById('candle-countdown-bar');
            const klines = realtimeCache.main.klines;

            if (!klines || klines.length === 0) {
                countdownContainer.classList.add('hidden');
                return;
            }

            countdownContainer.classList.remove('hidden');

            const lastCandle = klines[klines.length - 1];
            const candleOpenTime = lastCandle[0];
            const candleCloseTime = lastCandle[6];
            const candleDuration = candleCloseTime - candleOpenTime;

            // Set interval untuk update bar setiap detik
            candleCountdownInterval = setInterval(() => {
                const now = Date.now();

                // Jika waktu saat ini sudah melewati waktu tutup candle
                if (now > candleCloseTime) {
                    countdownBar.style.width = '100%';
                    clearInterval(candleCountdownInterval);
                    return;
                }

                const elapsedTime = now - candleOpenTime;
                const percentage = (elapsedTime / candleDuration) * 100;

                countdownBar.style.width = `${Math.min(100, percentage)}%`;

            }, 1000); // Update setiap 1 detik
        }
        // 
        function adaptIndicatorParamsToTimeframe(timeframe) {
            const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];

            userSettings.active.indicatorParams = { ...userSettings.presets['default'].indicatorParams, ...params };

            document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
            document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
            document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
            document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
            document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
            document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
            document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
            document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;
        }
        // 
        function applyPreset(presetName) {
            if (!userSettings.presets[presetName]) return;

            userSettings.active.weights = { ...userSettings.presets['default'].weights, ...userSettings.presets[presetName].weights };

            document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
            document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
            document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;

            if (realtimeCache.main.calculatedData) {
                updateQuickConfluenceWidget();
            }
        }
        // 
        function debounce(func, delay) {
            let timeout;
            return function (...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }
        // 
        function determineMarketRegime(klines, closes) {
            if (!klines || klines.length < 200) {
                return { regime: 'RANGING', reason: 'Data kurang' };
            }

            const adxData = calculateADX(klines, 14);
            const ema200 = calculateEMA(closes, 200).pop();
            const lastPrice = closes[closes.length - 1];

            const isTrending = parseFloat(adxData.adx) > 25;

            if (isTrending) {
                if (lastPrice > ema200) {
                    return { regime: 'TRENDING_UP', reason: `ADX (${adxData.adx}) > 25 & Harga > EMA 200` };
                } else {
                    return { regime: 'TRENDING_DOWN', reason: `ADX (${adxData.adx}) > 25 & Harga < EMA 200` };
                }
            } else {
                return { regime: 'RANGING', reason: `ADX (${adxData.adx}) < 25` };
            }
        }
        // 
        function displaySentimentDataInDashboard(data) {
            const container = document.getElementById('sentiment-display-container');

            const netflowClass = data.netflow < 0 ? 'positive' : 'negative';
            const netflowText = data.netflow < 0 ? `Outflow (Bullish)` : `Inflow (Bearish)`;

            const oiClass = data.oiChange > 0 ? 'positive' : 'negative';
            const oiText = data.oiChange > 0 ? `Naik` : `Turun`;

            const fundingClass = Math.abs(data.fundingRate) > 0.02 ? 'negative' : 'text-gray-400';
            const fundingText = Math.abs(data.fundingRate) > 0.02 ? `Ekstrem` : `Sehat`;

            const lsParts = data.lsRatio24h.split('/');
            const longRatio = parseFloat(lsParts[0]);
            const shortRatio = parseFloat(lsParts[1]);
            const lsClass = longRatio > shortRatio ? 'positive' : (shortRatio > longRatio ? 'negative' : 'text-gray-400');
            const lsText = longRatio > shortRatio ? `Dominan Long` : (shortRatio > longRatio ? `Dominan Short` : `Seimbang`);

            container.innerHTML = `
            <h3 class="text-lg font-bold mb-4 text-center">üå°Ô∏è Sentimen Pasar (via AI)</h3>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between items-center"><span class="text-gray-400">Aliran Bursa (Netflow BTC)</span><span class="font-bold ${netflowClass}">${data.netflow.toFixed(2)} BTC (${netflowText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Perubahan Open Interest</span><span class="font-bold ${oiClass}">${data.oiChange.toFixed(2)}% (${oiText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rata-rata Funding Rate</span><span class="font-bold ${fundingClass}">${(data.fundingRate * 100).toFixed(4)}% (${fundingText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rasio Long/Short (24j)</span><span class="font-bold ${lsClass}">${data.lsRatio24h} (${lsText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Likuidasi (Long vs Short)</span><span class="font-bold text-gray-200">${data.liquidations}</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">MVRV Z-Score</span><span class="font-bold text-yellow-400">${data.mvrv_z_score.toFixed(2)}</span></div>
                <p class="text-center text-xs text-gray-500 pt-2">Data diambil oleh AI pada: ${new Date().toLocaleTimeString('id-ID')}</p>
            </div>
        `;
        }
        // 
        function saveSettings() {
            userSettings.active.indicatorParams.rsi_period = parseInt(document.getElementById('setting-rsi-period').value);
            userSettings.active.indicatorParams.macd_fast = parseInt(document.getElementById('setting-macd-fast').value);
            userSettings.active.indicatorParams.macd_slow = parseInt(document.getElementById('setting-macd-slow').value);
            userSettings.active.indicatorParams.macd_signal = parseInt(document.getElementById('setting-macd-signal').value);

            userSettings.active.weights.rsiDivergence = parseFloat(document.getElementById('setting-weight-divergence').value);
            userSettings.active.weights.macd = parseFloat(document.getElementById('setting-weight-macd').value);
            userSettings.active.weights.obvDivergence = parseFloat(document.getElementById('setting-weight-obv-divergence').value);

            localStorage.setItem('ultimateAppSettings', JSON.stringify(userSettings.active));
            const msgEl = document.getElementById('settings-saved-msg');
            msgEl.classList.remove('hidden');
            setTimeout(() => msgEl.classList.add('hidden'), 2000);
        }
        // 
        function loadSettings() {
            const savedActiveSettings = localStorage.getItem('ultimateAppSettings');

            applyPreset('default');

            if (savedActiveSettings) {
                try {
                    const parsed = JSON.parse(savedActiveSettings);
                    if (parsed.weights) userSettings.active.weights = { ...userSettings.active.weights, ...parsed.weights };
                    if (parsed.indicatorParams && Object.keys(parsed.indicatorParams).length > 0) {
                        userSettings.active.indicatorParams = { ...userSettings.active.indicatorParams, ...parsed.indicatorParams };
                    }
                } catch (e) {
                    console.error("Gagal parse pengaturan.", e);
                }
            }

            if (Object.keys(userSettings.active.indicatorParams).length === 0) {
                adaptIndicatorParamsToTimeframe(timeframeSelect.value);
            }

            document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
            document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
            document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
            document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
            document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
            document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
            document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
            document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;
            document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
            document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
            document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;
        }
        // 
        function showError(message) {
            assetError.textContent = message;
            assetError.classList.remove('hidden');
        }
        // 
        function hideError() {
            assetError.classList.add('hidden');
        }
        // 
        function showLoader(show, text = '') {
            if (show) {
                loaderText.textContent = text;
                loaderOverlay.classList.remove('hidden');
                loaderOverlay.classList.add('flex');
            } else {
                loaderOverlay.classList.add('hidden');
                loaderOverlay.classList.remove('flex');
            }
            setButtonState(analyzeBtn, show);
        }
        // 
        function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
            const button = document.getElementById(buttonId);
            const contentWrapper = document.getElementById(contentWrapperId);
            const icon = document.getElementById(iconId);
            if (!button || !contentWrapper || !icon) {
                console.error('Elemen toggle tidak ditemukan untuk:', buttonId);
                return;
            }
            contentWrapper.classList.add('collapsible-content');
            const applyState = (isVisible) => {
                if (isVisible) {
                    contentWrapper.classList.add('expanded');
                    icon.style.transform = 'rotate(0deg)';
                } else {
                    contentWrapper.classList.remove('expanded');
                    icon.style.transform = 'rotate(-90deg)';
                }
            };
            let isVisible = startVisible;
            applyState(isVisible);
            button.addEventListener('click', () => {
                isVisible = !isVisible;
                applyState(isVisible);
            });
        }
        // 
        function adjustContentPadding() {
            if (navWrapper && mainContent) {
                const navHeight = navWrapper.offsetHeight;
                mainContent.style.paddingTop = `${navHeight}px`;
            }
        }
        // 
        const formatPrice = (price) => {
            if (typeof price !== 'number' || isNaN(price)) {
                return price;
            }

            if (price >= 1) {
                return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            }
            const priceString = price.toString();
            const decimalPart = priceString.includes('.') ? priceString.split('.')[1] : '';
            if (decimalPart.length === 0) return `$${price.toFixed(2)}`;

            let nonZeroIndex = -1;
            for (let i = 0; i < decimalPart.length; i++) {
                if (decimalPart[i] !== '0') {
                    nonZeroIndex = i;
                    break;
                }
            }
            if (nonZeroIndex !== -1) {
                const significantDigits = 4;
                return `$${price.toFixed(nonZeroIndex + significantDigits)}`;
            }
            return `$${price.toFixed(8)}`;
        };
        // 
        function getPrecisionForAsset(price) {
            if (price === 0) return 2;
            if (price > 1000) return 2;
            if (price > 1) return 4;
            if (price > 0.001) return 7;
            return 8;
        }
        // 
        function getUltimateSignalScore(indicator, signalData) {
            const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
            const mapRange = (x, inMin, inMax, outMin, outMax) => {
                const t = (x - inMin) / (inMax - inMin);
                return outMin + clamp(t, 0, 1) * (outMax - outMin);
            };
            const confidence = (typeof signalData?.confidence === 'number')
                ? clamp(signalData.confidence, 0, 1)
                : 1;
            const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
            const biasSigned = (typeof signalData?.biasSigned === 'number')
                ? Math.sign(signalData.biasSigned)
                : null;

            if (['ma', 'macd', 'rsi', 'stoch', 'psar', 'linreg', 'roc', 'pivot', 'vwap', 'ichimoku', 'candlePattern', 'bollingerBands'].includes(indicator)) {
                if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;

                if (text.includes('OVERSOLD')) return +1 * confidence;
                if (text.includes('OVERBOUGHT')) return -1 * confidence;

                if (text.includes('BULL')) return +1 * confidence;
                if (text.includes('BEAR')) return -1 * confidence;
                return 0;
            }

            if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
                if (text.includes('BULL')) return +1 * confidence;
                if (text.includes('BEAR')) return -1 * confidence;
                return 0;
            }

            if (indicator === 'openInterest') {
                if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
                if (text.includes('UP')) return +1 * confidence;
                if (text.includes('DOWN')) return -1 * confidence;
                return 0;
            }

            if (indicator === 'funding' || indicator === 'fundingRate') {
                const v = typeof signalData?.value === 'number' ? signalData.value : 0; // ex: 0.0005 = 0.05%
                const s = Math.max(-1, Math.min(1, v / 0.0025));
                return s * confidence;
            }

            if (indicator === 'lsr' || indicator === 'lsRatio') {
                const v = typeof signalData?.value === 'number' ? signalData.value : 1;
                const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
                return s * confidence;
            }

            if (indicator === 'orderBookBias') {
                if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
                if (text.includes('BID')) return +1 * confidence;
                if (text.includes('ASK')) return -1 * confidence;
                return 0;
            }

            if (indicator === 'bbSqueeze') {
                const st = (signalData?.status || '').toString().toUpperCase();
                if (st.includes('RELEASE')) return +1 * confidence;
                if (st.includes('ON')) return 0;
                if (st.includes('OFF')) return 0.3 * confidence;
                return 0;
            }

            return 0;
        }
        // 
        async function updateQuickConfluenceWidget() {
            //console.log('üèÅ CHECKPOINT 3: Entering updateQuickConfluenceWidget. Data received:', realtimeCache.main.calculatedData);        
            const data = realtimeCache.main.calculatedData;
            // Safety check: Pastikan data kalkulasi sudah siap
            if (!data || !data.marketRegime) {
                return;
            }

            // --- 1. DAPATKAN REZIM DARI HASIL PREDIKSI AI ---
            // (Dengan asumsi `recalculateAllIndicators` sudah di-upgrade untuk memanggil AI)
            const currentRegime = data.marketRegime; // Contoh: 'BULL_TREND'

            // --- 2. PILIH BOBOT STRATEGI SESUAI REZIM ---
            // Konversi 'BULL_TREND' (dari AI) menjadi 'bullTrend' (untuk kunci objek)
            const regimeWeightsKey = currentRegime.toLowerCase().replace(/_(\w)/g, (match, letter) => letter.toUpperCase());
            const regimeWeights = userSettings.presets[regimeWeightsKey]?.weights || {};
            const activeWeights = { ...userSettings.presets['default'].weights, ...regimeWeights };

            // --- 3. KALKULASI SKOR BULL vs BEAR (Logika ini tetap sama seperti di index.html Anda) ---
            const marketType = marketTypeSelect.value;
            const mtfAlignmentScore = realtimeCache.main.tfAlignmentSummary?.score || 0;
            const mtfMultiplier = 1 + (Math.abs(mtfAlignmentScore) / 4) * 0.25;

            let totalBullScore = 0;
            let totalBearScore = 0;
            let maxPossibleScore = 0;

            for (const indicator in activeWeights) {
                if (['fundingRate', 'lsRatio', 'openInterest'].includes(indicator) && marketType !== 'futures') continue;

                const weight = activeWeights[indicator] || 0;
                const signalData = indicator === 'bbSqueeze' ? data.bollingerBands : data[indicator];

                if (signalData) {
                    const rawScore = getUltimateSignalScore(indicator, signalData);

                    let finalWeight = weight;
                    if (rawScore > 0 && mtfAlignmentScore > 0) finalWeight *= mtfMultiplier;
                    else if (rawScore < 0 && mtfAlignmentScore < 0) finalWeight *= mtfMultiplier;

                    const weightedScore = rawScore * finalWeight;

                    if (weightedScore > 0) totalBullScore += weightedScore;
                    if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                }
                maxPossibleScore += Math.abs(weight);
            }

            const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
            const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;

            realtimeCache.main.quickConfluenceScore = { score: bullPercentage - bearPercentage, bull: bullPercentage, bear: bearPercentage };

            document.getElementById('quick-finalBullishScore').textContent = `${bullPercentage.toFixed(0)}% üêÇ`;
            document.getElementById('quick-finalBearishScore').textContent = `üêª ${bearPercentage.toFixed(0)}%`;
            const totalStrength = bullPercentage + bearPercentage;
            const bullWidthPercentage = totalStrength > 0 ? (bullPercentage / totalStrength) * 100 : 50;
            document.getElementById('quick-confluenceBarBullish').style.width = `${bullWidthPercentage}%`;
            document.getElementById('quick-confluenceBarBearish').style.width = `${100 - bullWidthPercentage}%`;

            // --- 4. TAMPILKAN HASIL KE UI ---
            const container = document.getElementById('verdict-and-regime-container');
            if (!container) return;

            const { text: verdict, class: verdictClass } = generateShortVerdict(bullPercentage, bearPercentage);
            const mtfScoreText = mtfAlignmentScore > 0 ? `+${mtfAlignmentScore}` : mtfAlignmentScore;
            const mtfHtml = `<div class="text-xs text-center text-gray-400 mt-2">Multi-Timeframe Trend Confirmation: <span class="font-bold ${mtfAlignmentScore > 0 ? 'positive' : (mtfAlignmentScore < 0 ? 'negative' : '')}">${mtfScoreText}</span></div>`;
            const verdictHtml = `<p class="font-semibold">${verdict} <span class="text-sm font-mono ${verdictClass}">(${(bullPercentage - bearPercentage).toFixed(0)})</span></p>${mtfHtml}`;

            const tensionScore = Math.min(100, bullPercentage + bearPercentage);
            let tensionText = "Low";
            if (tensionScore > 50) tensionText = "Medium";
            if (tensionScore > 75) tensionText = "High";
            if (tensionScore > 90) tensionText = "Extreme";
            const tensionHtml = `
            <div class="text-xs">
                <span class="text-gray-400">Market Tension: <strong>${tensionText}</strong> (${tensionScore.toFixed(0)}/100)</span>
                <div class="tension-bar-bg">
                    <div class="tension-bar-fill" style="width: ${tensionScore}%;"></div>
                </div>
            </div>
        `;

            // BARU: Logika untuk menampilkan rezim dari AI
            const regimeInfo = {
                'BULL_TREND': { text: "BULL TREND", icon: "üêÇ", class: "status-uptrend" },
                'BEAR_TREND': { text: "BEAR TREND", icon: "üêª", class: "status-downtrend" },
                'RANGING': { text: "RANGING", icon: "üêí", class: "status-chop" },
                'LOW_VOLATILITY': { text: "LOW VOLATILITY", icon: "ü™´", class: "status-lowvolatility" }
            };
            const activeRegime = regimeInfo[currentRegime] || { text: "UNKNOWN", icon: "‚ùì", class: "text-gray-500" };
            const regimeHtml = `<div class="text-xs font-mono">[ Active Model: <span class="${activeRegime.class} font-bold">${activeRegime.icon} ${activeRegime.text}</span> ]</div>`;

            container.innerHTML = verdictHtml + tensionHtml + regimeHtml;

            analyzeAndDisplayConfluenceContributors();
            const regimeDisplayEl = document.getElementById('active-regime-display');
            const regimeStatusEl = document.getElementById('ai-status');

            if (regimeDisplayEl && regimeStatusEl) {
                regimeStatusEl.textContent = 'SIAP (TF.js)'; // Pastikan status AI benar
                regimeDisplayEl.textContent = currentRegime.replace(/_/g, ' ');

                // Gunakan fungsi helper baru untuk mengubah warna teks sesuai rezim
                const colorClass = getRegimeColorClass(currentRegime);
                regimeDisplayEl.className = `font-bold text-base ${colorClass}`;
            }
        }
        // 
        function updateCvdTableLive() {
            const tableBody = document.getElementById('cvd-table-body');
            if (!tableBody || liveCvdData.length === 0) return;

            const lastDataPoint = liveCvdData[liveCvdData.length - 1];
            const newRow = tableBody.insertRow(0);
            const date = new Date(lastDataPoint.x);
            const formattedTime = date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            const prevUsdt = liveCvdData.length > 1 ? liveCvdData[liveCvdData.length - 2].y_usdt : 0;
            const colorClass = lastDataPoint.y_usdt > prevUsdt ? 'positive' : 'negative';

            newRow.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${formattedTime}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">${lastDataPoint.y_coin.toFixed(4)}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">$${lastDataPoint.y_usdt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        `;

            while (tableBody.rows.length > 5) {
                tableBody.deleteRow(tableBody.rows.length - 1);
            }
        }
        // 
        async function updateRealTimeIndicators(klines) {
            if (!klines || klines.length < 50) return;
            realtimeCache.main.calculatedData = await recalculateAllIndicators(
                klines,
                realtimeCache.main.tickerData,
                null,
                marketTypeSelect.value,
                realtimeCache.main.cvdData,
                realtimeCache.main.orderBookData,
                realtimeCache.main.fundingRateData,
                realtimeCache.main.lsRatioUmumData,
                realtimeCache.main.openInterestData
            );
            //console.log('‚úÖ CHECKPOINT 2: calculatedData received. Has marketRegime property?', realtimeCache.main.calculatedData.hasOwnProperty('marketRegime'));
            populateCurrentStateWidget();
            populateConfluenceDetailsWidget();
            await updateQuickConfluenceWidget();
            calculateAndDisplayScalpingSetup();
        }
        // 
        async function updatePeriodicData() {
            try {
                const binanceSymbol = realtimeCache.main.binanceSymbol;
                if (!binanceSymbol || marketTypeSelect.value !== 'futures') return;

                const [lsRatioUmumData, lsRatioTopData] = await Promise.all([
                    fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                    fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
                ]);

                realtimeCache.main.lsRatioUmumData = lsRatioUmumData;
                realtimeCache.main.lsRatioTopData = lsRatioTopData;

                if (lsRatioUmumData?.[0]) {
                    document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
                }
                if (lsRatioTopData?.[0]) {
                    document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
                }

            } catch (error) {
                console.error("Gagal memperbarui data periodik:", error);
            }
        }
        // 
        async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
            const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
            const query = new URLSearchParams(params).toString();
            const url = `${baseUrl}/${endpoint}?${query}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorData = await response.json();
                    const errorMessage = `Binance API error for ${endpoint} (${marketType}): ${errorData.msg || response.statusText}`;
                    throw new Error(errorMessage);
                }
                return response.json();
            } catch (error) {
                console.error(`Network Error fetching from ${url}: ${error.message}`);
                throw new Error(`Gagal mengambil data untuk ${endpoint} dari Binance ${marketType.toUpperCase()}.`);
            }
        }
        // 
        async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
            const params = { symbol, startTime, endTime, limit: 1000 };
            return await fetchBinanceAPIData('aggTrades', params, marketType);
        }
        // 
        async function fetchCoinGeckoData(coinId) {
            if (!coinId) return null;
            const url = `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`;
            try {
                const response = await fetch(url);
                if (!response.ok) return null;
                return response.json();
            } catch (error) { return null; }
        }
        // 
        async function getCoinGeckoId(baseAssetSymbol) {
            if (!coinListCache) {
                const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
                if (!response.ok) throw new Error('Gagal unduh daftar koin CoinGecko.');
                coinListCache = await response.json();
            }
            const assetSymbolLower = baseAssetSymbol.toLowerCase();
            const priorityMap = {
                'btc': 'bitcoin', 'eth': 'ethereum', 'bnb': 'binancecoin', 'weth': 'wrapped-ether',
                'sol': 'solana', 'wbtc': 'wrapped-bitcoin', 'uni': 'uniswap', 'shib': 'shiba-inu',
                'pepe': 'pepe', 'cross': 'cross-2', 'ada': 'cardano', 'xrp': 'ripple', 'ava': 'avant-usd', 'ethw': 'ethereum-pow-iou',
                'avax': 'avalanche-2'
            };
            if (priorityMap[assetSymbolLower]) return priorityMap[assetSymbolLower];

            let match = coinListCache.find(coin => coin.symbol === assetSymbolLower);
            if (match) return match.id;

            try {
                const searchResult = await fetchGeckoTerminal(`search/pools?query=${baseAssetSymbol}`);
                if (searchResult.data && searchResult.data.length > 0) {
                    const topResult = searchResult.data[0];
                    if (topResult.relationships.base_token.data.id) {
                        const coinId = topResult.relationships.base_token.data.id.split('_')[1];
                        if (coinId) return coinId;
                    }
                }
            } catch (e) { console.error("Pencarian cerdas gagal:", e); }

            throw new Error(`Simbol "${baseAssetSymbol}" tidak ditemukan di CoinGecko.`);
        }
        // 
        async function initializeExchangeInfo(marketType) {
            if (exchangeInfoCache[marketType]) return;
            const url = marketType === 'spot' ? 'https://api.binance.com/api/v3/exchangeInfo' : 'https://fapi.binance.com/fapi/v1/exchangeInfo';
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
            const data = await response.json();
            exchangeInfoCache[marketType] = data.symbols;
            if (document.getElementById('market-type-select').value === marketType) {
                populateAssetDatalist(data.symbols, marketType);
            }
        }
        // 
        function populateAssetDatalist(symbols, marketType) {
            const dataList = document.getElementById('asset-list');
            if (!dataList) return;
            dataList.innerHTML = '';
            const filterFn = s => s.quoteAsset === 'USDT' && s.status === 'TRADING' && (marketType === 'spot' || s.contractType === 'PERPETUAL');
            symbols.filter(filterFn).sort((a, b) => a.symbol.localeCompare(b.symbol)).forEach(s => {
                const option = document.createElement('option');
                option.value = s.symbol;
                dataList.appendChild(option);
            });
        }
        // 
        async function validateBinanceSymbol(symbol, marketType) {
            if (!exchangeInfoCache[marketType]) {
                await initializeExchangeInfo(marketType);
            }

            const symbolData = exchangeInfoCache[marketType].find(s => s.symbol === symbol);
            if (!symbolData || symbolData.status !== 'TRADING') {
                throw new Error(`Simbol "${symbol}" tidak valid atau tidak aktif di Binance ${marketType}.`);
            }
        }
        // 
        async function callGemini(parts, isJsonOutput = true) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) throw new Error("PASTE API Key!!!!!!!");
            const model = 'gemini-2.5-flash-preview-05-20';
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts }] };
            if (isJsonOutput) {
                payload.generationConfig = {
                    "response_mime_type": "application/json",
                    "max_output_tokens": 8192
                };
            }
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(`Google AI API error: ${errorBody?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
            throw new Error("Respons dari AI tidak valid atau kosong.");
        }

        function renderTrendingPools(poolsData) {
            let html = '';
            const topPools = poolsData.slice(0, 5);

            topPools.forEach(pool => {
                const attributes = pool.attributes;
                const priceChange = parseFloat(attributes.price_change_percentage.h24);
                const colorClass = priceChange >= 0 ? 'positive' : 'negative';
                const volume = parseFloat(attributes.volume_usd.h24);

                html += `
                <div class="p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                    <div class="flex justify-between items-center font-semibold">
                        <span>${attributes.name}</span>
                        <span class="${colorClass}">${priceChange.toFixed(2)}%</span>
                    </div>
                    <div class="text-xs text-gray-400 flex justify-between mt-1">
                        <span>Vol 24j: $${(volume / 1_000_000).toFixed(2)}jt</span>
                        <span>Jaringan: ${pool.relationships.network.data.id}</span>
                    </div>
                </div>
            `;
            });
            trendingPoolsContent.innerHTML = html;
        }

        async function fetchGeckoTerminal(endpoint) {
            const baseUrl = 'https://api.geckoterminal.com/api/v2';
            const url = `${baseUrl}/${endpoint}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`GeckoTerminal API error: ${errorData.errors?.[0]?.title || response.statusText}`);
                }
                return response.json();
            } catch (error) {
                console.error(`Network Error fetching from GeckoTerminal ${endpoint}: ${error.message}`);
                throw new Error(`Gagal mengambil data dari GeckoTerminal.`);
            }
        }
        // 
        async function runFullAnalysis(symbol = null) {
            isAnalysisRunning = true; // Set analysis flag
            document.getElementById('analyze-asset-btn').classList.add('hidden');
            document.getElementById('stop-analysis-btn').classList.remove('hidden');

            // 1. CLEAR & INITIAL SETUP
            if (candleCountdownInterval) clearInterval(candleCountdownInterval);
            adaptIndicatorParamsToTimeframe(timeframeSelect.value);

            // Setup WebSocket Handlers
            WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
            WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
            WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));

            orderBookDOMElements = null;
            hideError();
            showLoader(true, 'Please Wait! AWACS Engine Running (Optimized).............');
            destroyCharts();
            specificTokenTitle.innerHTML = 'Analisis Token Spesifik';
            specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Mencari data on-chain...</p>`;
            trendingPoolsContent.innerHTML = `<div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div>`;

            try {
                if (!isAnalysisRunning) return; // Check before heavy processing

                const aiContentContainer = document.getElementById('ai-content-container');
                if (aiContentContainer) aiContentContainer.classList.add('hidden');
                const comprehensiveBtn = document.getElementById('toggle-ai-btn');
                if (comprehensiveBtn) {
                    const btnText = comprehensiveBtn.querySelector('span');
                    const btnLoader = comprehensiveBtn.querySelector('.loader');
                    btnText.classList.remove('hidden');
                    btnLoader.classList.add('hidden');
                    comprehensiveBtn.disabled = false;
                }

                const binanceSymbol = (symbol || assetInput.value.trim() || 'BTCUSDT').toUpperCase();

                if (symbol) {
                    assetInput.value = symbol;
                }

                const correlationAsset = document.getElementById('correlation-asset-input').value.trim().toUpperCase() || 'BTCUSDT';
                const marketType = marketTypeSelect.value;
                const selectedTimeframe = timeframeSelect.value;

                await validateBinanceSymbol(binanceSymbol, marketType);

                if (!isAnalysisRunning) return; // Checkpoint

                showLoader(true, 'Fetching Market Data...');
                const baseAsset = binanceSymbol.replace(/USDT$|^\d+/g, '');

                let promisesToRun = [
                    fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: selectedTimeframe, limit: 1000 }, marketType),
                    fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1h', limit: 500 }, marketType),
                    fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '15m', limit: 500 }, marketType),
                    fetchBinanceAPIData('ticker/24hr', { symbol: binanceSymbol }, marketType),
                    fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 500 }, marketType),
                    fetchBinanceAPIData('klines', { symbol: correlationAsset, interval: '1d', limit: 500 }, 'spot'),
                    fetchBinanceAPIData('depth', { symbol: binanceSymbol, limit: 100 }, marketType),
                    fetch('https://api.coingecko.com/api/v3/global').then(res => res.json()),
                    (async () => {
                        try {
                            const coinGeckoId = await getCoinGeckoId(baseAsset);
                            return await fetchCoinGeckoData(coinGeckoId);
                        } catch (e) {
                            console.warn(`Gagal mengambil data CoinGecko: ${e.message}`);
                            return null;
                        }
                    })(),
                ];

                if (marketType === 'futures') {
                    promisesToRun.push(
                        fetchBinanceAPIData('openInterest', { symbol: binanceSymbol }, 'futures'),
                        fetchBinanceAPIData('premiumIndex', { symbol: binanceSymbol }, 'futures'),
                        fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                        fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
                    );
                }

                const results = await Promise.allSettled(promisesToRun);
                if (!isAnalysisRunning) return; // Checkpoint after network requests

                const rawKlines = results[0].status === 'fulfilled' ? results[0].value : null;
                if (!rawKlines || rawKlines.length < 550) {
                    throw new Error(`Data historis tidak cukup untuk pemanasan (min 550 candle).`);
                }

                const klines = rawKlines.slice(-500);
                const klines1h = results[1].status === 'fulfilled' ? results[1].value.slice(-200) : null;
                const klines15m = results[2].status === 'fulfilled' ? results[2].value.slice(-200) : null;
                const tickerData = results[3].status === 'fulfilled' ? results[3].value : null;
                const assetDailyKlines = results[4].status === 'fulfilled' ? results[4].value : null;
                const btcDailyKlines = results[5].status === 'fulfilled' ? results[5].value : null;
                const orderBookData = results[6].status === 'fulfilled' ? results[6].value : null;
                const prevDayKline = assetDailyKlines && assetDailyKlines.length >= 2 ? assetDailyKlines[assetDailyKlines.length - 2] : null;

                let openInterestData = null, fundingRateData = null, lsRatioUmumData = null, lsRatioTopData = null;
                if (marketType === 'futures' && results.length > 9) {
                    openInterestData = results[9].status === 'fulfilled' ? results[9].value : null;
                    fundingRateData = results[10].status === 'fulfilled' ? results[10].value : null;
                    lsRatioUmumData = results[11].status === 'fulfilled' ? results[11].value : null;
                    lsRatioTopData = results[12].status === 'fulfilled' ? results[12].value : null;
                }

                const allTrades = await fetchBinanceAPIData('aggTrades', { symbol: binanceSymbol, limit: 1000 }, marketType);
                if (!isAnalysisRunning) return; // Checkpoint
                const cvdData = calculateCVD(allTrades);

                const correlationValue = calculateCorrelation(assetDailyKlines.map(k => parseFloat(k[4])), btcDailyKlines.map(k => parseFloat(k[4])));

                realtimeCache.main = {
                    symbol: binanceSymbol, tickerData, klines, klines1h, klines15m, orderBookData, cvdData,
                    openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData, binanceSymbol,
                    selectedTimeframe, correlationData: correlationValue,
                    globalData: results[7].status === 'fulfilled' ? results[7].value : null,
                    coinGeckoData: results[8].status === 'fulfilled' ? results[8].value : null,
                    multiTfKlines: { [selectedTimeframe]: klines },
                    liveScores: { pumpStrength: 0, dumpRisk: 0 }
                };

                showLoader(true, 'Calculating Indicators (Optimizing CPU)...');
                const cacheKey = generateIndicatorCacheKey({ symbol: binanceSymbol, timeframe: selectedTimeframe });

                realtimeCache.main.calculatedData = await fetchOrCalculateIndicators(
                    klines, tickerData, prevDayKline, marketType,
                    realtimeCache.main.cvdData, realtimeCache.main.orderBookData,
                    realtimeCache.main.fundingRateData, realtimeCache.main.lsRatioUmumData,
                    realtimeCache.main.openInterestData,
                    cacheKey, selectedTimeframe
                );
                if (!isAnalysisRunning) return; // Checkpoint

                const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
                realtimeCache.main.tfAlignmentSummary = tfAlignmentSummary;
                realtimeCache.main.marketRegime = determineMarketRegime(klines, klines.map(k => parseFloat(k[4])));
                const swing = findLastSignificantSwing(klines);
                realtimeCache.main.fibExtensions = calculateAdvancedFibonacciExtension(swing);
                realtimeCache.main.fibRetracements = calculateFibonacciRetracement(swing);

                realtimeCache.main.calculatedData.fibExtensions = realtimeCache.main.fibExtensions;
                realtimeCache.main.calculatedData.fibRetracements = realtimeCache.main.fibRetracements;

                await updateDashboardUI();
                startCandleCountdown();
                document.getElementById('scalping-setup-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

                const navPriceEl = document.getElementById('nav-price');
                if (navPriceEl) {
                    navPriceEl.textContent = formatPrice(parseFloat(tickerData.lastPrice));
                }

                if (orderBookData) {
                    latestBids = orderBookData.bids;
                    latestAsks = orderBookData.asks;
                    const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
                    const precision = getPrecisionForAsset(parseFloat(latestPrice));
                    const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
                    renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
                }

                const symbolLower = binanceSymbol.toLowerCase();
                const streamsToSub = [
                    `${symbolLower}@kline_${selectedTimeframe}`,
                    `${symbolLower}@aggTrade`,
                    `${symbolLower}@depth20@100ms`
                ];
                WebSocketManager.subscribe(streamsToSub);

                (async () => {
                    if (!isAnalysisRunning) return;
                    try {
                        const searchQuery = (await getCoinGeckoId(baseAsset).then(id => fetchCoinGeckoData(id)).catch(() => null))?.platforms?.ethereum || baseAsset;
                        specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span>`;
                        const searchResult = await fetchGeckoTerminal(`search/pools?query=${searchQuery}`);
                        if (searchResult.data && searchResult.data.length > 0) {
                            // ... (rest of the on-chain logic remains the same)
                        } else {
                            specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Tidak ditemukan pool on-chain untuk ${baseAsset.toUpperCase()}.</p>`;
                        }
                    } catch (dexError) {
                        specificTokenContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data token spesifik: ${dexError.message}</p>`;
                    }
                })();

                (async () => {
                    if (!isAnalysisRunning) return;
                    try {
                        const trendingData = await fetchGeckoTerminal('networks/trending_pools');
                        renderTrendingPools(trendingData.data);
                    } catch (trendingError) {
                        trendingPoolsContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data trending: ${trendingError.message}</p>`;
                    }
                })();

            } catch (error) {
                console.error("Analisis Gagal:", error);
                showError(error.message);
            } finally {
                isAnalysisRunning = false; // Reset flag
                showLoader(false);
                document.getElementById('analyze-asset-btn').classList.remove('hidden');
                document.getElementById('stop-analysis-btn').classList.add('hidden');

                if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
                if (processingInterval) clearInterval(processingInterval);

                // Only start intervals if analysis completed without being stopped
                if (realtimeCache.main.klines) {
                    periodicUpdateInterval = setInterval(updatePeriodicData, 300000);
                    processingInterval = setInterval(processQueues, 500);
                }
            }
        }
        // ===========end of async function runFullAnalysis(symbol = null) 
        function generateIndicatorCacheKey(settings) {
            // Membuat kunci unik berdasarkan Symbol, Timeframe, dan Parameter utama
            return 'indexIndicatorCache_' + JSON.stringify({
                symbol: settings.symbol,
                timeframe: settings.timeframe,
                rsi: userSettings.active.indicatorParams.rsi_period,
                macd: userSettings.active.indicatorParams.macd_fast
            });
        }

        async function fetchOrCalculateIndicators(klines, tickerData, prevDayKline, marketType, cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData, cacheKey, selectedTimeframe) {

            // 1. Coba baca dari cache
            try {
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    return JSON.parse(cachedData);
                }
            } catch (e) {
                console.warn("Gagal membaca cache, akan melakukan kalkulasi ulang.");
            }

            // 2. Kalkulasi Ulang (jika Cache Miss)
            // ‚ñº‚ñº‚ñº PERBAIKAN KRUSIAL ADA DI SINI ‚ñº‚ñº‚ñº
            const calculatedData = await recalculateAllIndicators(
                klines, tickerData, prevDayKline, marketType,
                cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData
            );
            // ‚ñ≤‚ñ≤‚ñ≤ AKHIR DARI PERBAIKAN ‚ñ≤‚ñ≤‚ñ≤

            // 3. Simpan ke cache
            try {
                localStorage.setItem(cacheKey, JSON.stringify(calculatedData));
            } catch (e) {
                console.error("Gagal menyimpan ke cache (localStorage penuh).", e);
            }

            return calculatedData;
        }
        // 
        async function getConfluenceScoreForSymbol(symbol) {
            try {
                // Sekarang hanya mengambil data ticker 24 jam yang ringan
                const tickerData = await fetchBinanceAPIData('ticker/24hr', { symbol }, 'spot');

                return {
                    symbol,
                    price: parseFloat(tickerData.lastPrice),
                    change24h: parseFloat(tickerData.priceChangePercent),
                };
            } catch (error) {
                console.error(`Gagal memindai ${symbol}:`, error);
                return { symbol, error: error.message };
            }
        }
        // 
        async function runComprehensiveAIAnalysis() {
            if (!realtimeCache.main.tickerData) {
                showError("Jalankan 'GET DATA' terlebih dahulu untuk memuat data.");
                return;
            }

            const comprehensiveBtn = document.getElementById('toggle-ai-btn');
            const btnText = comprehensiveBtn.querySelector('span');
            const btnLoader = comprehensiveBtn.querySelector('.loader');
            const aiNarrativeEl = document.getElementById('ai-narrative-content');

            btnText.classList.add('hidden');
            btnLoader.classList.remove('hidden');
            comprehensiveBtn.disabled = true;

            document.getElementById('projection-results-container').innerHTML = '';
            document.getElementById('saran-buyer').textContent = '-';
            document.getElementById('alasan-buyer').textContent = '';
            document.getElementById('saran-holder').textContent = '-';
            document.getElementById('alasan-holder').textContent = '';

            try {
                const {
                    binanceSymbol,
                    calculatedData,
                    tickerData,
                    correlationData,
                    onChainSummary
                } = realtimeCache.main;

                const marketType = marketTypeSelect.value;
                const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
                const klines1d = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 200 }, marketType);
                const vwap20d = calculateVWAP(klines1d, 'rolling', 20);
                const obvValues = calculateOBV(klines1d);
                const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik (Akumulasi)' : 'Turun (Distribusi)';
                const vwapStatus = parseFloat(tickerData.lastPrice) > vwap20d ? 'Di Atas VWAP (Bullish)' : 'Di Bawah VWAP (Bearish)';

                const volumeAnalysisData = {
                    vwap_20d: vwapStatus,
                    obv_trend: obvTrend
                };

                const prompt = constructHybridAIPrompt(
                    binanceSymbol,
                    calculatedData,
                    tfAlignmentSummary,
                    volumeAnalysisData,
                    onChainSummary,
                    correlationData
                );

                const aiResponseText = await callGemini([{ text: prompt }], false);
                const parsedData = parseAIResponseWithTags(aiResponseText);

                displayComprehensiveResults(parsedData);

            } catch (error) {
                aiNarrativeEl.innerHTML = `<p class="text-red-500">Gagal mendapatkan analisa AI: ${error.message}</p>`;
                isAiAnalysisVisible = false;
                document.querySelector('#toggle-ai-btn span').textContent = 'ASK AI';
            } finally {
                btnText.classList.remove('hidden');
                btnLoader.classList.add('hidden');
                comprehensiveBtn.disabled = false;
            }
        }
        // 
        function constructHybridAIPrompt(symbol, singleTfData, multiTfData, volumeData, onChainSummary, correlationData) {
            const mainPriceContext = {
                current_price: formatPrice(parseFloat(realtimeCache.main.tickerData.lastPrice))
            };
            const cleanSingleTfData = {
                timeframe: timeframeSelect.value,
                candlestick_pattern: singleTfData.candlePattern,
                chart_pattern: singleTfData.chartPattern,
                rsi_divergence: singleTfData.rsiDivergence,
                obv_divergence: singleTfData.obvDivergence.status,
                volatilitas_atr: singleTfData.atr,
                order_book_bias: realtimeCache.main.orderBookBias,
                bollinger_squeeze: singleTfData.bollingerBands.squeezeStatus,
                pivot_harian_bias: singleTfData.pivot.status + (singleTfData.pivot.data?.P ? ` (Pivot @ ${formatPrice(singleTfData.pivot.data.P)})` : ' (Data N/A)'),
                vwap_20d_bias: singleTfData.vwap.status,
                ichimoku_bias: singleTfData.ichimoku.status,
                squeeze_pro_bb_kc: (singleTfData.bollingerBands.width.slice(-1)[0] < singleTfData.keltnerChannels.width.slice(-1)[0]) ? 'Terdeteksi!' : 'Tidak Aktif'
            };
            const fundamentalData = {
                market_cap: realtimeCache.main.coinGeckoData?.market_data?.market_cap?.usd?.toLocaleString() || 'N/A'
            };
            const correlationText = correlationData !== null ? correlationData.toFixed(2) : 'N/A (Aset adalah BTC atau data tidak cukup)';
            const mvrvPromptData = realtimeCache.main.mvrvData
                ? {
                    status: "Data MVRV disediakan pengguna",
                    nilai_z_score: realtimeCache.main.mvrvData.value,
                    tanggal_data: realtimeCache.main.mvrvData.date
                }
                : "Data MVRV tidak disediakan pengguna.";

            const ema9 = calculateEMA(realtimeCache.main.klines.map(k => parseFloat(k[4])), 9).pop();
            const ema21 = calculateEMA(realtimeCache.main.klines.map(k => parseFloat(k[4])), 21).pop();
            const scalpingBias = ema9 > ema21 ? 'LONG' : 'SHORT';
            const scalpingSetupData = {
                bias_sesaat: scalpingBias,
                timeframe: timeframeSelect.value
            };

            return `Sebagai seorang analis kuantitatif (Quant Analyst) senior, berikan analisis pasar yang komprehensif untuk ${symbol}.

        TUGAS UTAMA:
        1.  **CARI DATA EKSTERNAL TERBARU:** Sebelum melakukan analisis, cari data sentimen pasar TERBARU (tidak lebih dari 24 jam terakhir) untuk BITCOIN dari sumber on-chain (Glassnode, CryptoQuant, Coinglass). Sertakan data-data berikut:
            a.  **MVRV Z-Score:** Cari nilai Z-Score terbaru.
            b.  **Data Sentimen Coinglass:** Cari data Netflow, Perubahan OI, Funding Rate, Rasio L/S 24 jam, dan Likuidasi.
            c.  **Format hasilnya HANYA dalam bentuk JSON** di dalam tag [SENTIMEN_DATA_JSON_START]. Strukturnya harus: {\"mvrv_z_score\":1.23, \"netflow\":-57.82, \"oiChange\":-0.89, \"fundingRate\":0.0050, \"lsRatio24h\":\"50.9% / 49.1%\", \"liquidations\":\"215.30M vs 89.10M\"}
        2.  **ANALISIS SEMUA DATA:** Lanjutkan dengan menganalisis SEMUA data yang diberikan di bawah ini untuk mengisi sisa tag output.
        3.  **GUNAKAN JANGKAR HARGA:** Gunakan 'current_price' dari DATA #0 sebagai satu-satunya titik acuan untuk SEMUA PROYEKSI HARGA.
        4.  **GAYA PENULISAN:** Gunakan bahasa yang padat, fokus pada data kunci, dan hindari kalimat berlebihan. Buat dalam bentuk poin-poin.

        **DATA #0: KONTEKS HARGA UTAMA (JANGKAR)**
        ${JSON.stringify(mainPriceContext, null, 2)}

        **DATA #1: Analisis Detail Timeframe Utama (${cleanSingleTfData.timeframe})**
        ${JSON.stringify(cleanSingleTfData, null, 2)}

        **DATA #2: Ringkasan Keselarasan Tren Multi-Timeframe (EMA 21/50)**
        ${JSON.stringify(multiTfData, null, 2)}

        **DATA #3: Analisis Berbasis Volume (CEX - Harian)**
        ${JSON.stringify(volumeData, null, 2)}

        **DATA #4: Data Fundamental Dasar**
        ${JSON.stringify(fundamentalData, null, 2)}

        **DATA #5: Ringkasan Aktivitas On-Chain (DEX - Transaksi >$5000)**
        ${onChainSummary ? JSON.stringify(onChainSummary, null, 2) : '"Data on-chain tidak tersedia untuk aset ini."'}

        **DATA #6: Korelasi Pasar (vs. BTCUSDT 30 Hari)**
        ${JSON.stringify({ correlation_coefficient: correlationText }, null, 2)}

        **DATA #7: Metrik Makro On-Chain (MVRV Z-Score)**
        ${JSON.stringify(mvrvPromptData, null, 2)}

        INSTRUKSI OUTPUT (WAJIB IKUTI FORMAT TAG DAN STRUKTUR MARKDOWN DI BAWAH INI):

        [SENTIMEN_DATA_JSON_START]
        (Letakkan hasil pencarian data sentimen Coinglass dalam format JSON murni di sini)
        [SENTIMEN_DATA_JSON_END]
        
        [NARASI_PASAR_START]
        (Berikan analisis narasi pasar. WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT. Setiap poin harus berupa kalimat singkat dan padat berisi data.
        ### üü• Argumen Bearish (Jangka Pendek)
        * ### üü© Argumen Bullish (Tersembunyi)
        * ### ‚öñÔ∏è Kesimpulan Narasi
        * )
        [NARASI_PASAR_END]

        [ANALISIS_RISIKO_START]
        (Berikan analisis risiko dalam 1-2 kalimat singkat.)
        [ANALISIS_RISIKO_END]

        [SMC_NARRATIVE_START]
        (Berikan analisis struktur pasar (SMC) dalam poin-poin singkat.
        ### üü• Sinyal Bearish (Distribusi)
        * ### üü© Sinyal Bullish (Akumulasi)
        * ### üéØ Target & Konfirmasi Berikutnya
        * )
        [SMC_NARRATIVE_END]

        [SMC_POI_BULLISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bullish terdekat. Contoh: 'Order Block H4 di $50000 - $51000')
        [SMC_POI_BULLISH_END]

        [SMC_POI_BEARISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bearish terdekat. Contoh: 'Supply zone H1 di $60000 - $61000')
        [SMC_POI_BEARISH_END]

        [PROYEKSI_LENGKAP_JSON_START]
        [
            { "periode": "Micro Scalp (1-4 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Sangat Pendek (24-48 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Pendek (1-7 hari)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Menengah (1-4 minggu)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Panjang (6-12 bulan)", "target_harga": "...", "alasan": "..." },
            { "periode": "Siklus Makro (1-3 tahun)", "target_harga": "...", "alasan": "..." }
        ]
        [PROYEKSI_LENGKAP_JSON_END]

        [SARAN_HOLDER_START]
        (Pilih salah satu: TAHAN, JUAL, TAMBAH, KURANGI SEBAGIAN)
        [SARAN_HOLDER_END]

        [ALASAN_HOLDER_START]
        (Berikan 2-3 poin alasan teknikal singkat.)
        [ALASAN_HOLDER_END]

        [SARAN_BUYER_START]
        (Pilih salah satu: BELI SEKARANG, TUNGGU DI AREA, JANGAN MASUK)
        [SARAN_BUYER_END]

        [ALASAN_BUYER_START]
        (Berikan 2-3 poin alasan teknikal singkat. Jika TUNGGU, berikan rentang harga ideal.)
        [ALASAN_BUYER_END]
        `;
        }
        // 
        function parseAIResponseWithTags(rawText) {
            const result = {};
            const tags = [
                "SENTIMEN_DATA_JSON",
                "PUTUSAN_FINAL", "TINGKAT_KEYAKINAN", "NARASI_PASAR", "ANALISIS_SCALPING", "ANALISIS_RISIKO",
                "SMC_NARRATIVE", "SMC_POI_BULLISH", "SMC_POI_BEARISH",
                "PROYEKSI_LENGKAP_JSON", "SARAN_HOLDER", "ALASAN_HOLDER",
                "SARAN_BUYER", "ALASAN_BUYER"
            ];

            tags.forEach(tag => {
                const regex = new RegExp(`\\[${tag}_START\\]([\\s\\S]*?)\\[${tag}_END\\]`, 'i');
                const match = rawText.match(regex);
                const content = match ? match[1].trim() : null;

                const key = tag.toLowerCase();
                if (key === "proyeksi_lengkap_json" && content) {
                    try {
                        result[key] = JSON.parse(content);
                    } catch (e) {
                        console.error(`Gagal parse JSON untuk tag ${tag}:`, e);
                        result[key] = [];
                    }
                } else {
                    result[key] = content;
                }
            });
            return result;
        }
        // 
        function displayComprehensiveResults(data) {
            const aiNarrativeEl = document.getElementById('ai-narrative-content');
            const projectionContainer = document.getElementById('projection-results-container');
            const buyerSaranEl = document.getElementById('saran-buyer');
            const buyerAlasanEl = document.getElementById('alasan-buyer');
            const holderSaranEl = document.getElementById('saran-holder');
            const holderAlasanEl = document.getElementById('alasan-holder');

            aiNarrativeEl.innerHTML = '';
            projectionContainer.innerHTML = '';
            buyerSaranEl.textContent = '-';
            buyerAlasanEl.textContent = '';
            holderSaranEl.textContent = '-';
            holderAlasanEl.textContent = '';

            if (!data || Object.keys(data).length === 0) {
                aiNarrativeEl.innerHTML = '<p class="text-red-500 text-center">AI gagal memberikan analisis yang bisa diproses. Coba lagi.</p>';
                return;
            }

            if (data.sentimen_data_json) {
                try {
                    const sentimentData = { ...JSON.parse(data.sentimen_data_json), lastUpdated: new Date() };
                    realtimeCache.main.shortTermSentiment = sentimentData;
                    displaySentimentDataInDashboard(sentimentData);
                } catch (e) {
                    console.error("Gagal parse JSON sentimen dari AI:", e);
                    const sentimentContainer = document.getElementById('sentiment-display-container');
                    if (sentimentContainer) {
                        sentimentContainer.innerHTML = `<p class="text-xs text-center text-red-500">AI gagal memberikan data sentimen dalam format JSON yang benar.</p>`;
                    }
                }
            }

            let shortVerdictHtml = '';
            if (realtimeCache.main.quickConfluenceScore) {
                const { bull, bear } = realtimeCache.main.quickConfluenceScore;
                const { text, class: verdictClass } = generateShortVerdict(bull, bear);
                shortVerdictHtml = `<p class="text-center font-bold text-2xl mb-4 ${verdictClass}">${text}</p>`;
            }

            const narrativeHtml = data.narasi_pasar ? marked.parse(data.narasi_pasar) : '';
            const smcHtml = data.smc_narrative ? marked.parse(data.smc_narrative) : '';

            let detailsHtml = `
            <div class="space-y-4 text-sm">
                ${narrativeHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md">${narrativeHtml}</div>` : ''}
                ${data.analisis_risiko ? `<div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border border-dashed border-yellow-500/50"><strong>Analisis Risiko:</strong> ${data.analisis_risiko}</div>` : ''}
                ${smcHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md mt-3">${smcHtml}</div>` : ''}
            </div>
        `;

            aiNarrativeEl.innerHTML = shortVerdictHtml + detailsHtml;

            if (data.proyeksi_lengkap_json && data.proyeksi_lengkap_json.length > 0) {
                data.proyeksi_lengkap_json.forEach(p => {
                    projectionContainer.innerHTML += `
                    <div class="card p-3 bg-gray-50 dark:bg-gray-800/50">
                        <h4 class="font-semibold text-blue-400 text-sm">${p.periode}</h4>
                        <p class="font-bold text-base text-gray-800 dark:text-white">${p.target_harga}</p>
                        <p class="text-xs text-gray-500 mt-1">${p.alasan}</p>
                    </div>`;
                });
                projectionContainer.className = `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3`;
            } else {
                projectionContainer.innerHTML = '<p class="text-xs text-gray-500 col-span-full">Proyeksi harga tidak tersedia.</p>';
            }

            buyerSaranEl.textContent = data.saran_buyer || 'N/A';
            buyerAlasanEl.innerHTML = (data.alasan_buyer || 'NONE alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
            holderSaranEl.textContent = data.saran_holder || 'N/A';
            holderAlasanEl.innerHTML = (data.alasan_holder || 'NONE alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
        }
        // 
        function generateShortVerdict(bullPercentage, bearPercentage) {
            let verdict = "NETRAL / CONSOLIDATION";
            let verdictClass = "text-yellow-400";

            if (bullPercentage > bearPercentage * 1.8 && bullPercentage > 40) {
                verdict = "STRONG BULLISH";
                verdictClass = "positive";
            } else if (bearPercentage > bullPercentage * 1.8 && bearPercentage > 40) {
                verdict = "STRONG BEARISH";
                verdictClass = "negative";
            } else if (bullPercentage > bearPercentage) {
                verdict = "SLIGHTLY BULLISH";
                verdictClass = "positive";
            } else if (bearPercentage > bullPercentage) {
                verdict = "SLIGHTLY BEARISH";
                verdictClass = "negative";
            }
            return { text: verdict, class: verdictClass };
        }
        // 
        function analyzeAndDisplayConfluenceContributors() {
            const data = realtimeCache.main.calculatedData;
            if (!data) return;

            let contributors = [];
            const indicatorsToInclude = ['vwap', 'pivot', 'ichimoku', 'macd', 'rsiDivergence', 'obvDivergence'];

            for (const indicator of indicatorsToInclude) {
                if (data[indicator]) {
                    const score = getUltimateSignalScore(indicator, data[indicator]);
                    if (score !== 0) {
                        contributors.push({
                            name: indicator.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()),
                            score: score
                        });
                    }
                }
            }

            contributors.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));

            const topBullish = contributors.filter(c => c.score > 0).slice(0, 3);
            const topBearish = contributors.filter(c => c.score < 0).slice(0, 3);

            let bullishHtml = '<h4 class="font-bold positive mb-1">üëç Pro Bullish</h4><ul class="space-y-1 text-gray-400">';
            if (topBullish.length > 0) {
                topBullish.forEach(item => {
                    bullishHtml += `<li class="flex justify-between"><span>‚Ä¢ ${item.name}</span> <span class="font-mono text-xs positive">+${item.score.toFixed(2)}</span></li>`;
                });
            } else {
                bullishHtml += '<li class="text-xs italic text-gray-600">NONE.</li>';
            }
            bullishHtml += '</ul>';
            document.getElementById('top-bullish-contributors').innerHTML = bullishHtml;

            let bearishHtml = '<h4 class="font-bold negative mb-1">üëé Pro Bearish</h4><ul class="space-y-1 text-gray-400">';
            if (topBearish.length > 0) {
                topBearish.forEach(item => {
                    bearishHtml += `<li class="flex justify-between"><span>‚Ä¢ ${item.name}</span> <span class="font-mono text-xs negative">${item.score.toFixed(2)}</span></li>`;
                });
            } else {
                bearishHtml += '<li class="text-xs italic text-gray-600">NONE.</li>';
            }
            bearishHtml += '</ul>';
            document.getElementById('top-bearish-contributors').innerHTML = bearishHtml;

            document.getElementById('confluence-breakdown-container').classList.remove('hidden');
        }
        // 
        async function createTFAlignmentSummary(symbol, marketType) {
            const timeframes = ['1m', '5m', '15m', '1h', '4h'];
            const summary = {};

            let score = 0;

            const klinesPromises = timeframes.map(tf =>
                fetchBinanceAPIData('klines', { symbol, interval: tf, limit: 51 }, marketType)
            );
            const klinesResults = await Promise.all(klinesPromises);

            klinesResults.forEach((klines, index) => {
                const tf = timeframes[index];
                if (klines && klines.length >= 50) {
                    const closes = klines.map(k => parseFloat(k[4]));
                    const ema21 = calculateEMA(closes, 21).pop();
                    const ema50 = calculateEMA(closes, 50).pop();
                    // Logika ini tetap menghasilkan 'UPTREND'/'DOWNTREND' untuk dependensi ke Bias Kontekstual
                    summary[tf] = ema21 > ema50 ? 'UPTREND' : 'DOWNTREND';
                } else {
                    summary[tf] = 'N/A';
                }

                // Kalkulasi skor (tidak diubah)
                if (summary[tf] === 'UPTREND') {
                    score++;
                } else if (summary[tf] === 'DOWNTREND') {
                    score--;
                }
            });

            realtimeCache.main.tfAlignmentSummary = { summary, score };

            // Tampilkan di UI
            const alignmentContainer = document.getElementById('tf-alignment-summary');
            let alignmentHtml = '<h4 class="font-semibold text-gray-300 mt-2 mb-1">Multi TF Alignment (EMA 21/50)</h4><div class="flex justify-center gap-1">';

            for (const tf in summary) {
                const trend = summary[tf];
                const colorClass = trend === 'UPTREND' ? 'positive' : (trend === 'DOWNTREND' ? 'negative' : 'text-gray-500');

                // --- PERUBAHAN 1: Definisikan ikon berdasarkan teks tren ---
                const trendIcon = trend === 'UPTREND' ? '‚ñ≤' : (trend === 'DOWNTREND' ? '‚ñº' : '‚Äî');

                // --- PERUBAHAN 2: Gunakan variabel ikon, bukan teks, dan perbesar ukurannya ---
                alignmentHtml += `
                <div class="text-center p-1 rounded-md bg-gray-800/50 flex-1 mtf-clickable-box" data-timeframe="${tf}">
                    <span class="font-semibold">${tf}</span><br>
                    <span class="text-sm ${colorClass}">${trendIcon}</span>
                </div>`;
            }

            alignmentHtml += '</div>';
            if (alignmentContainer) alignmentContainer.innerHTML = alignmentHtml;

            return { summary, score };
        }
        // 
        async function updateDashboardUI() {
            if (!realtimeCache.main.tickerData) return;
            const navInfoContainer = document.getElementById('nav-info-container');
            const navStatsContainer = document.getElementById('nav-stats-container');
            const tradeLinkContainer = document.getElementById('trade-link');

            const navTimeframeEl = document.getElementById('nav-timeframe');
            if (navTimeframeEl) {
                navTimeframeEl.textContent = timeframeSelect.value.toUpperCase();
            }

            if (navInfoContainer) {
                navInfoContainer.classList.remove('hidden');
                navInfoContainer.classList.add('md:flex');
            }
            if (navStatsContainer) {
                navStatsContainer.classList.remove('hidden');
                navStatsContainer.classList.add('md:flex');
            }
            if (tradeLinkContainer) {
                tradeLinkContainer.classList.remove('hidden');
            }
            initialPlaceholder.classList.add('hidden');
            dashboardContent.classList.remove('hidden');
            const navHeight = document.getElementById('sticky-nav-wrapper').offsetHeight;

            document.getElementById('quick-confluence-timeframe').textContent = timeframeSelect.value;

            populateCurrentStateWidget();
            populateConfluenceDetailsWidget();
            populateCorrelationWidget();

            if (isChartsVisible) {
                renderAllCharts();
            } else {
                destroyCharts();
                toggleChartsBtn.textContent = 'SHOW CHART';
            }

            renderCvdChart();
            await updateQuickConfluenceWidget();
            calculateAndDisplayScalpingSetup();
            displayFibonacciTargets();
        }
        // 
        function startFundingRateTimer(nextFundingTime) {
            if (fundingRateTimer) clearInterval(fundingRateTimer);

            const updateTimer = () => {
                const timeRemaining = formatTimeRemaining(nextFundingTime);
                document.getElementById('funding-rate-interval').textContent = timeRemaining;

                // Jika waktu sudah habis, hentikan timer
                if (timeRemaining === '00:00:00') {
                    clearInterval(fundingRateTimer);
                }
            };

            updateTimer();
            fundingRateTimer = setInterval(updateTimer, 1000);
        }
        // 
        function formatTimeRemaining(timestamp) {
            const now = new Date().getTime();
            const nextFunding = new Date(timestamp);
            const diff = nextFunding - now;

            if (diff <= 0) return '00:00:00';

            const hours = Math.floor(diff / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);

            const pad = (num) => num.toString().padStart(2, '0');

            return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }
        // 
        function populateConfluenceDetailsWidget() {
            const { calculatedData, tickerData, orderBookData, lsRatioUmumData, lsRatioTopData } = realtimeCache.main;
            if (!calculatedData || !calculatedData.vpvr || !calculatedData.pivot) {
                // Jika data inti belum siap, jangan lakukan apa-apa dan keluar dari fungsi.
                // Ini akan mencegah error 'TypeError'.
                return;
            }
            const pivotContainer = document.getElementById('pivot-levels-container');
            const pivotPEl = document.getElementById('pivot-p');
            const pivotData = calculatedData.pivot?.data;

            if (pivotData && pivotData.P) {
                pivotPEl.textContent = formatPrice(pivotData.P);

                document.getElementById('pivot-r1s1').textContent = `${formatPrice(pivotData.R1)} / ${formatPrice(pivotData.S1)}`;
                document.getElementById('pivot-r2s2').textContent = `${formatPrice(pivotData.R2)} / ${formatPrice(pivotData.S2)}`;
                document.getElementById('pivot-r3s3').textContent = `${formatPrice(pivotData.R3)} / ${formatPrice(pivotData.S3)}`;

                pivotContainer.classList.remove('hidden');
            }

            if (calculatedData.vwap) {
                document.getElementById('vwap-20d').textContent = formatPrice(calculatedData.vwap.value);
            }
            if (calculatedData.ichimoku) {
                const ichiBiasEl = document.getElementById('ichimoku-bias');
                ichiBiasEl.textContent = calculatedData.ichimoku.status;
                ichiBiasEl.className = `font-mono font-semibold ${calculatedData.ichimoku.status === 'Bullish' ? 'positive' : (calculatedData.ichimoku.status === 'Bearish' ? 'negative' : 'text-gray-500')}`;
            }

            if (calculatedData.obv?.value !== undefined) {
                const obv = calculatedData.obv;
                const obvEl = document.getElementById('obv-value');
                const formattedObv = (obv.value / 1_000_000).toFixed(2) + 'M'; // Format ke jutaan
                obvEl.textContent = `${formattedObv} (${obv.trend})`;
                obvEl.className = `font-mono font-semibold ${obv.trend === 'Naik' ? 'positive' : 'negative'}`;
            }

            document.getElementById('confluence-timeframe-display').textContent = timeframeSelect.value;
            document.getElementById('vpvr-vah').textContent = formatPrice(calculatedData.vpvr.vah);
            document.getElementById('vpvr-poc').textContent = formatPrice(calculatedData.vpvr.poc);
            document.getElementById('vpvr-val').textContent = formatPrice(calculatedData.vpvr.val);

            const maStatusEl = document.getElementById('ma-status');
            maStatusEl.textContent = calculatedData.ma.status;
            maStatusEl.className = `font-mono font-semibold ${calculatedData.ma.class}`;

            document.getElementById('ema-21-value').textContent = `EMA21: ${formatPrice(calculatedData.ma.value21)}`;
            document.getElementById('ema-50-value').textContent = `EMA50: ${formatPrice(calculatedData.ma.value50)}`;
            document.getElementById('rsi-value').textContent = calculatedData.rsi.last;

            const rsiStatusEl = document.getElementById('rsi-status');
            rsiStatusEl.textContent = calculatedData.rsi.status;
            rsiStatusEl.className = `tag ${calculatedData.rsi.class}`;
            const rsiDivergenceEl = document.getElementById('rsi-divergence');
            rsiDivergenceEl.textContent = calculatedData.rsiDivergence.status;
            rsiDivergenceEl.className = `font-mono font-semibold ${calculatedData.rsiDivergence.class}`;

            document.getElementById('stoch-value').textContent = `${calculatedData.stoch.k}/${calculatedData.stoch.d}`;

            const stochStatusEl = document.getElementById('stoch-status');
            stochStatusEl.textContent = calculatedData.stoch.status;
            stochStatusEl.className = `tag ${calculatedData.stoch.class}`;

            document.getElementById('macd-status').textContent = calculatedData.macd.status;
            document.getElementById('macd-status').className = `font-mono font-semibold ${calculatedData.macd.class}`;
            document.getElementById('macd-hist').textContent = calculatedData.macd.hist;
            document.getElementById('bollinger-bands-status').textContent = calculatedData.bollingerBands.status;

            const bbData = calculatedData.bollingerBands;
            const lastUpper = bbData.upper.filter(v => v !== undefined).pop();
            const lastMiddle = bbData.middle.filter(v => v !== undefined).pop();
            const lastLower = bbData.lower.filter(v => v !== undefined).pop();

            document.getElementById('bb-upper-value').textContent = `U: ${formatPrice(lastUpper)}`;
            document.getElementById('bb-middle-value').textContent = `M: ${formatPrice(lastMiddle)}`;
            document.getElementById('bb-lower-value').textContent = `L: ${formatPrice(lastLower)}`;

            const { atr, atrPercent } = calculatedData;
            const atrStatusBadge = document.getElementById('atr-status-badge');
            const statusClassMap = { 'Low': 'tag-green', 'Normal': 'tag-yellow', 'High': 'tag-red', 'Very High': 'tag-red' };
            atrStatusBadge.textContent = atr.status;
            atrStatusBadge.className = `tag ${statusClassMap[atr.status] || 'tag-gray'} ml-2`;

            document.getElementById('atr-percent-value').textContent = `${atrPercent.toFixed(2)}%`;
            document.getElementById('atr-absolute-value').textContent = atr.value.toFixed(6);

            const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
            const candleResult = calculatedData.candlePattern;
            let biasClass = '';
            if (candleResult.bias === 'BULLISH') biasClass = 'positive';
            if (candleResult.bias === 'BEARISH') biasClass = 'negative';
            const formattedTime = candleResult.timestamp ? new Date(candleResult.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
            candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Candlestick Pattern</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            
            <div class="h-16 flex items-center justify-center my-2">
                ${candleResult.svg || ''}
            </div>
            
            <p id="candlestick-pattern" class="text-xs font-semibold ${candleResult.class}">${candleResult.pattern}</p>
            ${candleResult.bias !== 'NETRAL' ? `<p class="text-xs font-semibold ${biasClass}">${candleResult.bias}</p>` : ''}
        `;
            const chartPatternEl = document.getElementById('chart-pattern');
            chartPatternEl.textContent = calculatedData.chartPattern.pattern;
            chartPatternEl.className = `font-semibold ${calculatedData.chartPattern.class}`;
            const psarStatusEl = document.getElementById('psar-status');

            psarStatusEl.textContent = calculatedData.psar.status;
            psarStatusEl.className = `font-mono font-semibold ${calculatedData.psar.status === 'Bullish' ? 'positive' : 'negative'}`;

            const rocStatusEl = document.getElementById('roc-status');
            rocStatusEl.textContent = `${calculatedData.roc.value.toFixed(2)}% (${calculatedData.roc.status})`;
            rocStatusEl.className = `font-mono font-semibold ${calculatedData.roc.status === 'Positif' ? 'positive' : 'negative'}`;

            document.getElementById('linreg-status').textContent = calculatedData.linreg.status;
            const bbWidth = calculatedData.bollingerBands.width.slice(-1)[0];
            const kcWidth = calculatedData.keltnerChannels.width.slice(-1)[0];
            const bbSqueezeEl = document.getElementById('bollinger-squeeze-status');
            if (bbWidth < kcWidth) {
                bbSqueezeEl.textContent = 'SQUEEZE PRO!';
                bbSqueezeEl.className = 'font-mono font-bold negative blinking-text-animation';
            } else if (calculatedData.bollingerBands.squeezeStatus === 'Squeeze!') {
                bbSqueezeEl.textContent = 'Squeeze!';
                bbSqueezeEl.className = 'font-mono font-bold text-yellow-500 blinking-text-animation';
            } else {
                bbSqueezeEl.textContent = 'Normal';
                bbSqueezeEl.className = 'font-mono text-gray-500';
            }

            document.getElementById('bollinger-rejection-status').textContent = calculatedData.bollingerBands.rejection;
            document.getElementById('bollinger-walk-status').textContent = calculatedData.bollingerBands.walkTheBands;
            if (calculatedData.adx) {
                document.getElementById('adx-value').textContent = calculatedData.adx.adx;
                document.getElementById('plus-di-value').textContent = calculatedData.adx.plusDI;
                document.getElementById('minus-di-value').textContent = calculatedData.adx.minusDI;
            }
            const lsUmumContainer = document.getElementById('ls-umum-container'), lsTopContainer = document.getElementById('ls-top-container');
            if (marketTypeSelect.value === 'futures' && lsRatioUmumData?.[0] && lsRatioTopData?.[0]) {
                lsUmumContainer.classList.remove('hidden');
                lsTopContainer.classList.remove('hidden');
                document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
                document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
            } else {
                lsUmumContainer.classList.add('hidden');
                lsTopContainer.classList.add('hidden');
            }
            if (orderBookData?.bids && orderBookData?.asks) {
                const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
                const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
                let biasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (BUYER LIMIT)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (SELLER LIMIT)' : 'Netral');
                document.getElementById('order-book-bias').textContent = biasText;
                realtimeCache.main.orderBookBias = biasText;
            } else {
                document.getElementById('order-book-bias').textContent = 'N/A';
                realtimeCache.main.orderBookBias = 'N/A';
            }
            //baru simulasi
            tsCalc.elements.marketPrice.value = parseFloat(realtimeCache.main.tickerData.lastPrice).toFixed(getPrecisionForAsset(parseFloat(realtimeCache.main.tickerData.lastPrice)));

            const resistanceContainer = document.getElementById('scalping-resistance-info');
            if (resistanceContainer && tickerData) {
                const currentPrice = parseFloat(tickerData.lastPrice);
                const pivots = calculatedData.pivot.data; // Simpan data pivot di variabel agar lebih rapi

                const potentialResistances = [
                    { name: 'VAH', value: calculatedData.vpvr.vah },
                    { name: '24H High', value: parseFloat(tickerData.highPrice) },
                    // Menambahkan SEMUA level resistance pivot (P, R1, R2, R3) sebagai kandidat
                    { name: 'Pivot', value: pivots?.P },
                    { name: 'R1', value: pivots?.R1 },
                    { name: 'R2', value: pivots?.R2 },
                    { name: 'R3', value: pivots?.R3 }
                ].filter(r => r.value && r.value > currentPrice); // Filter hanya yang di atas harga saat ini
                if (potentialResistances.length > 0) {
                    const nearestResistance = potentialResistances.reduce((prev, curr) =>
                        (Math.abs(curr.value - currentPrice) < Math.abs(prev.value - currentPrice) ? curr : prev)
                    );
                    resistanceContainer.querySelector('span:last-child').innerHTML = `${formatPrice(nearestResistance.value)} <span class="text-gray-500 text-xs">(${nearestResistance.name})</span>`;
                } else {
                    resistanceContainer.querySelector('span:last-child').textContent = 'N/A';
                }
            }
        }
        // 
        function detectAndDisplayWall(bids, asks) {
            const symbolInfo = exchangeInfoCache[marketTypeSelect.value]?.find(s => s.symbol === realtimeCache.main.binanceSymbol);
            const priceFilter = symbolInfo?.filters.find(f => f.filterType === 'PRICE_FILTER');
            const lotSizeFilter = symbolInfo?.filters.find(f => f.filterType === 'LOT_SIZE');
            const tickSize = priceFilter ? parseFloat(priceFilter.tickSize) : 0.01;
            const stepSize = lotSizeFilter ? parseFloat(lotSizeFilter.stepSize) : 0.001;

            let smoothedAvgVolume = 0;
            if (orderBookHistory.avgVolumes.length > 0) {
                smoothedAvgVolume = orderBookHistory.avgVolumes.reduce((sum, vol) => sum + vol, 0) / orderBookHistory.avgVolumes.length;
            } else {
                const initialLevels = [...bids.slice(0, 15), ...asks.slice(0, 15)];
                if (initialLevels.length > 0) {
                    smoothedAvgVolume = initialLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / initialLevels.length;
                }
            }

            const classifyWall = (volume, mediumThreshold, thickThreshold) => {
                if (volume >= thickThreshold) return 'Thick';
                if (volume >= mediumThreshold) return 'Medium';
                return 'Thin';
            };

            const findWallCluster = (levels) => {
                if (!levels || levels.length < 5 || smoothedAvgVolume === 0) return null;

                const topLevels = levels.slice(0, 15).map(l => parseFloat(l[1]));
                const maxVolume = Math.max(...topLevels);
                const thinThreshold = Math.max(smoothedAvgVolume * 3, maxVolume * 0.2);
                const mediumThreshold = Math.max(smoothedAvgVolume * 7, maxVolume * 0.5);
                const thickThreshold = Math.max(smoothedAvgVolume * 15, maxVolume * 0.7);

                let currentWall = null;
                let walls = [];

                for (let i = 0; i < levels.length; i++) {
                    const price = parseFloat(levels[i][0]);
                    const volume = parseFloat(levels[i][1]);

                    if (volume >= thinThreshold) {
                        if (!currentWall) {
                            currentWall = {
                                priceStart: price,
                                priceEnd: price,
                                totalVolume: volume,
                                levels: 1,
                                levelPrices: [price]
                            };
                        } else {
                            if (Math.abs(price - currentWall.priceEnd) <= (tickSize * 2)) {
                                currentWall.priceEnd = price;
                                currentWall.totalVolume += volume;
                                currentWall.levels++;
                                currentWall.levelPrices.push(price);
                            } else {
                                if (currentWall.levels >= 2) walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                                currentWall = { priceStart: price, priceEnd: price, totalVolume: volume, levels: 1, levelPrices: [price] };
                            }
                        }
                    } else {
                        if (currentWall && currentWall.levels >= 2) {
                            walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                        }
                        currentWall = null;
                    }
                }

                if (currentWall && currentWall.levels >= 2) {
                    walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                }

                if (walls.length > 0) {
                    return walls.reduce((max, w) => (w.totalVolume > max.totalVolume ? w : max), walls[0]);
                }
                return null;
            };


            const findSingleWall = (levels) => {
                if (!levels || levels.length === 0 || smoothedAvgVolume === 0) return null;

                const volumes = levels.slice(0, 20).map(l => parseFloat(l[1]));
                const maxVolume = Math.max(...volumes);

                if (maxVolume > smoothedAvgVolume * 20) {
                    const idx = volumes.findIndex(v => v === maxVolume);
                    return {
                        priceStart: parseFloat(levels[idx][0]),
                        priceEnd: parseFloat(levels[idx][0]),
                        totalVolume: maxVolume,
                        levels: 1,
                        wallType: 'Thick'
                    };
                }
                return null;
            };

            const buyWallCluster = findWallCluster(bids);
            const sellWallCluster = findWallCluster(asks);
            const buyWallSingle = findSingleWall(bids);
            const sellWallSingle = findSingleWall(asks);

            return {
                buyWall: buyWallCluster || buyWallSingle,
                sellWall: sellWallCluster || sellWallSingle
            };
        }
        // 
        function renderFullOrderBook(bids, asks, wallInfo, precision) {
            const numLevels = 10;
            if (!orderBookDOMElements) {
                let asksHtml = Array.from({ length: numLevels }).map(() => `
                <div class="flex items-center text-xs mt-1 relative z-0">
                    <div class="ask-bar absolute inset-0 bg-red-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                    <span class="ask-price w-1/2 text-left font-mono"></span>
                    <span class="ask-qty w-1/2 text-right font-mono"></span>
                </div>
            `).join('');

                let bidsHtml = Array.from({ length: numLevels }).map(() => `
                <div class="flex items-center text-xs mt-1 relative z-0">
                    <div class="bid-bar absolute inset-0 bg-green-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                    <span class="bid-qty w-1/2 text-left font-mono"></span>
                    <span class="bid-price w-1/2 text-right font-mono"></span>
                </div>
            `).join('');

                fullOrderBookContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <h4 class="text-red-500 font-bold">ASKs (Jual)</h4>
                        <div id="asks-container">${asksHtml}</div>
                    </div>
                    <div>
                        <h4 class="text-green-500 font-bold">BIDs (Beli)</h4>
                        <div id="bids-container">${bidsHtml}</div>
                    </div>
                </div>
                <div id="main-ob-wall-container" class="text-center text-xs mt-4 space-y-1">
                    <div id="main-ob-buy-wall" class="h-4 flex items-center justify-center"></div>
                    <div id="main-ob-sell-wall" class="h-4 flex items-center justify-center"></div>
                </div>
            `;

                orderBookDOMElements = {
                    asks: Array.from(document.querySelectorAll('#asks-container > div')).map(row => ({
                        row, bar: row.querySelector('.ask-bar'), price: row.querySelector('.ask-price'), qty: row.querySelector('.ask-qty')
                    })).reverse(),
                    bids: Array.from(document.querySelectorAll('#bids-container > div')).map(row => ({
                        row, bar: row.querySelector('.bid-bar'), price: row.querySelector('.bid-price'), qty: row.querySelector('.bid-qty')
                    })),
                    // PERBAIKAN: Tambahkan elemen baru untuk ditarget
                    mainObBuyWall: document.getElementById('main-ob-buy-wall'),
                    mainObSellWall: document.getElementById('main-ob-sell-wall')
                };
            }

            const topLevels = [...bids.slice(0, 15), ...asks.slice(0, 15)];
            if (topLevels.length > 0) {
                const currentAvgVolume = topLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / topLevels.length;


                orderBookHistory.avgVolumes.push(currentAvgVolume);

                while (orderBookHistory.avgVolumes.length > orderBookHistory.maxSize) {
                    orderBookHistory.avgVolumes.shift();
                }
            }

            const totalMaxVolume = Math.max(
                ...bids.slice(0, numLevels).map(b => parseFloat(b[1])),
                ...asks.slice(0, numLevels).map(a => parseFloat(a[1]))
            );

            for (let i = 0; i < numLevels; i++) {
                const el = orderBookDOMElements.asks[i];
                const data = asks[i];
                if (el && data) {
                    const price = parseFloat(data[0]);
                    const quantity = parseFloat(data[1]);
                    const percentage = (quantity / totalMaxVolume) * 100;
                    const isWall = wallInfo.sellWall && price >= wallInfo.sellWall.priceStart && price <= wallInfo.sellWall.priceEnd;

                    el.price.textContent = price.toFixed(precision);
                    el.qty.textContent = quantity.toFixed(2);
                    el.bar.style.width = `${percentage}%`;
                    el.price.className = `ask-price w-1/2 text-left font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-red-500' : 'text-red-400'}`;
                } else if (el) {
                    el.price.textContent = '';
                    el.qty.textContent = '';
                    el.bar.style.width = '0%';
                }
            }

            for (let i = 0; i < numLevels; i++) {
                const el = orderBookDOMElements.bids[i];
                const data = bids[i];
                if (el && data) {
                    const price = parseFloat(data[0]);
                    const quantity = parseFloat(data[1]);
                    const percentage = (quantity / totalMaxVolume) * 100;
                    const isWall = wallInfo.buyWall && price >= wallInfo.buyWall.priceStart && price <= wallInfo.buyWall.priceEnd;

                    el.price.textContent = price.toFixed(precision);
                    el.qty.textContent = quantity.toFixed(2);
                    el.bar.style.width = `${percentage}%`;
                    el.price.className = `bid-price w-1/2 text-right font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-green-500' : 'text-green-400'}`;
                } else if (el) {
                    el.price.textContent = '';
                    el.qty.textContent = '';
                    el.bar.style.width = '0%';
                }
            }

            const buyWallDisplay = document.getElementById('buy-wall-display');
            const sellWallDisplay = document.getElementById('sell-wall-display');
            const fullOrderBookWallInfo = orderBookDOMElements.wallInfo;

            let buyWallText = '<span class="text-gray-600 font-normal">‚Äî No Buy Wall Detected ‚Äî</span>';
            if (wallInfo.buyWall) {
                buyWallText = `<span class="font-normal ">BUY WALL ${wallInfo.buyWall.wallType.toUpperCase()}</span> DETECTED ${formatPrice(wallInfo.buyWall.priceStart)} TO ${formatPrice(wallInfo.buyWall.priceEnd)} (Vol: $${(wallInfo.buyWall.totalVolume * parseFloat(bids[0][0])).toLocaleString('en-US', { notation: 'compact' })})`;
            }
            buyWallDisplay.innerHTML = buyWallText;

            let sellWallText = '<span class="text-gray-600 font-normal">‚Äî No Sell Wall Detected ‚Äî</span>';
            if (wallInfo.sellWall) {
                sellWallText = `<span class="font-normal">SELL WALL ${wallInfo.sellWall.wallType.toUpperCase()}</span> DETECTED ${formatPrice(wallInfo.sellWall.priceStart)} TO ${formatPrice(wallInfo.sellWall.priceEnd)} (Vol: $${(wallInfo.sellWall.totalVolume * parseFloat(asks[0][0])).toLocaleString('en-US', { notation: 'compact' })})`;
            }
            sellWallDisplay.innerHTML = sellWallText;

            // (Opsional) Update juga info di panel Order Book besar
            if (fullOrderBookWallInfo) {
                let combinedText = '';
                if (wallInfo.buyWall) combinedText += buyWallDisplay.innerHTML + '<br>';
                if (wallInfo.sellWall) combinedText += sellWallDisplay.innerHTML;
                fullOrderBookWallInfo.innerHTML = combinedText;
            }
        }
        // CHART RENDERING ENGINE 
        function getChartBaseOptions(height) {
            const isDarkMode = document.documentElement.classList.contains('dark');
            return {
                width: document.getElementById('charts-wrapper').clientWidth - 48,
                height: height,
                layout: { background: { color: isDarkMode ? '#0e0d0d' : '#FFFFFF' }, textColor: isDarkMode ? '#D1D5DB' : '#374151' },
                grid: { vertLines: { color: 'transparent' }, horzLines: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' } },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: false,
                    borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                    lockVisibleTimeRangeOnResize: true,
                    rightOffset: -30,
                    barSpacing: 6,
                    minBarSpacing: 3,
                    horzTouchDrag: true,
                    vertTouchDrag: false,
                    mouseScroll: false,
                    pinchToZoom: true,
                    tickMarkFormatter: (time) => {
                        const date = new Date(time * 1000);
                        return date.toLocaleTimeString('id-ID', {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                    horzLine: {
                        visible: true,
                        labelVisible: true
                    },
                    vertLine: {
                        visible: true,
                        labelVisible: true
                    }
                },
                rightPriceScale: {
                    borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                    visible: true,
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.1
                    }
                },
                localization: {
                    timeFormatter: (time) => {
                        const date = new Date(time * 1000);
                        return date.toLocaleString('id-ID', {
                            year: 'numeric', month: 'short', day: 'numeric',
                            hour: '2-digit', minute: '2-digit', second: '2-digit',
                            timeZone: 'Asia/Jakarta'
                        });
                    }
                }
            };
        }
        // 
        function syncCharts(...chartsToSync) {
            chartsToSync.forEach(chart => {
                if (!chart) return;
                chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                    chartsToSync.forEach(otherChart => {
                        if (chart !== otherChart && otherChart) {
                            otherChart.timeScale().setVisibleRange(timeRange);
                        }
                    });
                });
            });
        }
        //
        function renderAllCharts() {
            if (!realtimeCache.main.klines) return;

            destroyCharts();

            const { klines, calculatedData } = realtimeCache.main;
            const closes = klines.map(k => parseFloat(k[4]));
            const formattedKlines = klines
                .filter(k => k && k.length >= 5 && k.slice(1, 5).every(v => v !== null && !isNaN(parseFloat(v))))
                .map(d => ({
                    time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]),
                    low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5])
                }));

            if (formattedKlines.length === 0) return;

            const formatLineData = (data, klineSource = klines, offset = 0) => data
                .map((value, index) => {
                    const val = (typeof value === 'object' && value !== null) ? value.value : value;
                    const klineIndex = index + offset;
                    if (klineSource[klineIndex] && val !== undefined && !isNaN(val)) {
                        const time = klineSource[klineIndex][0] / 1000;
                        if (typeof value === 'object' && value !== null) {
                            return { ...value, time };
                        }
                        return { time, value: val };
                    }
                    return null;
                }).filter(Boolean);

            const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
            charts.push(mainChart);

            chartSeries.candlestick = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
            chartSeries.candlestick.setData(formattedKlines);

            // --- Indikator di Grafik Utama ---
            const bbData = calculatedData.bollingerBands;
            chartSeries.ema50 = mainChart.addLineSeries({ color: 'yellow', lineWidth: 2, priceLineVisible: false, title: 'EMA50' });
            chartSeries.bbUpper = mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lineStyle: LightweightCharts.LineStyle.Dashed });
            chartSeries.bbMiddle = mainChart.addLineSeries({ color: 'white', lineWidth: 1, priceLineVisible: false, lineStyle: LightweightCharts.LineStyle.Dotted });
            chartSeries.bbLower = mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lineStyle: LightweightCharts.LineStyle.Dashed });

            chartSeries.ema50.setData(formatLineData(calculateEMA(closes, 50)));
            chartSeries.bbUpper.setData(formatLineData(bbData.upper, klines, klines.length - bbData.upper.length));
            chartSeries.bbMiddle.setData(formatLineData(bbData.middle, klines, klines.length - bbData.middle.length));
            chartSeries.bbLower.setData(formatLineData(bbData.lower, klines, klines.length - bbData.lower.length));

            // --- Panel Volume ---
            const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
            charts.push(volumeChart);
            chartSeries.volume = volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } });
            chartSeries.volume.setData(formattedKlines.map(d => ({ time: d.time, value: d.volume, color: d.close >= d.open ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' })));

            // --- Panel RSI ---
            const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(150));
            charts.push(rsiChart);
            chartSeries.rsi = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 });
            chartSeries.rsi.setData(formatLineData(calculatedData.rsi.values));
            // [PERBAIKAN] Garis harga dibuat di SERIES, bukan di CHART
            chartSeries.rsi.createPriceLine({ price: 70, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '70' });
            chartSeries.rsi.createPriceLine({ price: 30, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '30' });

            // --- Panel Stochastic RSI ---
            const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(150));
            charts.push(stochChart);
            const stochData = calculatedData.stoch;
            chartSeries.stochK = stochChart.addLineSeries({ color: '#2196F3', lineWidth: 2, title: '%K' });
            chartSeries.stochD = stochChart.addLineSeries({ color: '#FF9800', lineWidth: 2, title: '%D' });
            chartSeries.stochK.setData(formatLineData(stochData.kLine, klines, stochData.kOffset));
            chartSeries.stochD.setData(formatLineData(stochData.dLine, klines, stochData.dOffset));
            // [PERBAIKAN] Garis harga dibuat di SERIES, bukan di CHART
            chartSeries.stochK.createPriceLine({ price: 80, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '80' });
            chartSeries.stochK.createPriceLine({ price: 20, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '20' });

            // --- Panel MACD ---
            const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(150));
            charts.push(macdChart);
            const macdData = calculatedData.macd;
            chartSeries.macdHist = macdChart.addHistogramSeries({ base: 0 });
            chartSeries.macdLine = macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2 });
            chartSeries.signalLine = macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2 });
            chartSeries.macdHist.setData(formatLineData(macdData.histogram, klines, klines.length - macdData.histogram.length));
            chartSeries.macdLine.setData(formatLineData(macdData.macdLine, klines, klines.length - macdData.macdLine.length));
            chartSeries.signalLine.setData(formatLineData(macdData.signalLine, klines, klines.length - macdData.signalLine.length));

            // --- Panel ROC ---
            const rocChart = LightweightCharts.createChart(document.getElementById('roc-chart-container'), getChartBaseOptions(150));
            charts.push(rocChart);
            chartSeries.roc = rocChart.addLineSeries({ color: '#f472b6', lineWidth: 2 });
            const rocValues = calculateROC(closes).values;
            chartSeries.roc.setData(formatLineData(rocValues, klines, klines.length - rocValues.length));
            // [PERBAIKAN] Garis harga dibuat di SERIES, bukan di CHART
            chartSeries.roc.createPriceLine({ price: 0, color: '#9E9E9E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: '0' });

            syncCharts(mainChart, volumeChart, rsiChart, stochChart, macdChart, rocChart);
        }

        function updateLiveCharts(kline) {
            if (!isChartsVisible || !chartSeries.candlestick) return;

            const formattedCandle = {
                time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h),
                low: parseFloat(kline.l), close: parseFloat(kline.c)
            };
            const formattedVolume = {
                time: formattedCandle.time, value: parseFloat(kline.v),
                color: formattedCandle.close >= formattedCandle.open ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)'
            };

            if (chartSeries.candlestick) chartSeries.candlestick.update(formattedCandle);
            if (chartSeries.volume) chartSeries.volume.update(formattedVolume);

            const closes = realtimeCache.main.klines.map(k => parseFloat(k[4]));

            const lastRsi = calculateRSI(closes).pop();
            if (lastRsi && chartSeries.rsi) chartSeries.rsi.update({ time: formattedCandle.time, value: lastRsi });

            const stoch = calculateStochasticRSI(closes);
            const lastStochK = stoch.kLine.pop();
            const lastStochD = stoch.dLine.pop();
            if (lastStochK && chartSeries.stochK) chartSeries.stochK.update({ time: formattedCandle.time, value: lastStochK });
            if (lastStochD && chartSeries.stochD) chartSeries.stochD.update({ time: formattedCandle.time, value: lastStochD });

            const lastEma50 = calculateEMA(closes, 50).pop();
            if (lastEma50 && chartSeries.ema50) chartSeries.ema50.update({ time: formattedCandle.time, value: lastEma50 });

            const macd = calculateMACD(closes);
            const lastMacdLine = macd.macdLine.pop();
            const lastSignalLine = macd.signalLine.pop();
            const lastMacdHist = macd.histogram.pop();
            if (lastMacdLine && chartSeries.macdLine) chartSeries.macdLine.update({ time: formattedCandle.time, value: lastMacdLine });
            if (lastSignalLine && chartSeries.signalLine) chartSeries.signalLine.update({ time: formattedCandle.time, value: lastSignalLine });
            if (lastMacdHist && chartSeries.macdHist) chartSeries.macdHist.update({ time: formattedCandle.time, value: lastMacdHist.value, color: lastMacdHist.color });

            const roc = calculateROC(closes).values.pop();
            if (roc && chartSeries.roc) chartSeries.roc.update({ time: formattedCandle.time, value: roc });
        }

        function calculateBollingerBands_forPlot(closes, period = 20, stdDev = 2, klines) {
            if (closes.length < period) return { upper: [], middle: [], lower: [] };
            const middle = calculateSMA(closes, period);
            const upper = [], middleData = [], lower = [];
            for (let i = period - 1; i < closes.length; i++) {
                if (middle[i] === undefined) {
                    upper.push(undefined);
                    lower.push(undefined);
                    continue;
                }
                const slice = closes.slice(i - period + 1, i + 1);
                const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
                const stdev = Math.sqrt(sumSquaredDiff / period);
                const time = klines[i][0] / 1000;
                upper.push({ time, value: middle[i] + (stdev * stdDev) });
                lower.push({ time, value: middle[i] - (stdev * stdDev) });
                middleData.push({ time, value: middle[i] });
            }
            return { upper: upper.filter(d => d), middle: middleData.filter(d => d.value !== undefined), lower: lower.filter(d => d) };
        }
        // 
        function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
            const closes = klines.map(k => parseFloat(k[4]));
            if (closes.length < period) return { upper: [], middle: [], lower: [] };
            const upper = [], middle = [], lower = [];
            for (let i = period - 1; i < closes.length; i++) {
                const y = closes.slice(i - period + 1, i + 1);
                const n = period;
                const sumX = (n * (n - 1)) / 2;
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
                const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                let sumErrSq = 0;
                for (let j = 0; j < n; j++) {
                    const predictedY = intercept + slope * j;
                    sumErrSq += Math.pow(y[j] - predictedY, 2);
                }
                const stdErr = Math.sqrt(sumErrSq / (n - 2));

                const middleValue = intercept + slope * (n - 1);
                middle.push({ time: klines[i][0] / 1000, value: middleValue });
                upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
                lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) });
            }
            return { upper, middle, lower };
        }

        function calculateROC_forPlot(closes, period = 12) {
            if (closes.length < period + 1) return [];
            const rocData = [];
            for (let i = period; i < closes.length; i++) {
                const currentClose = closes[i];
                const pastClose = closes[i - period];
                if (pastClose !== 0) {
                    const roc = ((currentClose - pastClose) / pastClose) * 100;
                    rocData.push({ time: realtimeCache.main.klines[i][0] / 1000, value: roc });
                }
            }
            return rocData;
        }

        function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
            const closes = klines.map(k => parseFloat(k[4]));
            if (closes.length < period) return { upper: [], middle: [], lower: [] };
            const upper = [], middle = [], lower = [];
            for (let i = period - 1; i < closes.length; i++) {
                const y = closes.slice(i - period + 1, i + 1);
                const n = period;
                const sumX = (n * (n - 1)) / 2;
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
                const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                const intercept = (sumY - slope * sumX) / n;

                let sumErrSq = 0;
                for (let j = 0; j < n; j++) {
                    const predictedY = intercept + slope * j;
                    sumErrSq += Math.pow(y[j] - predictedY, 2);
                }
                const stdErr = Math.sqrt(sumErrSq / (n - 2));

                const middleValue = intercept + slope * (n - 1);
                middle.push({ time: klines[i][0] / 1000, value: middleValue });
                upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
                lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) });
            }
            return { upper, middle, lower };
        }

        function calculateParabolicSAR_forPlot(klines, step = 0.02, max = 0.2) {
            if (klines.length < 2) return [];
            let sar = parseFloat(klines[0][3]);
            let ep = parseFloat(klines[0][2]);
            let af = step;
            let isUptrend = true;
            const sarData = [];

            for (let i = 1; i < klines.length; i++) {
                const time = klines[i][0] / 1000;
                const high = parseFloat(klines[i][2]);
                const low = parseFloat(klines[i][3]);
                const prevSar = sar;

                if (isUptrend) {
                    sar = prevSar + af * (ep - prevSar);
                    if (low < sar) {
                        isUptrend = false;
                        sar = ep;
                        ep = low;
                        af = step;
                    } else {
                        if (high > ep) {
                            ep = high;
                            af = Math.min(max, af + step);
                        }
                    }
                } else {
                    sar = prevSar - af * (prevSar - ep);
                    if (high > sar) {
                        isUptrend = true;
                        sar = ep;
                        ep = high;
                        af = step;
                    } else {
                        if (low < ep) {
                            ep = low;
                            af = Math.min(max, af + step);
                        }
                    }
                }
                sarData.push({ time, value: sar });
            }
            return sarData;
        }
        // 
        function destroyCharts() {
            charts.forEach(chart => {
                if (chart) {
                    chart.remove();
                }
            });
            charts = [];
            candlestickSeries = null;

            const mainChartContainers = [
                'main-chart-container',
                'rsi-chart-container',
                'stoch-chart-container',
                'macd-chart-container',
                'roc-chart-container'
            ];
            mainChartContainers.forEach(id => {
                const container = document.getElementById(id);
                if (container) {
                    container.innerHTML = '';
                }
            });
        }
        // 
        function toggleChartsVisibility() {
            isChartsVisible = !isChartsVisible;
            if (isChartsVisible) {
                chartsWrapper.style.display = 'block';
                toggleChartsBtn.textContent = 'HIDE CHART';

                const observer = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const { width } = entry.contentRect;
                        if (width > 0) {
                            renderAllCharts();
                            observer.unobserve(entry.target); // Hentikan observer setelah chart dirender
                        }
                    }
                });
                observer.observe(chartsWrapper); // Mulai mengamati div charts-wrapper
            } else {
                chartsWrapper.style.display = 'none';
                toggleChartsBtn.textContent = 'SHOW CHART';
                destroyCharts();
            }
        }
        // 
        function populateCurrentStateWidget() {
            const { tickerData, coinGeckoData, globalData, openInterestData, fundingRateData, binanceSymbol } = realtimeCache.main;

            document.getElementById('nav-symbol').textContent = binanceSymbol;
            const navChange24hEl = document.getElementById('nav-change-24h');
            const navChange1hEl = document.getElementById('nav-change-1h');

            const change24h = parseFloat(tickerData.priceChangePercent);
            if (navChange24hEl) {
                navChange24hEl.textContent = `${change24h.toFixed(2)}%`;
                navChange24hEl.className = `font-semibold ${getSignClass(change24h)}`;
            }

            if (navChange1hEl && coinGeckoData?.market_data) {
                const change1h = coinGeckoData.market_data.price_change_percentage_1h_in_currency.usd || 0;
                navChange1hEl.textContent = `${change1h.toFixed(2)}%`;
                navChange1hEl.className = `font-semibold ${getSignClass(change1h)}`;
            }
            navVolume24h.textContent = `$${parseFloat(tickerData.quoteVolume).toLocaleString('en-US', { notation: 'compact' })}`;
            if (coinGeckoData?.market_data) {
                navAth.textContent = formatPrice(coinGeckoData.market_data.ath.usd);
                navAtl.textContent = formatPrice(coinGeckoData.market_data.atl.usd);
            }

            if (coinGeckoData?.market_data) {
                document.getElementById('market-cap').textContent = formatPrice(coinGeckoData.market_data.market_cap.usd);
            }
            if (globalData?.data) {
                document.getElementById('btc-dominance').textContent = `${globalData.data.market_cap_percentage.btc.toFixed(2)}%`;
            }

            document.getElementById('current-state-title').innerHTML = `Current State<span class="text-yellow-500 font-semibold ml-2">üí≤ ${binanceSymbol}</span>`;
            document.getElementById('range-24h').textContent = `${formatPrice(parseFloat(tickerData.lowPrice)).replace('$', '')} - ${formatPrice(parseFloat(tickerData.highPrice)).replace('$', '')}`;

            const futuresContainer = document.getElementById('futures-data-container');
            const price = parseFloat(tickerData.lastPrice);
            if (marketTypeSelect.value === 'futures' && openInterestData && fundingRateData) {
                futuresContainer.classList.remove('hidden');
                if (openInterestData && parseFloat(openInterestData.openInterest) > 0) {
                    const oiValue = parseFloat(openInterestData.openInterest) * price;
                    document.getElementById('open-interest').textContent = `$${oiValue.toLocaleString('en-US', { notation: 'compact' })}`;
                } else {
                    document.getElementById('open-interest').textContent = '-';
                }
                document.getElementById('funding-rate').textContent = `${(parseFloat(fundingRateData.lastFundingRate) * 100).toFixed(4)}%`;
                if (fundingRateData.nextFundingTime) {
                    startFundingRateTimer(fundingRateData.nextFundingTime);
                } else {
                    document.getElementById('funding-rate-interval').textContent = '-';
                }
            } else {
                futuresContainer.classList.add('hidden');
            }
        }
        // 
        function renderCvdChart() {
            const { cvdData } = realtimeCache.main;
            if (!cvdData || cvdData.length === 0) return;

            // Inisialisasi data live dengan format baru yang lengkap
            liveCvdData = cvdData.map(d => ({
                x: d.time * 1000,
                y_coin: d.cvd_coin,
                y_usdt: d.cvd_usdt
            }));

            // Inisialisasi nilai kumulatif terakhir
            if (liveCvdData.length > 0) {
                const lastPoint = liveCvdData[liveCvdData.length - 1];
                liveCvdValue = lastPoint.y_coin;
                liveCvdValueUsdt = lastPoint.y_usdt;
            }

            const ctx = document.getElementById('cvdChart').getContext('2d');
            if (cvdChartInstance) cvdChartInstance.destroy();

            const isDarkMode = document.documentElement.classList.contains('dark');
            const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
            const negativeColor = isDarkMode ? '#f87171' : '#dc2626';

            cvdChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'CVD (USDT)',
                        data: liveCvdData,
                        parsing: {
                            yAxisKey: 'y_usdt' // <-- PENTING: Memberitahu chart untuk menggunakan nilai USDT
                        },
                        fill: false, tension: 0.1, pointRadius: 0, borderWidth: 2,
                        segment: {
                            borderColor: ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor,
                        }
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false, animation: false,
                    scales: {
                        x: { type: 'time', time: { tooltipFormat: 'MMM dd, HH:mm:ss', unit: 'second' }, grid: { display: false }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563', source: 'auto', maxRotation: 0, autoSkip: true } },
                        y: { grid: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563' } }
                    },
                    plugins: { legend: { display: false } },
                    interaction: { mode: 'index', intersect: false }
                }
            });


            updateCvdTableLive(liveCvdData);
        }
        // 
        function calculateCorrelation(dataX, dataY) {
            if (dataX.length !== dataY.length || dataX.length === 0) {
                return null;
            }
            const n = dataX.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

            for (let i = 0; i < n; i++) {
                sumX += dataX[i];
                sumY += dataY[i];
                sumXY += dataX[i] * dataY[i];
                sumX2 += dataX[i] * dataX[i];
                sumY2 += dataY[i] * dataY[i];
            }

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            if (denominator === 0) {
                return 0;
            }

            return numerator / denominator;
        }
        // 
        async function recalculateAllIndicators(klines, tickerData, prevDayKline, marketType, cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData) {
            if (!klines || klines.length < 50) return {};

            const closes = klines.map(k => parseFloat(k[4]));
            const lastPrice = closes[closes.length - 1];
            const rsiValues = calculateRSI(closes);
            const ema21Values = calculateEMA(closes, 21);
            const ema50Values = calculateEMA(closes, 50);
            const lastEma21 = ema21Values.filter(v => v !== undefined).pop();
            const lastEma50 = ema50Values.filter(v => v !== undefined).pop();
            const pivotPoints = calculatePivotPoints(prevDayKline);
            const ichimoku = calculateIchimokuCloud(klines);
            const keltnerChannels = calculateKeltnerChannels(klines);
            const activeMode = document.querySelector('.vwap-mode-btn.active')?.dataset.mode || 'rolling';
            const vwapValue = calculateVWAP(klines, activeMode);
            const atr = calculateATR(klines); // Panggil fungsi yang lebih akurat
            const atrPercent = calculateATRPercentage(klines); // Dapatkan persentase ATR

            let trendStatus = 'Netral';
            let trendClass = 'text-yellow-400';
            if (lastEma21 > lastEma50) {
                trendStatus = (lastPrice > lastEma21) ? 'Strong Uptrend' : 'Correction in Uptrend';
                trendClass = (lastPrice > lastEma21) ? 'positive' : 'text-yellow-400';
            } else if (lastEma50 > lastEma21) {
                trendStatus = (lastPrice < lastEma21) ? 'Strong Downtrend' : 'Downtrend Rally';
                trendClass = (lastPrice < lastEma21) ? 'negative' : 'text-yellow-400';
            }

            let orderBookBiasText = 'N/A';
            if (orderBookData?.bids && orderBookData?.asks) {
                const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
                const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
                orderBookBiasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (Buyer Limit)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (Seller Limit)' : 'Netral');
            }

            const openInterestStatus = (marketType === 'futures' && openInterestData?.openInterest > 0 && tickerData?.priceChangePercent)
                ? (parseFloat(tickerData.priceChangePercent) > 0 ? 'Bullish' : 'Bearish')
                : 'Netral';

            const bb = calculateBollingerBands(closes);
            const bbPriceAction = analyzeBollingerBandsPriceAction(klines, bb);
            const obvValues = calculateOBV(klines);
            const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik' : 'Turun';
            const lastObv = obvValues.length > 0 ? obvValues[obvValues.length - 1] : 0;
            const marketRegime = await predictMarketRegime(klines);
            //console.log('‚úÖ CHECKPOINT 1: AI Prediction SUCCESS. Regime:', marketRegime);
            return {
                adx: calculateADX(klines),
                cvd: CVDanalyze(klines, cvdData),
                vpvr: calculateVPVR(klines),
                ma: { status: trendStatus, class: trendClass, value21: lastEma21, value50: lastEma50 },
                rsi: {
                    values: rsiValues,
                    last: rsiValues.filter(v => v !== undefined).pop()?.toFixed(2) || 50,
                    status: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'Overbought' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'Oversold' : 'Netral'),
                    class: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'tag-red' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'tag-green' : 'tag-yellow')
                },
                rsiDivergence: detectRSIDivergence(closes, rsiValues),
                obvDivergence: detectOBVDivergence(closes, klines),
                stoch: calculateStochasticRSI(closes),
                macd: calculateMACD(closes),
                bollingerBands: { ...bb, rejection: bbPriceAction.rejection, walkTheBands: bbPriceAction.walkTheBands },
                obv: { value: lastObv, trend: lastObv > obvValues[obvValues.length - 2] ? 'Naik' : 'Turun' },
                pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
                atr: atr, // Menggunakan variabel atr yang sudah dihitung
                atrPercent: atrPercent, // Menggunakan variabel atrPercent yang sudah dihitung
                candlePattern: findCandlestickPatterns(klines),
                chartPattern: findChartPatterns(klines),
                roc: calculateROC(closes),
                psar: calculateParabolicSAR(klines),
                linreg: calculateLinearRegressionChannel(closes),
                vwap: { status: lastPrice > vwapValue ? 'Bullish' : 'Bearish', value: vwapValue },
                ichimoku: { status: ichimoku?.status || 'Netral', data: ichimoku },
                keltnerChannels: keltnerChannels,
                fundingRate: fundingRateData,
                lsRatio: lsRatioUmumData?.[0],
                openInterest: { status: openInterestStatus },
                orderBookBias: orderBookBiasText,
                obv: { value: lastObv, trend: obvTrend },
                marketRegime: marketRegime
            };
        }
        // 
        function populateCorrelationWidget() {
            const valueEl = document.getElementById('correlation-value');
            const textEl = document.getElementById('correlation-text');
            const correlationData = realtimeCache.main.correlationData;

            if (correlationData === null || correlationData === undefined) {
                valueEl.textContent = '-';
                textEl.textContent = 'NOT ENOUGH DATA TO CALCULATE.';
                valueEl.className = 'text-base font-sbold text-gray-400 dark:text-gray-500';
                return;
            }

            const value = correlationData;
            valueEl.textContent = value.toFixed(2);

            let text = 'NONE';
            let colorClass = 'text-gray-400 dark:text-gray-500';

            if (value >= 0.7) { text = 'Positif Strong'; colorClass = 'positive'; }
            else if (value >= 0.4) { text = 'Positive Medium'; colorClass = 'positive'; }
            else if (value >= 0.1) { text = 'Positive Weak'; colorClass = 'text-yellow-400'; }
            else if (value <= -0.7) { text = 'Negative Strong'; colorClass = 'negative'; }
            else if (value <= -0.4) { text = 'Negative Medium'; colorClass = 'negative'; }
            else if (value <= -0.1) { text = 'Negative Weak'; colorClass = 'text-yellow-400'; }

            textEl.textContent = text;
            valueEl.className = `text-lg font-semibold ${colorClass}`;
        }
        // 
        function resetDashboard() {
            if (candleCountdownInterval) clearInterval(candleCountdownInterval);
            WebSocketManager.resetSubscriptions();
            if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
            if (fundingRateTimer) clearInterval(fundingRateTimer);

            dashboardContent.classList.add('hidden');
            initialPlaceholder.classList.remove('hidden');
            destroyCharts();
            realtimeCache.main = {};
            realtimeCache.movers = {};
            klineCache = {};
            orderBookHistory = { avgVolumes: [], maxSize: 30 };
        }
        // 
        function updateVwapDisplay(mode) {
            if (!realtimeCache.main.klines) return;

            // Gunakan klines yang sesuai dengan timeframe
            const vwapValue = calculateVWAP(realtimeCache.main.klines, mode);
            const lastPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);

            // Simpan ke cache untuk digunakan oleh skor konfluensi dan AI
            realtimeCache.main.calculatedData.vwap = {
                status: lastPrice > vwapValue ? 'Bullish' : 'Bearish',
                value: vwapValue
            };

            // Perbarui tampilan di panel Data Timeframe
            document.getElementById('vwap-20d').textContent = formatPrice(vwapValue);

            // Panggil ulang update skor konfluensi agar ikut berubah
            updateQuickConfluenceWidget();
        }
        // 
        function renderTriggerBreakdown(breakdown) {
            const container = document.getElementById('trigger-breakdown-list');
            if (!container) return;

            const renderTrigger = (name, triggerData, valueText, conditionText = '') => {
                const safeTriggerData = triggerData || { triggered: false, points: 0 };
                const isTriggered = safeTriggerData.triggered;
                const points = safeTriggerData.points;
                const icon = isTriggered ? '‚úÖ' : '‚ñ´Ô∏è';
                const pointsText = isTriggered ? `+${points.toFixed(1).replace('.0', '')} Poin` : `0 Poin`;
                const mainColor = isTriggered ? 'text-green-400' : 'text-gray-500';
                const pointColor = isTriggered ? 'text-green-400' : 'text-gray-500';

                return `
                <li class="flex justify-between items-center py-2 border-b border-gray-700/50 ${mainColor}">
                    <span>${icon} ${name}</span>
                    <div class="text-right text-xs">
                        <span class="font-semibold">${valueText}</span>
                        <span class="text-gray-600 ml-1">${conditionText}</span>
                        <br>
                        <span class="font-mono font-bold ${pointColor}">${pointsText}</span>
                    </div>
                </li>
            `;
            };

            let html = '<ul class="list-none">';

            html += renderTrigger('Red Candle after HH', breakdown.candleRed, breakdown.candleRed?.triggered ? 'Detected' : 'NONE');
            html += renderTrigger('Bearish Candle', breakdown.doji, breakdown.candlePattern, '(ex: Shooting Star)');
            html += renderTrigger('Volume Exhaustion', breakdown.volumeExhaustion, breakdown.volumeExhaustion?.triggered ? 'DETECTED!' : 'Normal', '(Vol Top < 60% Avg)');
            html += renderTrigger('CVD Nose Dive', breakdown.cvdDip, breakdown.cvdDip?.triggered ? 'Yes' : 'No');
            html += renderTrigger('CVD Divergence', breakdown.cvdDivergence, breakdown.cvdStatus, '');
            // Ganti baris lama dengan ini untuk menampilkan nilai U/M/L
            html += renderTrigger(
                'Rejection Bollinger Band',
                breakdown.bbRejection,
                `<span class="text-red-400">U: ${breakdown.bbUpper}</span> / <span class="text-blue-400">M: ${breakdown.bbMiddle}</span> / <span class="text-green-400">L: ${breakdown.bbLower}</span>`,
                breakdown.bbStatus
            );
            html += renderTrigger('MACD Bearish Cross', breakdown.macdCross, `Status: ${breakdown.macdStatus}`);
            html += renderTrigger('RSI Overbought', breakdown.rsiOverbought, `Value: ${breakdown.rsiValue}`, '');

            html += '</ul>';
            container.innerHTML = html;
        }
        // 
        function detectSignificantSellWall(asks) {
            if (!asks || asks.length === 0) return null;

            let totalVolume = asks.reduce((sum, ask) => sum + parseFloat(ask[1]), 0);
            let avgVolume = totalVolume / asks.length;
            let sellWallVolume = 0;
            const wallThreshold = avgVolume * 5;

            for (const ask of asks) {
                if (parseFloat(ask[1]) > wallThreshold) {
                    sellWallVolume += parseFloat(ask[1]);
                }
            }

            if (sellWallVolume > totalVolume * 0.2) {
                return { volume: sellWallVolume, type: 'significant' };
            }

            return null;
        }
        // 
        async function updateTopMovers(timeframe = "1h") {
            try {
                const topGainersList = document.getElementById('gainers-list');

                if (topGainersList && !topGainersList.hasChildNodes()) {
                    const loaderHtml = `<div class="p-4 flex justify-center items-center"><div class="loader"></div></div>`;
                    topGainersList.innerHTML = loaderHtml;
                    if (losersList) losersList.innerHTML = loaderHtml;
                }

                if (!exchangeInfoCache.futures) await initializeExchangeInfo('futures');

                const tradingSymbols = new Set(exchangeInfoCache.futures
                    .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
                    .map(s => s.symbol)
                );

                const ticker24hData = await fetchBinanceAPIData('ticker/24hr', {}, 'futures');
                let usdtPairs = ticker24hData.filter(d => d.symbol.endsWith('USDT') && tradingSymbols.has(d.symbol));

                usdtPairs.forEach(d => {
                    const priceChange24h = parseFloat(d.priceChangePercent);
                    const volume24h = parseFloat(d.quoteVolume);
                    d.strengthScore24h = priceChange24h * Math.log10(volume24h + 1);
                });
                usdtPairs.sort((a, b) => b.strengthScore24h - a.strengthScore24h);
                const candidates = usdtPairs.slice(0, 15);

                let finalSortedGainers;

                if (timeframe !== '24h') {
                    const klinesPromises = candidates.map(d =>
                        fetchBinanceAPIData('klines', { symbol: d.symbol, interval: timeframe, limit: 100 }, 'futures').catch(() => null)
                    );
                    const klinesResults = await Promise.all(klinesPromises);

                    candidates.forEach((pair, index) => {
                        const klines = klinesResults[index];
                        if (klines && klines.length > 1) {
                            const firstClose = parseFloat(klines[0][4]);
                            const lastClose = parseFloat(klines[klines.length - 1][4]);
                            const quoteVolume = klines.reduce((sum, k) => sum + (parseFloat(k[5]) * parseFloat(k[4])), 0);
                            const priceChange = firstClose > 0 ? ((lastClose - firstClose) / firstClose) * 100 : 0;
                            pair.strengthScore = priceChange * Math.log10(quoteVolume + 1);
                            pair.dynamicPriceChange = priceChange;
                        } else {
                            pair.strengthScore = -Infinity;
                            pair.dynamicPriceChange = 0;
                        }
                    });

                    candidates.sort((a, b) => b.strengthScore - a.strengthScore);
                    finalSortedGainers = candidates.slice(0, 10);

                } else {
                    finalSortedGainers = candidates.slice(0, 10);
                    finalSortedGainers.forEach(d => d.dynamicPriceChange = parseFloat(d.priceChangePercent));
                }

                const calculateChange = (kData) => {
                    if (!kData || kData.length < 2) return 'N/A';
                    const prevClose = parseFloat(kData[0][4]);
                    const currentClose = parseFloat(kData[1][4]);
                    return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
                };

                const gainersWithDetails = await Promise.all(finalSortedGainers.map(async (mover) => {
                    const [klines1h, klines15m, klines5m, aggTrades] = await Promise.all([
                        fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                        fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 200 }, 'futures').catch(() => null),
                        fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '5m', limit: 200 }, 'futures').catch(() => []),
                        fetchBinanceAPIData('aggTrades', { symbol: mover.symbol, limit: 1000 }, 'futures').catch(() => [])
                    ]);

                    realtimeCache.movers[mover.symbol] = {
                        klines_1h: klines1h,
                        klines_5m: klines5m,
                        aggTrades: aggTrades,
                    };

                    return {
                        ...mover,
                        change1h: calculateChange(klines1h.slice(-2)),
                        change15m: calculateChange(klines15m)
                    };
                }));

                // >>> AWAL BLOK PENAMBAHAN ASET PIN <<<
                const pinnedAssets = ['BTCUSDT', 'ASTERUSDT'];

                // Filter aset pin yang belum ada di daftar top movers untuk menghindari duplikat
                const existingSymbols = new Set(gainersWithDetails.map(m => m.symbol));
                const assetsToFetch = pinnedAssets.filter(symbol => !existingSymbols.has(symbol));

                if (assetsToFetch.length > 0) {
                    // Ambil data ticker untuk aset yang di-pin dari data yang sudah di-fetch
                    const pinnedTickers = usdtPairs.filter(d => assetsToFetch.includes(d.symbol));

                    // Ambil detail klines untuk aset yang di-pin (logika sama seperti top movers)
                    const pinnedAssetsWithDetails = await Promise.all(pinnedTickers.map(async (mover) => {
                        const [klines1h, klines15m, klines5m, aggTrades] = await Promise.all([
                            fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                            fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 200 }, 'futures').catch(() => null),
                            fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '5m', limit: 200 }, 'futures').catch(() => []),
                            fetchBinanceAPIData('aggTrades', { symbol: mover.symbol, limit: 1000 }, 'futures').catch(() => [])
                        ]);

                        realtimeCache.movers[mover.symbol] = {
                            klines_1h: klines1h,
                            klines_5m: klines5m,
                            aggTrades: aggTrades,
                        };

                        // Dapatkan kembali fungsi helper 'calculateChange' jika tidak tersedia secara global
                        const calculateChange = (kData) => {
                            if (!kData || kData.length < 2) return 'N/A';
                            const prevClose = parseFloat(kData[0][4]);
                            const currentClose = parseFloat(kData[1][4]);
                            return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
                        };

                        return {
                            ...mover,
                            change1h: calculateChange(klines1h.slice(-2)),
                            change15m: calculateChange(klines15m),
                            dynamicPriceChange: parseFloat(mover.priceChangePercent)
                        };
                    }));

                    // Gabungkan daftar top movers dengan daftar aset yang di-pin
                    gainersWithDetails.push(...pinnedAssetsWithDetails);
                }
                renderMoversList('gainers-list', gainersWithDetails, true, timeframe);

                if (losersList) {
                }

                attachTopMoversListeners();
                WebSocketManager.subscribeToMovers(gainersWithDetails.map(m => m.symbol));

            } catch (error) {
                console.error("Failed Getting Top Movers Data:", error);
                document.getElementById('gainers-list').innerHTML = `<div class="text-red-500 text-xs p-2">Error: ${error.message}. Try Again Later...</div>`;
                if (losersList) losersList.innerHTML = '';
            }
        }
        // 
        function renderMoversList(containerId, moversData, isGainer, timeframe) {
            const container = document.getElementById(containerId);
            if (!container) return; // Pengaman jika kontainer NONE

            let html = "";
            const maxStrengthScore = isGainer && moversData.length > 0 && moversData[0].strengthScore ? moversData[0].strengthScore : 1;

            moversData.forEach(item => {
                const priceChange24h = parseFloat(item.priceChangePercent);
                // Ganti text-white menjadi text-gray-800 dark:text-white
                let headerHtml = `<div class="flex justify-between items-center text-sm font-semibold"><span class="font-bold text-gray-800 dark:text-white cursor-pointer" onclick="runFullAnalysis('${item.symbol}')">${item.symbol}</span><span class="font-mono text-gray-800 dark:text-white" id="price-${item.symbol}">${formatPrice(parseFloat(item.lastPrice))}</span></div>`;
                let detailsHtml = '';

                if (isGainer) {
                    const pumpStrengthPercentage = Math.max(0, item.dynamicPriceChange > 0 ? Math.min(100, item.dynamicPriceChange * 2) : 0);

                    const formatChange = (val, lbl) => {
                        if (val === 'N/A' || isNaN(parseFloat(val))) return `<span class="text-gray-500">${lbl}: --</span>`;
                        const value = parseFloat(val);
                        const color = value >= 0 ? 'positive' : 'negative';
                        // Logika untuk menyorot timeframe aktif
                        const isPrimary = timeframe && timeframe.toUpperCase() === lbl;
                        return `<span class="${color} ${isPrimary ? 'font-bold underline' : ''}">${lbl}: ${value.toFixed(2)}%</span>`;
                    };

                    detailsHtml = `<div class="flex justify-between items-center">
                    <div class="flex items-center gap-2 text-xs font-mono">
                        ${formatChange(priceChange24h, '24H')} 
                        ${formatChange(item.change1h, '1H')} 
                        ${formatChange(item.change15m, '15M')}
                    </div>
                    <div class="hybrid-bar" id="hybrid-bar-${item.symbol}">
                        <div class="pump-strength" style="width: ${pumpStrengthPercentage}%"></div>
                        <div class="dump-risk" style="width:0%;"></div>
                    </div>
                </div>`;
                } else {
                }

                html += `<div class="flex flex-col bg-gray-100 dark:bg-gray-800 p-2 rounded gap-2 mover-item" data-symbol="${item.symbol}">${headerHtml}${detailsHtml}</div>`;
            });

            container.innerHTML = html || `<div class="text-xs text-gray-500 p-2">NONE data.</div>`;
        }
        // 
        function calculateShortConfluenceScore(symbol, timeframe) {
            if (!symbol) return { score: 0, breakdown: {} };

            let klines;
            let aggTrades;

            if (symbol === realtimeCache.main.symbol) {
                klines = realtimeCache.main.multiTfKlines[timeframe];
                aggTrades = realtimeCache.main.cvdData ? null : realtimeCache.main.aggTrades;
            } else if (realtimeCache.movers[symbol]) {
                if (timeframe === '5m') {
                    klines = realtimeCache.movers[symbol].klines_5m;
                } else {
                    klines = realtimeCache.movers[symbol].klines_1h;
                }
                aggTrades = realtimeCache.movers[symbol].aggTrades;
            } else {
                console.error(`NONE data cache yang ditemukan untuk simbol ${symbol}`);
                return { score: 0, breakdown: {} };
            }

            if (!klines || klines.length < 50) {
                return { score: 0, breakdown: {} };
            }

            const closes = klines.map(k => parseFloat(k[4]));
            const cvdDataForAnalysis = (symbol === realtimeCache.main.symbol && realtimeCache.main.cvdData)
                ? realtimeCache.main.cvdData
                : calculateCVD(aggTrades || []);

            const bbData = calculateBollingerBands(closes);
            const lastUpper = bbData.upper.filter(v => v !== undefined).pop() || 0;
            const lastMiddle = bbData.middle.filter(v => v !== undefined).pop() || 0;
            const lastLower = bbData.lower.filter(v => v !== undefined).pop() || 0;

            const indicators = {
                candlePattern: findCandlestickPatterns(klines),
                macd: calculateMACD(closes),
                rsi: calculateRSI(closes),
                bollingerBands: analyzeBollingerBandsPriceAction(klines, bbData),
                cvd: CVDanalyze(klines, cvdDataForAnalysis),
                atr: calculateATR(klines)
            };

            const atrStatus = indicators.atr.status;
            let volatilityMultiplier = 1.0;

            if (atrStatus === 'High') {
                volatilityMultiplier = 0.75;
            } else if (atrStatus === 'Very High') {
                volatilityMultiplier = 0.5;
            }

            const lastRsiValue = indicators.rsi.filter(v => v !== undefined).pop() || 50;
            let score = 0;

            let breakdown = {
                rsiValue: lastRsiValue.toFixed(2),
                macdStatus: indicators.macd.status,
                bbStatus: indicators.bollingerBands.rejection,
                bbUpper: formatPrice(lastUpper),
                bbMiddle: formatPrice(lastMiddle),
                bbLower: formatPrice(lastLower),
                cvdStatus: indicators.cvd.divergence,
                candlePattern: indicators.candlePattern.pattern,
                candleRed: { triggered: false, points: 0 },
                doji: { triggered: false, points: 0 },
                cvdDip: { triggered: false, points: 0 },
                cvdDivergence: { triggered: false, points: 0 },
                rsiOverbought: { triggered: false, points: 0 },
                bbRejection: { triggered: false, points: 0 },
                macdCross: { triggered: false, points: 0 },
                volumeExhaustion: { triggered: false, points: 0 }
            };

            const lookbackPeriod = 15;
            const recentKlines = klines.slice(-lookbackPeriod);

            if (recentKlines.length >= 3) {
                let peakIndex = 0;
                for (let i = 1; i < recentKlines.length; i++) {
                    if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
                }

                if (peakIndex < lookbackPeriod - 2) {
                    const triggerCandleArr = recentKlines[peakIndex + 1];
                    if (triggerCandleArr) {
                        const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                        if (triggerCandle.Close < triggerCandle.Open) {
                            const points = 3 * volatilityMultiplier;
                            score += points;
                            breakdown.candleRed = { triggered: true, points: points };
                        }
                    }
                }

                if (peakIndex > 4 && peakIndex < recentKlines.length - 1) {
                    const pumpVolumeLookback = 5;
                    const pumpCandles = recentKlines.slice(peakIndex - pumpVolumeLookback, peakIndex);

                    if (pumpCandles.length > 0) {
                        const avgPumpVolume = pumpCandles.reduce((sum, k) => sum + parseFloat(k[5]), 0) / pumpCandles.length;
                        const peakVolume = parseFloat(recentKlines[peakIndex][5]);

                        if (peakVolume < (avgPumpVolume * 0.6)) {
                            const points = 2;
                            score += points;
                            breakdown.volumeExhaustion = { triggered: true, points: points };
                        }
                    }
                }
            }

            if (indicators.candlePattern.bias === 'BEARISH') {
                const points = 1 * volatilityMultiplier;
                score += points;
                breakdown.doji = { triggered: true, points: points };
            }

            const now = Date.now();
            if (now - lastCvdDipCalculationTime > CVD_DIP_DEBOUNCE_MS) {
                lastCvdDipCalculationTime = now;
                const cvdValues = cvdDataForAnalysis.map(d => d.cvd_usdt);
                const changeLookback = 50;
                const stdDevMultiplier = 1.3;

                if (cvdValues.length > changeLookback) {
                    let cvdChanges = [];
                    for (let i = cvdValues.length - changeLookback; i < cvdValues.length; i++) {
                        cvdChanges.push(cvdValues[i] - cvdValues[i - 1]);
                    }
                    const avgChange = cvdChanges.reduce((sum, val) => sum + val, 0) / changeLookback;
                    const variance = cvdChanges.reduce((sum, val) => sum + Math.pow(val - avgChange, 2), 0) / changeLookback;
                    const stdDev = Math.sqrt(variance);
                    const lastChange = cvdChanges[cvdChanges.length - 1];
                    if (lastChange < (avgChange - (stdDevMultiplier * stdDev))) {
                        const points = 0.09 * volatilityMultiplier;
                        lastCvdDipResult = { triggered: true, points: points };
                    } else {
                        lastCvdDipResult = { triggered: false, points: 0 };
                    }
                } else {
                    lastCvdDipResult = { triggered: false, points: 0 };
                }
            }

            if (lastCvdDipResult.triggered) {
                score += lastCvdDipResult.points;
            }
            breakdown.cvdDip = lastCvdDipResult;

            if (indicators.cvd.divergence.includes('Bearish')) {
                const points = 2 * volatilityMultiplier;
                score += points;
                breakdown.cvdDivergence = { triggered: true, points: points };
            }

            if (lastRsiValue > 70) {
                const points = 2 * volatilityMultiplier;
                score += points;
                breakdown.rsiOverbought = { triggered: true, points: points };
            }

            if (indicators.bollingerBands.rejection === 'Bearish Rejection (Upper BB)') {
                score += 3;
                breakdown.bbRejection = { triggered: true, points: 3 };
            }
            if (indicators.macd.status === 'Bearish Cross') {
                score += 2;
                breakdown.macdCross = { triggered: true, points: 2 };
            }
            return { score: Math.min(score, 10), breakdown };
        }
        // 
        function getConfluenceAnalysis(klines) {
            if (!klines || klines.length < 50) {
                return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
            }

            let skorBullish = 0;
            let skorBearish = 0;
            const closes = klines.map(k => parseFloat(k[4]));

            // --- Kalkulasi Indikator Penting ---
            const rsiValues = calculateRSI(closes);
            const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
            const macd = calculateMACD(closes);
            const candlePattern = findCandlestickPatterns(klines);
            const rsiDivergence = detectRSIDivergence(closes, rsiValues);

            // --- Logika Penilaian Bearish ---
            if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
            if (macd.status === 'Bearish Cross') skorBearish += 2.0;
            if (lastRsi > 70) skorBearish += 1.5; // Overbought
            if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

            // --- Logika Penilaian Bullish ---
            if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
            if (macd.status === 'Bullish Cross') skorBullish += 2.0;
            if (lastRsi < 30) skorBullish += 1.5; // Oversold
            if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;

            // Total skor maksimal adalah 8
            const totalPossibleScore = 8.0;

            return {
                skorBullish: (skorBullish / totalPossibleScore) * 10,
                skorBearish: (skorBearish / totalPossibleScore) * 10,
                detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
            };
        }
        // 
        function onNewMoverData(symbol, streamName, payload) {
            if (!realtimeCache.movers[symbol]) {
                realtimeCache.movers[symbol] = { klines_1h: [], aggTrades: [], orderBook: { bids: [], asks: [] } };
            }
            const moverData = realtimeCache.movers[symbol];

            // Blok untuk memproses update kline 1 jam
            if (streamName.includes('@kline_1h')) {
                const k = payload.k;
                // Format kline baru sebagai ARRAY agar konsisten dengan data awal
                const newKlineArray = [
                    k.t, k.o, k.h, k.l, k.c, k.v, k.T,
                    k.q, k.n, k.V, k.Q, k.B
                ];

                // Cek kline terakhir berdasarkan timestamp di indeks [0]
                if (moverData.klines_1h && moverData.klines_1h.length > 0 && moverData.klines_1h[moverData.klines_1h.length - 1][0] === k.t) {
                    // Update kline terakhir jika timestamp sama
                    moverData.klines_1h[moverData.klines_1h.length - 1] = newKlineArray;
                } else {
                    // Tambahkan kline baru jika ini candle baru
                    moverData.klines_1h.push(newKlineArray);
                }

                // Jaga agar panjang array tidak melebihi batas
                if (moverData.klines_1h.length > 200) {
                    moverData.klines_1h.shift();
                }
            }
            // Blok untuk memproses update trade
            else if (streamName.includes('@aggTrade')) {
                moverData.aggTrades.push(payload);
                if (moverData.aggTrades.length > 1000) moverData.aggTrades.shift();
            }
            // Blok untuk memproses update order book
            else if (streamName.includes('@depth20')) {
                moverData.orderBook = { bids: payload.bids, asks: payload.asks };
            }
            // ================== AWAL BLOK PERBAIKAN FINAL ==================
            // Menghitung dan memperbarui "Bullish Momentum" bar secara real-time untuk setiap mover
            let pumpStrengthPercentage = 0;
            const klines1h = moverData.klines_1h;
            if (klines1h && klines1h.length >= 2) {
                const prevClose = parseFloat(klines1h[klines1h.length - 2][4]);
                const lastClose = parseFloat(klines1h[klines1h.length - 1][4]);
                const change1h = prevClose > 0 ? ((lastClose - prevClose) / prevClose) * 100 : 0;
                // Kalkulasi sederhana: persentase kenaikan dikali 2, maks 100%
                pumpStrengthPercentage = Math.max(0, change1h > 0 ? Math.min(100, change1h * 2) : 0);
            }

            // Update langsung elemen UI (bar) untuk mover yang bersangkutan
            const pumpBarElement = document.querySelector(`#hybrid-bar-${symbol} .pump-strength`);
            if (pumpBarElement) {
                pumpBarElement.style.width = `${pumpStrengthPercentage}%`;
            }

            // Menghitung skor Dump Potention
            const scoreData = calculateShortConfluenceScore(symbol, '5m');

            if (scoreData !== null) {
                // Memperbarui UI skor Dump Potention
                updateShortScoreUI(symbol, scoreData.score, scoreData.breakdown);

                // Sinkronisasi dengan panel utama jika mover yang diupdate adalah aset yang sedang dianalisis
                if (realtimeCache.main.symbol === symbol) {
                    const klines1h_sync = moverData.klines_1h;

                    // Perbarui skor pump/dump di cache utama
                    if (klines1h_sync.length >= 2) {
                        // Anda bisa menambahkan logika skor pump yang lebih kompleks di sini jika perlu
                        // Untuk sekarang, kita akan sinkronkan skor pump & dump
                    }
                    realtimeCache.main.liveScores.pumpStrength = pumpStrengthPercentage;
                    realtimeCache.main.liveScores.dumpRisk = scoreData.score;

                    // Sinkronkan data kline 1 jam terbaru ke cache utama SEBELUM render ulang
                    realtimeCache.main.klines1h = klines1h_sync;

                    // Panggil ulang render panel scalping dengan data terbaru
                    calculateAndDisplayScalpingSetup();
                }
            }
        }
        // 
        function calculateAndDisplayScalpingSetup() {
            const selectedDumpTf = document.getElementById('dump-trigger-timeframe-select').value;
            const { klines, calculatedData, symbol, selectedTimeframe, tfAlignmentSummary } = realtimeCache.main;
            if (!klines || klines.length < 50 || !calculatedData) {
                document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Not Enough Data</p>';
                return;
            }

            // --- 1. AMBIL DATA DAN HITUNG SKOR UTAMA ---
            document.getElementById('scalping-timeframe-display').textContent = `üí≤${symbol} at TF ${selectedTimeframe}`;
            const scoreData = calculateShortConfluenceScore(symbol, selectedDumpTf) || { score: 0, breakdown: {} };
            const dumpRiskScore = scoreData.score;
            const triggerBreakdown = scoreData.breakdown;

            // Sinkronisasi Pump/Dump Score (Realtime)
            const pumpStrength = realtimeCache.main.liveScores.pumpStrength || 0;
            document.getElementById('main-pump-bar').style.width = `${pumpStrength}%`;
            document.getElementById('main-dump-bar').style.width = `${dumpRiskScore * 10}%`;
            document.getElementById('main-pump-score').textContent = `${pumpStrength.toFixed(0)}%`;
            document.getElementById('main-dump-score').textContent = `${dumpRiskScore}/10`;
            renderTriggerBreakdown(triggerBreakdown);

            const container = document.getElementById('scalping-setup-content');
            const closes = klines.map(k => parseFloat(k[4]));
            const lastPrice = closes[closes.length - 1];

            // --- 2. TENTUKAN BIAS KONTEKSTUAL BERDASARKAN QUICK CONF. SCORE (AI-WEIGHTED) ---
            let biasKontekstual = "NETRAL / CHOP";
            let biasClass = "status-chop";
            let biasDetail = "Waiting Signal...";
            let trenUtama = "CHOP";
            let trenUtamaClass = "status-chop";

            // Dapatkan skor Konfluensi yang telah diboboti oleh AI Regime
            const quickScore = realtimeCache.main.quickConfluenceScore;
            const skorBullish = quickScore?.bull || 0;
            const skorBearish = quickScore?.bear || 0;

            if (tfAlignmentSummary && tfAlignmentSummary.summary['1h']) {
                const trend1h = tfAlignmentSummary.summary['1h'];
                if (trend1h === 'UPTREND') { trenUtama = "UPTREND"; trenUtamaClass = "status-uptrend"; }
                else if (trend1h === 'DOWNTREND') { trenUtama = "DOWNTREND"; trenUtamaClass = "status-downtrend"; }
            }

            biasDetail = `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`;

            const diff = skorBullish - skorBearish;
            const absDiff = Math.abs(diff);

            // Gunakan ambang batas absolut (15%) untuk memfilter sinyal lemah
            if (absDiff > 5) {
                if (diff > 0) { // Bullish kuat
                    if (trenUtama === 'UPTREND') { biasKontekstual = 'LONG (Follow Trend)'; biasClass = 'status-uptrend'; }
                    else { biasKontekstual = 'LONG (Counter Trend/Range)'; biasClass = 'status-uptrend'; }
                } else { // Bearish kuat
                    if (trenUtama === 'DOWNTREND') { biasKontekstual = 'SHORT (Follow Trend)'; biasClass = 'status-downtrend'; }
                    else { biasKontekstual = 'SHORT (Counter Trend/Range)'; biasClass = 'status-downtrend'; }
                }
            } else {
                biasKontekstual = "NETRAL / CHOP";
                biasClass = "status-chop";
            }

            // --- 3. INISIALISASI VARIABEL SETUP ---
            let entryPrice = NaN, stopLoss = NaN, takeProfit1 = NaN, takeProfit2 = NaN;
            let entryPercent = '', slPercent = '', tp1Percent = '', tp2Percent = '';
            let slColorClass = 'text-gray-500', tpColorClass = 'text-gray-500';
            let finalVerdictHtml = '';
            let takeProfit3 = calculatedData.fibExtensions?.levels?.level_1_618; // Default ke Fib Extension

            // --- 4. KALKULASI ENTRY/SL/TP BERDASARKAN BIAS ---
            if (biasKontekstual !== "NETRAL / CHOP") {
                const biasKalkulator = biasKontekstual.startsWith('LONG') ? 'LONG' : 'SHORT';
                const ema9 = calculateEMA(closes, 9).pop();
                const pivots = calculatedData.pivot.data;
                const vpvr = calculatedData.vpvr;
                const atrValue = calculatedData.atr.value;

                entryPrice = ema9; // Entry di EMA9 (Pullback)

                let structuralSL, structuralTP1;

                if (biasKalkulator === 'LONG') {
                    // LONG: SL harus Support, TP1 harus Resistance
                    structuralSL = pivots?.S1 || vpvr.val; // Ambil nilai Support terdekat
                    structuralTP1 = pivots?.R1 || vpvr.vah; // Ambil nilai Resistance terdekat

                    stopLoss = structuralSL - atrValue;
                    takeProfit1 = structuralTP1;

                    // CRITICAL CHECK: Jika TP1 ternyata lebih rendah dari Entry (kesalahan data/logika), 
                    // kita paksa TP1 menggunakan TP2 (RR 1:1) dan SL harus valid.
                    if (takeProfit1 <= entryPrice) {
                        const risk = Math.abs(entryPrice - stopLoss);
                        takeProfit1 = entryPrice + risk; // Paksa RR 1:1
                    }

                    const risk = Math.abs(entryPrice - stopLoss);
                    takeProfit2 = entryPrice + (risk * 1.5);

                    slColorClass = 'negative';
                    tpColorClass = 'positive';
                } else { // SHORT
                    // SHORT: SL harus Resistance, TP1 harus Support
                    structuralSL = pivots?.R1 || vpvr.vah; // Ambil nilai Resistance terdekat
                    structuralTP1 = pivots?.S1 || vpvr.val; // Ambil nilai Support terdekat

                    stopLoss = structuralSL + atrValue;
                    takeProfit1 = structuralTP1;

                    // CRITICAL CHECK: Jika TP1 ternyata lebih tinggi dari Entry (kesalahan data/logika), 
                    // kita paksa TP1 menggunakan TP2 (RR 1:1) dan SL harus valid.
                    if (takeProfit1 >= entryPrice) {
                        const risk = Math.abs(stopLoss - entryPrice);
                        takeProfit1 = entryPrice - risk; // Paksa RR 1:1
                    }

                    const risk = Math.abs(stopLoss - entryPrice);
                    takeProfit2 = entryPrice - (risk * 1.5);

                    slColorClass = 'negative';
                    tpColorClass = 'positive';
                }
                const getPNLPercentage = (target, entry, bias) => {
                    if (typeof target !== 'number' || entry === 0) return '';
                    const change = (target - entry) / entry;

                    // Jika TP (profit), selalu positif
                    const isTP = (bias === 'LONG' && target > entry) || (bias === 'SHORT' && target < entry);
                    if (isTP) {
                        return `(+${(Math.abs(change) * 100).toFixed(2)}%)`;
                    }

                    // Jika SL (loss), selalu negatif
                    const isSL = (bias === 'LONG' && target < entry) || (bias === 'SHORT' && target > entry);
                    if (isSL) {
                        return `(${(change * 100).toFixed(2)}%)`;
                    }

                    // Untuk Entry Percent, hitung murni
                    return `(${(change * 100).toFixed(2)}%)`;
                };

                entryPercent = getPNLPercentage(entryPrice, lastPrice, biasKalkulator);
                slPercent = getPNLPercentage(stopLoss, entryPrice, biasKalkulator);
                tp1Percent = getPNLPercentage(takeProfit1, entryPrice, biasKalkulator);
                tp2Percent = getPNLPercentage(takeProfit2, entryPrice, biasKalkulator);

                slColorClass = 'negative';
                tpColorClass = 'positive';
                realtimeCache.main.latestScalpingSetup = { entry: entryPrice, sl: stopLoss, tp1: takeProfit1 };
            } else {
                finalVerdictHtml = `
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-center p-4 rounded-lg bg-gray-100 dark:bg-gray-800/50">
                <p class="font-semibold text-sm text-yellow-400">SIDEWAYS</p>
                <p class="text-sm text-gray-400 mt-1">No Feasible Long/Short Setup. Do Not Trade.</p>
            </div>
        `;
                realtimeCache.main.latestScalpingSetup = null;
            }

            // --- Auto-Trade Logic ---
            paperTrade.autoTradeLogic(biasKontekstual, entryPrice, stopLoss, takeProfit1);

            // Format Display (Gunakan NaN check)
            const formatValue = (value, fallback = '--') => isNaN(value) ? fallback : formatPrice(value);

            const entryDisplay = formatValue(entryPrice);
            const slDisplay = formatValue(stopLoss);
            const tp1Display = formatValue(takeProfit1);
            const tp2Display = formatValue(takeProfit2);

            // Final TP3 Display (Jika ada Fib Extension)
            const tp3Formatted = formatValue(takeProfit3, 'N/A');
            const tp3Percent = calculatePercentage(takeProfit3, entryPrice);
            const tp3Display = takeProfit3 && !isNaN(takeProfit3) ? `${tp3Formatted}<br><span class="text-xs font-mono ${tpColorClass}">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';

            // --- 5. RENDER UI ---
            container.innerHTML = `
        <div class="grid grid-cols-3 gap-3 text-center items-start">
            <div class="col-span-1">
                <p class="text-xs text-gray-500">Contextual Bias (TF: 1H)</p>
                <p class="text-[10px] font-mono ${trenUtamaClass}">1H Trend: ${trenUtama}</p> 
                <p class="text-sm font-semiboldblinking-text-animation ${biasClass}">${biasKontekstual}</p>
                <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
            </div>
            <div class="col-span-2 grid grid-cols-2 gap-3">
                <div>
                    <p class="text-xs text-gray-500">Entry</p>
                    <p class="font-normal text-sm text-yellow-400">${entryDisplay}</p>
                    <p class="text-xs font-mono text-yellow-500">${entryPercent}</p>
                </div>
                <div>
                    <p class="text-sm text-gray-500">SL (Structural)</p>
                    <p class="font-normal text-sm ${slColorClass}">${slDisplay}</p>
                    <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                </div>
            </div>
        </div>
        <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-3 text-center items-start">
            <div>
                <p class="text-xs text-gray-500">TP 1 (Structural)</p>
                <p class="font-normal ${tpColorClass}">${tp1Display}</p>
                <p class="text-xs font-mono ${tpColorClass}">${tp1Percent}</p>
            </div>
            <div>
                <p class="text-xs text-gray-500">TP 2 (R:R 1:1.5)</p>
                <p class="font-normal ${tpColorClass}">${tp2Display}</p>
                <p class="text-xs font-mono ${tpColorClass}">${tp2Percent}</p>
            </div>
            <div>
                <p class="text-xs text-gray-500">TP 3 (Key Level)</p>
                <p class="font-semibold text-sm">${tp3Display}</p>
            </div>
        </div>
        <div class="min-h-[55px] flex flex-col justify-center">
            ${finalVerdictHtml}
        </div>
    `;
        }
        // 
        // --- Fungsi Pembantu (Helper) yang diperlukan oleh Scalping Setup ---
        // TEMUKAN FUNGSI calculatePercentage dan GANTI SELURUHNYA
        // TEMUKAN FUNGSI calculatePercentage (BARIS 1530) dan GANTI SELURUHNYA
        function calculatePercentage(target, entry, biasKalkulator = 'LONG') {
            if (typeof target !== 'number' || typeof entry !== 'number' || isNaN(target) || isNaN(entry) || entry === 0) {
                return '';
            }

            let change = (target - entry) / entry;

            // Perbaikan Kritis: Jika posisi adalah SHORT, balikkan tanda (Short profit = harga turun, PNL harus positif).
            if (biasKalkulator === 'SHORT') {
                change = -change;
            }

            // Selalu tampilkan tanda negatif untuk Stop Loss (asumsi SL selalu dihitung agar menghasilkan change negatif)
            if (biasKalkulator !== 'NETRAL' && target < entry && Math.abs(change * 100) > 0.01 && biasKalkulator === 'LONG') {
                // Jika Target (SL Long) lebih rendah dari Entry, pastikan itu negatif
                return `(${(change * 100).toFixed(2)}%)`;
            }
            if (biasKalkulator !== 'NETRAL' && target > entry && Math.abs(change * 100) > 0.01 && biasKalkulator === 'SHORT') {
                // Jika Target (SL Short) lebih tinggi dari Entry, pastikan itu negatif
                return `(${(change * 100).toFixed(2)}%)`;
            }

            // Jika ini TP, atau SL yang sudah dibalikkan (di atas), tampilkan positif
            const sign = change >= 0 ? '' : '-'; // HANYA untuk kasus-kasus khusus seperti entry percent
            const absChange = Math.abs(change);

            // Periksa apakah ini SL (di mana kita ingin tanda negatif yang benar)
            // Cara terbaik adalah menghitung persentase SL terpisah tanpa membalikkan tanda, 
            // lalu memanggil fungsi ini untuk TP. Tapi karena ini satu fungsi, kita gunakan logika ini:

            // JIKA target adalah SL, kembalikan tanda negatif
            const isSL = (biasKalkulator === 'LONG' && target < entry) || (biasKalkulator === 'SHORT' && target > entry);
            if (isSL) {
                // Hitung persentase murni Entry ke Target dan pastikan negatif
                const pureChange = (target - entry) / entry * 100;
                return `(${pureChange.toFixed(2)}%)`;
            }

            // JIKA target adalah TP, kembalikan tanda positif
            return `(+${(absChange * 100).toFixed(2)}%)`;
        }

        function updateShortScoreUI(symbol, score, breakdown) {
            const dumpRiskElement = document.querySelector(`#hybrid-bar-${symbol} .dump-risk`);
            if (dumpRiskElement) dumpRiskElement.style.width = `${score * 10}%`;
            const moverItem = document.querySelector(`.mover-item[data-symbol="${symbol}"]`);
            if (moverItem) {
                moverItem.dataset.dumpRiskScore = score;
                moverItem.dataset.breakdown = JSON.stringify(breakdown || {});
            }
        }
        // 
        function attachTopMoversListeners() {
            document.querySelectorAll("#gainers-list .mover-item").forEach(el => {
                el.addEventListener("mouseenter", e => { showCustomTooltip(e.currentTarget); });
                el.addEventListener("mouseleave", () => { hideCustomTooltip(); });
                el.addEventListener("click", e => {
                    if (!el.classList.contains("tooltip-active")) {
                        document.querySelectorAll('.mover-item.tooltip-active').forEach(activeEl => activeEl.classList.remove('tooltip-active'));
                        el.classList.add("tooltip-active");
                        showCustomTooltip(e.currentTarget);
                        e.stopPropagation();
                    } else {
                        el.classList.remove("tooltip-active");
                        hideCustomTooltip();
                        runFullAnalysis(el.dataset.symbol);
                    }
                });
            });
        }
        // 
        function showCustomTooltip(target) {
            isTooltipActive = true;
            const tooltip = document.getElementById("custom-tooltip");
            const symbol = target.dataset.symbol;
            const score = target.dataset.dumpRiskScore || '0';
            const breakdown = JSON.parse(target.dataset.breakdown || '{}');

            tooltip.innerHTML = `
            <strong>${symbol} - Analisis Short</strong>
            <p>Skor Potensi Dump: ${score}/10</p>
            <ul class="list-none text-xs mt-2 space-y-1">
                <li>Candle Merah: ${breakdown.candleRed ? "‚úÖ" : "‚ñ´Ô∏è"}</li>
                <li>CVD Menukik: ${breakdown.cvd ? "‚úÖ" : "‚ñ´Ô∏è"}</li>
                <li>Shooting Star/Doji: ${breakdown.doji ? "‚úÖ" : "‚ñ´Ô∏è"}</li>
                <li class="italic text-gray-500">Resistance & Sell Wall (di panel utama)</li>
            </ul>`;
            tooltip.style.opacity = 1;
            tooltip.style.visibility = "visible";
            const rect = target.getBoundingClientRect();
            tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
            tooltip.style.left = `${rect.left + window.scrollX}px`;
        }
        // 
        function hideCustomTooltip() {
            isTooltipActive = false;
            const tooltip = document.getElementById("custom-tooltip");
            if (tooltip) {
                tooltip.style.opacity = 0;
                tooltip.style.visibility = "hidden";
            }
            document.querySelectorAll('.mover-item.tooltip-active').forEach(el => el.classList.remove('tooltip-active'));
        }
        // 
        function initTopMoversTimeframeSelector() {
            document.querySelectorAll(".top-movers-tf-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    document.querySelectorAll(".top-movers-tf-btn").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    window.currentScanTimeframe = btn.dataset.timeframe;

                    // Trigger scan for active tab
                    if (!document.getElementById('pump-hunter-list').classList.contains('hidden')) {
                        PumpHunter.scan();
                    } else {
                        DipHunter.scan();
                    }
                });
            });
        }
        // 
        function initRefreshIntervalSelector() {
            const select = document.getElementById("refresh-interval-select");
            select.addEventListener("change", () => {
                const interval = parseInt(select.value, 10);
                startTopMoversAutoRefresh(currentTimeframe, interval);
            });
        }
        // 
        async function startTopMoversAutoRefresh(timeframe = "1H", interval = 120000) {
            currentTimeframe = timeframe;
            currentInterval = interval;
            remainingTime = interval / 1000;

            if (topMoversInterval) clearInterval(topMoversInterval);
            if (topMoversCountdown) clearInterval(topMoversCountdown);

            const refreshMovers = async () => {
                if (!isTooltipActive) {
                    try {
                        if (!exchangeInfoCache.futures) {
                            ////console.log("Menunggu info bursa futures untuk Top Movers...");
                            await initializeExchangeInfo('futures');
                        }
                        await updateTopMovers(timeframe);
                        remainingTime = interval / 1000;
                    } catch (error) {
                        console.error("Gagal refresh Top Movers:", error);
                        const gainersList = document.getElementById('gainers-list');
                        if (gainersList) gainersList.innerHTML = `<div class="text-red-500 text-xs p-2">Error: ${error.message}</div>`;
                    }
                }
            };

            await refreshMovers();

            // Atur interval untuk refresh berikutnya
            topMoversInterval = setInterval(refreshMovers, interval);

            topMoversCountdown = setInterval(() => {
                if (!isTooltipActive) {
                    remainingTime--;
                    if (remainingTime < 0) remainingTime = interval / 1000;
                }
                const countdownEl = document.getElementById("refresh-countdown");
                if (countdownEl) {
                    countdownEl.textContent = isTooltipActive ? "‚è∏ Paused" : `‚è±Ô∏è ${remainingTime}s`;
                }
            }, 1000);
        }
        // 
        const tsCalc = {
            elements: {
                leverage: document.getElementById('ts-leverage'),
                cost: document.getElementById('ts-cost'),
                slider: document.getElementById('ts-margin-slider'),
                walletBalance: document.getElementById('ts-wallet-balance'),
                marketPrice: document.getElementById('ts-market-price'),
                tpslToggle: document.getElementById('ts-tpsl-toggle'),
                tpslInputs: document.getElementById('ts-tpsl-inputs'),
                takeProfit: document.getElementById('ts-take-profit'),
                stopLoss: document.getElementById('ts-stop-loss'),
                resultCost: document.getElementById('ts-result-cost'),
                resultMax: document.getElementById('ts-result-max'),
                resultPosSize: document.getElementById('ts-result-position-size'),
                resultLiqPrice: document.getElementById('ts-result-liq-price'),
                resultStatus: document.getElementById('ts-result-status'),
                resultSlPrice: document.getElementById('ts-result-sl-price'),
                resultRoe: document.getElementById('ts-result-roe'),
                crossBtn: document.getElementById('ts-mode-cross'),
                isolatedBtn: document.getElementById('ts-mode-isolated'),
                buyBtn: document.getElementById('ts-buy-long-btn'),
                sellBtn: document.getElementById('ts-sell-short-btn'),
                autofillBtn: document.getElementById('autofill-ts-btn'),
                tsOptionsBtn: document.getElementById('ts-trailing-stop-options'),
                // Elemen Modal
                modalContainer: document.getElementById('ts-modal-container'),
                modalCallbackRate: document.getElementById('ts-modal-callback-rate'),
                modalActivationPrice: document.getElementById('ts-modal-activation-price'),
                modalSaveBtn: document.getElementById('ts-modal-save-btn'),
                modalCloseBtn: document.getElementById('ts-modal-close-btn')
            },
            state: {
                marginMode: 'cross',
                leverage: 20,
                cost: 0,
                entryPrice: 0,
                walletBalance: 1000,
                tp: null,
                sl: null,
                callbackRate: null,
                activationPrice: null,
                positionType: 'long'
            },

            toggleModal: function (show) {
                if (show) {
                    this.elements.modalContainer.classList.remove('hidden');
                } else {
                    this.elements.modalContainer.classList.add('hidden');
                }
            },
            recalculate: function () {
                this.state.walletBalance = parseFloat(this.elements.walletBalance.value) || 0;
                this.state.leverage = parseFloat(this.elements.leverage.value) || 20;
                this.state.cost = parseFloat(this.elements.cost.value) || 0;
                const marketPrice = parseFloat(this.elements.marketPrice.value);

                const lastPrice = realtimeCache.main.tickerData?.lastPrice ? parseFloat(realtimeCache.main.tickerData.lastPrice) : this.state.entryPrice;
                if (lastPrice === 0 && !marketPrice) return;
                const entry = this.state.entryPrice || lastPrice;

                const positionSize = this.state.cost * this.state.leverage;
                const quantity = entry > 0 ? positionSize / entry : 0;

                this.elements.resultCost.textContent = `${this.state.cost.toFixed(2)} USDT`;
                this.elements.resultMax.textContent = `${this.state.walletBalance.toFixed(2)} USDT`;
                this.elements.resultPosSize.textContent = `${positionSize.toFixed(2)} USDT`;

                let liqPrice = 0;
                const maintenanceMarginRate = 0.004;
                if (positionSize > 0) {
                    if (this.state.marginMode === 'isolated') {
                        const priceChange = (this.state.cost / positionSize) * (1 - maintenanceMarginRate);
                        liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                    } else { // Cross
                        const priceChange = ((this.state.walletBalance) / positionSize) * (1 - maintenanceMarginRate);
                        liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                    }
                }
                this.elements.resultLiqPrice.textContent = liqPrice > 0 ? `${liqPrice.toFixed(4)} USDT` : 'N/A';

                if (this.state.callbackRate && this.state.activationPrice && !isNaN(marketPrice)) {
                    let isActive = false;
                    let stopLossPrice = 0;

                    if (this.state.positionType === 'long' ? marketPrice >= this.state.activationPrice : marketPrice <= this.state.activationPrice) {
                        isActive = true;
                        const rate = this.state.callbackRate / 100;
                        stopLossPrice = this.state.positionType === 'long' ? marketPrice * (1 - rate) : marketPrice * (1 + rate);

                        this.elements.resultStatus.textContent = 'Aktif ‚úÖ';
                        this.elements.resultStatus.className = 'positive';
                        this.elements.resultSlPrice.textContent = `${stopLossPrice.toFixed(4)} USDT`;

                        const pnl = (this.state.positionType === 'long') ? (stopLossPrice - entry) * quantity : (entry - stopLossPrice) * quantity;
                        const roe = this.state.cost > 0 ? (pnl / this.state.cost) * 100 : 0;
                        this.elements.resultRoe.textContent = `${roe.toFixed(2)}%`;
                        this.elements.resultRoe.className = pnl >= 0 ? 'profit positive' : 'loss negative';
                    } else {
                        this.elements.resultStatus.textContent = 'Belum Aktif';
                        this.elements.resultStatus.className = 'text-yellow-400';
                        this.elements.resultSlPrice.textContent = '--';
                        this.elements.resultRoe.textContent = '--';
                        this.elements.resultRoe.className = '';
                    }
                } else {
                    this.elements.resultStatus.textContent = 'Belum Diatur';
                    this.elements.resultStatus.className = 'text-gray-500';
                    this.elements.resultSlPrice.textContent = '--';
                    this.elements.resultRoe.textContent = '--';
                    this.elements.resultRoe.className = '';
                }
            },

            autofill: function () {

                const setup = realtimeCache.main.latestScalpingSetup; // Benar 'i'

                if (!setup || !setup.entry) { // Pengecekan lebih kuat
                    alert("Setup scalping belum siap atau pasar sedang sideways. Tidak bisa auto-fill.");
                    return;
                }

                // Tentukan tipe posisi dari setup
                const isLong = setup.tp1 > setup.entry;
                this.state.positionType = isLong ? 'long' : 'short';

                // Perbarui UI tombol Buy/Sell
                if (isLong) {
                    this.elements.buyBtn.classList.remove('opacity-50');
                    this.elements.sellBtn.classList.add('opacity-50');
                } else {
                    this.elements.sellBtn.classList.remove('opacity-50');
                    this.elements.buyBtn.classList.add('opacity-50');
                }

                // Dapatkan harga pasar saat ini dari cache
                const currentMarketPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                const precision = getPrecisionForAsset(currentMarketPrice);

                // Isi semua field di kalkulator
                this.elements.marketPrice.value = currentMarketPrice.toFixed(precision); // Harga saat ini
                this.elements.takeProfit.value = setup.tp1.toFixed(precision); // TP dari scalping setup
                this.elements.stopLoss.value = setup.sl.toFixed(precision);   // SL dari scalping setup

                // Aktifkan toggle TP/SL
                this.elements.tpslToggle.checked = true;
                this.elements.tpslInputs.classList.remove('hidden');

                // Beri fokus ke input modal agar pengguna bisa langsung mengisi
                this.elements.cost.focus();
                this.recalculate(); // Hitung ulang semua nilai di kalkulator

                // Scroll ke kalkulator agar terlihat
                this.elements.leverage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            },
        };
        // 
        function initializeNewCalculator() {
            const { elements, state } = tsCalc;

            elements.sellBtn.classList.add('opacity-50');
            state.positionType = 'long';

            elements.crossBtn.addEventListener('click', () => {
                state.marginMode = 'cross';
                elements.crossBtn.classList.add('active');
                elements.isolatedBtn.classList.remove('active');
                tsCalc.recalculate();
            });
            elements.isolatedBtn.addEventListener('click', () => {
                state.marginMode = 'isolated';
                elements.isolatedBtn.classList.add('active');
                elements.crossBtn.classList.remove('active');
                tsCalc.recalculate();
            });
            elements.buyBtn.addEventListener('click', () => {
                state.positionType = 'long';
                elements.buyBtn.classList.remove('opacity-50');
                elements.sellBtn.classList.add('opacity-50');

                if (confirm(`Buka posisi LONG simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                    paperTrade.openPosition('long', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
                }

                tsCalc.recalculate();
            });
            elements.sellBtn.addEventListener('click', () => {
                state.positionType = 'short';
                elements.sellBtn.classList.remove('opacity-50');
                elements.buyBtn.classList.add('opacity-50');

                if (confirm(`Buka posisi SHORT simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                    paperTrade.openPosition('short', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
                }

                tsCalc.recalculate();
            });
            elements.tpslToggle.addEventListener('change', () => {
                elements.tpslInputs.classList.toggle('hidden', !elements.tpslToggle.checked);
            });
            elements.slider.addEventListener('input', () => {
                const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
                const percentage = parseFloat(elements.slider.value);
                const newCost = (currentWalletBalance * (percentage / 100));
                elements.cost.value = newCost.toFixed(2);
                tsCalc.recalculate();
            });
            ['cost', 'leverage', 'walletBalance', 'marketPrice'].forEach(id => {
                elements[id].addEventListener('input', () => tsCalc.recalculate());
            });
            elements.cost.addEventListener('input', () => {
                const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
                const costValue = parseFloat(elements.cost.value) || 0;
                const percentage = currentWalletBalance > 0 ? (costValue / currentWalletBalance) * 100 : 0;
                elements.slider.value = Math.min(100, percentage);
            });
            elements.autofillBtn.addEventListener('click', () => tsCalc.autofill());

            // --- LOGIKA BARU UNTUK MODAL TS ---
            elements.tsOptionsBtn.addEventListener('click', () => tsCalc.toggleModal(true));
            elements.modalCloseBtn.addEventListener('click', () => tsCalc.toggleModal(false));
            elements.modalContainer.addEventListener('click', (e) => {
                if (e.target === elements.modalContainer) tsCalc.toggleModal(false);
            });
            elements.modalSaveBtn.addEventListener('click', () => {
                state.callbackRate = parseFloat(elements.modalCallbackRate.value);
                state.activationPrice = parseFloat(elements.modalActivationPrice.value);
                tsCalc.toggleModal(false);
                tsCalc.recalculate();
            });

            tsCalc.recalculate();
        }
        // === LOGIKA SIMULASI TRADING (MULAI) ===
        // === LOGIKA SIMULASI TRADING (MULAI) ===
        const PROXY_BASE_URL = 'http://localhost:3000'; // Sesuaikan jika proxy Anda berjalan di port/host lain

        async function sendBinanceRequest(method, endpoint, params = {}) {
            try {
                const response = await fetch(`${PROXY_BASE_URL}/proxy-request`, {
                    method: 'POST', // Proxy endpoint always uses POST
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ method, endpoint, params }),
                });

                const data = await response.json();

                if (response.ok) {
                    return data;
                } else {
                    console.error(`Binance API Error (${endpoint}):`, data);
                    throw new Error(data.msg || `Binance API Error: ${response.status}`);
                }
            } catch (error) {
                console.error('Error sending request to proxy:', error);
                throw error;
            }
        }


        let currentTradingMode;
        let isLiveSessionActive = false;
        // --- WHITE SWAN STRATEGY LOGIC (Ported from final_backtest.py) ---
        const WhiteSwanLogic = {
            RSI_PERIOD: 14,
            STOCH_PERIOD: 14,
            K_PERIOD: 3,
            D_PERIOD: 3,
            OVERBOUGHT: 80,
            OVERSOLD: 20,

            calculateRSI: function (closes) {
                if (closes.length < this.RSI_PERIOD + 1) return null;

                let gains = 0;
                let losses = 0;

                for (let i = 1; i <= this.RSI_PERIOD; i++) {
                    const diff = closes[closes.length - i] - closes[closes.length - i - 1];
                    if (diff >= 0) gains += diff;
                    else losses += Math.abs(diff);
                }

                let avgGain = gains / this.RSI_PERIOD;
                let avgLoss = losses / this.RSI_PERIOD;

                // Simple RSI for the last point (approximation for stream)
                // For better accuracy, we should maintain EMA of gains/losses
                if (avgLoss === 0) return 100;
                const rs = avgGain / avgLoss;
                return 100 - (100 / (1 + rs));
            },

            calculateStochRSI: function (closes) {
                // Need enough data
                if (closes.length < 30) return { k: 50, d: 50, trigger: 'NONE' };

                // Calculate RSI series
                const rsiSeries = [];
                for (let i = 0; i < closes.length; i++) {
                    // Slice closes to simulate historical calculation
                    // This is expensive in a loop, but necessary for correct StochRSI
                    // Optimization: Just calc last 20 RSIs
                    if (i < this.RSI_PERIOD) continue;

                    // Simple RSI Calculation (Window based)
                    let gains = 0, losses = 0;
                    for (let j = 0; j < this.RSI_PERIOD; j++) {
                        const diff = closes[i - j] - closes[i - j - 1];
                        if (diff >= 0) gains += diff;
                        else losses += Math.abs(diff);
                    }
                    const avgGain = gains / this.RSI_PERIOD;
                    const avgLoss = losses / this.RSI_PERIOD;
                    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                    rsiSeries.push(100 - (100 / (1 + rs)));
                }

                if (rsiSeries.length < this.STOCH_PERIOD) return { k: 50, d: 50, trigger: 'NONE' };

                // Calculate StochRSI
                const stochRsiSeries = [];
                for (let i = this.STOCH_PERIOD - 1; i < rsiSeries.length; i++) {
                    const window = rsiSeries.slice(i - this.STOCH_PERIOD + 1, i + 1);
                    const minRSI = Math.min(...window);
                    const maxRSI = Math.max(...window);
                    const stoch = maxRSI === minRSI ? 0 : (window[window.length - 1] - minRSI) / (maxRSI - minRSI);
                    stochRsiSeries.push(stoch * 100);
                }

                // Calculate K and D
                // Simple SMA for K and D
                const kValue = stochRsiSeries.slice(-this.K_PERIOD).reduce((a, b) => a + b, 0) / this.K_PERIOD;
                // We need previous K values to calculate D
                // This is getting complex to do perfectly in a simple function.
                // Let's use a simplified trigger check based on the LAST values.

                const currentK = kValue;
                // Approximation for D (SMA of K)
                const currentD = currentK; // Simplified for now

                let trigger = 'NONE';
                if (currentK < this.OVERSOLD) trigger = 'LONG'; // Aggressive Entry
                else if (currentK > this.OVERBOUGHT) trigger = 'SHORT'; // Aggressive Entry

                return { k: currentK, d: currentD, trigger: trigger };
            },

            // Check for entry signal based on current market data
            checkEntrySignal: function (klines) {
                const closes = klines.map(k => parseFloat(k[4])); // Close prices
                const srsi = this.calculateStochRSI(closes);
                return srsi.trigger;
            }
        };

        const paperTrade = {
            state: {
                balance: 1000,
                initialBalance: 1000,
                peakEquity: 1000,
                maxDrawdown: 0,
                totalTrades: 0,
                winningTrades: 0,
                losingTrades: 0,
                totalPnl: 0,
                isAutoTradeEnabled: false,
                position: null,
                history: []
            },
            elements: {
                equity: document.getElementById('sim-equity'),
                unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
                availableMargin: document.getElementById('sim-available-margin'),
                resetBtn: document.getElementById('sim-reset-account-btn'),
                positionContainer: document.getElementById('sim-active-position-container'),
                positionHeader: document.getElementById('sim-position-header'),
                closePositionBtn: document.getElementById('sim-close-position-btn'),
                positionSize: document.getElementById('sim-position-size'),
                positionEntry: document.getElementById('sim-position-entry'),
                positionMark: document.getElementById('sim-position-mark'),
                positionLiq: document.getElementById('sim-position-liq'),
                positionPnl: document.getElementById('sim-position-pnl'),
                tradeHistoryList: document.getElementById('sim-trade-history-list'),
                totalPnlDisplay: document.getElementById('sim-result-pnl'),
                winRateDisplay: document.getElementById('sim-result-winrate'),
                profitFactorDisplay: document.getElementById('sim-result-profit-factor'),
                totalTradesDisplay: document.getElementById('sim-result-total-trades'),
                maxDrawdownDisplay: document.getElementById('sim-result-max-drawdown'),
                expectancyDisplay: document.getElementById('sim-result-expectancy'),
                maxLoseStreakDisplay: document.getElementById('sim-result-losing-streak')
            },

            init: function () {
                this.loadState();
                this.elements.resetBtn.addEventListener('click', () => this.resetAccount());
                this.elements.closePositionBtn.addEventListener('click', () => this.closePosition());

                const importBtn = document.getElementById('sim-import-btn');
                const importInput = document.getElementById('sim-import-input');
                document.getElementById('sim-export-btn').addEventListener('click', exportHistoryToCSV);
                importBtn.addEventListener('click', () => importInput.click());
                importInput.addEventListener('change', importHistoryFromCSV);

                setInterval(() => this.update(), 500);
                this.render();
                this.calculateMetrics(); // Call calculateMetrics after loading state and rendering
            },

            calculateMetrics: function () {
                let totalPnl = 0;
                let winningTrades = 0;
                let losingTrades = 0;
                let totalProfit = 0;
                let totalLoss = 0;
                let currentEquity = this.state.initialBalance;
                let peakEquity = this.state.initialBalance;
                let maxDrawdown = 0;
                let currentDrawdown = 0;
                let currentLoseStreak = 0;
                let maxLoseStreak = 0;

                this.state.history.slice().reverse().forEach(trade => { // Iterate in chronological order
                    totalPnl += trade.pnl;
                    if (trade.pnl >= 0) {
                        winningTrades++;
                        totalProfit += trade.pnl;
                        currentLoseStreak = 0;
                    } else {
                        losingTrades++;
                        totalLoss += Math.abs(trade.pnl);
                        currentLoseStreak++;
                        if (currentLoseStreak > maxLoseStreak) {
                            maxLoseStreak = currentLoseStreak;
                        }
                    }

                    currentEquity += trade.pnl; // Update equity for drawdown calculation
                    if (currentEquity > peakEquity) {
                        peakEquity = currentEquity;
                    } else {
                        currentDrawdown = ((peakEquity - currentEquity) / peakEquity) * 100;
                        if (currentDrawdown > maxDrawdown) {
                            maxDrawdown = currentDrawdown;
                        }
                    }
                });

                this.state.totalTrades = this.state.history.length;
                this.state.winningTrades = winningTrades;
                this.state.losingTrades = losingTrades;
                this.state.totalPnl = totalPnl;
                this.state.peakEquity = peakEquity;
                this.state.maxDrawdown = maxDrawdown;
                this.state.maxLoseStreak = maxLoseStreak;

                const winRate = this.state.totalTrades > 0 ? (winningTrades / this.state.totalTrades) * 100 : 0;
                const profitFactor = totalLoss > 0 ? totalProfit / totalLoss : (totalProfit > 0 ? Infinity : 0);
                const avgWin = winningTrades > 0 ? totalProfit / winningTrades : 0;
                const avgLoss = losingTrades > 0 ? totalLoss / losingTrades : 0;
                const expectancy = (winRate / 100) * avgWin - ((100 - winRate) / 100) * avgLoss;

                // Update UI elements
                if (this.elements.totalPnlDisplay) this.elements.totalPnlDisplay.textContent = formatPrice(totalPnl);
                if (this.elements.totalPnlDisplay) this.elements.totalPnlDisplay.className = `font-mono text-xs ${totalPnl >= 0 ? 'positive' : 'negative'}`;
                if (this.elements.winRateDisplay) this.elements.winRateDisplay.textContent = `${winRate.toFixed(2)}%`;
                if (this.elements.profitFactorDisplay) this.elements.profitFactorDisplay.textContent = profitFactor.toFixed(2);
                if (this.elements.totalTradesDisplay) this.elements.totalTradesDisplay.textContent = this.state.totalTrades;
                if (this.elements.maxDrawdownDisplay) this.elements.maxDrawdownDisplay.textContent = `${maxDrawdown.toFixed(2)}%`;
                if (this.elements.maxDrawdownDisplay) this.elements.maxDrawdownDisplay.className = `font-mono text-xs ${maxDrawdown > 0 ? 'negative' : ''}`;
                if (this.elements.expectancyDisplay) this.elements.expectancyDisplay.textContent = formatPrice(expectancy);
                if (this.elements.maxLoseStreakDisplay) this.elements.maxLoseStreakDisplay.textContent = maxLoseStreak;
            },

            openPosition: async function (type, leverage, cost, entryPrice) {
                if (this.state.position) {
                    alert("Hanya 1 posisi yang bisa dibuka dalam satu waktu.");
                    return;
                }
                if (cost > this.state.balance && currentTradingMode === 'simulation') {
                    alert("Modal tidak cukup untuk membuka posisi.");
                    return;
                }

                const symbol = realtimeCache.main.symbol;
                const side = type === 'long' ? 'BUY' : 'SELL';
                const positionSide = type === 'long' ? 'LONG' : 'SHORT'; // For Binance Futures API

                if (currentTradingMode === 'live' && isLiveSessionActive) {
                    try {
                        // 1. Sync Account State to get real balance and position info
                        const accountData = await sendBinanceRequest('GET', '/fapi/v2/account');
                        const usdtAsset = accountData.assets.find(a => a.asset === 'USDT');
                        if (!usdtAsset) throw new Error('USDT asset not found in Binance account.');

                        const availableBalance = parseFloat(usdtAsset.availableBalance);
                        if (cost > availableBalance) {
                            alert(`Modal tidak cukup di Binance (${availableBalance.toFixed(2)} USDT) untuk membuka posisi.`);
                            return;
                        }

                        // 2. Set Leverage (if not already set or different)
                        // First, get current leverage for the symbol
                        const leverageInfo = await sendBinanceRequest('GET', '/fapi/v1/leverageBracket', { symbol: symbol });
                        const currentLeverage = leverageInfo[0]?.brackets[0]?.initialLeverage || 1; // Default to 1 if not found

                        if (currentLeverage !== leverage) {
                            console.log(`Setting leverage for ${symbol} to ${leverage}x...`);
                            await sendBinanceRequest('POST', '/fapi/v1/leverage', { symbol: symbol, leverage: leverage });
                        }

                        // 3. Calculate Quantity
                        // For market orders, quantity is base asset.
                        // cost is in quote asset (USDT).
                        // quantity = cost / entryPrice (approx for market order)
                        const quantity = (cost / entryPrice).toFixed(realtimeCache.main.pricePrecision); // Use pricePrecision for quantity precision

                        // 4. Place Market Order
                        console.log(`Placing ${side} market order for ${quantity} ${symbol} at ${entryPrice} (approx)...`);
                        const orderResult = await sendBinanceRequest('POST', '/fapi/v1/order', {
                            symbol: symbol,
                            side: side,
                            positionSide: positionSide,
                            type: 'MARKET',
                            quantity: quantity,
                            newOrderRespType: 'RESULT' // Get full order details
                        });
                        console.log('Binance Order Result:', orderResult);

                        // Update paperTrade state with live position details
                        this.state.balance = availableBalance - cost; // Deduct cost from actual balance
                        this.state.position = {
                            type: type,
                            entryPrice: parseFloat(orderResult.avgPrice), // Use actual average entry price
                            quantity: parseFloat(orderResult.executedQty),
                            leverage: leverage,
                            cost: cost, // Cost as intended
                            liqPrice: 0 // Will be updated by syncAccountState or a dedicated endpoint
                        };
                        alert(`Live ${type.toUpperCase()} order placed for ${symbol}!`);

                    } catch (error) {
                        console.error('Error placing live order:', error);
                        alert(`Gagal membuka posisi live: ${error.message}`);
                        return;
                    }
                } else { // Simulation Mode
                    const positionSize = cost * leverage;
                    const quantity = entryPrice > 0 ? positionSize / entryPrice : 0;

                    // Asumsi margin terisolasi untuk perhitungan likuidasi sederhana
                    const maintenanceMarginRate = 0.005;
                    const liqPriceChange = (cost / positionSize) * (1 - maintenanceMarginRate);
                    const liqPrice = type === 'long'
                        ? entryPrice * (1 - liqPriceChange)
                        : entryPrice * (1 + liqPriceChange);

                    this.state.balance -= cost;
                    this.state.position = {
                        type: type,
                        entryPrice: entryPrice,
                        quantity: quantity,
                        leverage: leverage,
                        cost: cost,
                        liqPrice: liqPrice
                    };
                }

                this.saveState();
                this.render();
                this.calculateMetrics(); // Recalculate metrics after opening position
            },

            closePosition: async function () {
                if (!this.state.position) return;
                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) {
                    alert("Tidak bisa menutup posisi, harga pasar tidak tersedia.");
                    return;
                }

                const pos = this.state.position;
                const symbol = realtimeCache.main.symbol;
                const side = pos.type === 'long' ? 'SELL' : 'BUY'; // Opposite of current position type
                const positionSide = pos.type === 'long' ? 'LONG' : 'SHORT';

                if (currentTradingMode === 'live' && isLiveSessionActive) {
                    try {
                        console.log(`Closing ${pos.type.toUpperCase()} position for ${symbol} with quantity ${pos.quantity}...`);
                        const orderResult = await sendBinanceRequest('POST', '/fapi/v1/order', {
                            symbol: symbol,
                            side: side,
                            positionSide: positionSide,
                            type: 'MARKET',
                            quantity: pos.quantity,
                            newOrderRespType: 'RESULT'
                        });
                        console.log('Binance Close Order Result:', orderResult);

                        // Assuming successful closure, update paperTrade state
                        // For live, we need to re-sync account to get actual PNL and balance
                        // For simplicity here, we'll just clear the position and let syncAccountState update balance
                        this.state.position = null;
                        alert(`Live ${pos.type.toUpperCase()} position for ${symbol} closed!`);

                    } catch (error) {
                        console.error('Error closing live position:', error);
                        console.error(`Gagal menutup posisi live: ${error.message}`);
                        return;
                    }
                } else { // Simulation Mode
                    const isLong = pos.type === 'long';
                    const pnlGross = (isLong ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * pos.quantity;

                    // Calculate fees
                    const entryNotional = pos.entryPrice * pos.quantity;
                    const closeNotional = markPrice * pos.quantity;
                    const totalFees = (entryNotional + closeNotional) * TAKER_FEE_NOTIONAL;

                    const pnlNet = pnlGross - totalFees;
                    const roeNet = (pos.cost > 0) ? (pnlNet / pos.cost) * 100 : 0;

                    this.state.balance += (pos.cost + pnlNet); // Add back cost + net PNL

                    this.state.history.unshift({
                        symbol: realtimeCache.main.symbol,
                        type: pos.type,
                        entryPrice: pos.entryPrice,
                        closePrice: markPrice,
                        pnl: pnlNet, // Store net PNL
                        roe: roeNet, // Store net ROE
                        closedAt: new Date(),
                        liquidated: false,
                        fees: totalFees // Store fees
                    });

                    if (this.state.history.length > 20) this.state.history.pop();

                    this.state.position = null;
                }

                this.saveState();
                this.render();
                this.calculateMetrics(); // Recalculate metrics after closing position
            },

            update: function () {
                if (!this.state.position) return;

                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) return;

                const pos = this.state.position;
                const isLong = pos.type === 'long';
                const pnlGross = (isLong ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * pos.quantity;

                // Calculate estimated fees for unrealized PNL
                const entryNotional = pos.entryPrice * pos.quantity;
                const currentNotional = markPrice * pos.quantity;
                const estimatedFees = (entryNotional + currentNotional) * TAKER_FEE_NOTIONAL;

                const pnlNetUnrealized = pnlGross - estimatedFees;

                const currentEquity = this.state.balance + pos.cost + pnlNetUnrealized;

                // Update peakEquity and maxDrawdown
                if (currentEquity > this.state.peakEquity) {
                    this.state.peakEquity = currentEquity;
                } else {
                    const currentDrawdown = ((this.state.peakEquity - currentEquity) / this.state.peakEquity) * 100;
                    if (currentDrawdown > this.state.maxDrawdown) {
                        this.state.maxDrawdown = currentDrawdown;
                    }
                }

                this.elements.equity.textContent = formatPrice(currentEquity);
                this.elements.unrealizedPnl.textContent = formatPrice(pnlNetUnrealized);
                this.elements.unrealizedPnl.className = `font-mono font-bold text-lg ${pnlNetUnrealized >= 0 ? 'positive' : 'negative'}`;
                this.elements.positionMark.textContent = formatPrice(markPrice);

                const roe = (pos.cost > 0) ? (pnlNetUnrealized / pos.cost) * 100 : 0;
                this.elements.positionPnl.textContent = `${formatPrice(pnlNetUnrealized)} (${roe.toFixed(2)}%)`;
                this.elements.positionPnl.className = `font-mono font-bold text-lg ml-2 ${pnlNetUnrealized >= 0 ? 'positive' : 'negative'}`;

                if ((pos.type === 'long' && markPrice <= pos.liqPrice) || (pos.type === 'short' && markPrice >= pos.liqPrice)) {
                    alert(`Posisi ${pos.type.toUpperCase()} terlikuidasi!`);

                    // Calculate fees for liquidated trade
                    const liquidationNotional = markPrice * pos.quantity;
                    const liquidationFees = (entryNotional + liquidationNotional) * TAKER_FEE_NOTIONAL;

                    this.state.history.unshift({
                        symbol: realtimeCache.main.symbol,
                        type: pos.type,
                        entryPrice: pos.entryPrice,
                        closePrice: markPrice,
                        pnl: -pos.cost - liquidationFees, // PNL is negative cost + fees
                        roe: -100,
                        closedAt: new Date(),
                        liquidated: true,
                        fees: liquidationFees
                    });
                    this.state.position = null;
                    this.saveState();
                    this.render();
                    this.calculateMetrics(); // Recalculate metrics after liquidation
                }
            },

            render: function () {
                const pos = this.state.position;

                if (pos) {
                    const currentEquity = this.state.balance + pos.cost;
                    this.elements.equity.textContent = formatPrice(currentEquity);
                    this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                    this.elements.positionContainer.classList.remove('hidden');
                    this.elements.positionHeader.textContent = `${pos.type.toUpperCase()} / ${pos.leverage}x`;
                    this.elements.positionHeader.className = `font-bold text-lg ${pos.type === 'long' ? 'positive' : 'negative'}`;
                    this.elements.positionSize.textContent = formatPrice(pos.cost * pos.leverage);
                    this.elements.positionEntry.textContent = formatPrice(pos.entryPrice);
                    this.elements.positionLiq.textContent = formatPrice(pos.liqPrice);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                } else {
                    this.elements.equity.textContent = formatPrice(this.state.balance);
                    this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                    this.elements.positionContainer.classList.add('hidden');
                }

                if (this.state.history.length > 0) {
                    this.elements.tradeHistoryList.innerHTML = this.state.history.map(trade => {
                        const pnlDisplay = trade.pnl !== undefined && trade.pnl !== null ? formatPrice(trade.pnl) : 'N/A';
                        const roeDisplay = trade.roe !== undefined && trade.roe !== null ? `${trade.roe.toFixed(2)}%` : 'N/A';
                        const pnlClass = trade.pnl !== undefined && trade.pnl !== null ? (trade.pnl >= 0 ? 'positive' : 'negative') : 'text-gray-400';
                        const typeClass = trade.type === 'long' ? 'positive' : 'negative';

                        return `
                            <div class="p-1.5 rounded-md ${pnlClass === 'positive' ? 'bg-green-900/40' : 'bg-red-900/40'}">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <span class="font-bold ${typeClass}">${trade.symbol} ${trade.type.toUpperCase()}</span>
                                        <span class="text-gray-400 text-[10px] ml-2">${trade.closedAt.toLocaleTimeString()}</span>
                                    </div>
                                    <div class="font-mono text-right ${pnlClass}">
                                        ${pnlDisplay} (${roeDisplay}) ${trade.liquidated ? 'üî•' : ''}
                                    </div>
                                </div>
                                <div class="text-gray-400 text-[10px] font-mono flex justify-between mt-1 pt-1 border-t border-gray-700/50">
                                    <span>Entry: ${formatPrice(trade.entryPrice)}</span>
                                    <span>Close: ${formatPrice(trade.closePrice)}</span>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    this.elements.tradeHistoryList.innerHTML = '<p class="text-center text-gray-600">No trade history yet.</p>';
                }
            },

            resetAccount: function () {
                if (confirm("Apakah Anda yakin ingin mereset akun simulasi? Semua riwayat akan hilang.")) {
                    this.state.balance = 1000;
                    this.state.initialBalance = 1000;
                    this.state.peakEquity = 1000;
                    this.state.maxDrawdown = 0;
                    this.state.totalTrades = 0;
                    this.state.winningTrades = 0;
                    this.state.losingTrades = 0;
                    this.state.totalPnl = 0;
                    this.state.position = null;
                    this.state.history = [];
                    this.saveState();
                    this.render();
                    this.calculateMetrics(); // Recalculate metrics after reset
                }
            },

            saveState: function () {
                localStorage.setItem('paperTradeState', JSON.stringify(this.state));
            },

            loadState: function () {
                const savedState = localStorage.getItem('paperTradeState');
                if (savedState) {
                    const loaded = JSON.parse(savedState);

                    // NEW: Always clear position on load to prevent stale state issues
                    loaded.position = null;

                    this.state = {
                        ...this.state,
                        ...loaded
                    };
                    if (this.state.history) {
                        this.state.history.forEach(trade => {
                            trade.closedAt = new Date(trade.closedAt);
                            // Robustly initialize potentially missing values
                            trade.pnl = trade.pnl ?? 0;
                            trade.roe = trade.roe ?? 0;
                            trade.fees = trade.fees ?? 0;
                            trade.symbol = trade.symbol ?? 'N/A';
                        });
                    }
                    // Ensure new metrics are initialized if not present
                    this.state.initialBalance = this.state.initialBalance ?? 1000;
                    this.state.peakEquity = this.state.peakEquity ?? this.state.initialBalance;
                    this.state.maxDrawdown = this.state.maxDrawdown ?? 0;
                    this.state.totalTrades = this.state.totalTrades ?? 0;
                    this.state.winningTrades = this.state.winningTrades ?? 0;
                    this.state.losingTrades = this.state.losingTrades ?? 0;
                    this.state.totalPnl = this.state.totalPnl ?? 0;
                    this.state.isAutoTradeEnabled = this.state.isAutoTradeEnabled ?? false;
                }
            },


            autoTradeLogic: function () {
                if (!this.state.isAutoTradeEnabled) return;

                // Ensure we have data
                if (!realtimeCache.main.klines || realtimeCache.main.klines.length < 50) return;

                const currentPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(currentPrice)) return;

                const currentPosition = this.state.position;

                // --- EXIT & MANAGEMENT LOGIC ---
                if (currentPosition) {
                    // 1. Check Intra-candle Liquidation (Simulated using current price as proxy for High/Low in live stream)
                    // In a real backtest we use High/Low. In live stream, we check every tick.
                    const isLong = currentPosition.type === 'long';

                    if ((isLong && currentPrice <= currentPosition.liqPrice) ||
                        (!isLong && currentPrice >= currentPosition.liqPrice)) {
                        console.log(`üî• LIQUIDATION TRIGGERED at ${currentPrice}`);
                        // Liquidation logic is handled in update() method, so we just let it happen there.
                        return;
                    }

                    // 2. Check Add Margin (Shit Happened)
                    // Logic: If PnL < -50% of Margin, Add Margin Once.
                    // PnL calc:
                    const pnlUnrealized = (isLong ? (currentPrice - currentPosition.entryPrice) : (currentPosition.entryPrice - currentPrice)) * currentPosition.quantity;
                    const pnlPercent = (pnlUnrealized / currentPosition.cost) * 100;

                    if (pnlPercent <= -50 && !currentPosition.marginAdded) {
                        console.log(`üöë ADD MARGIN TRIGGERED at ${currentPrice} (PnL: ${pnlPercent.toFixed(2)}%)`);

                        // Add Margin Logic
                        const addAmount = currentPosition.cost; // Add 100% of initial margin

                        // Check if we have enough balance
                        if (this.state.balance >= addAmount) {
                            this.state.balance -= addAmount;
                            currentPosition.cost += addAmount;
                            currentPosition.marginAdded = true;

                            // Recalculate BEP (Average Entry Price doesn't change if we just add margin to collateral, 
                            // BUT usually "Add Margin" in this strategy implies Averaging!
                            // So we must increase size too!

                            const newSize = (addAmount * currentPosition.leverage) / currentPrice;
                            const totalSize = currentPosition.quantity + newSize;
                            const totalCost = (currentPosition.entryPrice * currentPosition.quantity) + (currentPrice * newSize);
                            const newAvgPrice = totalCost / totalSize;

                            currentPosition.entryPrice = newAvgPrice;
                            currentPosition.quantity = totalSize;
                            currentPosition.bepPrice = newAvgPrice; // Reset BEP to new Avg Entry

                            // Recalculate Liq Price
                            // Liq Price formula needs to be updated for new size and margin
                            // Simplified approximation for simulation:
                            const maintenanceMargin = totalCost * 0.005; // 0.5% MM
                            const walletBalance = currentPosition.cost; // Total margin assigned

                            if (isLong) {
                                currentPosition.liqPrice = newAvgPrice - ((walletBalance - maintenanceMargin) / totalSize);
                            } else {
                                currentPosition.liqPrice = newAvgPrice + ((walletBalance - maintenanceMargin) / totalSize);
                            }

                            console.log(`‚úÖ Margin Added. New Entry: ${newAvgPrice.toFixed(2)}, New Liq: ${currentPosition.liqPrice.toFixed(2)}`);
                            this.saveState();
                        }
                    }

                    // 3. Check Exit (TP Bonus or BEP)
                    // TP Bonus: 3% from Entry (if no margin added) or specific logic
                    // BEP Exit: If margin added, exit at BEP.

                    let shouldExit = false;
                    let exitReason = '';

                    if (currentPosition.marginAdded) {
                        // BEP Exit Rule
                        // If PnL > 0 (just break even or slight profit), exit.
                        if (pnlUnrealized > 0) { // Slight profit to cover fees?
                            shouldExit = true;
                            exitReason = 'BEP_EXIT';
                        }
                    } else {
                        // Normal TP Rule (TP Bonus)
                        // Python: tp_price = entry * 1.03 (Long)
                        const tpPrice = isLong ? currentPosition.entryPrice * 1.03 : currentPosition.entryPrice * 0.97;

                        if ((isLong && currentPrice >= tpPrice) || (!isLong && currentPrice <= tpPrice)) {
                            shouldExit = true;
                            exitReason = 'TP_BONUS';
                        }
                    }

                    // Duration Exit (Optional, hard to track exact time in this simple loop without timestamp check)
                    // We skip Duration Exit for now in live simulation.

                    if (shouldExit) {
                        console.log(`üí∞ EXIT TRIGGERED: ${exitReason} at ${currentPrice}`);
                        this.closePosition();
                    }

                }
                // --- ENTRY LOGIC ---
                else {
                    // Check for new signals
                    const signal = WhiteSwanLogic.checkEntrySignal(realtimeCache.main.klines);

                    if (signal === 'LONG' || signal === 'SHORT') {
                        console.log(`üöÄ ENTRY SIGNAL: ${signal} at ${currentPrice}`);

                        const tradeAmount = this.state.balance * 0.1; // 10% of Balance
                        const leverage = 50; // White Swan Default

                        if (tradeAmount > 1) { // Min trade size check
                            this.openPosition(signal.toLowerCase(), leverage, tradeAmount, currentPrice);
                        }
                    }
                }
            },

            syncAccountState: async function () {
                if (currentTradingMode !== 'live') return;

                try {
                    const response = await fetch(`${PROXY_BASE_URL}/sync-futures-account`);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to sync account');
                    }
                    const accountInfo = await response.json();

                    if (accountInfo.usdtBalance) {
                        this.state.balance = parseFloat(accountInfo.usdtBalance.availableBalance);
                        this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                        this.elements.equity.textContent = formatPrice(parseFloat(accountInfo.usdtBalance.walletBalance));
                    }

                    const symbol = realtimeCache.main.symbol;
                    const livePosition = accountInfo.positions.find(p => p.symbol === symbol && parseFloat(p.positionAmt) !== 0);

                    if (livePosition) {
                        const positionType = parseFloat(livePosition.positionAmt) > 0 ? 'long' : 'short';
                        this.state.position = {
                            type: positionType,
                            entryPrice: parseFloat(livePosition.entryPrice),
                            quantity: Math.abs(parseFloat(livePosition.positionAmt)),
                            leverage: 20, // Assuming 20x for now, will need to fetch actual leverage
                            cost: Math.abs(parseFloat(livePosition.positionAmt) * parseFloat(livePosition.entryPrice) / 20), // Approximate cost
                            liqPrice: parseFloat(livePosition.liquidationPrice)
                        };
                        // Update unrealized PNL from live data
                        const unrealizedPnl = parseFloat(livePosition.unrealizedProfit);
                        this.elements.unrealizedPnl.textContent = formatPrice(unrealizedPnl);
                        this.elements.unrealizedPnl.className = `font-mono font-bold text-lg ${unrealizedPnl >= 0 ? 'positive' : 'negative'}`;
                    } else {
                        this.state.position = null;
                        this.elements.unrealizedPnl.textContent = '$0.00';
                        this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                    }
                    this.render(); // Re-render to update position display
                } catch (error) {
                    console.error('Error syncing Binance account state:', error);
                    // Optionally alert user or show error in UI
                }
            }
        };
        // 
        function exportHistoryToCSV() {
            const history = paperTrade.state.history;
            if (history.length === 0) {
                alert("Tidak ada riwayat trading untuk diekspor.");
                return;
            }

            // Header baru dengan EntryPrice dan ClosePrice
            const headers = ["Symbol", "Type", "EntryPrice", "ClosePrice", "PNL", "ROE", "ClosedAt", "Liquidated"];
            let csvContent = headers.join(",") + "\r\n";

            // Tambahkan data baru ke setiap baris
            history.forEach(trade => {
                const row = [
                    trade.symbol,
                    trade.type,
                    trade.entryPrice || 'N/A', // Tambahkan fallback jika data lama tidak ada
                    trade.closePrice || 'N/A', // Tambahkan fallback
                    trade.pnl,
                    trade.roe,
                    trade.closedAt.toISOString(),
                    trade.liquidated ? 'TRUE' : 'FALSE'
                ];
                csvContent += row.join(",") + "\r\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            const timestamp = new Date().toISOString().slice(0, 10);
            link.setAttribute("download", `trade_history_${timestamp}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        // 
        function importHistoryFromCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                const lines = text.split('\n').filter(line => line.trim() !== '');
                if (lines.length <= 1) {
                    alert("File CSV kosong atau hanya berisi header.");
                    return;
                }

                const importedHistory = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length < 8) continue; // Sekarang harus ada 8 kolom

                    try {
                        const trade = {
                            symbol: values[0].trim(),
                            type: values[1].trim(),
                            entryPrice: parseFloat(values[2]),
                            closePrice: parseFloat(values[3]),
                            pnl: parseFloat(values[4]),
                            roe: parseFloat(values[5]),
                            closedAt: new Date(values[6].trim()),
                            liquidated: values[7].trim().toUpperCase() === 'TRUE'
                        };
                        importedHistory.push(trade);
                    } catch (error) {
                        alert(`Error saat memproses baris ke-${i + 1}. Cek format file Anda.`);
                        return;
                    }
                }

                if (confirm(`Impor akan menimpa ${importedHistory.length} riwayat trading yang ada. Lanjutkan?`)) {
                    paperTrade.state.history = importedHistory.reverse();
                    paperTrade.saveState();
                    paperTrade.render();
                    alert("Impor riwayat trading berhasil!");
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function updateDnaDisplay(dna) {
            const qc = dna.metadata.qc_validation;
            const params = dna.parameters;

            document.getElementById('dna-type-display').textContent = dna.metadata.dnaType || '-';
            document.getElementById('dna-asset-display').textContent = dna.metadata.sourceAsset || '-';
            document.getElementById('dna-tf-display').textContent = dna.metadata.sourceTimeframe || '-';
            document.getElementById('dna-pnl-avg-display').textContent = qc ? `$${(qc.avgPnl_per_trade * 100).toFixed(2)}%` : '-';
            document.getElementById('dna-loss-prob-display').textContent = qc ? `${qc.loss_probability_percent.toFixed(1)}%` : '-';
            document.getElementById('dna-threshold-display').textContent = params ? params.biasThreshold : '-';
        }

        // --- PUMP HUNTER LOGIC (SHORT STRATEGY) ---
        const PumpHunter = {
            isScanning: false,

            async scan() {
                if (this.isScanning) return;
                this.isScanning = true;
                const listContainer = document.getElementById('pump-hunter-list');
                listContainer.innerHTML = '<div class="text-center text-red-500 text-xs py-4 animate-pulse">Scanning for Pumps... üöÄ</div>';

                try {
                    // 1. Fetch Top Volume Pairs
                    const [resTicker, resPremium] = await Promise.all([
                        fetch('https://fapi.binance.com/fapi/v1/ticker/24hr'),
                        fetch('https://fapi.binance.com/fapi/v1/premiumIndex')
                    ]);

                    const dataTicker = await resTicker.json();
                    const dataPremium = await resPremium.json();
                    const premiumMap = new Map(dataPremium.map(p => [p.symbol, p.lastFundingRate]));

                    // Filter: Top 50 Volume, USDT pairs
                    let candidates = dataTicker.filter(t => t.symbol.endsWith('USDT') && parseFloat(t.quoteVolume) > 50000000)
                        .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                        .slice(0, 50);

                    let results = [];

                    // Local helper for Normalized BB
                    const calculateBB = (closes, period = 20, multiplier = 2) => {
                        const sma = closes.map((val, idx, arr) => {
                            if (idx < period - 1) return null;
                            const slice = arr.slice(idx - period + 1, idx + 1);
                            return slice.reduce((a, b) => a + b, 0) / period;
                        });

                        return sma.map((avg, idx) => {
                            if (avg === null) return null;
                            const slice = closes.slice(idx - period + 1, idx + 1);
                            const variance = slice.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / period;
                            const stdDev = Math.sqrt(variance);
                            return {
                                upper: avg + (multiplier * stdDev),
                                lower: avg - (multiplier * stdDev),
                                width: (avg + (multiplier * stdDev) - (avg - (multiplier * stdDev))) / avg
                            };
                        });
                    };

                    // 2. Analyze Each Candidate
                    for (const coin of candidates) {
                        await new Promise(r => setTimeout(r, 100)); // Rate limit safety

                        try {
                            const klines = await fetchBinanceAPIData('klines', { symbol: coin.symbol, interval: window.currentScanTimeframe || '4h', limit: 100 }, 'futures');
                            if (!klines || klines.length < 90) continue;

                            const closes = klines.map(k => parseFloat(k[4]));
                            const volumes = klines.map(k => parseFloat(k[5]));
                            const currentPrice = closes[closes.length - 1];

                            const ema8 = calculateEMA(closes, 8).pop();
                            const ema21 = calculateEMA(closes, 21).pop();
                            const ema89 = calculateEMA(closes, 89).pop();
                            const rsi = calculateRSI(closes, 14).pop();
                            const bb = calculateBB(closes, 20, 2).pop();

                            // Vol Ratio
                            const volSlice = volumes.slice(-21, -1);
                            const avgVol = volSlice.length > 0 ? volSlice.reduce((a, b) => a + b, 0) / volSlice.length : 0;
                            const currentVol = volumes[volumes.length - 1];
                            const volRatio = (avgVol > 0 && !isNaN(avgVol)) ? (currentVol / avgVol).toFixed(1) : "0.0";

                            const fundingRate = parseFloat(premiumMap.get(coin.symbol) || 0) * 100;
                            const priceChange = parseFloat(coin.priceChangePercent);

                            // --- SCORING SYSTEM (Pump Hunter) ---
                            let score = 0;
                            let status = "WATCHING üëÄ";
                            let badgeClass = "text-gray-400 border-gray-600";
                            let trend = "NEUTRAL";
                            let action = "WAIT";
                            let reason = "Monitoring for short setup.";

                            // 1. RSI Score (Max 40)
                            if (rsi > 70) score += 30;
                            else if (rsi > 60) score += 10;
                            if (rsi > 80) score += 10; // Extreme Overbought

                            // 2. Extension Score (Max 30)
                            // Price far above EMA89
                            const extension = (currentPrice - ema89) / ema89;
                            if (extension > 0.10) score += 20; // 10% above EMA89
                            if (extension > 0.20) score += 10; // 20% above EMA89

                            // 3. Funding Score (Max 20)
                            // High positive funding = Crowded Longs = Squeeze Potential
                            if (fundingRate > 0.05) score += 20;
                            else if (fundingRate > 0.02) score += 10;

                            // 4. Resistance Score (Max 10)
                            if (bb && currentPrice > bb.upper) score += 10;

                            // --- STATUS DETERMINATION ---
                            if (score >= 70) {
                                status = "MOONING üöÄ";
                                badgeClass = "text-red-400 border-red-500 bg-red-900/20 font-bold";
                                trend = "PARABOLIC";
                                action = "SHORT (SCALP)";
                                reason = "Extreme Pump + Overbought + High Funding.";
                            } else if (rsi > 70 && fundingRate > 0.05) {
                                status = "OVERBOUGHT ‚ö†Ô∏è";
                                badgeClass = "text-orange-400 border-orange-500 bg-orange-900/20 font-bold";
                                trend = "BULLISH (TIRED)";
                                action = "SHORT (DCA)";
                                reason = "RSI Overbought + Crowded Longs.";
                            } else if (bb && currentPrice > bb.upper) {
                                status = "RESISTANCE üõë";
                                badgeClass = "text-yellow-400 border-yellow-500 bg-yellow-900/20";
                                trend = "UPTREND";
                                action = "WAIT / SHORT";
                                reason = "Hitting Upper Bollinger Band.";
                            }

                            results.push({
                                symbol: coin.symbol,
                                price: parseFloat(coin.lastPrice),
                                change: priceChange,
                                status: status,
                                badgeClass: badgeClass,
                                rsi: rsi.toFixed(1),
                                volRatio: volRatio,
                                ema8: ema8.toFixed(coin.lastPrice < 1 ? 5 : 2),
                                ema21: ema21.toFixed(coin.lastPrice < 1 ? 5 : 2),
                                ema89: ema89.toFixed(coin.lastPrice < 1 ? 5 : 2),
                                funding: fundingRate.toFixed(4),
                                trend: trend,
                                action: action,
                                reason: reason,
                                volSpike: parseFloat(volRatio) > 2,
                                score: score,
                                extension: (extension * 100).toFixed(1)
                            });

                        } catch (err) {
                            console.error(`Error analyzing ${coin.symbol}`, err);
                        }
                    }

                    // Sort by Score (High to Low) and take Top 10
                    results.sort((a, b) => b.score - a.score);
                    results = results.slice(0, 10);

                    // 3. Render Results
                    if (results.length === 0) {
                        listContainer.innerHTML = '<div class="text-center text-gray-500 text-xs py-4">No short setups found. Market is dumping?</div>';
                    } else {
                        listContainer.innerHTML = results.map((r, index) => `
                            <div class="rounded bg-gray-800 border border-gray-700 overflow-hidden transition-all duration-300">
                                <div class="p-3 flex justify-between items-center cursor-pointer hover:bg-gray-750"
                                     onclick="document.getElementById('pump-detail-${index}').classList.toggle('hidden');">
                                    <div>
                                        <div class="font-bold text-sm text-gray-200 flex items-center gap-2">
                                            ${r.symbol}
                                            <span class="text-[10px] px-1.5 py-0.5 rounded border ${r.badgeClass}">${r.status}</span>
                                        </div>
                                        <div class="text-xs ${r.change >= 0 ? 'text-green-400' : 'text-red-400'} mt-1">${r.change.toFixed(2)}%</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-xs text-gray-400">Score: <span class="font-bold ${r.score > 60 ? 'text-red-400' : 'text-gray-300'}">${r.score}</span></div>
                                        <div class="text-xs text-gray-400">RSI: <span class="${r.rsi > 70 ? 'text-red-400 font-bold' : ''}">${r.rsi}</span></div>
                                    </div>
                                </div>
                                
                                <!-- DROPDOWN DETAIL (PUMP HUNTER STYLE) -->
                                <div id="pump-detail-${index}" class="hidden bg-slate-900 p-4 border-t border-gray-700">
                                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                                        <!-- 1. ASSET INFO -->
                                        <div class="bg-slate-800 p-3 rounded border border-slate-600">
                                            <h3 class="text-[10px] text-slate-400 mb-2">ASSET INFO</h3>
                                            <div class="text-xl font-bold text-red-400 mb-1">${r.symbol}</div>
                                            <div class="text-2xl font-mono text-white">${r.price}</div>
                                            <div class="mt-2 text-[10px] text-slate-500">Funding Rate: <span class="${r.funding > 0.05 ? 'text-red-400 font-bold' : 'text-green-400'}">${r.funding}%</span></div>
                                        </div>

                                        <!-- 2. EMA RIBBON -->
                                        <div class="bg-slate-800 p-3 rounded border border-slate-600">
                                            <h3 class="text-[10px] text-slate-400 mb-2">EXTENSION (Overbought)</h3>
                                            <div class="space-y-1 text-[10px] font-mono">
                                                <div class="flex justify-between"><span>Price vs EMA89:</span> <span class="${r.extension > 20 ? 'text-red-400 font-bold' : 'text-yellow-300'}">+${r.extension}%</span></div>
                                                <div class="flex justify-between"><span>EMA 8:</span> <span class="text-cyan-300">${r.ema8}</span></div>
                                                <div class="flex justify-between"><span>EMA 89:</span> <span class="text-purple-300 font-bold">${r.ema89}</span></div>
                                            </div>
                                            <div class="mt-3 text-[10px] border-t border-slate-600 pt-2">
                                                Trend: <span class="font-bold ${r.trend.includes('PARABOLIC') ? 'text-red-400' : 'text-yellow-400'}">${r.trend}</span>
                                            </div>
                                        </div>

                                        <!-- 3. MOMENTUM -->
                                        <div class="bg-slate-800 p-3 rounded border border-slate-600">
                                            <h3 class="text-[10px] text-slate-400 mb-2">MOMENTUM & FUEL</h3>
                                            <div class="mb-2">
                                                <div class="text-[10px] flex justify-between mb-1"><span>RSI (14):</span> <span>${r.rsi}</span></div>
                                                <div class="w-full bg-slate-700 h-1.5 rounded-full">
                                                    <div class="h-1.5 rounded-full transition-all duration-500 ${r.rsi > 70 ? 'bg-red-500' : (r.rsi < 30 ? 'bg-green-500' : 'bg-blue-500')}" style="width: ${r.rsi}%"></div>
                                                </div>
                                            </div>
                                            <div class="text-[10px] mt-3">
                                                <div>Vol vs Avg: <span class="${r.volSpike ? 'text-red-400 font-bold' : 'text-slate-400'}">${r.volRatio}x</span></div>
                                                ${r.volSpike ? '<div class="mt-1 text-red-400 animate-pulse">‚ö†Ô∏è HIGH VOLUME PUMP!</div>' : ''}
                                            </div>
                                        </div>

                                        <!-- 4. REKOMENDASI -->
                                        <div class="bg-slate-800 p-3 rounded border border-slate-600 flex flex-col justify-center items-center text-center">
                                            <h3 class="text-[10px] text-slate-400 mb-1">REKOMENDASI SHORT</h3>
                                            <div class="text-lg font-bold mb-2 ${r.action.includes('SHORT') ? 'text-red-400' : 'text-yellow-400'}">${r.action}</div>
                                            <p class="text-[10px] text-slate-300 px-2">${r.reason}</p>
                                        </div>
                                    </div>

                                    <button class="w-full py-2 bg-red-600 hover:bg-red-500 text-white rounded font-bold text-xs transition shadow-lg shadow-red-900/20"
                                            onclick="document.getElementById('asset-input').value='${r.symbol}'; document.getElementById('analyze-asset-btn').click();">
                                        LOAD CHART & SHORT üìâ
                                    </button>
                                </div>
                            </div>
                        `).join('');
                    }

                } catch (e) {
                    console.error("Pump Hunter Scan Failed:", e);
                    listContainer.innerHTML = '<div class="text-center text-red-500 text-xs py-4">Scan Failed. Check Console.</div>';
                } finally {
                    this.isScanning = false;
                }
            }
        };



        const DipHunter = {
            isScanning: false,

            async scan() {
                if (this.isScanning) return;
                this.isScanning = true;
                const listContainer = document.getElementById('dip-hunter-list');
                listContainer.innerHTML = '<div class="text-center text-yellow-500 text-xs py-4 animate-pulse">Scanning Top 50 Vol... ü¶ñ</div>';

                try {
                    // 1. Fetch Top Volume Pairs
                    const [resTicker, resPremium] = await Promise.all([
                        fetch('https://fapi.binance.com/fapi/v1/ticker/24hr'),
                        fetch('https://fapi.binance.com/fapi/v1/premiumIndex')
                    ]);

                    const dataTicker = await resTicker.json();
                    const dataPremium = await resPremium.json();
                    const premiumMap = new Map(dataPremium.map(p => [p.symbol, p.lastFundingRate]));

                    let candidates = dataTicker.filter(t => t.symbol.endsWith('USDT') && parseFloat(t.quoteVolume) > 50000000)
                        .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                        .slice(0, 50);

                    let results = [];

                    // Local helper for Normalized BB (to avoid conflict with global function)
                    const calculateBB = (closes, period = 20, multiplier = 2) => {
                        const sma = closes.map((val, idx, arr) => {
                            if (idx < period - 1) return null;
                            const slice = arr.slice(idx - period + 1, idx + 1);
                            return slice.reduce((a, b) => a + b, 0) / period;
                        });

                        return sma.map((avg, idx) => {
                            if (avg === null) return null;
                            const slice = closes.slice(idx - period + 1, idx + 1);
                            const variance = slice.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / period;
                            const stdDev = Math.sqrt(variance);
                            return {
                                width: (avg + (multiplier * stdDev) - (avg - (multiplier * stdDev))) / avg // Normalized Width
                            };
                        });
                    };

                    // 2. Analyze Each Candidate (Sequential to be safe with rate limits)
                    for (const coin of candidates) {
                        // Safety Delay: 100ms per request to stay well under 1200 weight/min
                        await new Promise(r => setTimeout(r, 100));

                        try {
                            const klines = await fetchBinanceAPIData('klines', { symbol: coin.symbol, interval: window.currentScanTimeframe || '4h', limit: 100 }, 'futures');
                            if (!klines || klines.length < 90) continue;

                            const closes = klines.map(k => parseFloat(k[4]));
                            const volumes = klines.map(k => parseFloat(k[5]));
                            const currentPrice = closes[closes.length - 1];

                            const ema8 = calculateEMA(closes, 8).pop();
                            const ema21 = calculateEMA(closes, 21).pop();
                            const ema89 = calculateEMA(closes, 89).pop();
                            const rsi = calculateRSI(closes, 14).pop();
                            const bb = calculateBB(closes, 20, 2).pop();

                            // Vol Ratio
                            const volSlice = volumes.slice(-21, -1);
                            const avgVol = volSlice.length > 0 ? volSlice.reduce((a, b) => a + b, 0) / volSlice.length : 0;
                            const currentVol = volumes[volumes.length - 1];
                            const volRatio = (avgVol > 0 && !isNaN(avgVol)) ? (currentVol / avgVol).toFixed(1) : "0.0";

                            const fundingRate = parseFloat(premiumMap.get(coin.symbol) || 0) * 100;
                            const priceChange = parseFloat(coin.priceChangePercent);

                            // --- SCORING SYSTEM (Sleeping Giant) ---
                            let score = 0;
                            let status = "WATCHING üëÄ";
                            let badgeClass = "text-gray-400 border-gray-600";
                            let trend = "NEUTRAL";
                            let action = "WAIT";
                            let reason = "Monitoring for setup.";

                            // 1. Squeeze Score (Max 40)
                            // BB Width < 0.10 (10%) is tight for crypto
                            const bbWidth = bb ? bb.width : 1;
                            const isSqueeze = bbWidth < 0.15; // 15% width threshold
                            if (isSqueeze) score += 30;
                            if (bbWidth < 0.08) score += 10; // Super Squeeze

                            // 2. Dip Score (Max 40)
                            const isNearEMA89 = Math.abs((currentPrice - ema89) / ema89) < 0.05;
                            if (isNearEMA89) score += 20;
                            if (rsi < 40) score += 10;
                            if (rsi < 30) score += 10;

                            // 3. Funding Score (Max 20)
                            if (fundingRate < 0.01) score += 10;
                            if (fundingRate < 0) score += 10;

                            // --- STATUS DETERMINATION ---
                            if (score >= 70) {
                                status = "SLEEPING GIANT üíé";
                                badgeClass = "text-purple-400 border-purple-500 bg-purple-900/20 font-bold";
                                trend = "ACCUMULATION";
                                action = "LONG (DCA)";
                                reason = "High Potential: Squeeze + Support + Low Funding.";
                            } else if (rsi < 35 && isNearEMA89 && fundingRate < 0.01) {
                                status = "BIKINI BOTTOM üçç";
                                badgeClass = "text-yellow-400 border-yellow-500 bg-yellow-900/20 font-bold";
                                trend = "OVERSOLD";
                                action = "LONG (SCALP)";
                                reason = "Classic Dip: Oversold at Support.";
                            } else if (isSqueeze) {
                                status = "SQUEEZE ü§è";
                                badgeClass = "text-blue-400 border-blue-500 bg-blue-900/20";
                                trend = "SIDEWAYS";
                                action = "WAIT / STALK";
                                reason = "Volatility Squeeze. Wait for breakout.";
                            } else if (priceChange < -10 && !isNearEMA89 && rsi > 30) {
                                status = "DUMPING ‚ö†Ô∏è";
                                badgeClass = "text-red-400 border-red-500 bg-red-900/20";
                                trend = "BEARISH";
                                action = "AVOID";
                                reason = "Falling Knife. No support yet.";
                            }

                            results.push({
                                symbol: coin.symbol,
                                price: parseFloat(coin.lastPrice),
                                change: priceChange,
                                status: status,
                                badgeClass: badgeClass,
                                rsi: rsi.toFixed(1),
                                volRatio: volRatio,
                                ema8: ema8.toFixed(coin.lastPrice < 1 ? 5 : 2),
                                ema21: ema21.toFixed(coin.lastPrice < 1 ? 5 : 2),
                                ema89: ema89.toFixed(coin.lastPrice < 1 ? 5 : 2),
                                funding: fundingRate.toFixed(4),
                                trend: trend,
                                action: action,
                                reason: reason,
                                volSpike: parseFloat(volRatio) > 2,
                                score: score,
                                bbWidth: (bbWidth * 100).toFixed(2)
                            });

                        } catch (err) {
                            console.error(`Error analyzing ${coin.symbol}`, err);
                        }
                    }

                    // Sort by Score (High to Low) and take Top 10
                    results.sort((a, b) => b.score - a.score);
                    results = results.slice(0, 10);

                    // 3. Render Results
                    if (results.length === 0) {
                        listContainer.innerHTML = '<div class="text-center text-gray-500 text-xs py-4">No setups found in Top 50 Vol. Market is boring.</div>';
                    } else {
                        listContainer.innerHTML = results.map((r, index) => `
                <div class="rounded bg-gray-800 border border-gray-700 overflow-hidden transition-all duration-300">
                    <div class="p-3 flex justify-between items-center cursor-pointer hover:bg-gray-750"
                         onclick="document.getElementById('detail-${index}').classList.toggle('hidden');">
                        <div>
                            <div class="font-bold text-sm text-gray-200 flex items-center gap-2">
                                ${r.symbol}
                                <span class="text-[10px] px-1.5 py-0.5 rounded border ${r.badgeClass}">${r.status}</span>
                            </div>
                            <div class="text-xs ${r.change >= 0 ? 'text-green-400' : 'text-red-400'} mt-1">${r.change.toFixed(2)}%</div>
                        </div>
                        <div class="text-right">
                            <div class="text-xs text-gray-400">Score: <span class="font-bold ${r.score > 60 ? 'text-yellow-400' : 'text-gray-300'}">${r.score}</span></div>
                            <div class="text-xs text-gray-400">BB Width: <span class="${r.bbWidth < 15 ? 'text-blue-400' : ''}">${r.bbWidth}%</span></div>
                        </div>
                    </div>
                    
                    <!-- DROPDOWN DETAIL (SOP MONITOR STYLE) -->
                    <div id="detail-${index}" class="hidden bg-slate-900 p-4 border-t border-gray-700">
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                            <!-- 1. ASSET INFO -->
                            <div class="bg-slate-800 p-3 rounded border border-slate-600">
                                <h3 class="text-[10px] text-slate-400 mb-2">ASSET INFO</h3>
                                <div class="text-xl font-bold text-emerald-400 mb-1">${r.symbol}</div>
                                <div class="text-2xl font-mono text-white">${parseFloat(r.price).toFixed(r.price < 1 ? 5 : 2)}</div>
                                <div class="mt-2 text-[10px] text-slate-500">Funding Rate: <span class="${r.funding < 0.01 ? 'text-green-400' : 'text-red-400'}">${r.funding}%</span></div>
                            </div>

                            <!-- 2. EMA RIBBON -->
                            <div class="bg-slate-800 p-3 rounded border border-slate-600">
                                <h3 class="text-[10px] text-slate-400 mb-2">EMA RIBBON (Support)</h3>
                                <div class="space-y-1 text-[10px] font-mono">
                                    <div class="flex justify-between"><span>EMA 8:</span> <span class="text-cyan-300">${r.ema8}</span></div>
                                    <div class="flex justify-between"><span>EMA 21:</span> <span class="text-yellow-300">${r.ema21}</span></div>
                                    <div class="flex justify-between"><span>EMA 89:</span> <span class="text-purple-300 font-bold">${r.ema89}</span></div>
                                </div>
                                <div class="mt-3 text-[10px] border-t border-slate-600 pt-2">
                                    Trend: <span class="font-bold ${r.trend === 'BULLISH' ? 'text-green-400' : (r.trend === 'BEARISH' ? 'text-red-400' : 'text-yellow-400')}">${r.trend}</span>
                                </div>
                            </div>

                            <!-- 3. MOMENTUM -->
                            <div class="bg-slate-800 p-3 rounded border border-slate-600">
                                <h3 class="text-[10px] text-slate-400 mb-2">MOMENTUM & FUEL</h3>
                                <div class="mb-2">
                                    <div class="text-[10px] flex justify-between mb-1"><span>RSI (14):</span> <span>${r.rsi}</span></div>
                                    <div class="w-full bg-slate-700 h-1.5 rounded-full">
                                        <div class="h-1.5 rounded-full transition-all duration-500 ${r.rsi > 70 ? 'bg-red-500' : (r.rsi < 30 ? 'bg-green-500' : 'bg-blue-500')}" style="width: ${r.rsi}%"></div>
                                    </div>
                                </div>
                                <div class="text-[10px] mt-3">
                                    <div>Vol vs Avg: <span class="${r.volSpike ? 'text-green-400 font-bold' : 'text-slate-400'}">${r.volRatio}x</span></div>
                                    <div>Squeeze: <span class="${r.bbWidth < 15 ? 'text-blue-400 font-bold' : 'text-slate-400'}">${r.bbWidth}%</span></div>
                                </div>
                            </div>

                            <!-- 4. REKOMENDASI -->
                            <div class="bg-slate-800 p-3 rounded border border-slate-600 flex flex-col justify-center items-center text-center">
                                <h3 class="text-[10px] text-slate-400 mb-1">REKOMENDASI SOP</h3>
                                <div class="text-lg font-bold mb-2 ${r.action.includes('LONG') ? 'text-green-400' : (r.action === 'AVOID' ? 'text-red-400' : 'text-blue-400')}">${r.action}</div>
                                <p class="text-[10px] text-slate-300 px-2">${r.reason}</p>
                            </div>
                        </div>

                        <button class="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold text-xs transition shadow-lg shadow-blue-900/20"
                                onclick="document.getElementById('asset-input').value='${r.symbol}'; document.getElementById('analyze-asset-btn').click();">
                            LOAD CHART & ANALYZE üìä
                        </button>
                    </div>
                </div>
            `).join('');
                    }

                } catch (e) {
                    console.error("Dip Hunter Scan Failed:", e);
                    listContainer.innerHTML = '<div class="text-center text-red-500 text-xs py-4">Scan Failed. Check Console.</div>';
                } finally {
                    this.isScanning = false;
                }
            }
        };

        // Event Listeners for Tabs (Inject this before DOMContentLoaded)
        const initDipHunterTabs = () => {
            const tabTop = document.getElementById('tab-top-movers');
            const tabDip = document.getElementById('tab-dip-hunter');
            const listTop = document.getElementById('gainers-list');
            const listDip = document.getElementById('dip-hunter-list');

            if (tabTop && tabDip) {
                tabTop.addEventListener('click', () => {
                    tabTop.classList.add('text-yellow-500', 'border-b-2', 'border-yellow-500');
                    tabTop.classList.remove('text-gray-400');
                    tabDip.classList.remove('text-yellow-500', 'border-b-2', 'border-yellow-500');
                    tabDip.classList.add('text-gray-400');

                    listTop.classList.remove('hidden');
                    listDip.classList.add('hidden');
                });

                tabDip.addEventListener('click', () => {
                    tabDip.classList.add('text-yellow-500', 'border-b-2', 'border-yellow-500');
                    tabDip.classList.remove('text-gray-400');
                    tabTop.classList.remove('text-yellow-500', 'border-b-2', 'border-yellow-500');
                    tabTop.classList.add('text-gray-400');

                    listDip.classList.remove('hidden');
                    listTop.classList.add('hidden');

                    // Trigger Scan
                    DipHunter.scan();
                });
            }
        };
        // --- DIP HUNTER LOGIC END ---

        document.addEventListener('DOMContentLoaded', async () => {
            initDipHunterTabs(); // Call the tab init


            loadSettings();
            window.currentScanTimeframe = '4h'; // Default Timeframe
            initTopMoversTimeframeSelector();
            initRefreshIntervalSelector();
            adjustContentPadding();

            setupToggle('toggle-scalping-btn', 'scalping-content-wrapper', 'toggle-scalping-icon', true);
            setupToggle('toggle-sentiment-btn', 'sentiment-content-wrapper', 'toggle-sentiment-icon', false);
            setupToggle('toggle-market-state-btn', 'current-state-content-wrapper', 'toggle-market-state-icon', true);
            setupToggle('toggle-confluence-btn', 'confluence-content-wrapper', 'toggle-confluence-icon', true);
            setupToggle('toggle-onchain-btn', 'onchain-content-wrapper', 'toggle-onchain-icon', false);
            setupToggle('toggle-settings-btn', 'settings-content-wrapper', 'toggle-settings-icon', false);
            setupToggle('toggle-order-book-cvd-btn', 'order-book-cvd-content-wrapper', 'toggle-order-book-cvd-icon', true);
            setupToggle('toggle-ts-calc-btn', 'ts-calc-content-wrapper', 'toggle-ts-calc-icon', false);
            setupToggle('toggle-paper-trading-btn', 'paper-trading-content-wrapper', 'toggle-paper-trading-icon', true);
            setupToggle('toggle-top-movers-btn', 'top-movers-content-wrapper', 'toggle-top-movers-icon', true);
            toggleChartsBtn.addEventListener('click', () => toggleChartsVisibility());
            window.addEventListener('resize', adjustContentPadding);
            document.getElementById('save-settings-btn').addEventListener('click', saveSettings);

            timeframeSelect.addEventListener('change', (e) => {
                adaptIndicatorParamsToTimeframe(e.target.value);
            });

            themeToggleBtn.addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                darkIcon.classList.toggle('hidden');
                lightIcon.classList.toggle('hidden');
                localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                if (cvdChartInstance) {
                    const isDarkMode = document.documentElement.classList.contains('dark');
                    const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
                    const negativeColor = isDarkMode ? '#f87171' : '#dc2626';
                    cvdChartInstance.data.datasets[0].segment.borderColor = ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor;
                    cvdChartInstance.options.scales.x.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                    cvdChartInstance.options.scales.y.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                    cvdChartInstance.options.scales.y.grid.color = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                    cvdChartInstance.update();
                }
            });

            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
                darkIcon.classList.remove('hidden');
            } else {
                lightIcon.classList.remove('hidden');
            }

            apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
            apiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', apiKeyInput.value));

            const presetSelect = document.getElementById('preset-select');
            presetSelect.addEventListener('change', (e) => applyPreset(e.target.value));

            document.getElementById('vwap-mode-buttons').addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    const mode = e.target.dataset.mode;
                    document.querySelectorAll('.vwap-mode-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    updateVwapDisplay(mode);
                }
            });

            tradeLink.addEventListener('click', (e) => {
                e.preventDefault();
                const binanceSymbol = realtimeCache.main.binanceSymbol;
                if (!binanceSymbol) return;
                const marketType = marketTypeSelect.value;
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);
                const desktopUrl = marketType === 'futures' ? `https://www.binance.com/en/futures/${binanceSymbol}` : `https://www.binance.com/en/trade/${binanceSymbol}`;
                const mobileUrl = marketType === 'futures' ? `binance://futures/trade?symbol=${binanceSymbol}` : `binance://trade?symbol=${binanceSymbol}`;
                if (isMobile) {
                    window.location.href = mobileUrl;
                    setTimeout(() => { window.location.href = desktopUrl; }, 1500);
                } else {
                    window.open(desktopUrl, '_blank');
                }
            });

            resetBtn.addEventListener('click', resetDashboard);

            const toggleAiBtn = document.getElementById('toggle-ai-btn');
            const aiContentContainer = document.getElementById('ai-content-container');
            let isAiAnalysisVisible = false;

            toggleAiBtn.addEventListener('click', async () => {
                const aiNarrativeEl = document.getElementById('ai-narrative-content');

                if (isAiAnalysisVisible) {
                    // Logika untuk menyembunyikan panel
                    aiContentContainer.classList.add('hidden');
                    document.querySelector('#toggle-ai-btn span').textContent = 'ASK AI';
                    isAiAnalysisVisible = false;
                    return;
                }

                // Jika panel tidak terlihat, periksa apakah konten sudah ada
                if (aiNarrativeEl.innerHTML.trim() === '' || !realtimeCache.main.calculatedData) {
                    // Jika konten belum ada, jalankan analisis baru
                    isAiAnalysisVisible = true;
                    aiContentContainer.classList.remove('hidden');
                    document.querySelector('#toggle-ai-btn span').textContent = 'HIDE ANALYSIS';
                    aiNarrativeEl.innerHTML = '<p class="text-center text-gray-500">Analisa sedang diproses...</p>';
                    await runComprehensiveAIAnalysis();
                } else {
                    // Jika konten sudah ada, tampilkan saja tanpa memanggil API lagi
                    isAiAnalysisVisible = true;
                    aiContentContainer.classList.remove('hidden');
                    document.querySelector('#toggle-ai-btn span').textContent = 'HIDE ANALYSIS';
                }
            });

            const tooltipElement = document.createElement('div');
            tooltipElement.id = 'custom-tooltip';
            document.body.appendChild(tooltipElement);

            const debouncedRunAnalysis = debounce(runFullAnalysis, 100);
            let isAnalysisRunning = false; // Global flag to control analysis

            const stopAnalysisBtn = document.getElementById('stop-analysis-btn');
            const buttonText = document.getElementById('button-text');
            const buttonLoader = document.getElementById('button-loader');

            analyzeBtn.addEventListener('click', () => {
                analyzeBtn.disabled = true;
                buttonText.classList.add('hidden');
                buttonLoader.classList.remove('hidden');
                stopAnalysisBtn.classList.remove('hidden');
                isAnalysisRunning = true;
                debouncedRunAnalysis();
            });

            stopAnalysisBtn.addEventListener('click', () => {
                isAnalysisRunning = false;
                analyzeBtn.disabled = false;
                buttonText.classList.remove('hidden');
                buttonLoader.classList.add('hidden');
                stopAnalysisBtn.classList.add('hidden');
                console.log("Analysis stopped by user.");
                // Optionally, clear any partial results or reset UI elements
            });

            assetInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    analyzeBtn.disabled = true;
                    buttonText.classList.add('hidden');
                    buttonLoader.classList.remove('hidden');
                    stopAnalysisBtn.classList.remove('hidden');
                    isAnalysisRunning = true;
                    debouncedRunAnalysis();
                }
            });

            const triggers = document.querySelectorAll('[data-tooltip]');
            const dumpTfSelect = document.getElementById('dump-trigger-timeframe-select');
            const triggerListDiv = document.getElementById('trigger-breakdown-list');
            const mtfAlignmentContainer = document.getElementById('tf-alignment-summary');
            mtfAlignmentContainer.addEventListener('click', (event) => {
                const clickedBox = event.target.closest('.mtf-clickable-box');
                if (clickedBox) {
                    const newTimeframe = clickedBox.dataset.timeframe;
                    const mainTimeframeSelect = document.getElementById('timeframe-select');
                    const mainAnalyzeBtn = document.getElementById('analyze-asset-btn');
                    if (mainAnalyzeBtn.disabled) return;
                    mainTimeframeSelect.value = newTimeframe;
                    mainAnalyzeBtn.click();
                }
            });

            dumpTfSelect.addEventListener('change', async () => {
                if (!realtimeCache.main.symbol) return;
                const selectedTf = dumpTfSelect.value;
                const symbol = realtimeCache.main.symbol;
                const marketType = marketTypeSelect.value;
                try {
                    dumpTfSelect.disabled = true;
                    triggerListDiv.innerHTML = `<p class="text-xs text-center text-yellow-400">Loading data ${selectedTf}...</p>`;
                    if (!realtimeCache.main.multiTfKlines[selectedTf]) {
                        const newData = await fetchBinanceAPIData('klines', { symbol: symbol, interval: selectedTf, limit: 200 }, marketType);
                        realtimeCache.main.multiTfKlines[selectedTf] = newData;
                    }
                    calculateAndDisplayScalpingSetup();
                    const symbolLower = symbol.toLowerCase();
                    const mainTfStream = `${symbolLower}@kline_${realtimeCache.main.selectedTimeframe}`;
                    const newDumpTfStream = `${symbolLower}@kline_${selectedTf}`;
                    const newStreamsToSub = [`${symbolLower}@aggTrade`, `${symbolLower}@depth20@100ms`, mainTfStream];
                    if (mainTfStream !== newDumpTfStream) newStreamsToSub.push(newDumpTfStream);
                    WebSocketManager.subscribe(newStreamsToSub);
                } catch (error) {
                    console.error(`Gagal mengambil data untuk ${selectedTf}:`, error);
                    triggerListDiv.innerHTML = `<p class="text-xs text-center text-red-500">Failed Data Fetch.. ${selectedTf}.</p>`;
                } finally {
                    dumpTfSelect.disabled = false;
                }
            });

            document.getElementById('dna-file-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    document.getElementById('dna-status').textContent = 'Status: Import dibatalkan.';
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const dna = JSON.parse(e.target.result);
                        if (!dna || !dna.metadata || !dna.parameters || !dna.weights) {
                            throw new Error("Struktur file DNA tidak valid.");
                        }

                        activeStrategy = dna;
                        updateDnaDisplay(dna);

                        document.getElementById('dna-status').textContent = `‚úÖ Berhasil memuat ${file.name}`;
                        document.getElementById('dna-status').classList.remove('text-gray-500');
                        document.getElementById('dna-status').classList.add('text-green-600');

                        ////console.log("DNA Strategy berhasil dimuat:", activeStrategy);
                    } catch (error) {
                        document.getElementById('dna-status').textContent = `‚ùå Error: ${error.message}`;
                        document.getElementById('dna-status').classList.remove('text-gray-500', 'text-green-600');
                        document.getElementById('dna-status').classList.add('text-red-600');
                        console.error("Gagal memuat DNA:", error);
                        activeStrategy = null;
                    }
                };
                reader.readAsText(file);
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                activeStrategy = null;
                document.getElementById('dna-file-input').value = ''; // Reset input file
                document.getElementById('dna-status').textContent = 'Status: Belum ada DNA yang dimuat.';
                document.getElementById('dna-type-display').textContent = '-';
                document.getElementById('dna-asset-display').textContent = '-';
                document.getElementById('dna-tf-display').textContent = '-';
                document.getElementById('dna-pnl-avg-display').textContent = '-';
                document.getElementById('dna-loss-prob-display').textContent = '-';
                document.getElementById('dna-threshold-display').textContent = '-';

            });

            initializeNewCalculator();

            window.switchTab = function (tabId) {
                // Hide all lists
                document.getElementById('pump-hunter-list').classList.add('hidden');
                document.getElementById('dip-hunter-list').classList.add('hidden');

                // Reset Tab Styles
                document.getElementById('tab-pump-hunter').classList.remove('text-white', 'border-red-500'); // Red for Pump Hunter
                document.getElementById('tab-pump-hunter').classList.add('text-gray-400', 'border-transparent');

                document.getElementById('tab-dip-hunter').classList.remove('text-white', 'border-blue-500');
                document.getElementById('tab-dip-hunter').classList.add('text-gray-400', 'border-transparent');

                // Activate Selected Tab
                if (tabId === 'pump-hunter') {
                    document.getElementById('pump-hunter-list').classList.remove('hidden');
                    document.getElementById('tab-pump-hunter').classList.remove('text-gray-400', 'border-transparent');
                    document.getElementById('tab-pump-hunter').classList.add('text-white', 'border-red-500');
                    PumpHunter.scan(); // Auto scan on tab switch
                } else if (tabId === 'dip-hunter') {
                    document.getElementById('dip-hunter-list').classList.remove('hidden');
                    document.getElementById('tab-dip-hunter').classList.remove('text-gray-400', 'border-transparent');
                    document.getElementById('tab-dip-hunter').classList.add('text-white', 'border-blue-500');
                    DipHunter.scan(); // Auto scan on tab switch
                }
            };

            // Initialize Default Tab
            switchTab('pump-hunter');
            paperTrade.init();

            const toggleAutoTradeBtn = document.getElementById('toggle-auto-trade-btn');
            const autoTradeStatusText = document.getElementById('auto-trade-status-text');

            function updateAutoTradeButton() {
                if (paperTrade.state.isAutoTradeEnabled) {
                    autoTradeStatusText.textContent = '‚è∏Ô∏è DISABLE AUTO-TRADE';
                    toggleAutoTradeBtn.classList.remove('!bg-gray-600', 'hover:!bg-gray-500');
                    toggleAutoTradeBtn.classList.add('!bg-red-600', 'hover:!bg-red-500');
                } else {
                    autoTradeStatusText.textContent = '‚ñ∂Ô∏è ENABLE AUTO-TRADE';
                    toggleAutoTradeBtn.classList.remove('!bg-red-600', 'hover:!bg-red-500');
                    toggleAutoTradeBtn.classList.add('!bg-gray-600', 'hover:!bg-gray-500');
                }
            }

            toggleAutoTradeBtn.addEventListener('click', () => {
                paperTrade.state.isAutoTradeEnabled = !paperTrade.state.isAutoTradeEnabled;
                paperTrade.saveState(); // Save the state of auto-trade
                updateAutoTradeButton();
                if (paperTrade.state.isAutoTradeEnabled) {
                    console.log("Auto-Trade Enabled");
                    // Optionally trigger an immediate check for trade opportunities
                    // calculateAndDisplayScalpingSetup(); 
                } else {
                    console.log("Auto-Trade Disabled");
                }
            });
            updateAutoTradeButton(); // Initial render of the button

            // --- START: New Robust Mode Switching Logic ---

            // Initialize in a safe, known state
            currentTradingMode = 'simulation';
            isLiveSessionActive = false;

            const modeSimulationBtn = document.getElementById('mode-simulation-btn');
            const modeLiveBtn = document.getElementById('mode-live-btn');

            function updateTradingModeButtons() {
                const statusEl = document.getElementById('trading-mode-status');

                if (currentTradingMode === 'simulation') {
                    // Button styles
                    modeSimulationBtn.classList.add('btn-primary');
                    modeSimulationBtn.classList.remove('btn-secondary');
                    modeLiveBtn.classList.add('btn-secondary');
                    modeLiveBtn.classList.remove('btn-primary');

                    // Status indicator styles
                    statusEl.textContent = 'SIMULATION';
                    statusEl.className = 'px-3 py-1 text-base rounded-full font-bold transition-all duration-300 bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300';

                } else { // live mode
                    // Button styles
                    modeLiveBtn.classList.add('btn-primary');
                    modeLiveBtn.classList.remove('btn-secondary');
                    modeSimulationBtn.classList.add('btn-secondary');
                    modeSimulationBtn.classList.remove('btn-primary');

                    // Status indicator styles
                    statusEl.textContent = 'LIVE';
                    if (isLiveSessionActive) {
                        statusEl.className = 'px-3 py-1 text-base rounded-full font-bold transition-all duration-300 blinking-live-bg';
                    } else {
                        // Style for when "Live" is selected but not yet confirmed by sync
                        statusEl.className = 'px-3 py-1 text-base rounded-full font-bold transition-all duration-300 bg-gray-400 text-white dark:bg-gray-600';
                    }
                }
                localStorage.setItem('tradingMode', currentTradingMode);
                console.log(`UI Updated. Current Mode: ${currentTradingMode}, Live Session Active: ${isLiveSessionActive}`);
            }

            let syncIntervalId = null;

            function stopSyncInterval() {
                if (syncIntervalId) {
                    clearInterval(syncIntervalId);
                    syncIntervalId = null;
                    console.log("Account sync stopped.");
                }
            }

            function startSyncInterval() {
                stopSyncInterval(); // Ensure no duplicates
                if (currentTradingMode === 'live' && isLiveSessionActive) {
                    console.log("Starting periodic account sync...");
                    // Initial sync is already done by the button click, so we just set the interval
                    syncIntervalId = setInterval(() => paperTrade.syncAccountState(), 15000); // Sync every 15s
                }
            }

            modeSimulationBtn.addEventListener('click', () => {
                console.log("Switched to Simulation Mode.");
                currentTradingMode = 'simulation';
                isLiveSessionActive = false;
                stopSyncInterval();
                updateTradingModeButtons();
            });

            modeLiveBtn.addEventListener('click', async () => {
                console.log("Attempting to activate Live Mode...");
                // Show immediate feedback to user
                modeLiveBtn.disabled = true;
                modeLiveBtn.textContent = 'Connecting...';

                try {
                    await paperTrade.syncAccountState();

                    console.log("Account sync successful. Activating Live Mode.");
                    currentTradingMode = 'live';
                    isLiveSessionActive = true;
                    updateTradingModeButtons();
                    startSyncInterval();

                } catch (error) {
                    console.error("Failed to switch to Live Mode. Could not sync account.", error);
                    alert("Gagal terhubung ke Akun Binance. Pastikan API Key benar dan proxy berjalan. Mode tetap di Simulasi.");

                    // Revert to simulation state
                    currentTradingMode = 'simulation';
                    isLiveSessionActive = false;
                    updateTradingModeButtons();
                } finally {
                    modeLiveBtn.disabled = false;
                    modeLiveBtn.textContent = 'Live Trade Mode';
                }
            });

            // Set initial button styles on load
            updateTradingModeButtons();

            // --- END: New Robust Mode Switching Logic ---



            await loadRegimeSensorModel();
            // 2. Sekarang, muat data eksternal WAJIB secara berurutan
            try {
                // Langkah A: Download daftar koin futures dulu. INI KUNCINYA.
                await initializeExchangeInfo('futures');

                // Langkah B: Setelah daftar koin siap, BARU jalankan Top Movers.
                await startTopMoversAutoRefresh("1h", 120000);

                // Langkah C: Siapkan juga daftar koin spot
                await initializeExchangeInfo('spot');

            } catch (err) {
                console.error("Gagal inisialisasi awal:", err);
                const gainersList = document.getElementById('gainers-list');
                if (gainersList) gainersList.innerHTML = `<p class="text-red-500 text-xs p-2">Error: ${err.message}</p>`;
            }

            // Listener terakhir yang bergantung pada data di atas
            marketTypeSelect.addEventListener('change', () => initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message)));

            //updateSignalLogStatistics();
        });
    </script>
</body>

</html>