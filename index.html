<!DOCTYPE html>
<html lang="id" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate CEX_DEX</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.0.1/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF7;
            color: #342d27;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .card {
            background-color: #FFFFFF;
            border: 1px solid #EAE5E0;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            transition: all 0.3s ease-in-out;
        }
        .btn-primary {
            background-color: #c97c00;
            color: #2b2a28;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary:hover { background-color: #eb9413 }
        .btn-primary:disabled { background-color: #333333; cursor: not-allowed; }
        .input-primary {
            background-color: #F8F5F1;
            border: 1px solid #DCD6CF;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #3D352E;
        }
        .input-primary:focus {
            outline: none;
            border-color: #747462;
            box-shadow: 0 0 0 2px rgba(34, 55, 40, 0.2);
        }
        .tag { padding: 0.25rem 0.625rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; }
        .tag-green { background-color: #E6F4EA; color: #4A7C59; }
        .tag-red { background-color: #FCE8E8; color: #A83A3A; }
        .tag-yellow { background-color: #FFF8E1; color: #B5840F; }
        .tag-gray { background-color: #F1F3F4; color: #5F6368; }

        /* Dark Mode Styles */
        .dark body { background-color: #000000; color: #E0E0E0; }
        .dark .card { background-color: #151414; border-color: #333; }
        .dark .input-primary { background-color: #1c1b1b; border-color: #444; color: #E0E0E0; }
        .dark .input-primary:focus { border-color: #2b2d2b; box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.3); }
        .dark .tag-green { background-color: rgba(74, 124, 89, 0.2); color: #69b37f; }
        .dark .tag-red { background-color: rgba(168, 58, 58, 0.2); color: #d17474; }
        .dark .tag-yellow { background-color: rgba(181, 132, 15, 0.2); color: #e0c273; }
        .dark .tag-gray { background-color: rgba(95, 99, 104, 0.2); color: #9aa0a6; }
        .dark .text-gray-800 { color: #E0E0E0; }
        .dark .text-gray-500 { color: #d8d2d2; }
        .dark .text-gray-600 { color: #dddddd; }
        .dark .text-gray-700 { color: #e0e0e0; }
        .dark hr { border-color: #3e4946; }
        .dark .positive { color: #69b37f; }
        .dark .negative { color: #d17474; }

        /* Chart Container Styles */
        .chart-container { position: relative; width: 100%; }
        #main-chart-container { height: 450px; }
        .pane-chart-container { height: 150px; margin-top: 8px; border-top: 1px solid rgba(128, 128, 128, 0.2); padding-top: 8px;}
        .pane-title { position: absolute; top: 15px; left: 15px; z-index: 10; font-size: 12px; font-weight: bold; color: #dddddd; }
        .dark .pane-title { color: #d9d5d5; }

        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px; /* Jarak antar titik */
        }

        .dot {
            width: 14px;
            height: 14px;
            background-color: #e1e1e1; /* Warna hijau dari tema Anda */
            border-radius: 50%;
            animation: bounce 1.0s infinite ease-in-out both;
        }

        /* Atur penundaan animasi untuk setiap titik */
        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1.5);
            }
        }
        
        .positive { color: #16a34a; }
        .dark .positive { color: #4ade80; }
        .negative { color: #dc2626; }
        .dark .negative { color: #f87171; }
        .blinking-text-animation { animation: blinking-text 1.0s infinite; }
        @keyframes blinking-text { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        /* Untuk loader di dalam tombol, buat titiknya lebih kecil */
        #button-loader .dot {
            width: 8px;
            height: 8px;
        }

        /* Style untuk tombol toggle indikator */
        .toggle-btn {
            background-color: #E7A13B;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #d1d5db;
        }
        .toggle-btn:hover {
            background-color: #d1d5db;
        }
        .toggle-btn.active {
            background-color: #1755c6;
            color: #121010;
            border-color: #1c295c;
        }
        .dark .toggle-btn {
            background-color: #1c1b1b;
            color: #d1d5db;
            border-color: #444;
        }
        .dark .toggle-btn:hover {
            background-color: #444;
        }
        .dark .toggle-btn.active {
            background-color: #4f3e01;
            color: #ffffff;
            border-color: #4A7C59;
        }
        .projection-results-container .card {
            background-color: #1c1b1b;
            border-color: #444;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .projection-results-container h4 {
            font-size: 1rem;
            color: #008c38;
        }
        .projection-results-container p {
            color: #e0e0e0;
        }
        .btn-yellow {
            background-color: #f59e0b; /* Tailwind yellow-500 */
            color: #1f2937; /* Tailwind gray-800 */
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-yellow:hover {
            background-color: #d97706;
        }
        .dark .btn-yellow {
            color: #120f0f;
        }
        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }
        #trade-link:hover {
            text-decoration: none;
        }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (MULAI) === */
        .status-uptrend { color: #34d399; }
        .dark .status-uptrend { color: #4ade80; }
        .status-downtrend { color: #ef4444; }
        .dark .status-downtrend { color: #f87171; }
        .status-chop { color: #fbbf24; }
        .dark .status-chop { color: #fcd34d; }

        .confluence-bar-container {
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            height: 30px;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .dark .confluence-bar-container { background-color: #374151; }

        .confluence-bar {
            height: 100%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
            color: #111827;
        }

        .confluence-bar-bullish { background: linear-gradient(to right, #22c55e, #86efac); }
        .confluence-bar-bearish { background: linear-gradient(to right, #ef4444, #fca5a5); }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (SELESAI) === */
        .dark .btn-yellow {
            color: #120f0f;
        }
        /* === TAMBAHKAN BLOK CSS DI BAWAH INI === */
        .btn-secondary {
            background-color: #ff1869; /* gray-500 */
            color: #070707;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-secondary:hover {
            background-color: #ff0a0a; /* gray-600 */
        }
        .dark .btn-secondary {
            background-color: #bb3103; /* gray-600 */
        }
        .dark .btn-secondary:hover {
            background-color: #a21000; /* gray-700 */
        }
     /* === CSS BARU UNTUK SINKRONISASI LEBAR SUMBU HARGA (MULAI) === */
        .chart-container table td:last-child {
            /* Memaksa kolom terakhir (sumbu harga) memiliki lebar 80px */
            width: 80px !important; 
        }
        .chart-container table td:first-child {
            /* Memastikan kolom utama (area chart) mengisi sisa ruang */
            width: calc(100% - 80px) !important;
        }
        
        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dashed rgba(128, 128, 128, 0.5);
        }

        #custom-tooltip {
            position: absolute;
            background-color: #141517; /* dark:bg-gray-800 */
            color: #e2e8f0; /* dark:text-gray-200 */
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #e48005; /* dark:border-gray-600 */
            font-size: 0.875rem;
            line-height: 1.5;
            z-index: 100;
            max-width: 320px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }

        #custom-tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: #2d3748 transparent transparent transparent;
        }

        #custom-tooltip strong {
            color: #63b3ed; /* dark:text-blue-400 */
            display: block;
            margin-bottom: 4px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 4px;
        }

        #ai-narrative-content .prose h3 {
            margin-top: 1.25rem; /* Beri jarak di atas setiap judul (###) */
            margin-bottom: 0.5rem;
        }

        #ai-narrative-content .prose ul {
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        #ai-narrative-content .prose li {
            margin-bottom: 0.5rem; /* Beri jarak antar poin-poin (*) */
        }
        .vwap-mode-btn {
            background-color: #4a5568; /* gray-600 */
            color: #e2e8f0; /* gray-200 */
            border: 1px solid #718096; /* gray-500 */
            opacity: 0.6;
        }
        .vwap-mode-btn.active {
            background-color: #f59e0b; /* yellow-500 */
            color: #1f2937; /* gray-800 */
            opacity: 1;
            font-weight: bold;
        }
        
    </style>
</head>
<body class="antialiased">

    <div id="sticky-nav-wrapper" class="sticky top-0 z-50 bg-[#FDFBF7]/80 dark:bg-[#121212]/80 backdrop-blur-lg border-b border-gray-200/50 dark:border-gray-700/50 shadow-sm">
        <div class="flex items-center justify-between py-2 px-4 sm:px-6 lg:px-8">
            <div class="flex items-center gap-3">
                <a href="https://copilot.page.gd/" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-lg transition-colors duration-300 text-sm">🏠</a>
                
                <div id="nav-info-container" class="items-center gap-2 hidden md:flex">
                    <div class="flex flex-col">
                        <span id="nav-symbol" class="text-base font-bold text-yellow-500 dark:text-yellow-500"></span>
                        <div class="font-mono text-[10px]">
                            <span class="text-gray-400">VOL 24H:</span>
                            <span id="nav-volume-24h" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                    </div>
                    <div class="flex flex-col text-left text-xs">
                        <span id="nav-change-24h" class="font-semibold positive">-</span>
                        <span id="nav-change-1h" class="font-semibold positive">-</span>
                    </div>
                </div>
            </div>

            <div id="nav-stats-container" class="items-center gap-4 font-mono text-[10px] hidden md:flex">
                <div class="flex flex-col text-left">
                    <div>
                        <span class="text-gray-400">ATH:</span>
                        <span id="nav-ath" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                    </div>
                    <div>
                        <span class="text-gray-400">ATL:</span>
                        <span id="nav-atl" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                    </div>
                </div>
            </div>
            
            <a href="#" id="trade-link" class="text-right no-underline hidden">
                <span id="nav-price" class="text-yellow-500 text-lg">-</span>
                <span id="nav-price-idr" class="block text-[10px] text-gray-400"></span>
            </a>
        </div>
    </div>

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <header class="py-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-gray-800">ULTIMATE 🤑 with MVRZ Z-Score</h1>
                <p class="text-yellow-500 font-mono mt-1 text-sm">Final Goes to $1.000.000.000,00 Bugs Fixed!</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none">
                <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8 0 1010.586 10.586z"></path></svg>
                <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414 1.414zM-.707 7.072l.707-.707a1 1 0 10-1.414-1.414l-.707.707a1 1 0 001.414 1.414zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z"></path></svg>
            </button>
        </header>

        <main>
            <div class="space-y-6 mb-8">
                <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                    <div>
                        <input type="password" id="gemini-api-key" class="input-primary" placeholder="Tempel API Key dari Google AI Studio...">
                        <p class="text-xs text-gray-400 mt-1">API 🔑  👆🏻<a href="https://aistudio.google.com/app/apikey" target="_blank" class="underline hover:text-blue-500">GET KEY</a>.</p>
                    </div>
                    <div>
                        <div class="flex flex-col sm:flex-row gap-4">
                            <input type="text" id="asset-input" list="asset-list" class="input-primary text-sm flex-grow uppercase" placeholder="Ketik Simbol Aset (cth: BTCUSDT)" value="BTCUSDT">
                            <datalist id="asset-list"></datalist>
                            <select id="market-type-select" class="input-primary text-sm !w-auto">
                                <option value="spot">Spot</option>
                                <option value="futures" selected>Perp</option>
                            </select>
                            <select id="timeframe-select" class="input-primary text-sm !w-auto">
                                <option value="1m">1m</option><option value="3m">3m</option><option value="5m">5m</option><option value="15m"selected>15m</option><option value="30m">30m</option><option value="1h" >1h</option><option value="2h">2h</option><option value="4h">4h</option><option value="1d">1d</option><option value="1w">W</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="md:col-span-2 flex gap-4">
                         <button id="analyze-asset-btn" class="btn-primary w-full font-bold text-xl">
                            <span id="button-text">GET DATA</span>
                            <div id="button-loader" class="loader hidden">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                        </button>
                        <p id="asset-error" class="text-red-600 text-sm mt-2 text-center hidden"></p>
                        <button id="reset-btn" class="btn-secondary !w-auto">REFRESH</button>
                    </div>
                </section>
                <section id="settings-card" class="card p-4">
                    <button id="toggle-settings-btn" class="w-full flex justify-between items-center text-left">
                        <h2 class="text-lg font-bold">Indicators Settings</h2>
                        <svg id="toggle-settings-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>                                
                    </button>
                    <div id="settings-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Parameter Indikator</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between"><label for="setting-rsi-period" class="text-gray-500">Periode RSI</label><input type="number" id="setting-rsi-period" class="input-primary !w-20 text-center" value="14"></div>
                                        <div class="flex items-center justify-between"><label for="setting-macd-fast" class="text-gray-500">MACD Fast/Slow/Signal</label><div class="flex gap-1"><input type="number" id="setting-macd-fast" class="input-primary !w-16 text-center" value="12"><input type="number" id="setting-macd-slow" class="input-primary !w-16 text-center" value="26"><input type="number" id="setting-macd-signal" class="input-primary !w-16 text-center" value="9"></div></div>
                                        <div class="flex items-center justify-between">
                                            <label for="setting-weight-obv-divergence" class="text-gray-500">Bobot Divergensi OBV</label>
                                            <input type="number" step="0.1" id="setting-weight-obv-divergence" class="input-primary !w-20 text-center" value="3.0">
                                        </div>
                                    </div>
                                </div>
                                <div>
                                    <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Bobot Skor Konfluensi</h3>
                                    <div class="space-y-2 text-sm">
                                        <div class="flex items-center justify-between"><label for="setting-weight-divergence" class="text-gray-500">Bobot Divergensi RSI</label><input type="number" step="0.1" id="setting-weight-divergence" class="input-primary !w-20 text-center" value="2.5"></div>
                                        <div class="flex items-center justify-between"><label for="setting-weight-macd" class="text-gray-500">Bobot MACD Cross</label><input type="number" step="0.1" id="setting-weight-macd" class="input-primary !w-20 text-center" value="2.0"></div>
                                    </div>
                                </div>
                            </div>
                            <div class="text-right mt-4"><button id="save-settings-btn" class="btn-primary">💾 Simpan</button></div>
                            <p id="settings-saved-msg" class="text-green-500 text-sm mt-2 text-center hidden">Pengaturan disimpan!</p>
                        </div>
                    </div>
                </section>
                <section id="watchlist-section" class="card p-6">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
                        <h2 class="text-base font-senibold">📈 Watchlist</h2>
                        <div class="w-full sm:w-auto flex items-center gap-2">
                            <input type="text" id="watchlist-input" class="input-primary text-sm flex-grow uppercase" placeholder="BTCUSDT, ETHUSDT, SOLUSDT...">
                            <button id="save-watchlist-btn" class="btn-primary !p-2" title="Simpan Watchlist">💾</button>
                        </div>
                    </div>
                    <button id="scan-watchlist-btn" class="btn-yellow w-full mb-4">
                        <span>🔍 Watchlist</span>
                        <div class="loader w-5 h-5 hidden"></div>
                    </button>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                            <thead class="bg-gray-50 dark:bg-gray-800">
                                <tr>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Aset</th>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Harga</th>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">𝌡 24J </th>
                                    <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Skor Konfluensi</th>
                                </tr>
                            </thead><tbody id="watchlist-results-body" class="bg-white dark:bg-gray-900 divide-y divide-gray-500 dark:divide-gray-700">
                                <tr>
                                    <td colspan="4" class="px-4 py-4 text-center text-sm text-gray-900">Jalankan pemindaian untuk melihat hasil.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>
                <section id="top-movers-section" class="card p-6 hidden">
                    <h2 class="text-base font-semibold mb-4">Top 5 Movers USDⓈ-M Perpetual</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div><h3 class="text-lg font-semibold text-green-500 mb-2">🟢</h3><div id="gainers-list" class="space-y-2"></div></div>
                        <div><h3 class="text-lg font-semibold text-red-500 mb-2"> 🔴</h3><div id="losers-list" class="space-y-2"></div></div>
                    </div>
                </section>
                
                
            </div>

            <div id="dashboard-content" class="hidden">
                <div class="space-y-8">
                    <button id="toggle-charts-btn" class="btn-yellow w-full">SHOW CHART</button>
                    <section id="charts-wrapper" class="card p-6" style="display: none;">
                        <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                        <div class="chart-container relative"><div class="pane-title">Price</div><div id="main-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">Volume</div>
                            <div id="volume-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">RSI (14)</div><div id="rsi-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">Stochastic RSI</div><div id="stoch-chart-container"></div></div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">MACD</div>
                            <div id="macd-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative"><div class="pane-title">Rate of Change (ROC)</div><div id="roc-chart-container"></div></div>
                    </section>
                    
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:items-start">
                        <div class="flex flex-col gap-4">
                            <section id="scalping-setup-section" class="card p-6">
                                <h2 class="text-xl font-bold mb-4">⚡ Setup Scalping Cepat (<span id="scalping-timeframe-display"></span>)</h2>
                                
                                <div id="futures-data-container" class="hidden space-y-1 text-sm">
                                    <div class="flex justify-between items-center"><span class="text-gray-500">Open Interest</span><span id="open-interest">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-yellow-500">Funding Rate</span><span id="funding-rate" class="font-mono text-yellow-500">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500">Funding Interval</span><span id="funding-rate-interval" class="font-mono">-</span></div>
                                </div>
                                
                                <div id="ls-umum-container" class="flex justify-between items-center text-sm"><span class="text-gray-500">L/S Ratio (Umum)</span><span id="ls-ratio-umum" class="font-mono">-</span></div>
                                <div id="ls-top-container" class="flex justify-between items-center text-sm"><span class="text-gray-500">L/S Ratio (Top Trader)</span><span id="ls-ratio-top" class="font-mono">-</span></div>
                                
                                <div class="text-sm mt-1">
                                    <span class="text-gray-500">Volatilitas (ATR)</span>
                                    <span id="atr-percent-status" class="font-mono text-blue-500">-</span>
                                    <span id="atr-status" class="text-xs text-gray-400">-</span>
                                </div>
                                
                                <div id="scalping-setup-content" class="text-center mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                    <p class="text-sm text-gray-500">Menunggu data...</p>
                                </div>
                            </section>

                            <section id="sentiment-display-container" class="card p-6">
                                <p class="text-center text-gray-500">Data Tambahan Sentimen via "AI" belum dimuat.</p>
                            </section>
                        
                            <section id="current-state-section" class="card p-6">
                                <button id="toggle-market-state-btn" class="w-full flex justify-between items-center text-left mb-4">
                                    <h2 id="current-state-title" class="text-xl font-semibold">Kondisi Pasar (CEX)</h2>
                                    <svg id="toggle-market-state-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                </button>
                                <div id="current-state-content-wrapper" class="collapsible-content expanded">
                                    <div class="space-y-6">
                                        <h2 class="text-lg font-semibold text-center">Timeframe <span id="quick-confluence-timeframe">15m</span></h2>
                                        <div class="flex items-center gap-4 my-2">
                                            <div id="quick-finalBearishScore" class="text-2xl font-bold status-downtrend text-right w-1/5">🐻 0%</div>
                                            <div class="confluence-bar-container w-3/5">
                                                <div id="quick-confluenceBarBearish" class="confluence-bar confluence-bar-bearish" style="width: 50%;"></div>
                                                <div id="quick-confluenceBarBullish" class="confluence-bar confluence-bar-bullish" style="width: 50%;"></div>
                                            </div>
                                            <div id="quick-finalBullishScore" class="text-2xl font-bold status-uptrend text-left w-1/5">0% 🐂</div>
                                        </div>
                                        <p id="quick-finalVerdict" class="text-center font-semibold"></p>

                                        <div id="confluence-breakdown-container" class="mt-4 text-xs text-center space-y-2 hidden">
                                            <div class="grid grid-cols-2 gap-2 text-left">
                                                <div id="top-bullish-contributors"></div>
                                                <div id="top-bearish-contributors"></div>
                                            </div>
                                            <div id="tf-alignment-summary" class="pt-2 border-t border-gray-200 dark:border-gray-700">
                                            </div>
                                        </div>
                                        <div class="space-y-2 pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                                <p class="text-sm text-gray-500">Pola Candlestick</p>
                                                <p id="candlestick-pattern" class="font-semibold">BELUM ADA</p>
                                            </div>
                                            <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                                <p id="chart-pattern-label" class="text-xs text-gray-500">Pola Chart</p>
                                                <p id="chart-pattern" class="font-semibold">BELUM ADA</p>
                                            </div>
                                        </div>
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h2 class="text-xl font-bold mb-4">Live Order Book</h2>
                                            <div id="full-order-book-container" class="space-y-2 text-sm"><p class="text-center text-gray-500">Menunggu data order book...</p></div>
                                        </div>
                                        
                                        <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                            <h3 class="text-lg font-bold mb-4">CVD Order Flow</h3>
                                            <div class="chart-container" style="height: 150px;"><canvas id="cvdChart"></canvas></div>
                                        </div>
                                    </div>
                                </div>
                            </section>
                        
                        <div class="flex flex-col gap-3">
                            <section id="confluence-details-section" class="card p-6">
    <button id="toggle-confluence-btn" class="w-full flex justify-between items-center text-left mb-4">
        <h2 class="text-lg font-bold">📊 Data Timeframe <span id="confluence-timeframe-display">1H</span></h2>
        <svg id="toggle-confluence-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
    </button>
    <div id="confluence-content-wrapper" class="collapsible-content expanded">
        <div>
            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">🌍 Konteks Pasar & Tren Utama</h3>
                <div class="space-y-1 text-sm">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Korelasi vs. BTC (30 Hari)</span>
                        <div>
                            <span id="correlation-value" class="font-mono font-semibold text-gray-300">-</span>
                            <span id="correlation-text" class="text-xs text-gray-500 ml-1">...</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Dominasi BTC</span>
                        <span id="btc-dominance" class="font-mono">-</span>
                    </div>
                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                        <span class="text-gray-500">Market Cap</span>
                        <span id="market-cap" class="font-mono">-</span>
                    </div>

                    <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-500">Tren (EMA 21/50)</span>
                            <span id="ma-status" class="font-mono font-semibold">-</span>
                        </div>
                        <div class="text-right text-xs text-gray-400 font-mono">
                            <span id="ema-21-value">-</span> / 
                            <span id="ema-50-value">-</span>
                        </div>
                    </div>
                     <div class="flex justify-between items-center">
                        <span class="text-gray-500" data-tooltip="Ichimoku Bias|Sistem tren komprehensif yang melihat momentum dan level S/R dinamis.<br><br><b>Kondisi:</b><br>• <b>Bullish:</b> Harga di atas Awan (Kumo).<br>• <b>Bearish:</b> Harga di bawah Awan (Kumo).<br>• <b>Netral:</b> Harga di dalam Awan (Kumo).">Ichimoku Bias</span>
                        <span id="ichimoku-bias" class="font-mono font-semibold">-</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500" data-tooltip="Kekuatan Tren (ADX)|Mengukur KEKUATAN sebuah tren, bukan arahnya.<br><br><b>Kondisi:</b><br>• <b>0-25:</b> Tren Lemah / Sideways.<br>• <b>25-50:</b> Tren Kuat.<br>• <b>50-75:</b> Tren Sangat Kuat.<br>• <b>75-100:</b> Tren Ekstrem.">Kekuatan Tren (ADX 14)</span>
                        <div>
                            <span id="adx-value" class="font-mono font-semibold">-</span>
                            <span class="text-xs positive" id="plus-di-value"></span> /
                            <span class="text-xs negative" id="minus-di-value"></span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">🎯 Area Penting & Level Kunci</h3>
                <div class="space-y-1 text-sm">
                    <div class="flex justify-between"><span class="text-red-500">Value Area High</span><span id="vpvr-vah" class="font-mono">-</span></div>
                    <div class="flex justify-between"><span class="font-bold text-blue-500" data-tooltip="Point of Control (POC)|Level harga dengan volume trading tertinggi pada periode terlihat. Bertindak sebagai magnet harga.<br><br><b>Kondisi:</b><br>• <b>Harga > POC:</b> Dianggap sebagai area support.<br>• <b>Harga < POC:</b> Dianggap sebagai area resistance.">Point of Control (POC)</span><span id="vpvr-poc" class="font-mono font-bold">-</span></div>
                    <div class="flex justify-between"><span class="text-green-500">Value Area Low</span><span id="vpvr-val" class="font-mono">-</span></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500">Rentang 24 Jam</span><span id="range-24h" class="font-mono font-semibold">-</span></div>
                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                        <span class="text-gray-500" data-tooltip="Pivot Harian (P)|Level acuan sentral yang dihitung dari High, Low, Close hari sebelumnya.<br><br><b>Kondisi:</b><br>• <b>Harga > Pivot:</b> Sentimen Bullish Intraday.<br>• <b>Harga < Pivot:</b> Sentimen Bearish Intraday.">Pivot Harian (P)</span><span id="pivot-p" class="font-mono font-bold text-blue-500">-</span>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500" data-tooltip="VWAP (Volume-Weighted Average Price)|Harga rata-rata tertimbang volume. Acuan penting bagi trader institusional.<br><br><b>Mode:</b><br>• <b>Rolling:</b> Rata-rata 20 candle terakhir.<br>• <b>Session:</b> Direset setiap hari (00:00 UTC).<br>• <b>Anchored:</b> Dimulai dari titik terendah 200 candle terakhir.">VWAP</span>
                        <div class="flex items-center gap-2">
                            <div id="vwap-mode-buttons" class="flex text-xs">
                                <button data-mode="rolling" class="vwap-mode-btn active px-2 py-0.5 rounded-l-md" data-tooltip="Rolling VWAP|Menghitung VWAP berdasarkan 20 candle terakhir. Berguna untuk melihat nilai wajar jangka pendek yang terus bergerak.">R</button>
                                <button data-mode="session" class="vwap-mode-btn px-2 py-0.5" data-tooltip="Session VWAP|VWAP direset setiap hari pada pukul 00:00 UTC. Sangat umum digunakan oleh day trader untuk menentukan bias intraday.">S</button>
                                <button data-mode="anchored" class="vwap-mode-btn px-2 py-0.5 rounded-r-md" data-tooltip="Anchored VWAP|VWAP dimulai dari titik terendah dalam 200 candle terakhir. Berguna untuk melihat harga rata-rata sejak titik pembalikan tren terakhir.">A</button>
                            </div>
                            <span id="vwap-20d" class="font-mono text-yellow-500">-</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">⚡ Momentum & Kondisi Saat Ini</h3>
                <div class="space-y-1 text-sm">
                     <div class="flex justify-between items-center"><span class="text-gray-500">RSI (14)</span><div><span id="rsi-value" class="font-mono text-xs">-</span> <span id="rsi-status" class="tag tag-gray"></span></div></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500">Stoch RSI (%K/%D)</span><div><span id="stoch-value" class="font-mono text-xs">-</span> <span id="stoch-status" class="tag tag-gray"></span></div></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500">MACD</span><div><span id="macd-status" class="font-mono font-semibold">-</span> <span id="macd-hist" class="font-mono text-xs ml-1">-</span></div></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="RSI Divergence|Kondisi di mana harga dan indikator RSI bergerak ke arah berlawanan, menandakan potensi pembalikan tren.<br><br><b>Kondisi:</b><br>• <b>BULLISH:</b> Harga 'Lower Low', RSI 'Higher Low'.<br>• <b>BEARISH:</b> Harga 'Higher High', RSI 'Lower High'.">RSI Divergence</span><span id="rsi-divergence" class="font-mono font-semibold text-xs">-</span></div>
                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50"><span class="text-gray-500">Parabolic SAR</span><span id="psar-status" class="font-mono">-</span></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Rate of Change (ROC)|Mengukur kecepatan perubahan harga dalam persentase.<br><br><b>Kondisi:</b><br>• <b>Positif (> 0):</b> Momentum Bullish.<br>• <b>Negatif (< 0):</b> Momentum Bearish.">Rate of Change (ROC)</span><span id="roc-status" class="font-mono">-</span></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Linear Regression Channel|Kanal statistik yang menunjukkan tren utama harga dan deviasi normalnya.<br><br><b>Kondisi:</b><br>• <b>Upper Line:</b> Area overbought/resistance.<br>• <b>Lower Line:</b> Area oversold/support.<br>• <b>In Channel:</b> Harga bergerak dalam rentang normal.">LinReg Channel</span><span id="linreg-status" class="font-mono">-</span></div>
                </div>
            </div>

            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">🔬 Volatilitas & Sentimen Jangka Pendek</h3>
                <div class="space-y-1 text-sm">
                    <div class="flex justify-between items-center"><span class="text-blue-500" data-tooltip="Bollinger Squeeze|Indikasi volatilitas pasar yang sangat rendah, seringkali mendahului pergerakan harga yang besar.<br><br><b>Kondisi:</b><br>• <b>SQUEEZE PRO!:</b> Volatilitas sangat terkompresi (BB di dalam Keltner Channel).<br>• <b>Squeeze!:</b> Volatilitas rendah (BB menyempit).<br>• <b>Normal:</b> Volatilitas normal.">Bollinger Squeeze</span><span id="bollinger-squeeze-status" class="font-mono">-</span></div>
                    <div class="flex justify-between items-center"><span class="text-yellow-500">BB Rejection</span><span id="bollinger-rejection-status" class="font-mono">-</span></div>
                    <div class="flex justify-between items-center"><span class="text-gray-500">BB Walk the Bands</span><span id="bollinger-walk-status" class="font-mono">-</span></div>    
                    <div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-500">Bollinger Bands</span>
                            <span id="bollinger-bands-status" class="font-mono">-</span>
                        </div>
                        <div class="text-right text-xs text-gray-400 font-mono">
                            <span id="bb-upper-value">-</span> / 
                            <span id="bb-middle-value">-</span> / 
                            <span id="bb-lower-value">-</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                        <span class="text-gray-500">Order Book Bias</span><span id="order-book-bias" class="font-mono">-</span>
                    </div>
                </div>
            </div>

            <div class="hidden">
                 <div class="flex justify-between items-center">
                    <h2 class="text-base font-semibold">Korelasi Pasar</h2>
                    <div class="flex items-center justify-center gap-2">
                        <span class="text-sm text-gray-400">vs.</span>
                        <input type="text" id="correlation-asset-input" class="input-primary !w-32 text-center uppercase font-mono text-xs" value="BTCUSDT">
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
                                <section id="onchain-card" class="card p-6">
                                    <button id="toggle-onchain-btn" class="w-full flex justify-between items-center text-left mb-4">
                                        <h2 class="text-xl font-bold">⛓️‍💥 Aktivitas On-Chain</h2>
                                        <svg id="toggle-onchain-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                                    </button>
                                    <div id="onchain-content-wrapper" class="collapsible-content">
                                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                            <div id="specific-token-analysis" class="mb-4">
                                                <h3 id="specific-token-title" class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Analisis Token Spesifik</h3>
                                                <div id="specific-token-content" class="text-sm space-y-1"><p class="text-xs text-gray-500 text-center">Mencari data on-chain untuk aset yang dianalisa...</p></div>
                                            </div>                                    
                                            <div>
                                                <h3 class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Pool Trending Teratas</h3>
                                                <div id="trending-pools-content" class="text-sm space-y-2"><div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div></div>
                                            </div>
                                        </div>
                                    </div>
                                </section>
                            </div>
                        </div> 
                    <section id="ai-analysis-section" class="card p-6 relative">
    <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold">💡 Analisis AI</h2>
    </div>

    <div id="ai-verdict-content-wrapper" class="collapsible-content expanded">
        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
            <button id="run-comprehensive-ai-btn" class="btn-primary w-full mb-4">
    <span>🚀 ANALISA</span>
    <div class="loader w-5 h-5 hidden">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
    </div>
</button>
            <div id="ai-content-container" class="hidden space-y-6">
                <div id="ai-narrative-content" class="prose prose-sm dark:prose-invert max-w-none text-gray-600 space-y-4"></div>
                <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">🔮 Proyeksi Harga</h3><div id="projection-results-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div></div>
                <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">♟️ Saran Strategis</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-green-500 mb-2">Untuk Calon Buyer</h4><p id="saran-buyer" class="text-lg font-bold"></p><p id="alasan-buyer" class="text-sm text-gray-500 mt-1"></p></div><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-blue-500 mb-2">Untuk Holder</h4><p id="saran-holder" class="text-lg font-bold"></p><p id="alasan-holder" class="text-sm text-gray-500 mt-1"></p></div></div></div>
            </div>
        </div>
    </div>

    <div class="absolute bottom-2 right-2">
        <button id="toggle-ai-verdict-btn" class="p-1 rounded-full text-gray-400 hover:bg-gray-700 focus:outline-none">
            <svg id="toggle-ai-verdict-icon" class="w-5 h-5 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
            </svg>
        </button>
    </div>
</section>             
                    </div>
                    
            <div id="initial-placeholder" class="text-center py-20">
                <p class="text-xs font-mono text-gray-500">Pilih Spot or Futures ERROR? REFRESH browser</p>
            </div>
            <div id="loader-overlay" class="... flex-col ...">
                <div class="loader">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
                <p id="loader-text" class="text-white font-semibold mt-4">Memulai Analisa...</p>
            </div>
        </main>
    </div>

<script>
    // =======================================================
    // BAGIAN 1: DEKLARASI SEMUA ELEMEN DOM
    // =======================================================
    const gainersList = document.getElementById('gainers-list');
    const losersList = document.getElementById('losers-list');
    const navWrapper = document.getElementById('sticky-nav-wrapper');
    const mainContent = document.getElementById('main-content-container');
    const toggleAiVerdictBtn = document.getElementById('toggle-ai-verdict-btn');
    const toggleAiVerdictIcon = document.getElementById('toggle-ai-verdict-icon');
    const aiVerdictContentWrapper = document.getElementById('ai-verdict-content-wrapper');
    const assetInput = document.getElementById('asset-input');
    const apiKeyInput = document.getElementById('gemini-api-key');
    const timeframeSelect = document.getElementById('timeframe-select');
    const marketTypeSelect = document.getElementById('market-type-select');
    const analyzeBtn = document.getElementById('analyze-asset-btn');
    const buttonText = document.getElementById('button-text');
    const buttonLoader = document.getElementById('button-loader');
    const assetError = document.getElementById('asset-error');
    const dashboardContent = document.getElementById('dashboard-content');
    const initialPlaceholder = document.getElementById('initial-placeholder');
    const loaderOverlay = document.getElementById('loader-overlay');
    const loaderText = document.getElementById('loader-text');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const darkIcon = document.getElementById('theme-toggle-dark-icon');
    const lightIcon = document.getElementById('theme-toggle-light-icon');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');   
    const projectionResultsContainer = document.getElementById('projection-results-container');
    const specificTokenTitle = document.getElementById('specific-token-title');
    const specificTokenContent = document.getElementById('specific-token-content');
    const trendingPoolsContent = document.getElementById('trending-pools-content');
    const topMoversSection = document.getElementById('top-movers-section');
    const fullOrderBookContainer = document.getElementById('full-order-book-container');
    const tradeLink = document.getElementById('trade-link');
    const watchlistInput = document.getElementById('watchlist-input');
    const saveWatchlistBtn = document.getElementById('save-watchlist-btn');
    const scanWatchlistBtn = document.getElementById('scan-watchlist-btn');
    const watchlistResultsBody = document.getElementById('watchlist-results-body');
    const navVolume24h = document.getElementById('nav-volume-24h');
    const navAth = document.getElementById('nav-ath');
    const navAtl = document.getElementById('nav-atl');
    const resetBtn = document.getElementById('reset-btn');
    // =======================================================
    // BAGIAN 2: KONSTANTA KONFIGURASI
    // =======================================================
    const UI_UPDATE_INTERVAL = 500;
    const KLINE_CACHE_DURATION = 5 * 60 * 1000; // Cache berlaku 5 menit
    // =======================================================
    // BAGIAN 3: DEKLARASI STATE & VARIABEL GLOBAL
    // =======================================================
    let userSettings = {
        indicator: {
            rsi_period: 14,
            macd_fast: 12,
            macd_slow: 26,
            macd_signal: 9,
        },
        weights: {
        // core TA
        ma: 2, pivot: 2, vwap: 2, ichimoku: 3,
        rsi: 1.5, stoch: 1, macd: 2, candlePattern: 1.5,
        psar: 1, linreg: 1, roc: 1, bollingerBands: 1,

        // divergence
        rsiDivergence: 1.5, obvDivergence: 1,

        // derivatives / order book / volatility
        openInterest: 1,
        funding: 1,       // alias fundingRate akan tetap di-handle di scorer
        lsr: 1,           // alias lsRatio di-handle di scorer
        orderBookBias: 1,
        bbSqueeze: 1
        }       
    };

    // Tambahan bobot indikator derivatif + microstructure
    userSettings.weights.openInterest  = userSettings.weights.openInterest  ?? 2;
    userSettings.weights.funding       = userSettings.weights.funding       ?? 1;
    userSettings.weights.lsr           = userSettings.weights.lsr           ?? 1;
    userSettings.weights.orderBookBias = userSettings.weights.orderBookBias ?? 2;
    userSettings.weights.bbSqueeze     = userSettings.weights.bbSqueeze     ?? 1; // setup, bukan arah


    let klineCache = {};
    let latestBids = [];
    let latestAsks = [];
    let topMoversInterval = null;
    let coinListCache = null;
    let exchangeInfoCache = { spot: null, futures: null };
    let analysisCache = {};
    let charts = [];
    let candlestickSeries = null; 
    let cvdChartInstance = null;
    let liveCvdValue = 0;
    let liveCvdData = [];
    let isChartsVisible = false;
    let liveCvdValueUsdt = 0;
    let periodicUpdateInterval = null;
    let latestCalculatedData = {};
    let lastUiUpdateTime = 0;
    let tradeQueue = [];
    let depthQueue = [];
    let klineQueue = [];
    let processingInterval = null;
    let fundingRateTimer = null;
    let watchlist = [];
    let orderBookDOMElements = null;

// =======================================================
    // BAGIAN 4: DEFINISI FUNGSI-FUNGSI
// =======================================================
// OBJEK WEBSOCKET MANAGER HARUS DIDEKLARASIKAN DI AWAL
    const WebSocketManager = {
        ws: null,
        subscriptions: new Set(),
        messageHandlers: {},
        reconnectInterval: 5000,
        pingTimer: null,
        isConnecting: false,

        handleOpen() {
            console.log("Koneksi WebSocket Berhasil Dibuka.");
            this.isConnecting = false;
            this.startPing();
        },
        handleMessage(event) {
            const message = JSON.parse(event.data);
            if (message.result !== undefined) return;
            if (message.stream && message.data) {
                const streamName = message.stream;
                const payload = message.data;
                if (streamName.includes('@kline')) {
                    if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                } else if (streamName.includes('@aggTrade')) {
                    if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                } else if (streamName.includes('@depth')) {
                    if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                } else if (streamName.includes('@bookTicker')) {
                    if (this.messageHandlers['bookTicker']) this.messageHandlers['bookTicker'](payload);
                }
            }
        },
        handleClose() {
            console.warn("Koneksi WebSocket Ditutup. Mencoba menghubungkan kembali...");
            this.stopPing();
            this.isConnecting = false;
            if (this.subscriptions.size > 0) {
                 setTimeout(() => this.connect(), this.reconnectInterval);
            }
        },
        handleError(error) {
            console.error("Kesalahan WebSocket:", error);
            this.isConnecting = false;
            if (this.ws) {
                this.ws.close();
            }
        },
        connect() {
            if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) || this.isConnecting) {
                return;
            }
            this.isConnecting = true;
            const streamNames = Array.from(this.subscriptions).join('/');
            if (streamNames.length === 0) {
                this.isConnecting = false;
                return;
            }
            const url = `wss://stream.binance.com:9443/stream?streams=${streamNames}`;
            console.log("Menyambung ke:", url);
            this.ws = new WebSocket(url);
            this.ws.onopen = this.handleOpen.bind(this);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);
        },
        startPing() {
            this.stopPing();
            this.pingTimer = setInterval(() => {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ method: "PONG", id: new Date().getTime() }));
                }
            }, 3 * 60 * 1000);
        },
        stopPing() {
            clearInterval(this.pingTimer);
        },
        subscribe(streams) {
            streams.forEach(stream => this.subscriptions.add(stream));
            this.connect();
        },
        resetSubscriptions() {
            this.subscriptions.clear();
            if (this.ws) {
                this.ws.onclose = null; 
                this.ws.close();
            }
            this.stopPing();
            if (processingInterval) clearInterval(processingInterval);
        },
        registerHandler(streamName, handler) {
            this.messageHandlers[streamName] = handler;
        }
    };
// =======================================================
   function displaySentimentDataInDashboard(data) {
        const container = document.getElementById('sentiment-display-container');

        // --- Interpretasi & Pewarnaan untuk setiap data poin ---
        const netflowClass = data.netflow < 0 ? 'positive' : 'negative';
        const netflowText = data.netflow < 0 ? `Outflow (Bullish)` : `Inflow (Bearish)`;

        const oiClass = data.oiChange > 0 ? 'positive' : 'negative';
        const oiText = data.oiChange > 0 ? `Naik` : `Turun`;

        // Funding rate dianggap sehat jika dekat dengan nol
        const fundingClass = Math.abs(data.fundingRate) > 0.02 ? 'negative' : 'text-gray-400';
        const fundingText = Math.abs(data.fundingRate) > 0.02 ? `Ekstrem` : `Sehat`;

        // Ekstrak L/S Ratio untuk pewarnaan
        const lsParts = data.lsRatio24h.split('/');
        const longRatio = parseFloat(lsParts[0]);
        const shortRatio = parseFloat(lsParts[1]);
        const lsClass = longRatio > shortRatio ? 'positive' : (shortRatio > longRatio ? 'negative' : 'text-gray-400');
        const lsText = longRatio > shortRatio ? `Dominan Long` : (shortRatio > longRatio ? `Dominan Short` : `Seimbang`);

        container.innerHTML = `
            <h3 class="text-lg font-bold mb-4 text-center">🌡️ Sentimen Pasar (via AI)</h3>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between items-center"><span class="text-gray-400">Aliran Bursa (Netflow BTC)</span><span class="font-bold ${netflowClass}">${data.netflow.toFixed(2)} BTC (${netflowText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Perubahan Open Interest</span><span class="font-bold ${oiClass}">${data.oiChange.toFixed(2)}% (${oiText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rata-rata Funding Rate</span><span class="font-bold ${fundingClass}">${(data.fundingRate * 100).toFixed(4)}% (${fundingText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rasio Long/Short (24j)</span><span class="font-bold ${lsClass}">${data.lsRatio24h} (${lsText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Likuidasi (Long vs Short)</span><span class="font-bold text-gray-200">${data.liquidations}</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">MVRV Z-Score</span><span class="font-bold text-yellow-400">${data.mvrv_z_score.toFixed(2)}</span></div>
                <p class="text-center text-xs text-gray-500 pt-2">Data diambil oleh AI pada: ${new Date().toLocaleTimeString('id-ID')}</p>
            </div>
        `;
    }
// --- FUNGSI PENGATURAN ---
    function saveSettings() {
        userSettings.indicator.rsi_period = parseInt(document.getElementById('setting-rsi-period').value);
        userSettings.indicator.macd_fast = parseInt(document.getElementById('setting-macd-fast').value);
        userSettings.indicator.macd_slow = parseInt(document.getElementById('setting-macd-slow').value);
        userSettings.indicator.macd_signal = parseInt(document.getElementById('setting-macd-signal').value);
        userSettings.weights.rsiDivergence = parseFloat(document.getElementById('setting-weight-divergence').value);
        userSettings.weights.macd = parseFloat(document.getElementById('setting-weight-macd').value);
        userSettings.weights.obvDivergence = parseFloat(document.getElementById('setting-weight-obv-divergence').value);
        localStorage.setItem('ultimateAppSettings', JSON.stringify(userSettings));
        const msgEl = document.getElementById('settings-saved-msg');
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 2000);
    }
// =======================================================
    function loadSettings() {
        const savedSettings = localStorage.getItem('ultimateAppSettings');
        if (savedSettings) {
            try {
                const parsed = JSON.parse(savedSettings);
                // Lakukan merge untuk memastikan semua properti ada
                userSettings = {
                    indicator: { ...userSettings.indicator, ...parsed.indicator },
                    weights: { ...userSettings.weights, ...parsed.weights }
                };
            } catch (e) {
                console.error("Gagal parse pengaturan dari localStorage, gunakan default.", e);
            }
        }
        document.getElementById('setting-rsi-period').value = userSettings.indicator.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.indicator.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.indicator.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.indicator.macd_signal;
        document.getElementById('setting-weight-divergence').value = userSettings.weights.rsiDivergence;
        document.getElementById('setting-weight-macd').value = userSettings.weights.macd;
        document.getElementById('setting-weight-obv-divergence').value = userSettings.weights.obvDivergence;
    }
// --- FUNGSI UTAMA & UTILITIES ---
    function showError(message) {
        assetError.textContent = message;
        assetError.classList.remove('hidden');
    }
// =======================================================
    function hideError() {
        assetError.classList.add('hidden');
    }
// =======================================================
    function showLoader(show, text = '') {
        if (show) {
            loaderText.textContent = text;
            loaderOverlay.classList.remove('hidden');
            loaderOverlay.classList.add('flex');
            analyzeBtn.disabled = true;
            buttonText.classList.add('hidden');
            buttonLoader.classList.remove('hidden');
        } else {
            loaderOverlay.classList.add('hidden');
            loaderOverlay.classList.remove('flex');
            analyzeBtn.disabled = false;
            buttonText.classList.remove('hidden');
            buttonLoader.classList.add('hidden');
        }
    }
// =======================================================
    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) {
            console.error('Elemen toggle tidak ditemukan untuk:', buttonId);
            return;
        }
        contentWrapper.classList.add('collapsible-content');
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };
        let isVisible = startVisible;
        applyState(isVisible);
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }
// =======================================================
    function adjustContentPadding() {
        if (navWrapper && mainContent) {
            const navHeight = navWrapper.offsetHeight;
            mainContent.style.paddingTop = `${navHeight}px`;
        }
    }
// =======================================================
    const formatPrice = (price) => {
        if (price === null || price === undefined) return '-';
        if (price >= 1) {
            return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }
        const priceString = price.toString();
        const decimalPart = priceString.includes('.') ? priceString.split('.')[1] : '';
        if (decimalPart.length === 0) return `$${price.toFixed(2)}`;
        let nonZeroIndex = -1;
        for (let i = 0; i < decimalPart.length; i++) {
            if (decimalPart[i] !== '0') {
                nonZeroIndex = i;
                break;
            }
        }
        if (nonZeroIndex !== -1) {
            const significantDigits = 4;
            return `$${price.toFixed(nonZeroIndex + significantDigits)}`;
        }
        return `$${price.toFixed(8)}`;
    };
// =======================================================
    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 7;
        return 8;
    }
// =======================================================
// From ChatGPT Confluence scoring – potongan terhenti
// Lengkapi return untuk bullish/bearish; tambahkan default 0. Juga pastikan semua indicator punya bobot di userSettings.weights.
// // =======================================================
    function getUltimateSignalScore(indicator, signalData) {
    let w = (userSettings?.weights?.[indicator]) ?? 1;
    // pastikan numeric
    w = (typeof w === 'number') ? w : (Number(w) || 1);

    // Helper umum
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const mapRange = (x, inMin, inMax, outMin, outMax) => {
        const t = (x - inMin) / (inMax - inMin);
        return outMin + clamp(t, 0, 1) * (outMax - outMin);
    };

    // Ambil confidence (default = 1)
    const confidence = (typeof signalData?.confidence === 'number')
        ? clamp(signalData.confidence, 0, 1)
        : 1;

    // Parsing umum bias/teks
    const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
    const biasSigned = (typeof signalData?.biasSigned === 'number') 
        ? Math.sign(signalData.biasSigned) 
        : null;

    // Normalisasi indikator by name
    if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
        if (biasSigned !== null) return clamp(biasSigned, -1, 1) * w * confidence;
        if (text.includes('BULL')) return +1 * w * confidence;
        if (text.includes('BEAR')) return -1 * w * confidence;
        return 0;
    }

    if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
        if (text.includes('BULL')) return +1 * w * confidence;
        if (text.includes('BEAR')) return -1 * w * confidence;
        return 0;
    }

    if (indicator === 'openInterest') {
        if (biasSigned !== null) return clamp(biasSigned, -1, 1) * w * confidence;
        if (text.includes('UP')) return +1 * w * confidence;
        if (text.includes('DOWN')) return -1 * w * confidence;
        return 0;
    }

    if (indicator === 'funding' || indicator === 'fundingRate') {
        const v = typeof signalData?.value === 'number' ? signalData.value : 0;
        const s = mapRange(Math.abs(v), 0, 0.05, 0, 1) * Math.sign(v || 0);
        return clamp(s, -1, 1) * w * confidence;
    }

    if (indicator === 'lsr' || indicator === 'lsRatio') {
        const v = typeof signalData?.value === 'number' ? signalData.value : 1;
        const s = clamp(v - 1, -1, 1);
        return s * w * confidence;
    }

    if (indicator === 'orderBookBias') {
        if (biasSigned !== null) return clamp(biasSigned, -1, 1) * w * confidence;
        if (text.includes('BID')) return +1 * w * confidence;
        if (text.includes('ASK')) return -1 * w * confidence;
        return 0;
    }

    if (indicator === 'bbSqueeze') {
        const st = (signalData?.status || '').toString().toUpperCase();
        if (st.includes('RELEASE')) return +1 * w * confidence;
        if (st.includes('ON')) return 0;
        if (st.includes('OFF')) return 0.3 * w * confidence;
        return 0;
    }

    return 0;
}


// =======================================================

// ==============chatgpt=========================================
    function updateQuickConfluenceWidget() {
    const data = analysisCache.calculatedData;
    if (!data) return;

    let totalScore = 0;
    let totalBullScore = 0;
    let totalBearScore = 0;
    let maxPossibleScore = 0;

    // Hitung skor semua indikator sesuai bobot
    for (const indicator in userSettings.weights) {
        const weight = userSettings.weights[indicator] || 0;
        if (data[indicator]) {
            const rawScore = getUltimateSignalScore(indicator, data[indicator]);
            const weightedScore = rawScore * weight;
            totalScore += weightedScore;
            if (weightedScore > 0) totalBullScore += weightedScore;
            if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
        }
        maxPossibleScore += weight;
    }

    // Normalisasi skor ke -100..+100
    const normalizedScore = maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 100 : 0;

    // Simpan ke cache
    analysisCache.quickConfluenceScore = { 
        score: normalizedScore,
        bull: maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0,
        bear: maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0
    };

    // Gunakan fungsi verdict singkat
    const { text: verdict, class: verdictClass } = generateShortVerdict(
        analysisCache.quickConfluenceScore.bull, 
        analysisCache.quickConfluenceScore.bear
    );

    // Update UI
    document.getElementById('quick-confluence-timeframe').textContent = timeframeSelect.value;

    // Breakdown lama 🐂🐻 → tetap tampil
    document.getElementById('quick-finalBullishScore').textContent = `${analysisCache.quickConfluenceScore.bull.toFixed(0)}% 🐂`;
    document.getElementById('quick-finalBearishScore').textContent = `🐻 ${analysisCache.quickConfluenceScore.bear.toFixed(0)}%`;

    // Bar visual
    const bullWidth = (normalizedScore + 100) / 2; // -100..+100 jadi 0..100
    document.getElementById('quick-confluenceBarBullish').style.width = `${bullWidth}%`;
    document.getElementById('quick-confluenceBarBearish').style.width = `${100 - bullWidth}%`;

    // Verdict + skor ringkas
    const verdictEl = document.getElementById('quick-finalVerdict');
    const scoreText = normalizedScore > 0 ? `+${normalizedScore.toFixed(0)}` : normalizedScore.toFixed(0);
    verdictEl.innerHTML = `${verdict} <span class="text-sm font-mono ${verdictClass}">(${scoreText})</span>`;
    verdictEl.className = `text-center font-semibold ${verdictClass}`;
    analyzeAndDisplayConfluenceContributors();
}

// =======================================================   
    function updateCvdTableLive() {
        const tableBody = document.getElementById('cvd-table-body');
        if (!tableBody || liveCvdData.length === 0) return;

        // Ambil data paling baru
        const lastDataPoint = liveCvdData[liveCvdData.length - 1];

        // Buat baris baru dan masukkan di paling atas (index 0)
        const newRow = tableBody.insertRow(0);
        
        const date = new Date(lastDataPoint.x);
        const formattedTime = date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        // Tentukan warna berdasarkan perubahan nilai USDT
        const prevUsdt = liveCvdData.length > 1 ? liveCvdData[liveCvdData.length - 2].y_usdt : 0;
        const colorClass = lastDataPoint.y_usdt > prevUsdt ? 'positive' : 'negative';

        // Isi sel di baris baru
        newRow.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${formattedTime}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">${lastDataPoint.y_coin.toFixed(4)}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">$${lastDataPoint.y_usdt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        `;

        // Jaga agar jumlah baris tidak lebih dari 5, hapus yang paling bawah
        while (tableBody.rows.length > 5) {
            tableBody.deleteRow(tableBody.rows.length - 1);
        }
    }
// ===========================chatgpt============================
    async function fetchTopMovers() {
    try {
        const resp = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
        if (!resp.ok) throw new Error('Failed to fetch top movers data.');
        const tickers = await resp.json();

        const exchangeInfo = await fetchBinanceAPIData('exchangeInfo', {}, 'futures');
        const trading = new Set(exchangeInfo.symbols.filter(s => s.status === 'TRADING').map(s => s.symbol));

        const filtered = tickers.filter(t => t.symbol.endsWith('USDT') && parseFloat(t.priceChangePercent) !== 0 && trading.has(t.symbol));

        const with1h = await Promise.all(filtered.map(async t => {
        try {
            const r = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${t.symbol}&interval=1h&limit=2`);
            if (!r.ok) return { ...t, priceChangePercent1h: 'N/A' };
            const kl = await r.json();
            if (kl.length < 2) return { ...t, priceChangePercent1h: 'N/A' };
            const prev = parseFloat(kl[0][4]);
            const cur  = parseFloat(kl[1][4]);
            const ch1h = ((cur - prev) / prev) * 100;
            return { ...t, priceChangePercent1h: ch1h.toFixed(2) };
        } catch {
            return { ...t, priceChangePercent1h: 'N/A' };
        }
        }));

        with1h.sort((a,b) => parseFloat(b.priceChangePercent) - parseFloat(a.priceChangePercent));
        const gainers = with1h.slice(0, 5);
        const losers  = with1h.slice(-5).reverse();

        displayTopMovers(gainers, gainersList, 'positive');
        displayTopMovers(losers, losersList, 'negative');
        attachTopMoversListeners();
        topMoversSection.classList.remove('hidden');
    } catch (e) {
        console.error('Error fetching top movers:', e);
        topMoversSection.classList.add('hidden');
    }
    }

    function displayTopMovers(data, container, colorClass) {
    container.innerHTML = data.map(item => {
        const formattedPrice = formatPrice(parseFloat(item.lastPrice)).replace('$', '');
        
        // Menentukan warna untuk perubahan 1 jam
        const change1h = parseFloat(item.priceChangePercent1h);
        const colorClass1h = change1h >= 0 ? 'positive' : 'negative';

        return `
        <button class="w-full text-left p-2 rounded-md bg-gray-800 dark:bg-gray-800 hover:bg-gray-800 dark:hover:bg-gray-900 transition-colors duration-200" data-symbol="${item.symbol}">
            <div class="flex justify-between items-center text-sm font-semibold">
                <span class="dark:text-white">${item.symbol.replace('USDT','')}</span>
                <span class="dark:text-white">${formattedPrice}</span>
            </div>
            <div class="flex justify-between items-center text-xs mt-1">
                <span class="${colorClass}">${parseFloat(item.priceChangePercent).toFixed(2)}% (24H)</span>
                <span class="${colorClass1h}">${item.priceChangePercent1h}% (1H)</span>
            </div>
        </button>`;
    }).join('');
}

    function attachTopMoversListeners() {
    document.querySelectorAll('#top-movers-section button').forEach(btn => {
        btn.addEventListener('click', () => {
        const symbol = btn.getAttribute('data-symbol');
        if (!symbol) return;
        assetInput.value = symbol;
        runFullAnalysis();
        window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    });
    }
// =================END OF TOP MOVERS CHATGPT=====================================  
// --- BAGIAN UPGRADE: Fungsi terpusat untuk update indikator real-time ---
    function updateRealTimeIndicators(klines) {
        if (!klines || klines.length < 50) return; // Pengaman

        console.log("Memperbarui indikator dari data candle terbaru...");

        const closes = klines.map(k => parseFloat(k[4]));

        // Hitung ulang semua indikator yang relevan
        const adx = calculateADX(klines);
        const ma = (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? { status: 'Uptrend', class: 'positive' } : { status: 'Downtrend', class: 'negative' };
        const rsiValues = calculateRSI(closes);
        const rsiLast = rsiValues.filter(v=>v!==undefined).pop() || 50;
        const rsi = { values: rsiValues, last: rsiLast.toFixed(2), status: rsiLast > 70 ? 'Overbought' : (rsiLast < 30 ? 'Oversold' : 'Netral'), class: rsiLast > 70 ? 'tag-red' : (rsiLast < 30 ? 'tag-green' : 'tag-yellow') };
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);
        const stoch = calculateStochasticRSI(closes);
        const macd = calculateMACD(closes);
        const bollingerBands = calculateBollingerBands(closes);
        const atr = calculateATR(klines);
        const candlePattern = findCandlestickPatterns(klines);
        const chartPattern = findChartPatterns(klines);
        const roc = calculateROC(closes);
        const psar = calculateParabolicSAR(klines);
        const linreg = calculateLinearRegressionChannel(closes);

        // Simpan hasil kalkulasi terbaru ke state
        latestCalculatedData = { adx, ma, rsi, rsiDivergence, stoch, macd, bollingerBands, atr, candlePattern, chartPattern, roc, psar, linreg };

        // Update UI dengan data terbaru
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = ma.status;
        maStatusEl.className = `font-mono font-semibold ${ma.class}`;

        document.getElementById('rsi-value').textContent = rsi.last;
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = rsi.status;
        rsiStatusEl.className = `tag ${rsi.class}`;
        
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${rsiDivergence.class}`;

        document.getElementById('stoch-value').textContent = `${stoch.k}/${stoch.d}`;
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = stoch.status;
        stochStatusEl.className = `tag ${stoch.class}`;

        document.getElementById('macd-status').textContent = macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${macd.class}`;
        document.getElementById('macd-hist').textContent = macd.hist;
        
        document.getElementById('bollinger-bands-status').textContent = bollingerBands.status;
        document.getElementById('atr-status').textContent = `${atr.value.toFixed(6)} (${atr.status})`;
        
        const psarStatusEl = document.getElementById('psar-status');
        psarStatusEl.textContent = psar.status;
        psarStatusEl.className = `font-mono font-semibold ${psar.status === 'Bullish' ? 'positive' : 'negative'}`;

        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${roc.value.toFixed(2)}% (${roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${roc.status === 'Positif' ? 'positive' : 'negative'}`;

        document.getElementById('linreg-status').textContent = linreg.status;

        document.getElementById('adx-value').textContent = adx.adx;
        document.getElementById('plus-di-value').textContent = adx.plusDI;
        document.getElementById('minus-di-value').textContent = adx.minusDI;

        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const formattedTime = candlePattern.timestamp ? new Date(candlePattern.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
        let biasClass = '';
        if (candlePattern.bias === 'BULLISH') biasClass = 'positive';
        if (candlePattern.bias === 'BEARISH') biasClass = 'negative';
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Pola Candlestick</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            ${candlePattern.svg}
            <p id="candlestick-pattern" class="font-semibold ${candlePattern.class}">${candlePattern.pattern}</p>
            ${candlePattern.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candlePattern.bias}</p>` : ''}
        `;
        
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${chartPattern.class}`;
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// --- BAGIAN UPGRADE: Fungsi untuk update data yang sifatnya periodik (API Polling) ---
    async function updatePeriodicData() {
        try {
            const binanceSymbol = analysisCache.binanceSymbol;
            if (!binanceSymbol || marketTypeSelect.value !== 'futures') return;

            console.log("Memperbarui data periodik (L/S Ratio)...");

            const [lsRatioUmumData, lsRatioTopData] = await Promise.all([
                 fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                 fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            ]);

            analysisCache.lsRatioUmumData = lsRatioUmumData;
            analysisCache.lsRatioTopData = lsRatioTopData;

            if (lsRatioUmumData?.[0]) {
                document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            }
            if (lsRatioTopData?.[0]) {
                document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
            }

        } catch(error) {
            console.error("Gagal memperbarui data periodik:", error);
        }
    }


    
// --- 3. API & CALCULATION ENGINES (ORIGINAL CODE) ---
    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
        const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Binance API error (${marketType}): ${errorData.msg || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from Binance ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari Binance ${marketType.toUpperCase()}.`);
        }
    }
// =======================================================
    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }
    // =======================================================
    async function fetchCoinGeckoData(coinId) {
        if (!coinId) return null;
        const url = `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) return null;
            return response.json();
        } catch (error) { return null; }
    }
// =======================================================
    async function fetchUsdToIdrRate() {
        try {
            const response = await fetch('https://api.frankfurter.app/latest?from=USD&to=IDR');
            if (!response.ok) return 16200;
            const data = await response.json();
            return (data && data.rates && data.rates.IDR) ? data.rates.IDR : 16200;
        } catch (error) { return 16200; }
    }
// =======================================================
    async function getCoinGeckoId(baseAssetSymbol) {
        if (!coinListCache) {
            const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
            if (!response.ok) throw new Error('Gagal unduh daftar koin CoinGecko.');
            coinListCache = await response.json();
        }
        const assetSymbolLower = baseAssetSymbol.toLowerCase();
        const priorityMap = {
            'btc': 'bitcoin', 'eth': 'ethereum', 'bnb': 'binancecoin', 'weth': 'wrapped-ether',
            'sol': 'solana', 'wbtc': 'wrapped-bitcoin', 'uni': 'uniswap', 'shib': 'shiba-inu',
            'pepe': 'pepe', 'cross': 'cross-2', 'ada': 'cardano', 'xrp': 'ripple', 'ava': 'avant-usd', 'ethw': 'ethereum-pow-iou',
            'avax': 'avalanche-2'
        };
        if (priorityMap[assetSymbolLower]) return priorityMap[assetSymbolLower];

        let match = coinListCache.find(coin => coin.symbol === assetSymbolLower);
        if (match) return match.id;

        console.log(`Simbol ${baseAssetSymbol} tidak ditemukan, mencoba pencarian cerdas...`);
        try {
            const searchResult = await fetchGeckoTerminal(`search/pools?query=${baseAssetSymbol}`);
            if (searchResult.data && searchResult.data.length > 0) {
                const topResult = searchResult.data[0];
                if (topResult.relationships.base_token.data.id) {
                    const coinId = topResult.relationships.base_token.data.id.split('_')[1];
                    if (coinId) return coinId;
                }
            }
        } catch (e) { console.error("Pencarian cerdas gagal:", e); }

        throw new Error(`Simbol "${baseAssetSymbol}" tidak ditemukan di CoinGecko.`);
    }
// =======================================================
    async function initializeExchangeInfo(marketType) {
        if (exchangeInfoCache[marketType]) return;
        const url = marketType === 'spot' ? 'https://api.binance.com/api/v3/exchangeInfo' : 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
        const data = await response.json();
        exchangeInfoCache[marketType] = data.symbols;
        if (document.getElementById('market-type-select').value === marketType) {
            populateAssetDatalist(data.symbols, marketType);
        }
    }
// =======================================================
    function populateAssetDatalist(symbols, marketType) {
        const dataList = document.getElementById('asset-list');
        if (!dataList) return;
        dataList.innerHTML = '';
        const filterFn = s => s.quoteAsset === 'USDT' && s.status === 'TRADING' && (marketType === 'spot' || s.contractType === 'PERPETUAL');
        symbols.filter(filterFn).sort((a, b) => a.symbol.localeCompare(b.symbol)).forEach(s => {
            const option = document.createElement('option');
            option.value = s.symbol;
            dataList.appendChild(option);
        });
    }
// =======================================================    
    async function validateBinanceSymbol(symbol, marketType) {
        if (!exchangeInfoCache[marketType]) await initializeExchangeInfo(marketType);
        const symbolData = exchangeInfoCache[marketType].find(s => s.symbol === symbol);
        if (!symbolData || symbolData.status !== 'TRADING') throw new Error(`Simbol "${symbol}" tidak valid atau tidak aktif di Binance ${marketType}.`);
    }
// =======================================================    
    async function callGemini(parts, isJsonOutput = true) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) throw new Error("API Key Google AI belum dimasukkan.");
        const model = 'gemini-2.5-flash-preview-05-20';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts }] };
        if (isJsonOutput) {
            payload.generationConfig = {
                "response_mime_type": "application/json",
                "max_output_tokens": 8192
            };
        }
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(`Google AI API error: ${errorBody?.error?.message || response.statusText}`);
        }
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
        throw new Error("Respons dari AI tidak valid atau kosong.");
    }

// =======================================================
    // == BLOK FUNGSI KALKULASI INDIKATOR BARU (MULAI) ==
// =======================================================
    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);

        const P = (high + low + close) / 3;
        const R1 = (2 * P) - low;
        const S1 = (2 * P) - high;
        const R2 = P + (high - low);
        const S2 = P - (high - low);
        const R3 = high + 2 * (P - low);
        const S3 = low - 2 * (high - P);

        return { P, R1, S1, R2, S2, R3, S3 };
    }
// =======================================================
    /**
     * Menghitung Keltner Channels.
     */
    function calculateKeltnerChannels(klines, period = 20, multiplier = 2, atrPeriod = 10) {
        if (!klines || klines.length < period) return { upper: [], middle: [], lower: [], width: [] };
        const closes = klines.map(k => parseFloat(k[4]));
        const emaMiddle = calculateEMA(closes, period);
        const atr = calculateATR(klines, atrPeriod).value; // Menggunakan fungsi ATR yang sudah ada

        const upper = emaMiddle.map(val => val !== undefined ? val + (atr * multiplier) : undefined);
        const lower = emaMiddle.map(val => val !== undefined ? val - (atr * multiplier) : undefined);
        const width = upper.map((u, i) => (u !== undefined && lower[i] !== undefined) ? u - lower[i] : undefined);
        
        return { upper, middle: emaMiddle, lower, width };
    }
    /**
     * Menghitung Ichimoku Cloud dengan logika yang diperbaiki dan standar.
     */
    // KODE BARU DENGAN LOGIKA STATUS YANG DISEMPURNAKAN
    function calculateIchimokuCloud(klines, tenkanP = 9, kijunP = 26, senkouP = 52) {
        if (klines.length < senkouP) return null;
        
        const result = { tenkan: [], kijun: [], senkouA: [], senkouB: [], chikou: [], status: 'Netral' };
        
        // ... (isi fungsi kalkulasi tenkan, kijun, dll. tetap sama seperti yang sudah ada di file Anda) ...
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= tenkanP - 1 ? getHighLow(klines.slice(i - tenkanP + 1, i + 1)) : { high: 0, low: 0 };
            result.tenkan.push(i >= tenkanP - 1 ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= kijunP - 1 ? getHighLow(klines.slice(i - kijunP + 1, i + 1)) : { high: 0, low: 0 };
            result.kijun.push(i >= kijunP - 1 ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
            result.chikou.push(parseFloat(klines[i][4]));
        }
        for (let i = 0; i < klines.length; i++) {
            const senkouA_val = (result.tenkan[i] !== undefined && result.kijun[i] !== undefined) ? (result.tenkan[i] + result.kijun[i]) / 2 : undefined;
            result.senkouA.push(senkouA_val);
            const senkouB_HighLow = i >= senkouP - 1 ? getHighLow(klines.slice(i - senkouP + 1, i + 1)) : { high: 0, low: 0 };
            result.senkouB.push(i >= senkouP - 1 ? (senkouB_HighLow.high + senkouB_HighLow.low) / 2 : undefined);
        }

        // --- LOGIKA STATUS BARU YANG LEBIH STANDAR DAN AKURAT ---
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = result.tenkan[result.tenkan.length - 1];
        const lastKijun = result.kijun[result.kijun.length - 1];
        
        // Cloud yang relevan untuk harga saat ini dihitung 26 periode lalu
        const currentSenkouA = result.senkouA[klines.length - 1 - kijunP];
        const currentSenkouB = result.senkouB[klines.length - 1 - kijunP];
        
        // Chikou Span (harga saat ini) dibandingkan dengan harga 26 periode lalu
        const pastPriceForChikou = parseFloat(klines[klines.length - 1 - kijunP][4]);

        // Kondisi Bullish: Harga > Awan, Tenkan > Kijun, Chikou > Harga Masa Lalu
        const isBullish = lastPrice > currentSenkouA && lastPrice > currentSenkouB &&
                        lastTenkan > lastKijun &&
                        lastPrice > pastPriceForChikou;

        // Kondisi Bearish: Harga < Awan, Tenkan < Kijun, Chikou < Harga Masa Lalu
        const isBearish = lastPrice < currentSenkouA && lastPrice < currentSenkouB &&
                        lastTenkan < lastKijun &&
                        lastPrice < pastPriceForChikou;

        if (isBullish) {
            result.status = "Bullish";
        } else if (isBearish) {
            result.status = "Bearish";
        }
        // Jika tidak memenuhi keduanya, status tetap "Netral"

        return result;
    }

    // =======================================================
    // == BLOK FUNGSI KALKULASI INDIKATOR BARU (SELESAI) ==
    // =======================================================
    // GANTI FUNGSI LAMA DENGAN VERSI BARU INI
    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A' };
        }

        // Kalkulasi TR (True Range) tetap sama
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
            trs.push(tr);
        }

        // Kalkulasi ATR tetap sama
        const atrValues = [];
        let sum = 0;
        for (let i = 0; i < trs.length; i++) {
            sum += trs[i];
            if (i >= period - 1) {
                if (i > period - 1) {
                    sum = sum - trs[i - period];
                }
                atrValues.push(sum / period);
            } else {
                atrValues.push(undefined);
            }
        }
        
        const atr = atrValues[atrValues.length - 1] || 0;

        // --- LOGIKA STATUS BARU BERDASARKAN PERSENTASE ---
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;

        let status;
        if (atrPercent > 5) {
            status = 'Sangat Tinggi';
        } else if (atrPercent > 2.5) {
            status = 'Tinggi';
        } else if (atrPercent < 1) {
            status = 'Rendah';
        } else {
            status = 'Normal';
        }
        // --- AKHIR LOGIKA BARU ---

        return { value: atr, status: status }; // Kembalikan status baru
    }

    const calculateEMA = (data, period) => {
        if (!data || data.length < period) return [];
        const k = 2 / (period + 1);
        let emaArray = Array(period - 1).fill(undefined);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        let currentEma = sum / period;
        emaArray.push(currentEma);
        for (let i = period; i < data.length; i++) {
            currentEma = (data[i] * k) + (currentEma * (1 - k));
            emaArray.push(currentEma);
        }
        return emaArray;
    };
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) return [];
        let sma = Array(period - 1).fill(undefined);
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            sma.push(slice.reduce((a, b) => a + b, 0) / period);
        }
        return sma;
    };
    const calculateRSI = (closes, period = userSettings.indicator.rsi_period) => {
        if (!closes || closes.length <= period) return Array(closes?.length || 0).fill(undefined);
        let gains = [], losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        if (avgLoss === 0) return Array(closes.length).fill(100);
        let rsi = [100 - (100 / (1 + (avgGain / avgLoss)))];
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            if (avgLoss === 0) { rsi.push(100); } 
            else { rsi.push(100 - (100 / (1 + (avgGain / avgLoss)))); }
        }
        return Array(period).fill(undefined).concat(rsi);
    };
    const calculateMACD = (closes, fast = userSettings.indicator.macd_fast, slow = userSettings.indicator.macd_slow, signal = userSettings.indicator.macd_signal) => {
        if (closes.length < slow + signal) {
            // Mengembalikan nilai default jika data tidak cukup
            return { status: 'Netral', hist: 'Netral', class: 'text-gray-500', macdLine: [], signalLine: [], histogram: [] };
        }
        
    const emaFast = calculateEMA(closes, fast);
    const emaSlow = calculateEMA(closes, slow);
        
    // Hitung garis MACD
    const macdLine = emaSlow.map((slowVal, i) => {
        if (slowVal !== undefined && emaFast[i] !== undefined) {
            return emaFast[i] - slowVal;
        }
            return undefined;
        });

    // Hitung garis Sinyal
        const signalLine = calculateEMA(macdLine.filter(v => v !== undefined), signal);

        // Hitung Histogram
        const histogram = macdLine.map((macdVal, i) => {
            // Sesuaikan indeks karena signalLine lebih pendek
            const signalIndex = i - (slow - 1); 
            if (macdVal !== undefined && signalLine[signalIndex] !== undefined) {
                const histValue = macdVal - signalLine[signalIndex];
                const prevHistValue = (i > 0 && macdLine[i-1] !== undefined && signalLine[signalIndex-1] !== undefined) 
                                    ? (macdLine[i-1] - signalLine[signalIndex-1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        });

        // Tentukan status terakhir untuk widget
        const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
        const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
        const lastHist = histogram.filter(v => v !== undefined).pop()?.value || 0;
        const prevMacdLine = macdLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        const prevSignalLine = signalLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        
        let status = 'Netral', macdClass = 'text-gray-500';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) { 
            status = 'Bullish Cross'; 
            macdClass = 'positive'; 
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) { 
            status = 'Bearish Cross'; 
            macdClass = 'negative'; 
        }
        
        return { 
            status, 
            hist: lastHist > 0 ? '(Naik)' : '(Turun)', 
            class: macdClass, 
            macdLine, 
            signalLine, 
            histogram 
        };
    };

    const calculateStochasticRSI = (closes, rsiPeriod = 14, stochPeriod = 14, kSmooth = 3, dSmooth = 3) => {
        const rsiValues = calculateRSI(closes, rsiPeriod).filter(v => v !== undefined);
        if (rsiValues.length < stochPeriod) {
            return { k: 50, d: 50, status: 'Netral', class: 'tag-gray', kLine: [], dLine: [], kOffset: 0, dOffset: 0 };
        }
        const stochArr = [];
        for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
            const window = rsiValues.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((rsiValues[i] - minR) / denom) * 100);
        }
        const kLine = calculateSMA(stochArr, kSmooth);
        const dLine = calculateSMA(kLine.filter(v => v !== undefined), dSmooth);
        const lastK = kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = dLine.filter(v => v !== undefined).pop() || 50;
        let status = 'Netral', stochClass = 'tag-yellow';
        if (lastK > 80 && lastD > 80) { status = 'Overbought'; stochClass = 'tag-red'; }
        else if (lastK < 20 && lastD < 20) { status = 'Oversold'; stochClass = 'tag-green'; }
        const kOffset = closes.length - kLine.length;
        const dOffset = closes.length - dLine.length;
        return {
            k: lastK.toFixed(2), d: lastD.toFixed(2), status, class: stochClass,
            kLine, dLine, kOffset, dOffset
        };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) return { upper: [], middle: [], lower: [], width: [], status: 'N/A' };
        const middle = calculateSMA(closes, period);
        let upper = Array(period - 1).fill(undefined);
        let lower = Array(period - 1).fill(undefined);
        let width = Array(period - 1).fill(undefined);

        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                width.push(undefined);
                continue;
            };
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            upper.push(middle[i] + (stdev * stdDev));
            lower.push(middle[i] - (stdev * stdDev));
            width.push((middle[i] + (stdev * stdDev)) - (middle[i] - (stdev * stdDev))); // KALKULASI LEBAR BANDS
        }

        const lastClose = closes[closes.length - 1];
        const lastUpper = upper.filter(v => v !== undefined).pop();
        const lastLower = lower.filter(v => v !== undefined).pop();
        const lastWidth = width.filter(v => v !== undefined).pop();

        let status = 'Dalam Band';
        if (lastClose > lastUpper) status = 'Di Atas Band';
        if (lastClose < lastLower) status = 'Di Bawah Band';

        // Tambahkan deteksi squeeze
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            const recentWidths = width.slice(-50);
            const minWidth = Math.min(...recentWidths);
            const avgWidth = recentWidths.reduce((a, b) => a + b, 0) / recentWidths.length;
            if (lastWidth < avgWidth * 0.7) { // 30% lebih kecil dari rata-rata 50 periode terakhir
                squeezeStatus = 'Squeeze!';
            }
        }

        return { upper, middle, lower, width, status, squeezeStatus }; // TAMBAHKAN 'width' dan 'squeezeStatus'
    };
    const calculateVPVR = (klines, numRows = 70, valueAreaPercent = 0.70) => {
        if (!klines || klines.length === 0) return { poc: 0, vah: 0, val: 0 };
        let overallLow = Infinity, overallHigh = -Infinity;
        const candles = klines.map(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]);
            if (high > overallHigh) overallHigh = high;
            if (low < overallLow) overallLow = low;
            return { high, low, volume: parseFloat(k[5]) };
        });
        const rowSize = (overallHigh - overallLow) / numRows;
        let profile = Array.from({ length: numRows }, (_, i) => ({ price: overallLow + (i * rowSize), volume: 0 }));
        let totalVolume = 0;
        candles.forEach(c => {
            totalVolume += c.volume;
            const startIdx = Math.max(0, Math.floor((c.low - overallLow) / rowSize));
            const endIdx = Math.min(numRows - 1, Math.floor((c.high - overallLow) / rowSize));
            const volPerRow = c.volume / (endIdx - startIdx + 1);
            for (let i = startIdx; i <= endIdx; i++) profile[i].volume += volPerRow;
        });
        if (totalVolume === 0) return { poc: 0, vah: 0, val: 0 };
        let pocIndex = profile.reduce((maxIdx, row, idx, arr) => row.volume > arr[maxIdx].volume ? idx : maxIdx, 0);
        const poc = profile[pocIndex].price + (rowSize / 2);
        const targetVolume = totalVolume * valueAreaPercent;
        let vaVolume = profile[pocIndex].volume;
        let upperIdx = pocIndex, lowerIdx = pocIndex;
        while (vaVolume < targetVolume) {
            const volAbove = (upperIdx + 1 < numRows) ? profile[upperIdx + 1].volume : -1;
            const volBelow = (lowerIdx - 1 >= 0) ? profile[lowerIdx - 1].volume : -1;
            if (volAbove === -1 && volBelow === -1) break;
            if (volAbove > volBelow) {
                upperIdx++;
                vaVolume += profile[upperIdx].volume;
            } else {
                lowerIdx--;
                vaVolume += profile[lowerIdx].volume;
            }
        }
        return { poc, vah: profile[upperIdx].price + rowSize, val: profile[lowerIdx].price };
    };
// =======================================================
    function CVDanalyze(klines, cvdData) {
        if (!klines || klines.length < 2 || !cvdData || cvdData.length < 2) {
        return { trend: 'N/A', divergence: 'N/A', summary: 'Data tidak cukup untuk analisa CVD.' };
        }

        // Determine price trend
        const firstPrice = parseFloat(klines[0][4]);
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const priceTrend = lastPrice > firstPrice ? 'Naik' : (lastPrice < firstPrice ? 'Turun' : 'Datar');

        // Determine CVD trend
        const firstCvd = cvdData[0].cvd;
        const lastCvd = cvdData[cvdData.length - 1].cvd;
        const cvdTrend = lastCvd > firstCvd ? 'Naik' : (lastCvd < firstCvd ? 'Turun' : 'Datar');

        // Detect divergence
        let divergence = 'Tidak Ada';
        let summary = `Tren harga dan CVD bergerak selaras (${priceTrend}).`;

            if (priceTrend === 'Naik' && cvdTrend === 'Turun') {
                divergence = 'Bearish 👎';
                summary = 'Harga naik tetapi tekanan beli melemah. Hati-hati, ini adalah sinyal divergensi bearish.';
            } else if (priceTrend === 'Turun' && cvdTrend === 'Naik') {
                divergence = 'Bullish 👍';
                summary = 'Harga turun tetapi tekanan beli menguat. Ini adalah sinyal divergensi bullish yang potensial.';
            }

            return {
                trend: cvdTrend,
                divergence: divergence,
                summary: summary
            };
    }
    // GANTI FUNGSI LAMA DENGAN INI
    const calculateCVD = (trades) => {
        let cumulativeDeltaCoin = 0;
        let cumulativeDeltaUsdt = 0;
        return trades.map(t => {
            const quantity = parseFloat(t.q);
            const price = parseFloat(t.p);
            const sign = t.m ? -1 : 1; // -1 untuk sell, 1 untuk buy
            
            cumulativeDeltaCoin += quantity * sign;
            cumulativeDeltaUsdt += (quantity * price) * sign;

            return { 
                time: t.T / 1000, 
                cvd_coin: cumulativeDeltaCoin,
                cvd_usdt: cumulativeDeltaUsdt 
            };
        });
    };

    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { adx: 'N/A', plusDI: 'N/A', minusDI: 'N/A' };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { adx: adxValues.filter(v=>v!==undefined).pop()?.toFixed(2) || 'N/A', plusDI: plusDIs.pop()?.toFixed(2) || 'N/A', minusDI: minusDIs.pop()?.toFixed(2) || 'N/A' };
    };
    
    const findCandlestickPatterns = (klines) => {        
        if (!klines || klines.length < 3) {            
            return { pattern: 'TIDAK ADA', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: null };
        }
               
        const lastCandleTimestamp = klines[klines.length - 1][0];
        const getCandleDetails = (k) => {
            const [open, high, low, close] = k.slice(1, 5).map(parseFloat);
            return { open, high, low, close, body: Math.abs(close - open), isGreen: close > open, isRed: close < open };
        };

        const c1 = getCandleDetails(klines[klines.length - 1]); // Paling Baru
        const c2 = getCandleDetails(klines[klines.length - 2]);
        const c3 = getCandleDetails(klines[klines.length - 3]);

        
        let result = { pattern: 'TIDAK ADA', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: lastCandleTimestamp };

        // Cek Pola 3-Candle
        if (c3.isGreen && c2.isGreen && c1.isGreen && c1.close > c2.close && c2.close > c3.close) {
            result = { pattern: 'THREE WHITE SOLDIERS', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('THREE_WHITE_SOLDIERS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.isRed && c1.isRed && c1.close < c2.close && c2.close < c3.close) {
            result = { pattern: 'THREE BLACK CROWS', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('THREE_BLACK_CROWS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.body < c3.body * 0.3 && c1.isGreen && c1.close > c3.open) {
            result = { pattern: 'MORNING STAR', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('MORNING_STAR'), timestamp: lastCandleTimestamp };
        } else if (c3.isGreen && c2.body < c3.body * 0.3 && c1.isRed && c1.close < c3.open) {
            result = { pattern: 'EVENING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('EVENING_STAR'), timestamp: lastCandleTimestamp };
        }

        // Jika belum ketemu, cek Pola 2-Candle
        if (result.pattern === 'TIDAK ADA') {
            if (c2.isRed && c1.isGreen && c1.close > c2.open && c1.open < c2.close) {
                result = { pattern: 'BULLISH ENGULFING', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.close < c2.open && c1.open > c2.close) {
                result = { pattern: 'BEARISH ENGULFING', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.close && c1.close < c2.open && c1.close > (c2.open + c2.body/2)) {
                result = { pattern: 'DARK CLOUD COVER', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('DARK_CLOUD_COVER'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.close && c1.close > c2.open && c1.close < (c2.open - c2.body/2)) {
                result = { pattern: 'PIERCING LINE', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('PIERCING_LINE'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close) {
                result = { pattern: 'BEARISH HARAMI', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close) {
                result = { pattern: 'BULLISH HARAMI', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.high - c2.high) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER TOP', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('TWEEZER_TOP'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.low - c2.low) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER BOTTOM', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('TWEEZER_BOTTOM'), timestamp: lastCandleTimestamp };
            }
        }

        // Jika masih belum ketemu, cek Pola 1-Candle
        if (result.pattern === 'TIDAK ADA') {
            const lowerWick = Math.min(c1.open, c1.close) - c1.low;
            const upperWick = c1.high - Math.max(c1.open, c1.close);
            if (lowerWick > c1.body * 2 && upperWick < c1.body * 0.5) {
                result = { pattern: 'HAMMER', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('HAMMER'), timestamp: lastCandleTimestamp };
            } else if (upperWick > c1.body * 2 && lowerWick < c1.body * 0.5) {
                result = { pattern: 'SHOOTING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('SHOOTING_STAR'), timestamp: lastCandleTimestamp };
            }
        }
        
        return result;
    };
    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'TIDAK ADA', class: 'text-gray-500' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPeaks = (data, isHigh) => {
            let peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    peaks.push({ index: i, value: data[i] });
                }
            }
            return peaks;
        };
        const priceLows = findPeaks(recentCloses, false), priceHighs = findPeaks(recentCloses, true);
        const rsiLows = findPeaks(recentRSI, false), rsiHighs = findPeaks(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'TIDAK ADA', class: 'text-gray-500' };
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'TIDAK ADA', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'TIDAK ADA', class: 'text-gray-500' };
    };
// =======================================================    
    function getPatternSVG(patternName) {
        // Pengaturan dasar untuk semua SVG
        const svgHeader = `<svg viewBox="0 0 110 60" class="w-24 h-auto mx-auto my-2">`;
        const svgFooter = `</svg>`;
        const green = '#26a69a', red = '#ef5350', gray = '#2A1E27';

        let content = '';

        // Logika untuk membuat satu candle
        const createCandle = (x, open, high, low, close, color) => {
            const bodyY = Math.min(open, close);
            const bodyHeight = Math.abs(open - close);
            return `
                <line x1="${x+10}" y1="${high}" x2="${x+10}" y2="${low}" stroke="${color}" stroke-width="1"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" fill="${color}"/>
            `;
        };

        switch(patternName) {
            // --- POLA BULLISH ---
            case 'BULLISH_ENGULFING':
                content = createCandle(20, 40, 45, 25, 30, red) + createCandle(50, 28, 55, 10, 50, green);
                break;
            case 'HAMMER':
                content = createCandle(40, 50, 52, 10, 48, red);
                break;
            case 'MORNING_STAR':
                content = createCandle(10, 50, 55, 15, 20, red) + createCandle(40, 15, 20, 5, 12, gray) + createCandle(70, 18, 50, 15, 45, green);
                break;
            case 'THREE_WHITE_SOLDIERS':
                content = createCandle(10, 25, 35, 10, 30, green) + createCandle(40, 32, 45, 28, 40, green) + createCandle(70, 42, 55, 38, 50, green);
                break;
            case 'BULLISH_HARAMI':
                content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                break;
            case 'TWEEZER_BOTTOM':
                content = createCandle(20, 40, 45, 10, 20, red) + createCandle(50, 22, 48, 10, 35, green);
                break;
            // --- POLA BEARISH ---
            case 'BEARISH_ENGULFING':
                content = createCandle(20, 20, 45, 15, 40, green) + createCandle(50, 42, 55, 10, 15, red);
                break;
            case 'SHOOTING_STAR':
                content = createCandle(40, 12, 50, 10, 15, green);
                break;
            case 'EVENING_STAR':
                content = createCandle(10, 15, 50, 10, 45, green) + createCandle(40, 52, 58, 48, 50, gray) + createCandle(70, 48, 50, 15, 20, red);
                break;
            case 'THREE_BLACK_CROWS':
                content = createCandle(10, 50, 55, 30, 45, red) + createCandle(40, 42, 48, 20, 25, red) + createCandle(70, 22, 28, 5, 10, red);
                break;
            case 'BEARISH_HARAMI':
                content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                break;
            case 'TWEEZER_TOP':
                content = createCandle(20, 20, 55, 15, 40, green) + createCandle(50, 38, 55, 18, 25, red);
                break;
            default:
                return ''; // Tidak ada SVG untuk pola ini
        }

        return svgHeader + content + svgFooter;
    }
// =======================================================
    function getTimeAgo(date) {
        if (!(date instanceof Date) || isNaN(date)) {
            return 'beberapa saat lalu'; // Fallback jika tanggal tidak valid
        }
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 0) return 'baru saja'; // Handle jika ada sedikit perbedaan waktu
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " tahun lalu";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " bulan lalu";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " hari lalu";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " jam lalu";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " menit lalu";
        return Math.floor(seconds) + " detik lalu";
    }

// =======================================================
    function getExplorerUrl(networkName) {
        const explorerMap = {
            'eth': 'https://etherscan.io', // Perbaikan untuk Ethereum
            'ethereum': 'https://etherscan.io',
            'solana': 'https://solscan.io',
            'bsc': 'https://bscscan.com',
            'arbitrum': 'https://arbiscan.io',
            'base': 'https://basescan.org'
        };
        const baseUrl = explorerMap[networkName] || `https://${networkName}.info`;
        // Kembalikan URL terpisah untuk dompet dan transaksi
        return {
            address: `${baseUrl}/address/`,
            tx: `${baseUrl}/tx/`
        };
    }
// =======================================================
    function getHolderCategory(usdValue) {
        if (usdValue >= 500000) return { name: 'Humpback', class: 'text-purple-400' };
        if (usdValue >= 100000) return { name: 'Whale', class: 'text-blue-400' };
        if (usdValue >= 50000) return { name: 'Tuna', class: 'text-teal-400' };
        if (usdValue >= 10000) return { name: 'Dolphin', class: 'text-cyan-400' };
        if (usdValue >= 1000) return { name: 'Crab', class: 'text-yellow-400' };
        return { name: 'Shrimp', class: 'text-gray-400' };
    }
// =======================================================
    // == BLOK FUNGSI BARU UNTUK DETEKSI POLA CHART (MULAI) ==
    // =======================================================

    /**
     * Mencari titik-titik pivot (puncak dan lembah) pada data klines.
     */
    function findPivots(klines, lookback = 10) {
        const pivots = [];
        if (klines.length < lookback * 2 + 1) return [];

        for (let i = lookback; i < klines.length - lookback; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            let isHigh = true, isLow = true;

            for (let j = 1; j <= lookback; j++) {
                if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
            }
            if (isHigh) pivots.push({ type: 'high', price: high, index: i });
            else if (isLow) pivots.push({ type: 'low', price: low, index: i });
        }
        return pivots;
    }
    
    /**
     * Fungsi bantuan untuk menghitung kemiringan (slope) antara dua titik pivot.
     */
    function calculateSlope(p1, p2) {
        if (p2.index === p1.index) return Infinity; // Garis vertikal
        return (p2.price - p1.price) / (p2.index - p1.index);
    }
    
    /**
     * Mendeteksi pola klasik: Head and Shoulders (Bearish) & Inverse H&S (Bullish).
     */
    function detectHeadAndShoulders(pivots) {
        for (let i = 4; i < pivots.length; i++) {
            // Cek Head & Shoulders (Bearish): H, L, H, L, H
            const p1 = pivots[i-4], p2 = pivots[i-3], p3 = pivots[i-2], p4 = pivots[i-1], p5 = pivots[i];
            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high' && p4.type === 'low' && p5.type === 'high') {
                if (p3.price > p1.price && p3.price > p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'HEAD & SHOULDERS', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Inverse Head & Shoulders (Bullish): L, H, L, H, L
            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low' && p4.type === 'high' && p5.type === 'low') {
                 if (p3.price < p1.price && p3.price < p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'INVERSE H&S', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

    /**
     * Mendeteksi pola klasik: Double Top (Bearish) & Double Bottom (Bullish).
     */
    function detectDoubles(pivots) {
        for (let i = 2; i < pivots.length; i++) {
            // Cek Double Top: H, L, H
            const p1_dt = pivots[i-2], p2_dt = pivots[i-1], p3_dt = pivots[i];
            if (p1_dt.type === 'high' && p2_dt.type === 'low' && p3_dt.type === 'high') {
                if (Math.abs(p1_dt.price - p3_dt.price) / p3_dt.price < 0.03 && p2_dt.price < p1_dt.price) {
                    return { pattern: 'DOUBLE TOP', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Double Bottom: L, H, L
            const p1_db = pivots[i-2], p2_db = pivots[i-1], p3_db = pivots[i];
            if (p1_db.type === 'low' && p2_db.type === 'high' && p3_db.type === 'low') {
                if (Math.abs(p1_db.price - p3_db.price) / p3_db.price < 0.03 && p2_db.price > p1_db.price) {
                    return { pattern: 'DOUBLE BOTTOM', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

    /**
     * Mendeteksi pola segitiga: Ascending, Descending, & Symmetrical.
     */
    function detectTriangles(pivots) {
        const recentPivots = pivots.slice(-7); // Fokus pada 7 pivot terakhir
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lastLow = lows[lows.length - 1], prevLow = lows[lows.length - 2];
            const lastHigh = highs[highs.length - 1], prevHigh = highs[highs.length - 2];

            const isLowsAscending = lastLow.price > prevLow.price;
            const isHighsFlat = Math.abs(lastHigh.price - prevHigh.price) / prevHigh.price < 0.015; // Toleransi 1.5%
            if (isLowsAscending && isHighsFlat) return { pattern: 'ASCENDING TRIANGLE', class: 'positive' };

            const isHighsDescending = lastHigh.price < prevHigh.price;
            const isLowsFlat = Math.abs(lastLow.price - prevLow.price) / prevLow.price < 0.015; // Toleransi 1.5%
            if (isHighsDescending && isLowsFlat) return { pattern: 'DESCENDING TRIANGLE', class: 'negative' };

            if (isLowsAscending && isHighsDescending) return { pattern: 'SYMMETRICAL TRIANGLE', class: 'text-yellow-400' };
        }
        return null;
    }
    
    /**
     * Mendeteksi pola baji: Rising Wedge (Bearish) & Falling Wedge (Bullish).
     */
    function detectWedges(pivots) {
        const recentPivots = pivots.slice(-7);
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lowSlope = calculateSlope(lows[lows.length - 2], lows[lows.length - 1]);
            const highSlope = calculateSlope(highs[highs.length - 2], highs[highs.length - 1]);

            // Rising Wedge: Kedua garis miring ke atas, garis bawah lebih curam.
            if (lowSlope > 0 && highSlope > 0 && lowSlope > highSlope) {
                 return { pattern: 'RISING WEDGE', class: 'negative blinking-text-animation' };
            }
            // Falling Wedge: Kedua garis miring ke bawah, garis atas lebih curam (nilai absolutnya).
            if (lowSlope < 0 && highSlope < 0 && Math.abs(highSlope) > Math.abs(lowSlope)) {
                return { pattern: 'FALLING WEDGE', class: 'positive blinking-text-animation' };
            }
        }
        return null;
    }

    /**
     * Mendeteksi pola bendera: Bull Flag (Bullish) & Bear Flag (Bearish).
     */
    function detectFlags(klines) {
        // Logika ini disederhanakan untuk deteksi cepat
        const lookback = 30; // Jarak untuk mencari "tiang"
        const flagLength = 10; // Panjang "bendera"
        if (klines.length < lookback + flagLength) return null;
        
        const closes = klines.map(k => parseFloat(k[4]));
        const poleStartPrice = closes[closes.length - flagLength - lookback];
        const poleEndPrice = closes[closes.length - flagLength];
        const priceChange = (poleEndPrice - poleStartPrice) / poleStartPrice;
        
        // Bull Flag: Tiang naik tajam (>5%), diikuti konsolidasi
        if (priceChange > 0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            // Konsolidasi harus berada di bagian atas tiang
            if (flagLow > poleStartPrice + (poleEndPrice - poleStartPrice) * 0.5) {
                return { pattern: 'BULL FLAG', class: 'positive' };
            }
        }
        // Bear Flag: Tiang turun tajam (<-5%), diikuti konsolidasi
        if (priceChange < -0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            // Konsolidasi harus berada di bagian bawah tiang
            if (flagHigh < poleStartPrice - (poleStartPrice - poleEndPrice) * 0.5) {
                return { pattern: 'BEAR FLAG', class: 'negative' };
            }
        }
        return null;
    }

    /**
     * FUNGSI UTAMA BARU: Mengatur pemanggilan semua fungsi deteksi pola.
     */
    function findChartPatterns(klines) {
        if (!klines || klines.length < 50) {
            return { pattern: 'Data Kurang', class: 'text-gray-500' };
        }
        
        const pivots = findPivots(klines, 10);
        let pattern;
            
        // Urutkan dari pola yang paling signifikan atau kompleks
        pattern = detectHeadAndShoulders(pivots);
        if (pattern) return pattern;

        pattern = detectDoubles(pivots);
        if (pattern) return pattern;
        
        pattern = detectWedges(pivots);
        if (pattern) return pattern;

        pattern = detectTriangles(pivots);
        if (pattern) return pattern;

        pattern = detectFlags(klines);
        if (pattern) return pattern;

        return { pattern: 'Tidak Terdeteksi', class: 'text-gray-500' };
    }
// =======================================================
// == BLOK FUNGSI BARU UNTUK DETEKSI POLA CHART (SELESAI) ==
// === TAMBAHKAN DUA FUNGSI BANTUAN BARU DI BAWAH INI ===
    /**
     * Menemukan titik-titik swing terakhir (Low-High-Low untuk uptrend, High-Low-High untuk downtrend)
     * untuk kalkulasi Fibonacci.
     */
    function findLastSignificantSwing(klines) {
        const pivots = findPivots(klines.slice(-100), 5); // Analisa 100 candle terakhir
        if (pivots.length < 3) return null;

        const lastPivot = pivots[pivots.length - 1];
        const prevPivot = pivots[pivots.length - 2];
        const prevPrevPivot = pivots[pivots.length - 3];

        // Swing untuk potensi LONG (kita mencari titik A, B, C: Low -> High -> Low)
        if (lastPivot.type === 'low' && prevPivot.type === 'high' && prevPrevPivot.type === 'low') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'UP' };
        }
        // Swing untuk potensi SHORT (kita mencari titik A, B, C: High -> Low -> High)
        if (lastPivot.type === 'high' && prevPivot.type === 'low' && prevPrevPivot.type === 'high') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'DOWN' };
        }
        return null;
    }

    /**
     * Menghitung target Fibonacci Extension 1.618.
     */
    function calculateFibonacciExtension(swing) {
        if (!swing) return null;
        const impulseMove = Math.abs(swing.B.price - swing.A.price);
        if (swing.type === 'UP') {
            return swing.C.price + (impulseMove * 1.618);
        } else { // DOWN
            return swing.C.price - (impulseMove * 1.618);
        }
    }
    
// =======================================================    
    function calculateAndDisplayScalpingSetup() {
        const { klines, calculatedData } = analysisCache;
        if (!klines || klines.length < 50 || !calculatedData) {
            document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Data tidak cukup untuk setup scalping.</p>';
            return;
        }

        const container = document.getElementById('scalping-setup-content');
        document.getElementById('scalping-timeframe-display').textContent = timeframeSelect.value;
        const closes = klines.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        
        // 1. Tentukan Bias Sesaat (EMA 9 vs EMA 21)
        const ema9 = calculateEMA(closes, 9).pop();
        const ema21 = calculateEMA(closes, 21).pop();
        const bias = ema9 > ema21 ? 'LONG' : 'SHORT';

        // 2. Kalkulasi Stop Loss & TP 1 berdasarkan ATR & R:R
        const atrValue = calculatedData.atr.value;
        if (atrValue === 0) {
            container.innerHTML = '<p class="text-sm text-gray-500">Volatilitas terlalu rendah untuk menghitung setup.</p>';
            return;
        }
        const slMultiplier = 1.5;
        const tp1Multiplier = 1.5; // R:R 1:1.5 untuk TP1
        const stopLoss = bias === 'LONG' ? lastPrice - (atrValue * slMultiplier) : lastPrice + (atrValue * slMultiplier);
        const takeProfit1 = bias === 'LONG' ? lastPrice + (atrValue * tp1Multiplier) : lastPrice - (atrValue * tp1Multiplier);

        // 3. Kalkulasi TP2 & TP3
        const pivots = findPivots(klines, 5);
        const lastSwing = findLastSignificantSwing(klines);
        let takeProfit2 = 'N/A', takeProfit3 = 'N/A';

        if (bias === 'LONG') {
            const atrTarget2 = lastPrice + (atrValue * 3.0); // R:R 1:2
            const pivotTarget = pivots.filter(p => p.type === 'high' && p.price > takeProfit1).map(p => p.price).sort((a, b) => a - b)[0];
            takeProfit2 = pivotTarget ? Math.min(atrTarget2, pivotTarget) : atrTarget2;
            const fibTarget = calculateFibonacciExtension(lastSwing);
            if (fibTarget && fibTarget > takeProfit2) takeProfit3 = fibTarget;

        } else if (bias === 'SHORT') {
            const atrTarget2 = lastPrice - (atrValue * 3.0); // R:R 1:2
            const pivotTarget = pivots.filter(p => p.type === 'low' && p.price < takeProfit1).map(p => p.price).sort((a, b) => b - a)[0];
            takeProfit2 = pivotTarget ? Math.max(atrTarget2, pivotTarget) : atrTarget2;
            const fibTarget = calculateFibonacciExtension(lastSwing);
            if (fibTarget && fibTarget < takeProfit2) takeProfit3 = fibTarget;
        }
        
        // --- [BARU] FUNGSI BANTUAN UNTUK MENGHITUNG PERSENTASE ---
        const calculatePercentage = (targetPrice, entryPrice) => {
            if (typeof targetPrice !== 'number' || entryPrice === 0) return '';
            const percentage = ((targetPrice - entryPrice) / entryPrice) * 100;
            return `(${percentage.toFixed(2)}%)`;
        };

        // --- [BARU] Hitung semua persentase ---
        const slPercent = calculatePercentage(stopLoss, lastPrice);
        const tp1Percent = calculatePercentage(takeProfit1, lastPrice);
        const tp2Percent = calculatePercentage(takeProfit2, lastPrice);
        const tp3Percent = calculatePercentage(takeProfit3, lastPrice);
        
        // --- Tampilan UI yang Diperbarui ---
        const biasClass = bias === 'LONG' ? 'positive' : 'negative';
        const tpColorClass = bias === 'LONG' ? 'positive' : 'negative'; // Untuk SHORT, TP lebih rendah dari entri, jadi warnanya harus 'negative' jika ingin konsisten, atau 'positive' jika ingin menandakan profit. Kita gunakan 'positive' untuk profit.
        const slColorClass = 'negative'; // SL selalu negatif

        // Logika tampilan untuk TP2 dan TP3 jika 'N/A'
        const tp2Display = takeProfit2 !== 'N/A' ? `${formatPrice(takeProfit2)}<br><span class="text-xs font-mono positive">${tp2Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';
        const tp3Display = takeProfit3 !== 'N/A' ? `${formatPrice(takeProfit3)}<br><span class="text-xs font-mono positive">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';

        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">Bias Sesaat</p>
                    <p class="font-bold text-2xl ${biasClass}">${bias}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">Saran Entri</p>
                    <p class="font-semibold text-lg text-gray-800 dark:text-gray-200">${formatPrice(lastPrice)}</p>
                </div>
                <div>
                    <p class="text-sm text-gray-500">SL (ATR x${slMultiplier})</p>
                    <p class="font-semibold text-lg ${slColorClass}">${formatPrice(stopLoss)}</p>
                    <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">TP 1 (R:R 1:1.5)</p>
                    <p class="font-semibold positive">${formatPrice(takeProfit1)}</p>
                    <p class="text-xs font-mono positive">${tp1Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 2 (Pivot/R:R)</p>
                    <p class="font-semibold positive">${tp2Display}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 3 (Fibonacci)</p>
                    <p class="font-semibold positive">${tp3Display}</p>
                </div>
            </div>
        `;
    }
    // =======================================================
    /**
     * Fungsi baru untuk menghitung ATR dalam bentuk persentase.
     */
    function calculateATRPercentage(klines, period = 14) {
        if (!klines || klines.length === 0) {
            return 0; // Kembalikan 0 jika tidak ada data
        }
        
        // Panggil fungsi ATR yang sudah ada
        const atrResult = calculateATR(klines, period);
        const atrValue = atrResult.value;

        // Ambil harga penutupan terakhir
        const lastClose = parseFloat(klines[klines.length - 1][4]);

        if (lastClose === 0) {
            return 0; // Hindari pembagian dengan nol
        }

        // Hitung dan kembalikan dalam bentuk persen
        const atrPercent = (atrValue / lastClose) * 100;
        
        return atrPercent;
    }
// =======================================================
    async function fetchGeckoTerminal(endpoint) {
        const baseUrl = 'https://api.geckoterminal.com/api/v2';
        const url = `${baseUrl}/${endpoint}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GeckoTerminal API error: ${errorData.errors?.[0]?.title || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from GeckoTerminal ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari GeckoTerminal.`);
        }
    }
// =======================================================
    function renderTrendingPools(poolsData) {
        let html = '';
        const topPools = poolsData.slice(0, 5); // Ambil 5 teratas

        topPools.forEach(pool => {
            const attributes = pool.attributes;
            const priceChange = parseFloat(attributes.price_change_percentage.h24);
            const colorClass = priceChange >= 0 ? 'positive' : 'negative';
            const volume = parseFloat(attributes.volume_usd.h24);

            html += `
                <div class="p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                    <div class="flex justify-between items-center font-semibold">
                        <span>${attributes.name}</span>
                        <span class="${colorClass}">${priceChange.toFixed(2)}%</span>
                    </div>
                    <div class="text-xs text-gray-400 flex justify-between mt-1">
                        <span>Vol 24j: $${(volume / 1_000_000).toFixed(2)}jt</span>
                        <span>Jaringan: ${pool.relationships.network.data.id}</span>
                    </div>
                </div>
            `;
        });
        trendingPoolsContent.innerHTML = html;
    }
// =======================================================
// =======================================================
async function runFullAnalysis() {
    WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
    WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
    WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));
    
    orderBookDOMElements = null;
    topMoversSection.classList.add('hidden');
    hideError();
    showLoader(true, 'Memulai Analisa...');
    WebSocketManager.resetSubscriptions();
    destroyCharts();

    specificTokenTitle.innerHTML = 'Analisis Token Spesifik';
    specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Mencari data on-chain...</p>`;
    trendingPoolsContent.innerHTML = `<div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div>`;
    
    try {
        const aiContentContainer = document.getElementById('ai-content-container');
        if (aiContentContainer) {
            aiContentContainer.classList.add('hidden');
        }
        const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
        if (comprehensiveBtn) {
            const btnText = comprehensiveBtn.querySelector('span');
            const btnLoader = comprehensiveBtn.querySelector('.loader');
            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            comprehensiveBtn.disabled = false;
        }
        const binanceSymbol = assetInput.value.trim().toUpperCase();
        const correlationAsset = document.getElementById('correlation-asset-input').value.trim().toUpperCase() || 'BTCUSDT';
        const marketType = marketTypeSelect.value;
        const selectedTimeframe = timeframeSelect.value;
        
        await validateBinanceSymbol(binanceSymbol, marketType);

        let klines;
        const cachedItem = klineCache[binanceSymbol + selectedTimeframe];
        if (cachedItem && (Date.now() - cachedItem.timestamp < KLINE_CACHE_DURATION)) {
            console.log(`Menggunakan Klines dari Cache untuk ${binanceSymbol}`);
            klines = cachedItem.data;
            showLoader(true, 'Menggunakan data dari cache...');
        } else {
            console.log(`Mengambil Klines dari API untuk ${binanceSymbol}`);
            showLoader(true, 'Mengambil data candle...');
            klines = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: selectedTimeframe, limit: 500 }, marketType);
            klineCache[binanceSymbol + selectedTimeframe] = { data: klines, timestamp: Date.now() };
        }

        const baseAsset = binanceSymbol.replace(/USDT$|^\d+/g, '');
        let coinGeckoId;
        try {
            coinGeckoId = await getCoinGeckoId(baseAsset);
        } catch (e) {
            console.warn(`Gagal mendapatkan CoinGecko ID untuk ${baseAsset}: ${e.message}`);
        }

        showLoader(true, 'Mengambil data pasar lainnya...');
        const promises = [
            fetchBinanceAPIData('ticker/24hr', { symbol: binanceSymbol }, marketType),
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 30 }, marketType),
            fetchBinanceAPIData('klines', { symbol: correlationAsset, interval: '1d', limit: 30 }, 'spot'),
            fetchBinanceAPIData('depth', { symbol: binanceSymbol, limit: 100 }, marketType),
            fetchUsdToIdrRate(),
            fetch('https://api.coingecko.com/api/v3/global').then(res => res.json()),
            coinGeckoId ? fetchCoinGeckoData(coinGeckoId) : Promise.resolve(null)
        ];

        if (marketType === 'futures') {
            promises.push(
                fetchBinanceAPIData('openInterest', { symbol: binanceSymbol }, 'futures'),
                fetchBinanceAPIData('premiumIndex', { symbol: binanceSymbol }, 'futures'),
                fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            );
        }

        const promiseResults = await Promise.all(promises);

        const [
            tickerData, assetDailyKlines, btcDailyKlines,
            orderBookData, usdToIdrRate, globalData, coinGeckoData,
            ...futuresData
        ] = promiseResults;

        let openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData;
        if (marketType === 'futures') {
            [openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData] = futuresData;
        }

        let correlationValue = null;
        if (binanceSymbol !== 'BTCUSDT' && assetDailyKlines && btcDailyKlines && assetDailyKlines.length === btcDailyKlines.length) {
            const assetCloses = assetDailyKlines.map(k => parseFloat(k[4]));
            const btcCloses = btcDailyKlines.map(k => parseFloat(k[4]));
            correlationValue = calculateCorrelation(assetCloses, btcCloses);
        }

        analysisCache = {
            tickerData, klines, orderBookData, usdToIdrRate, globalData, coinGeckoData,
            openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData,
            binanceSymbol, selectedTimeframe, correlationData: correlationValue
        };

        showLoader(true, 'Menghitung indikator...');

        const allTrades = await fetchBinanceAPIData('aggTrades', { symbol: binanceSymbol, limit: 1000 }, marketType);
        const cvdData = calculateCVD(allTrades);
        analysisCache.cvdData = cvdData;

        const closes = klines.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        const rsiValues = calculateRSI(closes);
        const ema21Values = calculateEMA(closes, 21);
        const ema50Values = calculateEMA(closes, 50);
        const lastEma21 = ema21Values.filter(v => v !== undefined).pop();
        const lastEma50 = ema50Values.filter(v => v !== undefined).pop();

        let trendStatus = 'Netral';
        let trendClass = 'text-yellow-400';
        if (lastEma21 > lastEma50) {
            if (lastPrice > lastEma21) {
                trendStatus = 'Uptrend Kuat';
                trendClass = 'positive';
            } else {
                trendStatus = 'Koreksi dalam Uptrend';
                trendClass = 'text-yellow-400';
            }
        } else if (lastEma50 > lastEma21) {
            if (lastPrice < lastEma21) {
                trendStatus = 'Downtrend Kuat';
                trendClass = 'negative';
            } else {
                trendStatus = 'Reli dalam Downtrend';
                trendClass = 'text-yellow-400';
            }
        }
        
        const pivotPoints = calculatePivotPoints(assetDailyKlines[assetDailyKlines.length - 2]);
        const ichimoku = calculateIchimokuCloud(klines);
        const keltnerChannels = calculateKeltnerChannels(klines);
        const activeMode = document.querySelector('.vwap-mode-btn.active')?.dataset.mode || 'rolling';
        const vwapValue = calculateVWAP(klines, activeMode);
        const vwapStatus = lastPrice > vwapValue ? 'Bullish' : 'Bearish';

        analysisCache.calculatedData = {
            adx: calculateADX(klines), 
            cvd: CVDanalyze(klines, cvdData), 
            vpvr: calculateVPVR(klines),
            ma: { status: trendStatus, class: trendClass, value21: lastEma21, value50: lastEma50 },
            rsi: { values: rsiValues, last: rsiValues.filter(v => v !== undefined).pop()?.toFixed(2) || 50, status: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'Overbought' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'Oversold' : 'Netral'), class: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'tag-red' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'tag-green' : 'tag-yellow') },
            rsiDivergence: detectRSIDivergence(closes, rsiValues), 
            obvDivergence: detectOBVDivergence(closes, klines),
            stoch: calculateStochasticRSI(closes), 
            macd: calculateMACD(closes),
            bollingerBands: calculateBollingerBands(closes), 
            atr: calculateATR(klines),
            atrPercent: calculateATRPercentage(klines), 
            candlePattern: findCandlestickPatterns(klines),
            chartPattern: findChartPatterns(klines), 
            roc: calculateROC(closes), 
            psar: calculateParabolicSAR(klines), 
            linreg: calculateLinearRegressionChannel(closes),
            vwap: { status: vwapStatus, value: vwapValue },
            pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
            ichimoku: { status: ichimoku?.status || 'Netral', data: ichimoku },
            keltnerChannels: keltnerChannels,
            fundingRate: analysisCache.fundingRateData,
            lsRatio: analysisCache.lsRatioUmumData?.[0],
            openInterest: { status: (analysisCache.openInterestData?.openInterest > 0 && parseFloat(analysisCache.tickerData.priceChangePercent) > 0) ? 'Bullish' : (analysisCache.openInterestData?.openInterest > 0 && parseFloat(analysisCache.tickerData.priceChangePercent) < 0) ? 'Bearish' : 'Netral' }
        };

        const bbPriceAction = analyzeBollingerBandsPriceAction(klines, analysisCache.calculatedData.bollingerBands);
        analysisCache.calculatedData.bollingerBands.rejection = bbPriceAction.rejection;
        analysisCache.calculatedData.bollingerBands.walkTheBands = bbPriceAction.walkTheBands;
        const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
        analysisCache.tfAlignmentSummary = tfAlignmentSummary;

        updateDashboardUI();
        
        const navPriceEl = document.getElementById('nav-price');
        const navIdrEl = document.getElementById('nav-price-idr');
        if(navPriceEl && navIdrEl) {
            navPriceEl.textContent = formatPrice(parseFloat(tickerData.lastPrice));
            navIdrEl.textContent = `Rp ${(parseFloat(tickerData.lastPrice) * (analysisCache.usdToIdrRate || 0)).toLocaleString('id-ID', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
        }
        
        if (orderBookData) {
            latestBids = orderBookData.bids;
            latestAsks = orderBookData.asks;
            const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
            const precision = getPrecisionForAsset(parseFloat(latestPrice));
            const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
            renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
        }

        const symbolLower = binanceSymbol.toLowerCase();
        const streamsToSub = [
            `${symbolLower}@kline_${selectedTimeframe}`,
            `${symbolLower}@aggTrade`,
            `${symbolLower}@depth20@100ms`
        ];
        WebSocketManager.subscribe(streamsToSub);

        (async () => {
            try {
                const searchQuery = (await getCoinGeckoId(baseAsset).then(id => fetchCoinGeckoData(id)).catch(() => null))?.platforms?.ethereum || baseAsset;
                specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span>`;
                const searchResult = await fetchGeckoTerminal(`search/pools?query=${searchQuery}`);
                if (searchResult.data && searchResult.data.length > 0) {
                    searchResult.data.sort((a, b) => parseFloat(b.attributes.reserve_in_usd) - parseFloat(a.attributes.reserve_in_usd));
                    const topPool = searchResult.data[0];
                    const attrs = topPool.attributes;
                    const networkName = topPool.id.split('_')[0];
                    const dexName = topPool.relationships?.dex?.data?.id.split('_').join(' ') || attrs.name.split(' ').pop();
                    if (networkName.includes('sepolia')) {
                        document.getElementById('onchain-card').style.display = 'none';
                        return;
                    } else {
                        document.getElementById('onchain-card').style.display = 'block';
                    }
                    specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span> <span class="text-xs text-gray-400 capitalize">(${networkName} / ${dexName})</span>`;
                    const price = formatPrice(parseFloat(attrs.base_token_price_usd));
                    const volume = (parseFloat(attrs.volume_usd.h24) / 1000000).toFixed(2);
                    const liquidity = attrs.reserve_in_usd ? (parseFloat(attrs.reserve_in_usd) / 1000000).toFixed(2) : 'N/A';
                    let staticContentHtml = `<div class="flex justify-between items-baseline"><span class="text-gray-500 capitalize">Harga DEX (${dexName})</span><span class="font-bold text-lg text-yellow-400">${price}</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Volume 24j DEX</span><span>$${volume}jt</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Likuiditas Pool</span><span>$${liquidity}jt</span></div>`;
                    specificTokenContent.innerHTML = staticContentHtml;
                    try {
                        const poolAddress = attrs.address;
                        const tradesData = await fetchGeckoTerminal(`networks/${networkName}/pools/${poolAddress}/trades`);
                        const tradeEvents = tradesData.data.filter(trade => trade.attributes.kind === 'buy' || trade.attributes.kind === 'sell').map(trade => ({ kind: trade.attributes.kind, usd: parseFloat(trade.attributes.volume_in_usd), price: parseFloat(trade.attributes.price_in_usd || attrs.base_token_price_usd), time: new Date(trade.attributes.block_timestamp), trader: trade.attributes.tx_from_address, network: topPool.id.split('_')[0] })).filter(event => event.usd >= 5000).slice(0, 100);
                        if (tradeEvents.length > 0) {
                            let buyVolume = 0, sellVolume = 0;
                            let buyCount = 0, sellCount = 0;
                            tradeEvents.forEach(event => { if (event.kind === 'buy') { buyVolume += event.usd; buyCount++; } else { sellVolume += event.usd; sellCount++; } });
                            analysisCache.onChainSummary = { totalBuyVolume: buyVolume, totalSellVolume: sellVolume, buyTransactions: buyCount, sellTransactions: sellCount, sentiment: buyVolume > sellVolume ? 'Dominan Beli' : 'Dominan Jual', netVolume: buyVolume - sellVolume };
                            let html = '<hr class="border-slate-700/50 my-3"/><h4 class="text-lg font-semibold mb-2">100 Trans Terbaru di DEX >$5000 </h4>';
                            tradeEvents.forEach(event => {
                                const category = getHolderCategory(event.usd);
                                const timeAgo = getTimeAgo(event.time);
                                const specificTime = event.time.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
                                const walletLink = `https://dexcheck.ai/app/wallet-analyzer/${event.trader}`;
                                const bgColor = event.kind === 'buy' ? 'bg-green-900/40 dark:bg-green-800/20' : 'bg-red-900/40 dark:bg-red-800/20';
                                const amountColor = event.kind === 'buy' ? 'text-green-400' : 'text-red-400';
                                const icon = event.kind === 'buy' ? '🟢' : '🔴';
                                const actionText = event.kind === 'buy' ? 'BELI' : 'JUAL';
                                html += `<div class="p-2 rounded-md ${bgColor}"><div class="flex justify-between items-center font-semibold"><span>${icon} ${actionText}</span><span class="${amountColor}">$${event.usd.toLocaleString('en-US', {maximumFractionDigits: 0})}</span></div><div class="text-xs text-gray-400 flex justify-between items-center mt-1"><span class="${category.class} font-bold">[${category.name}]</span><span class="font-mono text-yellow-400">@ ${formatPrice(event.price)}</span><span>${timeAgo} <span class="text-gray-500">(${specificTime})</span></span><a href="${walletLink}" target="_blank" class="underline hover:text-white">Lihat Dompet 🔗</a></div></div>`;
                            });
                            specificTokenContent.innerHTML += html;
                        } else {
                           analysisCache.onChainSummary = null;
                           specificTokenContent.innerHTML += `<p class="text-xs text-gray-500 text-center pt-2">Tidak ada transaksi jual/beli signifikan baru-baru ini.</p>`;
                        }
                    } catch (tradeError) {
                        specificTokenContent.innerHTML += `<p class="text-xs text-red-500 text-center pt-2">Gagal memuat jejak trader: ${tradeError.message}</p>`;
                    }
                } else {
                     specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Tidak ditemukan pool on-chain untuk ${baseAsset.toUpperCase()}.</p>`;
                }
            } catch (dexError) {
                specificTokenContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data token spesifik: ${dexError.message}</p>`;
            }
        })();

        (async () => {
            try {
                const trendingData = await fetchGeckoTerminal('networks/trending_pools');
                renderTrendingPools(trendingData.data);
            } catch (trendingError) {
                trendingPoolsContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data trending: ${trendingError.message}</p>`;
            }
        })();
    } catch (error) {
        console.error("Analisis Gagal:", error);
        showError(error.message);
    } finally {
        showLoader(false);
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (processingInterval) clearInterval(processingInterval);
        periodicUpdateInterval = setInterval(updatePeriodicData, 300000);
        processingInterval = setInterval(processQueues, 500);
    }
}
// =======================================================
// =======================================================
    /**
     * Menyimpan daftar watchlist dari input ke localStorage.
     */
    function saveWatchlist() {
        const symbols = watchlistInput.value.split(',')
            .map(s => s.trim().toUpperCase())
            .filter(s => s.length > 0);
        
        watchlist = [...new Set(symbols)]; // Hapus duplikat
        localStorage.setItem('ultimateAppWatchlist', JSON.stringify(watchlist));
        watchlistInput.value = watchlist.join(', ');
        alert('Watchlist disimpan!');
    }

    /**
     * Memuat daftar watchlist dari localStorage saat halaman dibuka.
     */
    function loadWatchlist() {
    console.log("1. Memulai fungsi loadWatchlist..."); // Mata-mata #1
    const savedWatchlist = localStorage.getItem('ultimateAppWatchlist');
    
    if (savedWatchlist && JSON.parse(savedWatchlist).length > 0) {
        console.log("2. Menemukan watchlist yang tersimpan di localStorage."); // Mata-mata #2a
        watchlist = JSON.parse(savedWatchlist);
    } else {
        console.log("2. TIDAK ada watchlist tersimpan, menggunakan daftar DEFAULT."); // Mata-mata #2b
        watchlist = ['BTCUSDT', 'ETHUSDT'];
    }
    
    watchlistInput.value = watchlist.join(', ');
    console.log("3. Selesai menjalankan loadWatchlist. Isi variabel 'watchlist' sekarang:", watchlist); // Mata-mata #3
}

    /**
     * Menjalankan pemindaian untuk satu simbol dan mengembalikan skor konfluensinya. 
     */
    async function getConfluenceScoreForSymbol(symbol) {
        try {
            const [tickerData, klines] = await Promise.all([
                fetchBinanceAPIData('ticker/24hr', { symbol }, 'spot'),
                fetchBinanceAPIData('klines', { symbol, interval: '15m', limit: 200 }, 'spot')
            ]);

            if (!klines || klines.length < 50) {
                return { symbol, error: 'Data kline tidak cukup.' };
            }

            const closes = klines.map(k => parseFloat(k[4]));
            const rsiValues = calculateRSI(closes);

            // Kalkulasi data yang dibutuhkan untuk skor
            const calculatedData = {
                ma: (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? { status: 'Uptrend' } : { status: 'Downtrend' },
                rsiDivergence: detectRSIDivergence(closes, rsiValues),
                stoch: calculateStochasticRSI(closes),
                macd: calculateMACD(closes),
                candlePattern: findCandlestickPatterns(klines),
                psar: calculateParabolicSAR(klines),
                linreg: calculateLinearRegressionChannel(closes),
                roc: calculateROC(closes)
            };

        // ===== Tambahan sinyal derivatif & microstructure ===== Modified with ChatGPT
        try {
            const bbInfo = calculateBollingerBands(closes, 20, 2);
            const kcInfo = calculateKeltnerChannels(klines);
            const squeezeState = (() => {
                const bbW = bbInfo.width.slice(-1)[0];
                const kcW = kcInfo.width.slice(-1)[0];
                if (bbW < kcW * 0.75) return 'Squeeze Pro';
                if (bbW < kcW) return 'Squeeze!';
                return 'Normal';
            })();

            // order book bias dari cache jika ada
            const obBias = analysisCache?.orderBookBias ?? 'Netral';

            // derivatif (hanya futures)
            let oiSigned = 0, fundingSigned = 0, lsrSigned = 0;
            if (marketTypeSelect.value === 'futures') {
                const lastClose = closes.at(-1);
                const prevClose = closes.at(-2) ?? lastClose;
                const priceDir = Math.sign(lastClose - prevClose) || 0;

                // Open Interest → gunakan delta vs nilai sebelumnya (jika API mengembalikan single snapshot, treat sebagai non-directional)
                if (analysisCache.openInterestData?.sumOpenInterest) {
                    const oi = parseFloat(analysisCache.openInterestData.sumOpenInterest);
                    const oiPrev = parseFloat(analysisCache.openInterestData.prevSumOpenInterest ?? oi);
                    const oiDelta = oi - oiPrev;
                    oiSigned = Math.sign(oiDelta) * Math.abs(oiDelta) * 0.001 * priceDir; // normalisasi sederhana
                }

                // Funding
                if (analysisCache.fundingRateData?.lastFundingRate !== undefined) {
                    const f = parseFloat(analysisCache.fundingRateData.lastFundingRate);
                    // funding tinggi saat harga naik → berisiko mean-revert (sedikit negatif), sebaliknya positif
                    fundingSigned = (f > 0 ? -1 : +1) * Math.min(Math.abs(f) * 100, 1); // batasi [-1..1]
                }

                // Long/Short Ratio (akun umum)
                if (analysisCache.lsRatioUmumData?.[0]?.longShortRatio) {
                    const lsr = parseFloat(analysisCache.lsRatioUmumData[0].longShortRatio);
                    // >1 condong long (crowded), interpretasi sedikit kontrarian → negatif kecil
                    lsrSigned = (lsr > 1 ? -1 : +1) * Math.min(Math.abs(lsr - 1), 1);
                }
            }

            calculatedData.bbSqueeze     = squeezeState;
            calculatedData.orderBookBias = obBias;
            calculatedData.openInterest  = { deltaSigned: oiSigned };
            calculatedData.funding       = { biasSigned: fundingSigned };
            calculatedData.lsRatio       = { biasSigned: lsrSigned };
        } catch(e) {
            console.warn('Tambahan sinyal derivatif gagal dihitung:', e);
        }

            // Hitung skor
            let totalBullScore = 0;
            let totalBearScore = 0;
            let maxScore = Object.entries(userSettings.weights)
                .filter(([k]) => k !== 'bbSqueeze')
                .reduce((sum, [, weight]) => sum + weight, 0);

            for (const indicator in userSettings.weights) {
                if (calculatedData[indicator]) {
                    const score = getUltimateSignalScore(indicator, calculatedData[indicator]);
                    if (score > 0) totalBullScore += score;
                    if (score < 0) totalBearScore += Math.abs(score);
                }
            }
            
            const bullPercentage = maxScore > 0 ? (totalBullScore / maxScore) * 100 : 0;
            const bearPercentage = maxScore > 0 ? (totalBearScore / maxScore) * 100 : 0;
            
            let verdict = "NEUTRAL";
            if (bullPercentage > 60 && bullPercentage > bearPercentage * 1.5) verdict = "BULLISH";
            if (bearPercentage > 60 && bearPercentage > bullPercentage * 1.5) verdict = "BEARISH";


            return {
                symbol,
                price: parseFloat(tickerData.lastPrice),
                change24h: parseFloat(tickerData.priceChangePercent),
                bullScore: bullPercentage,
                bearScore: bearPercentage,
                verdict
            };
        } catch (error) {
            console.error(`Gagal memindai ${symbol}:`, error);
            return { symbol, error: error.message };
        }
    }

    /**
     * Mengatur dan menjalankan pemindaian untuk semua aset di watchlist.
     */
    async function scanWatchlist() {
        if (watchlist.length === 0) {
            alert('Harap isi dan simpan watchlist Anda terlebih dahulu.');
            return;
        }

        const btn = scanWatchlistBtn;
        const btnText = btn.querySelector('span');
        const btnLoader = btn.querySelector('.loader');

        btnText.classList.add('hidden');
        btnLoader.classList.remove('hidden');
        btn.disabled = true;
        watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-10 text-center"><div class="loader mx-auto"></div><p class="mt-2 text-sm text-gray-400">Memindai ${watchlist.length} aset...</p></td></tr>`;

        try {
            const results = [];
            for (const symbol of watchlist) {
                const result = await getConfluenceScoreForSymbol(symbol);
                results.push(result);
                // Tambahkan jeda 300ms untuk menghindari rate limit API
                await new Promise(resolve => setTimeout(resolve, 300));
            }
renderWatchlistTable(results);
        } catch (error) {
            watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-4 text-center text-sm text-red-500">Terjadi kesalahan saat pemindaian: ${error.message}</td></tr>`;
        } finally {
            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            btn.disabled = false;
        }
    }

    /**
     * Menampilkan hasil pemindaian watchlist ke dalam tabel.
     */
    function renderWatchlistTable(results) {
        if (results.length === 0) {
            watchlistResultsBody.innerHTML = `<tr><td colspan="4" class="px-4 py-4 text-center text-sm text-gray-400">Tidak ada hasil.</td></tr>`;
            return;
        }
        
        let tableHtml = '';
        results.forEach(res => {
            if (res.error) {
                tableHtml += `
                    <tr class="cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800" data-symbol="${res.symbol}">
                        <td class="px-4 py-3 font-medium text-gray-900 dark:text-white">${res.symbol}</td>
                        <td colspan="3" class="px-4 py-3 text-sm text-red-400">Error: ${res.error}</td>
                    </tr>
                `;
            } else {
                const priceFormatted = formatPrice(res.price);
                const changeClass = res.change24h >= 0 ? 'positive' : 'negative';
                let verdictClass = '';
                if (res.verdict === 'BULLISH') verdictClass = 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300';
                if (res.verdict === 'BEARISH') verdictClass = 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-300';
                if (res.verdict === 'NEUTRAL') verdictClass = 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';

                tableHtml += `
                    <tr class="cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-800" data-symbol="${res.symbol}">
                        <td class="px-4 py-3 font-medium text-gray-900 dark:text-white">${res.symbol}</td>
                        <td class="px-4 py-3 text-sm text-gray-500 dark:text-gray-400">${priceFormatted}</td>
                        <td class="px-4 py-3 text-sm ${changeClass}">${res.change24h.toFixed(2)}%</td>
                        <td class="px-4 py-3 text-sm">
                            <div class="flex items-center justify-between gap-2">
                                <span class="font-semibold px-2 py-1 text-xs rounded-full ${verdictClass}">${res.verdict}</span>
                                <div class="text-right">
                                    <div class="text-xs positive">🐂 ${res.bullScore.toFixed(0)}%</div>
                                    <div class="text-xs negative">🐻 ${res.bearScore.toFixed(0)}%</div>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
            }
        });
        watchlistResultsBody.innerHTML = tableHtml;
        attachWatchlistRowListeners();
    }

    /**
     * Menambahkan event listener ke setiap baris di tabel watchlist.
     */
    function attachWatchlistRowListeners() {
        document.querySelectorAll('#watchlist-results-body tr').forEach(row => {
            row.addEventListener('click', () => {
                const symbol = row.dataset.symbol;
                if (symbol) {
                    assetInput.value = symbol;
                    runFullAnalysis();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            });
        });
    }

    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR WATCHLIST (SELESAI) ==
// =================================================================================
// == BLOK KODE UPGRADE FINAL V2 UNTUK ANALISIS AI (TERMASUK KORELASI & RISIKO) ==
// =================================================================================

/**
 * FUNGSI UTAMA: Menjalankan seluruh alur analisis AI yang komprehensif.
 */
// GANTI KESELURUHAN FUNGSI LAMA DENGAN VERSI LENGKAP DAN BENAR INI
async function runComprehensiveAIAnalysis() {
    if (!analysisCache.tickerData) {
        showError("Jalankan 'GET DATA' terlebih dahulu untuk memuat data.");
        return;
    }

    const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
    const btnText = comprehensiveBtn.querySelector('span');
    const btnLoader = comprehensiveBtn.querySelector('.loader');
    const aiContentContainer = document.getElementById('ai-content-container');
    const aiNarrativeEl = document.getElementById('ai-narrative-content');

    btnText.classList.add('hidden');
    btnLoader.classList.remove('hidden');
    comprehensiveBtn.disabled = true;

    // --- PERBAIKAN KUNCI: BERSIHKAN SEMUA KONTENER DI SINI ---
    document.getElementById('projection-results-container').innerHTML = '';
    document.getElementById('saran-buyer').textContent = '-';
    document.getElementById('alasan-buyer').textContent = '';
    document.getElementById('saran-holder').textContent = '-';
    document.getElementById('alasan-holder').textContent = '';

    aiNarrativeEl.innerHTML = '';
    aiContentContainer.classList.remove('hidden');

    try {
        const { 
            binanceSymbol, 
            calculatedData, 
            tickerData, 
            correlationData,
            onChainSummary
        } = analysisCache;
        
        const marketType = marketTypeSelect.value;

        // 1. Panggil fungsi untuk mendapatkan ringkasan TF Alignment
        const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);

        // 2. Siapkan data analisis volume
        const klines1d = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 200 }, marketType);
        const vwap20d = calculateVWAP(klines1d, 'rolling', 20);
        const obvValues = calculateOBV(klines1d);
        const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik (Akumulasi)' : 'Turun (Distribusi)';
        const vwapStatus = parseFloat(tickerData.lastPrice) > vwap20d ? 'Di Atas VWAP (Bullish)' : 'Di Bawah VWAP (Bearish)';
        
        const volumeAnalysisData = {
            vwap_20d: vwapStatus,
            obv_trend: obvTrend
        };

        // 3. Buat prompt hybrid dengan variabel yang benar
        const prompt = constructHybridAIPrompt(
            binanceSymbol, 
            calculatedData, 
            tfAlignmentSummary, // Mengirimkan hasil ringkasan
            volumeAnalysisData, 
            onChainSummary, 
            correlationData
        );
        
        const aiResponseText = await callGemini([{ text: prompt }], false);
        const parsedData = parseAIResponseWithTags(aiResponseText);
        displayComprehensiveResults(parsedData);

    } catch (error) {
        aiNarrativeEl.innerHTML = `<p class="text-red-500">Gagal mendapatkan analisa AI: ${error.message}</p>`;

    } finally {
        const btnText = comprehensiveBtn.querySelector('span');
        const btnLoader = comprehensiveBtn.querySelector('.loader');

        btnText.classList.remove('hidden');
        btnLoader.classList.add('hidden');
        comprehensiveBtn.disabled = false;
    }
}

    // GANTI SELURUH FUNGSI INI DENGAN VERSI FINAL YANG PALING ROBUST
    function constructHybridAIPrompt(symbol, singleTfData, multiTfData, volumeData, onChainSummary, correlationData) {
        const mainPriceContext = {
            current_price: formatPrice(parseFloat(analysisCache.tickerData.lastPrice))
        };
        const cleanSingleTfData = {
            timeframe: timeframeSelect.value,
            candlestick_pattern: singleTfData.candlePattern,
            chart_pattern: singleTfData.chartPattern,
            rsi_divergence: singleTfData.rsiDivergence,
            obv_divergence: singleTfData.obvDivergence.status,
            volatilitas_atr: singleTfData.atr,
            order_book_bias: analysisCache.orderBookBias,
            bollinger_squeeze: singleTfData.bollingerBands.squeezeStatus,
            pivot_harian_bias: singleTfData.pivot.status + ` (Pivot @ ${formatPrice(singleTfData.pivot.data.P)})`,
            vwap_20d_bias: singleTfData.vwap.status,
            ichimoku_bias: singleTfData.ichimoku.status,
            squeeze_pro_bb_kc: (singleTfData.bollingerBands.width.slice(-1)[0] < singleTfData.keltnerChannels.width.slice(-1)[0]) ? 'Terdeteksi!' : 'Tidak Aktif'
        };
        const fundamentalData = {
            market_cap: analysisCache.coinGeckoData?.market_data?.market_cap?.usd?.toLocaleString() || 'N/A'
        };
        const correlationText = correlationData !== null ? correlationData.toFixed(2) : 'N/A (Aset adalah BTC atau data tidak cukup)';
        const mvrvPromptData = analysisCache.mvrvData 
            ? {
                status: "Data MVRV disediakan pengguna",
                nilai_z_score: analysisCache.mvrvData.value,
                tanggal_data: analysisCache.mvrvData.date
            }
            : "Data MVRV tidak disediakan pengguna.";

        const ema9 = calculateEMA(analysisCache.klines.map(k=>parseFloat(k[4])), 9).pop();
        const ema21 = calculateEMA(analysisCache.klines.map(k=>parseFloat(k[4])), 21).pop();
        const scalpingBias = ema9 > ema21 ? 'LONG' : 'SHORT';
        const scalpingSetupData = {
            bias_sesaat: scalpingBias,
            timeframe: timeframeSelect.value
        };

        return `Sebagai seorang analis kuantitatif (Quant Analyst) senior, berikan analisis pasar yang komprehensif untuk ${symbol}.

            TUGAS UTAMA:
            1.  **CARI DATA EKSTERNAL TERBARU:** Sebelum melakukan analisis, cari data sentimen pasar TERBARU (tidak lebih dari 24 jam terakhir) untuk BITCOIN dari sumber on-chain (Glassnode, CryptoQuant, Coinglass). Sertakan data-data berikut:
                a.  **MVRV Z-Score:** Cari nilai Z-Score terbaru.
                b.  **Data Sentimen Coinglass:** Cari data Netflow, Perubahan OI, Funding Rate, Rasio L/S 24 jam, dan Likuidasi.
                c.  **Format hasilnya HANYA dalam bentuk JSON** di dalam tag [SENTIMEN_DATA_JSON_START]. Strukturnya harus: {\"mvrv_z_score\":1.23, \"netflow\":-57.82, \"oiChange\":-0.89, \"fundingRate\":0.0050, \"lsRatio24h\":\"50.9% / 49.1%\", \"liquidations\":\"215.30M vs 89.10M\"}
            2.  **ANALISIS SEMUA DATA:** Lanjutkan dengan menganalisis SEMUA data yang diberikan di bawah ini untuk mengisi sisa tag output.
            3.  **GUNAKAN JANGKAR HARGA:** Gunakan 'current_price' dari DATA #0 sebagai satu-satunya titik acuan untuk SEMUA PROYEKSI HARGA.


            **DATA #0: KONTEKS HARGA UTAMA (JANGKAR)**
            ${JSON.stringify(mainPriceContext, null, 2)}

            **DATA #1: Analisis Detail Timeframe Utama (${cleanSingleTfData.timeframe})**
            ${JSON.stringify(cleanSingleTfData, null, 2)}

            **DATA #2: Ringkasan Keselarasan Tren Multi-Timeframe (EMA 21/50)**
            ${JSON.stringify(multiTfData, null, 2)}

            **DATA #3: Analisis Berbasis Volume (CEX - Harian)**
            ${JSON.stringify(volumeData, null, 2)}

            **DATA #4: Data Fundamental Dasar**
            ${JSON.stringify(fundamentalData, null, 2)}

            **DATA #5: Ringkasan Aktivitas On-Chain (DEX - Transaksi >$5000)**
            ${onChainSummary ? JSON.stringify(onChainSummary, null, 2) : '"Data on-chain tidak tersedia untuk aset ini."'}

            **DATA #6: Korelasi Pasar (vs. BTCUSDT 30 Hari)**
            ${JSON.stringify({ correlation_coefficient: correlationText }, null, 2)}

            **DATA #7: Metrik Makro On-Chain (MVRV Z-Score)**
            ${JSON.stringify(mvrvPromptData, null, 2)}

            INSTRUKSI OUTPUT (WAJIB IKUTI FORMAT TAG DAN STRUKTUR MARKDOWN DI BAWAH INI):

            [SENTIMEN_DATA_JSON_START]
            (Letakkan hasil pencarian data sentimen Coinglass dalam format JSON murni di sini)
            [SENTIMEN_DATA_JSON_END]
            
            // ... (Sisa tag dari ANALISIS_SCALPING hingga TINGKAT_KEYAKINAN tetap sama) ...

            [NARASI_PASAR_START]
            (Berikan analisis narasi pasar. WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT:
            ### 🟥 Argumen Bearish (Jangka Pendek)
            * Poin 1...
            * Poin 2...

            ### 🟩 Argumen Bullish (Tersembunyi)
            * Poin 1...
            * Poin 2...

            ### ⚖️ Kesimpulan Narasi
            * Ringkasan kesimpulan...)
            [NARASI_PASAR_END]

            [ANALISIS_RISIKO_START]
            (Berikan analisis risiko singkat... // Instruksi ini tetap sama)
            [ANALISIS_RISIKO_END]

            [SMC_NARRATIVE_START]
            (Berikan analisis struktur pasar (SMC). WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT:
            ### 🟥 Sinyal Bearish (Distribusi)
            * Poin 1...
            * Poin 2...

            ### 🟩 Sinyal Bullish (Akumulasi)
            * Poin 1...
            * Poin 2...

            ### 🎯 Target & Konfirmasi Berikutnya
            * Poin 1...
            * Poin 2...)
            [SMC_NARRATIVE_END]

            [SMC_POI_BULLISH_START]
            (Sebutkan TIPE dan rentang harga zona POI bullish terdekat. Contoh: 'Order Block H4 di $50000 - $51000')
            [SMC_POI_BULLISH_END]

            [SMC_POI_BEARISH_START]
            (Sebutkan TIPE dan rentang harga zona POI bearish terdekat. Contoh: 'Supply zone H1 di $60000 - $61000')
            [SMC_POI_BEARISH_END]

            [PROYEKSI_LENGKAP_JSON_START]
            [
                { "periode": "Sangat Pendek (24-48 jam)", "target_harga": "...", "alasan": "..." },
                { "periode": "Jangka Pendek (1-7 hari)", "target_harga": "...", "alasan": "..." },
                { "periode": "Jangka Menengah (1-4 minggu)", "target_harga": "...", "alasan": "..." },
                { "periode": "Jangka Panjang (6-12 bulan)", "target_harga": "...", "alasan": "..." },
                { "periode": "Siklus Makro (1-3 tahun)", "target_harga": "...", "alasan": "..." }
            ]
            [PROYEKSI_LENGKAP_JSON_END]

            [SARAN_HOLDER_START]
            (Pilih salah satu: TAHAN, JUAL, TAMBAH, KURANGI SEBAGIAN)
            [SARAN_HOLDER_END]

            [ALASAN_HOLDER_START]
            (Jelaskan alasan teknikal untuk saran di atas)
            [ALASAN_HOLDER_END]

            [SARAN_BUYER_START]
            (Pilih salah satu: BELI SEKARANG, TUNGGU DI AREA, JANGAN MASUK)
            [SARAN_BUYER_END]

            [ALASAN_BUYER_START]
            (Jelaskan alasan teknikal. Jika TUNGGU, berikan rentang harga ideal berdasarkan POI)
            [ALASAN_BUYER_END]
            `;
    }

    function parseAIResponseWithTags(rawText) {
    const result = {};
    const tags = [
        "SENTIMEN_DATA_JSON",
        "PUTUSAN_FINAL", "TINGKAT_KEYAKINAN", "NARASI_PASAR", "ANALISIS_SCALPING", "ANALISIS_RISIKO",
        "SMC_NARRATIVE", "SMC_POI_BULLISH", "SMC_POI_BEARISH",
        "PROYEKSI_LENGKAP_JSON", "SARAN_HOLDER", "ALASAN_HOLDER",
        "SARAN_BUYER", "ALASAN_BUYER"
        // Tag Volatilitas, Sentimen, dll, sudah disatukan dalam narasi utama jadi tidak perlu diparsing terpisah
    ];

    tags.forEach(tag => {
        const regex = new RegExp(`\\[${tag}_START\\]([\\s\\S]*?)\\[${tag}_END\\]`, 'i');
        const match = rawText.match(regex);
        const content = match ? match[1].trim() : null;
        
        const key = tag.toLowerCase();
        if (key === "proyeksi_lengkap_json" && content) {
            try {
                result[key] = JSON.parse(content);
            } catch (e) {
                console.error(`Gagal parse JSON untuk tag ${tag}:`, e);
                result[key] = [];
            }
        } else {
            result[key] = content;
        }
    });
    return result;
}


/**
 * UI RENDERER (VERSI ULTIMATE v2): Menampilkan hasil analisis baru termasuk risiko.
 */
   // GANTI KESELURUHAN FUNGSI LAMA DENGAN VERSI FINAL INI
function displayComprehensiveResults(data) {
    // --- [PERBAIKAN KUNCI] Bersihkan semua kontainer sebelum menampilkan hasil baru ---
    const aiNarrativeEl = document.getElementById('ai-narrative-content');
    const projectionContainer = document.getElementById('projection-results-container');
    const buyerSaranEl = document.getElementById('saran-buyer');
    const buyerAlasanEl = document.getElementById('alasan-buyer');
    const holderSaranEl = document.getElementById('saran-holder');
    const holderAlasanEl = document.getElementById('alasan-holder');
    
    aiNarrativeEl.innerHTML = '';
    projectionContainer.innerHTML = '';
    buyerSaranEl.textContent = '-';
    buyerAlasanEl.textContent = '';
    holderSaranEl.textContent = '-';
    holderAlasanEl.textContent = '';
    // --- AKHIR PERBAIKAN ---

    if (!data || Object.keys(data).length === 0) {
        aiNarrativeEl.innerHTML = '<p class="text-red-500 text-center">AI gagal memberikan analisis yang bisa diproses. Coba lagi.</p>';
        return;
    }

    // 1. Tampilkan data sentimen (jika ada)
    if (data.sentimen_data_json) {
        try {
            const sentimentData = { ...JSON.parse(data.sentimen_data_json), lastUpdated: new Date() };
            analysisCache.shortTermSentiment = sentimentData;
            displaySentimentDataInDashboard(sentimentData);
        } catch (e) {
            console.error("Gagal parse JSON sentimen dari AI:", e);
            const sentimentContainer = document.getElementById('sentiment-display-container');
            if(sentimentContainer) {
                 sentimentContainer.innerHTML = `<p class="text-xs text-center text-red-500">AI gagal memberikan data sentimen dalam format JSON yang benar.</p>`;
            }
        }
    }
    
    // 2. Buat verdict singkat berdasarkan Skor Konfluensi
    let shortVerdictHtml = '';
    if (analysisCache.quickConfluenceScore) {
        const { bull, bear } = analysisCache.quickConfluenceScore;
        const { text, class: verdictClass } = generateShortVerdict(bull, bear);
        shortVerdictHtml = `<p class="text-center font-bold text-2xl mb-4 ${verdictClass}">${text}</p>`;
    }

    // 3. Gunakan Marked.js untuk memformat narasi dan smc (jika ada)
    const narrativeHtml = data.narasi_pasar ? marked.parse(data.narasi_pasar) : '';
    const smcHtml = data.smc_narrative ? marked.parse(data.smc_narrative) : '';

    let detailsHtml = `
        <div class="space-y-4 text-sm">
            ${narrativeHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md">${narrativeHtml}</div>` : ''}
            ${data.analisis_risiko ? `<div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border border-dashed border-yellow-500/50"><strong>Analisis Risiko:</strong> ${data.analisis_risiko}</div>` : ''}
            ${smcHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md mt-3">${smcHtml}</div>` : ''}
        </div>
    `;
    
    // 4. Gabungkan verdict singkat dengan sisa analisis
    aiNarrativeEl.innerHTML = shortVerdictHtml + detailsHtml;

    // 5. Tampilkan Proyeksi Harga & Saran Strategis
    if (data.proyeksi_lengkap_json && data.proyeksi_lengkap_json.length > 0) {
        data.proyeksi_lengkap_json.forEach(p => {
            projectionContainer.innerHTML += `
                <div class="card p-3 bg-gray-50 dark:bg-gray-800/50">
                    <h4 class="font-semibold text-blue-400 text-sm">${p.periode}</h4>
                    <p class="font-bold text-base text-gray-800 dark:text-white">${p.target_harga}</p>
                    <p class="text-xs text-gray-500 mt-1">${p.alasan}</p>
                </div>`;
        });
        projectionContainer.className = `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`;
    } else {
        projectionContainer.innerHTML = '<p class="text-xs text-gray-500 col-span-full">Proyeksi harga tidak tersedia.</p>';
    }

    buyerSaranEl.textContent = data.saran_buyer || 'N/A';
    buyerAlasanEl.innerHTML = (data.alasan_buyer || 'Tidak ada alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
    holderSaranEl.textContent = data.saran_holder || 'N/A';
    holderAlasanEl.innerHTML = (data.alasan_holder || 'Tidak ada alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
}
// =======================================================
function generateShortVerdict(bullPercentage, bearPercentage) {
    let verdict = "NETRAL / KONSOLIDASI";
    let verdictClass = "text-yellow-400";
    
    if (bullPercentage > bearPercentage * 1.8 && bullPercentage > 40) {
        verdict = "BULLISH KUAT";
        verdictClass = "positive";
    } else if (bearPercentage > bullPercentage * 1.8 && bearPercentage > 40) {
        verdict = "BEARISH KUAT";
        verdictClass = "negative";
    } else if (bullPercentage > bearPercentage) {
        verdict = "BIAS BULLISH RINGAN";
        verdictClass = "positive";
    } else if (bearPercentage > bullPercentage) {
        verdict = "BIAS BEARISH RINGAN";
        verdictClass = "negative";
    }
    return { text: verdict, class: verdictClass };
}

// =======================================================
function analyzeAndDisplayConfluenceContributors() {
    const data = analysisCache.calculatedData;
    if (!data) return;

    let contributors = [];
    for (const indicator in userSettings.weights) {
        if (data[indicator]) {
            const score = getUltimateSignalScore(indicator, data[indicator]);
            if (score !== 0) {
                contributors.push({ name: indicator.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()), score });
            }
        }
    }

    // Urutkan berdasarkan skor absolut
    contributors.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));

    const topBullish = contributors.filter(c => c.score > 0).slice(0, 3);
    const topBearish = contributors.filter(c => c.score < 0).slice(0, 3);

    let bullishHtml = '<h4 class="font-bold positive mb-1">👍 Pro Bullish</h4><ul class="list-disc list-inside text-gray-400">';
    topBullish.forEach(item => {
        bullishHtml += `<li>${item.name}</li>`;
    });
    bullishHtml += '</ul>';
    document.getElementById('top-bullish-contributors').innerHTML = bullishHtml;

    let bearishHtml = '<h4 class="font-bold negative mb-1">👎 Kontra Bearish</h4><ul class="list-disc list-inside text-gray-400">';
    topBearish.forEach(item => {
        bearishHtml += `<li>${item.name}</li>`;
    });
    bearishHtml += '</ul>';
    document.getElementById('top-bearish-contributors').innerHTML = bearishHtml;
    
    document.getElementById('confluence-breakdown-container').classList.remove('hidden');
}

// =======================================================
async function createTFAlignmentSummary(symbol, marketType) {
    const timeframes = ['15m', '1h', '4h', '1d'];
    const summary = {};
    
    const klinesPromises = timeframes.map(tf => 
        fetchBinanceAPIData('klines', { symbol, interval: tf, limit: 51 }, marketType)
    );
    const klinesResults = await Promise.all(klinesPromises);

    klinesResults.forEach((klines, index) => {
        const tf = timeframes[index];
        if (klines && klines.length >= 50) {
            const closes = klines.map(k => parseFloat(k[4]));
            const ema21 = calculateEMA(closes, 21).pop();
            const ema50 = calculateEMA(closes, 50).pop();
            summary[tf] = ema21 > ema50 ? 'BULLISH' : 'BEARISH';
        } else {
            summary[tf] = 'N/A';
        }
    });

    // Tampilkan juga di UI
    const alignmentContainer = document.getElementById('tf-alignment-summary');
    let alignmentHtml = '<h4 class="font-bold text-gray-300 mt-2 mb-1">Keselarasan Tren (EMA 21/50)</h4><div class="flex justify-center gap-2">';
    for(const tf in summary){
        const colorClass = summary[tf] === 'BULLISH' ? 'positive' : (summary[tf] === 'BEARISH' ? 'negative' : 'text-gray-500');
        alignmentHtml += `<div class="text-center p-1 rounded-md bg-gray-800/50 flex-1"><span class="font-bold">${tf}</span><br><span class="text-xs ${colorClass}">${summary[tf]}</span></div>`;
    }
    alignmentHtml += '</div>';
    alignmentContainer.innerHTML = alignmentHtml;

    return summary;
}
// ### AKHIR DARI BLOK KODE BARU ###
    function updateDashboardUI() {
        if (!analysisCache.tickerData) return;
        const navInfoContainer = document.getElementById('nav-info-container');
        const navStatsContainer = document.getElementById('nav-stats-container');
        const tradeLinkContainer = document.getElementById('trade-link');

        if (navInfoContainer) {
            navInfoContainer.classList.remove('hidden');
            navInfoContainer.classList.add('md:flex');
        }
        if (navStatsContainer) {
            navStatsContainer.classList.remove('hidden');
            navStatsContainer.classList.add('md:flex');
        }
        if (tradeLinkContainer) {
            tradeLinkContainer.classList.remove('hidden');
        }
        initialPlaceholder.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
        const navHeight = document.getElementById('sticky-nav-wrapper').offsetHeight;
        smoothScrollTo(document.getElementById('toggle-charts-btn'), 900, navHeight + 16); // 16px = margin tambahan
        
        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        populateCorrelationWidget(); 
        
        if (isChartsVisible) {
            renderAllCharts();
        } else {
            destroyCharts(); 
            toggleChartsBtn.textContent = 'SHOW CHART';
        }
        renderCvdChart();
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// =======================================================
    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleChartsBtn.textContent = 'HIDE CHART';
            if (analysisCache.klines) {
                renderAllCharts();
            }
        } else {
            chartsWrapper.style.display = 'none';
            toggleChartsBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }
    
    /**
 * Menjalankan animasi scroll yang halus ke sebuah elemen dengan offset.
 * @param {HTMLElement} element - Elemen tujuan untuk scroll.
 * @param {number} duration - Durasi animasi dalam milidetik.
 * @param {number} offset - Jarak (dalam pixel) dari puncak layar.
 */
    function smoothScrollTo(element, duration, offset = 0) {
    if (!element) return; // Pengaman jika elemen tidak ditemukan
    const targetPosition = element.getBoundingClientRect().top + window.pageYOffset - offset;
    const startPosition = window.pageYOffset;
    const distance = targetPosition - startPosition;
    let startTime = null;

    const easeInOutQuad = (t, b, c, d) => {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        t--;
        return -c / 2 * (t * (t - 2) - 1) + b;
    };

    const animation = (currentTime) => {
        if (startTime === null) startTime = currentTime;
        const timeElapsed = currentTime - startTime;
        const run = easeInOutQuad(timeElapsed, startPosition, distance, duration);
        window.scrollTo(0, run);
        if (timeElapsed < duration) requestAnimationFrame(animation);
    };

    requestAnimationFrame(animation);
}
    // =======================================================
    // == FUNGSI BARU UNTUK EFEK SCROLL HALUS (SELESAI) ==
    // =======================================================

    function startFundingRateTimer(nextFundingTime) {
        if (fundingRateTimer) clearInterval(fundingRateTimer);

        const updateTimer = () => {
            const timeRemaining = formatTimeRemaining(nextFundingTime);
            document.getElementById('funding-rate-interval').textContent = timeRemaining;

            // Jika waktu sudah habis, hentikan timer
            if (timeRemaining === '00:00:00') {
                clearInterval(fundingRateTimer);
                // Di sini, Anda bisa memicu pembaruan data funding rate dari API
            }
        };

        updateTimer(); // Panggil sekali untuk pembaruan instan
        fundingRateTimer = setInterval(updateTimer, 1000);
    }
// =======================================================
    function formatTimeRemaining(timestamp) {
        const now = new Date().getTime();
        const nextFunding = new Date(timestamp);
        const diff = nextFunding - now;

        if (diff <= 0) return '00:00:00';

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        const pad = (num) => num.toString().padStart(2, '0');

        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }
// =======================================================
    function populateConfluenceDetailsWidget() {  
        const { calculatedData, orderBookData, lsRatioUmumData, lsRatioTopData } = analysisCache;
        if (calculatedData.pivot?.data) {
            document.getElementById('pivot-p').textContent = formatPrice(calculatedData.pivot.data.P);
        }
        if (calculatedData.vwap) {
            document.getElementById('vwap-20d').textContent = formatPrice(calculatedData.vwap.value);
        }
        if (calculatedData.ichimoku) {
            const ichiBiasEl = document.getElementById('ichimoku-bias');
            ichiBiasEl.textContent = calculatedData.ichimoku.status;
            ichiBiasEl.className = `font-mono font-semibold ${calculatedData.ichimoku.status === 'Bullish' ? 'positive' : (calculatedData.ichimoku.status === 'Bearish' ? 'negative' : 'text-gray-500')}`;
        }
        document.getElementById('confluence-timeframe-display').textContent = timeframeSelect.value;
        document.getElementById('vpvr-vah').textContent = formatPrice(calculatedData.vpvr.vah);
        document.getElementById('vpvr-poc').textContent = formatPrice(calculatedData.vpvr.poc);
        document.getElementById('vpvr-val').textContent = formatPrice(calculatedData.vpvr.val);
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = calculatedData.ma.status;
        maStatusEl.className = `font-mono font-semibold ${calculatedData.ma.class}`;
        document.getElementById('ema-21-value').textContent = `EMA21: ${formatPrice(calculatedData.ma.value21)}`;
        document.getElementById('ema-50-value').textContent = `EMA50: ${formatPrice(calculatedData.ma.value50)}`;
        document.getElementById('rsi-value').textContent = calculatedData.rsi.last;
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = calculatedData.rsi.status;
        rsiStatusEl.className = `tag ${calculatedData.rsi.class}`;
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = calculatedData.rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${calculatedData.rsiDivergence.class}`;
        document.getElementById('stoch-value').textContent = `${calculatedData.stoch.k}/${calculatedData.stoch.d}`;
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = calculatedData.stoch.status;
        stochStatusEl.className = `tag ${calculatedData.stoch.class}`;
        document.getElementById('macd-status').textContent = calculatedData.macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${calculatedData.macd.class}`;
        document.getElementById('macd-hist').textContent = calculatedData.macd.hist;
        document.getElementById('bollinger-bands-status').textContent = calculatedData.bollingerBands.status;
        const bbData = calculatedData.bollingerBands;
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop();
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop();
        const lastLower = bbData.lower.filter(v => v !== undefined).pop();
        document.getElementById('bb-upper-value').textContent = `U: ${formatPrice(lastUpper)}`;
        document.getElementById('bb-middle-value').textContent = `M: ${formatPrice(lastMiddle)}`;
        document.getElementById('bb-lower-value').textContent = `L: ${formatPrice(lastLower)}`;
        document.getElementById('atr-status').textContent = `${calculatedData.atr.value.toFixed(6)} (${calculatedData.atr.status})`;
        const atrPercentValue = calculatedData.atrPercent;
        if (atrPercentValue !== undefined) {
            document.getElementById('atr-percent-status').textContent = `(${atrPercentValue.toFixed(2)}%)`;
        }
        // KODE BARU DAN FINAL untuk Tampilan Pola
        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const candleResult = calculatedData.candlePattern;

        // Tentukan kelas warna untuk label Bullish/Bearish
        let biasClass = '';
        if (candleResult.bias === 'BULLISH') biasClass = 'positive';
        if (candleResult.bias === 'BEARISH') biasClass = 'negative';

        // Format timestamp menjadi jam:menit yang mudah dibaca
        const formattedTime = candleResult.timestamp 
            ? new Date(candleResult.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) 
            : '';

        // Bangun HTML lengkap untuk ditampilkan
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Pola Candlestick</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            ${candleResult.svg}
            <p id="candlestick-pattern" class="font-semibold ${candleResult.class}">${candleResult.pattern}</p>
            ${candleResult.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candleResult.bias}</p>` : ''}
        `;
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = calculatedData.chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${calculatedData.chartPattern.class}`;
        const psarStatusEl = document.getElementById('psar-status');
        psarStatusEl.textContent = calculatedData.psar.status;
        psarStatusEl.className = `font-mono font-semibold ${calculatedData.psar.status === 'Bullish' ? 'positive' : 'negative'}`;

        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${calculatedData.roc.value.toFixed(2)}% (${calculatedData.roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${calculatedData.roc.status === 'Positif' ? 'positive' : 'negative'}`;

        document.getElementById('linreg-status').textContent = calculatedData.linreg.status;

        // KODE BARU (Logika Squeeze Pro)
        const bbWidth = calculatedData.bollingerBands.width.slice(-1)[0];
        const kcWidth = calculatedData.keltnerChannels.width.slice(-1)[0];
        const bbSqueezeEl = document.getElementById('bollinger-squeeze-status');

        if (bbWidth < kcWidth) {
            bbSqueezeEl.textContent = 'SQUEEZE PRO!';
            bbSqueezeEl.className = 'font-mono font-bold negative blinking-text-animation';
        } else if (calculatedData.bollingerBands.squeezeStatus === 'Squeeze!') {
            bbSqueezeEl.textContent = 'Squeeze!';
            bbSqueezeEl.className = 'font-mono font-bold text-yellow-500 blinking-text-animation';
        } else {
            bbSqueezeEl.textContent = 'Normal';
            bbSqueezeEl.className = 'font-mono text-gray-500';
        }

        document.getElementById('bollinger-rejection-status').textContent = calculatedData.bollingerBands.rejection;
        document.getElementById('bollinger-walk-status').textContent = calculatedData.bollingerBands.walkTheBands;
        
        if (calculatedData.adx) {
            document.getElementById('adx-value').textContent = calculatedData.adx.adx;
            document.getElementById('plus-di-value').textContent = calculatedData.adx.plusDI;
            document.getElementById('minus-di-value').textContent = calculatedData.adx.minusDI;
        }
        const lsUmumContainer = document.getElementById('ls-umum-container'), lsTopContainer = document.getElementById('ls-top-container');
        if (marketTypeSelect.value === 'futures' && lsRatioUmumData?.[0] && lsRatioTopData?.[0]) {
            lsUmumContainer.classList.remove('hidden');
            lsTopContainer.classList.remove('hidden');
            document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
        } else {
            lsUmumContainer.classList.add('hidden');
            lsTopContainer.classList.add('hidden');
        }
        if (orderBookData?.bids && orderBookData?.asks) {
            const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
            const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
            let biasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (Banyak Beli)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (Banyak Jual)' : 'Netral');
            document.getElementById('order-book-bias').textContent = biasText;
            analysisCache.orderBookBias = biasText;
        } else {
            document.getElementById('order-book-bias').textContent = 'N/A';
            analysisCache.orderBookBias = 'N/A';
        }

    }

    // Fungsi baru untuk mendeteksi "wall"
    function detectAndDisplayWall(bids, asks) {
    // Util: hitung cluster dinding
    const findWallCluster = (levels) => {
        if (!levels || levels.length < 5) return null;
        const numLevelsToCheck = 15;
        const topLevels = levels.slice(0, numLevelsToCheck).map(l => parseFloat(l[1]));

        const sortedVolumes = [...topLevels].sort((a, b) => b - a);
        const avgVolume = sortedVolumes.slice(1).reduce((sum, vol) => sum + vol, 0) / (numLevelsToCheck - 1);

        const maxVolume = sortedVolumes[0];
        const thinThreshold   = Math.max(avgVolume * 2, maxVolume * 0.2);
        const mediumThreshold = Math.max(avgVolume * 5, maxVolume * 0.5);
        const thickThreshold  = Math.max(avgVolume * 10, maxVolume * 0.7);

        let currentWall = null;
        let walls = [];

        for (let i = 0; i < levels.length; i++) {
            const price = parseFloat(levels[i][0]);
            const volume = parseFloat(levels[i][1]);

            if (volume >= thinThreshold) {
                if (!currentWall) {
                    currentWall = {
                        priceStart: price,
                        priceEnd: price,
                        totalVolume: volume,
                        levels: 1,
                        levelPrices: [price]
                    };
                } else {
                    currentWall.priceEnd = price;
                    currentWall.totalVolume += volume;
                    currentWall.levels++;
                    currentWall.levelPrices.push(price);
                }
            } else {
                if (currentWall && currentWall.levels >= 3) {
                    walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                }
                currentWall = null;
            }
        }

        // akhir loop
        if (currentWall && currentWall.levels >= 3) {
            walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
        }

        if (walls.length > 0) {
            // pilih wall dengan totalVolume terbesar
            return walls.reduce((max, w) => (w.totalVolume > max.totalVolume ? w : max), walls[0]);
        }
        return null;
    };

    // Util: deteksi single order sangat besar
    const findSingleWall = (levels) => {
        if (!levels || levels.length === 0) return null;
        const volumes = levels.map(l => parseFloat(l[1]));
        const maxVolume = Math.max(...volumes);
        const avgVolume = volumes.reduce((a, b) => a + b, 0) / volumes.length;

        if (maxVolume > avgVolume * 10) {
            const idx = volumes.findIndex(v => v === maxVolume);
            return {
                priceStart: parseFloat(levels[idx][0]),
                priceEnd: parseFloat(levels[idx][0]),
                totalVolume: maxVolume,
                levels: 1,
                wallType: 'Thick' // order tunggal besar = Thick
            };
        }
        return null;
    };

    // Util: klasifikasi dinding
    const classifyWall = (volume, mediumThreshold, thickThreshold) => {
        if (volume >= thickThreshold * 3) return 'Thick';
        if (volume >= mediumThreshold * 3) return 'Medium';
        return 'Thin';
    };

    const buyWallCluster = findWallCluster(bids);
    const sellWallCluster = findWallCluster(asks);
    const buyWallSingle  = findSingleWall(bids);
    const sellWallSingle = findSingleWall(asks);

    return {
        buyWall: buyWallCluster || buyWallSingle,
        sellWall: sellWallCluster || sellWallSingle
    };
}

// =======================================================
    function renderFullOrderBook(bids, asks, wallInfo, precision) {
        const numLevels = 10;
        if (!orderBookDOMElements) {
            let asksHtml = '';
            for (let i = 0; i < numLevels; i++) {
                asksHtml += `
                    <div class="flex items-center text-xs mt-1 relative z-0">
                        <div class="ask-bar absolute inset-0 bg-red-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                        <span class="ask-price w-1/2 text-left font-mono"></span>
                        <span class="ask-qty w-1/2 text-right font-mono"></span>
                    </div>
                `;
            }
            let bidsHtml = '';
            for (let i = 0; i < numLevels; i++) {
                bidsHtml += `
                    <div class="flex items-center text-xs mt-1 relative z-0">
                        <div class="bid-bar absolute inset-0 bg-green-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                        <span class="bid-qty w-1/2 text-left font-mono"></span>
                        <span class="bid-price w-1/2 text-right font-mono"></span>
                    </div>
                `;
            }

            fullOrderBookContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-red-500 font-bold">ASKs (Jual)</h4>
                        <div id="asks-container">${asksHtml}</div>
                    </div>
                    <div>
                        <h4 class="text-green-500 font-bold">BIDs (Beli)</h4>
                        <div id="bids-container">${bidsHtml}</div>
                    </div>
                </div>
                <p id="wall-info-text" class="text-center text-xs mt-4 text-gray-500"></p>
            `;
            
            // Simpan referensi ke elemen DOM
            orderBookDOMElements = {
                asks: Array.from(document.querySelectorAll('#asks-container > div')).map(row => ({
                    row, bar: row.querySelector('.ask-bar'), price: row.querySelector('.ask-price'), qty: row.querySelector('.ask-qty')
                })).reverse(), // Reverse asks agar sesuai dengan data
                bids: Array.from(document.querySelectorAll('#bids-container > div')).map(row => ({
                    row, bar: row.querySelector('.bid-bar'), price: row.querySelector('.bid-price'), qty: row.querySelector('.bid-qty')
                })),
                wallInfo: document.getElementById('wall-info-text')
            };
        }

        // --- LOGIKA UPDATE: HANYA PERBARUI TEKS DAN STYLE ---
        const totalMaxVolume = Math.max(
            ...bids.slice(0, numLevels).map(b => parseFloat(b[1])), 
            ...asks.slice(0, numLevels).map(a => parseFloat(a[1]))
        );

        // Update Asks
        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.asks[i];
            const data = asks[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.sellWall && price >= wallInfo.sellWall.priceStart && price <= wallInfo.sellWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `ask-price w-1/2 text-left font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-red-500' : 'text-red-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        // Update Bids
        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.bids[i];
            const data = bids[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.buyWall && price >= wallInfo.buyWall.priceStart && price <= wallInfo.buyWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `bid-price w-1/2 text-right font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-green-500' : 'text-green-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        // Update Wall Info Text
        let wallText = '';
        if (wallInfo.buyWall) {
            wallText += `<span class="text-green-500 font-bold">Dinding Beli ${wallInfo.buyWall.wallType.toUpperCase()}</span> terdeteksi dari ${formatPrice(wallInfo.buyWall.priceStart)} ke ${formatPrice(wallInfo.buyWall.priceEnd)} (Volume: $${(wallInfo.buyWall.totalVolume * parseFloat(bids[0][0])).toLocaleString('en-US', {notation: 'compact'})}) `;
        }
        if (wallInfo.sellWall) {
            wallText += `<span class="text-red-500 font-bold">Dinding Jual ${wallInfo.sellWall.wallType.toUpperCase()}</span> terdeteksi dari ${formatPrice(wallInfo.sellWall.priceStart)} ke ${formatPrice(wallInfo.sellWall.priceEnd)} (Volume: $${(wallInfo.sellWall.totalVolume * parseFloat(asks[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        orderBookDOMElements.wallInfo.innerHTML = wallText;
    }

// --- 7. CHART RENDERING ENGINE (REBUILT) ---   
    function getChartBaseOptions(height) {
        const isDarkMode = document.documentElement.classList.contains('dark');
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 48, // Parent padding
            height: height,
            layout: { background: { color: isDarkMode ? '#0e0d0d' : '#FFFFFF' }, textColor: isDarkMode ? '#D1D5DB' : '#374151' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                secondsVisible: false, 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                // [PERBAIKAN] Mengoptimalkan drag untuk panning
                lockVisibleTimeRangeOnResize: true,
                rightOffset: -30, // chart offset
                barSpacing: 6,
                minBarSpacing: 3,
                horzTouchDrag: true, 
                vertTouchDrag: false, 
                mouseScroll: false, // Menonaktifkan mouse scroll zoom
                pinchToZoom: true, // Membiarkan pinch-to-zoom di mobile
                tickMarkFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format ke jam:menit menggunakan timezone default browser pengguna
                    return date.toLocaleTimeString('id-ID', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
            },
            crosshair: { 
                mode: LightweightCharts.CrosshairMode.Normal,
                horzLine: {
                    visible: true,
                    labelVisible: true
                },
                vertLine: {
                    visible: true,
                    labelVisible: true
                }
            },
            rightPriceScale: { 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                visible: true,
                scaleMargins: {
                    top: 0.1,
                    bottom: 0.1
                }
            },
            localization: {
                timeFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format waktu yang lebih lengkap untuk tooltip, menggunakan timezone lokal
                    return date.toLocaleString('id-ID', {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        timeZone: 'Asia/Jakarta'
                    });
                }
            }
        };
    }
// =======================================================
    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if(!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (chart !== otherChart && otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }
   
// [PERBAIKAN] FUNGSI renderAllCharts dengan logika perbaikan
    function renderAllCharts() {
        if (!analysisCache.klines) return;
        
        destroyCharts();

        const { klines, calculatedData } = analysisCache;
        const closes = klines.map(k => parseFloat(k[4]));
        
        const formattedKlines = klines
            .filter(k => k && k.length >= 5 && k.slice(1, 5).every(v => v !== null && !isNaN(parseFloat(v))))
            .map(d => ({ 
                time: d[0] / 1000,
                open: parseFloat(d[1]), 
                high: parseFloat(d[2]), 
                low: parseFloat(d[3]), 
                close: parseFloat(d[4]), 
                volume: parseFloat(d[5])
            }));
        
        if (formattedKlines.length === 0) return;

        const formatLineData = (data, klineData, offset = 5) => data
            .map((value, index) => {
                const klineIndex = index + offset;
                if (klineData[klineIndex]) {
                    const time = klineData[klineIndex][0] / 1000;
                    return { time, value };
                }
                return null;
            })
            .filter(d => d && d.value !== undefined && d.value !== null && !isNaN(d.value));

        const rocPlotData = calculateROC_forPlot(closes, 12);
        const ema50PlotData = formatLineData(calculateEMA(closes, 50), klines);
        const bbPlotData = calculateBollingerBands_forPlot(closes, 20, 2, klines);
        const macdData = calculatedData.macd;
        const macdLinePlotData = formatLineData(macdData.macdLine, klines);
        const signalLinePlotData = formatLineData(macdData.signalLine, klines, (userSettings.indicator.macd_slow - 1));
        const histogramPlotData = macdData.histogram
            .map((item, index) => {
                if (klines[index] && item !== undefined) {
                    return {
                        time: klines[index][0] / 1000, // <-- MENGGUNAKAN WAKTU UTC ASLI
                        value: item.value,
                        color: item.color
                    };
                }
                return null;
            })
            .filter(d => d);
        const volumePlotData = formattedKlines.map(d => ({
            time: d.time,
            value: d.volume,
            color: d.close >= d.open ? 'rgba(4, 150, 120, 0.5)' : 'rgba(220, 50, 80, 0.5)'
        }));

        
        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);
        candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
        candlestickSeries.setData(formattedKlines);        
        mainChart.addLineSeries({ color: 'yellow', lineWidth: 2, priceLineVisible: false, lastValueVisible: true, title: '' }).setData(ema50PlotData);
        mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.upper);
        mainChart.addLineSeries({ color: 'white', lineWidth: 2, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.middle);
        mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lastValueVisible: false, title: '' }).setData(bbPlotData.lower);
        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100)); // Tinggi lebih kecil
        charts.push(volumeChart);
        volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } }).setData(volumePlotData);        
        const vpvr = calculatedData.vpvr;
            if (vpvr.poc > 0) candlestickSeries.createPriceLine({ price: vpvr.poc, color: '#fbbf24', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Solid, axisLabelVisible: true, title: 'P' });
            if (vpvr.vah > 0) candlestickSeries.createPriceLine({ price: vpvr.vah, color: '#F4511E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'H' });
            if (vpvr.val > 0) candlestickSeries.createPriceLine({ price: vpvr.val, color: '#399BC8', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'L' });        
        const pivots = calculatedData.pivot.data;
            if (pivots) {
                candlestickSeries.createPriceLine({ price: pivots.P, color: '#ffc107', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Solid, axisLabelVisible: true, title: 'Piv' });
                candlestickSeries.createPriceLine({ price: pivots.R1, color: '#f44336', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'R1' });
                candlestickSeries.createPriceLine({ price: pivots.S1, color: '#4caf50', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'S1' });
            }

        // 2. Tampilkan VWAP
        const vwapValue = calculatedData.vwap.value;
            if (vwapValue > 0) {
                candlestickSeries.createPriceLine({ price: vwapValue, color: '#03a9f4', lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: 'VW' });
            }

        // 3. Tampilkan Ichimoku Cloud
        const ichimokuData = calculatedData.ichimoku.data;
            if (ichimokuData) {
                const KijunP = 26; // Periode Kijun untuk offset
                
                // Format data untuk Senkou A dan B yang digeser ke depan
                const senkouA_plot = ichimokuData.senkouA.map((val, idx) => klines[idx + KijunP] ? { time: klines[idx + KijunP][0] / 1000, value: val } : null).filter(Boolean);
                const senkouB_plot = ichimokuData.senkouB.map((val, idx) => klines[idx + KijunP] ? { time: klines[idx + KijunP][0] / 1000, value: val } : null).filter(Boolean);
                
                const cloudSeriesA = mainChart.addAreaSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, lineWidth: 1, color: 'rgba(38, 166, 154, 0.2)' });
                const cloudSeriesB = mainChart.addAreaSeries({ priceLineVisible: false, lastValueVisible: false, crosshairMarkerVisible: false, lineWidth: 1, color: 'rgba(239, 83, 80, 0.2)' });
                cloudSeriesA.setData(senkouA_plot);
                cloudSeriesB.setData(senkouB_plot);

                // Tampilkan Tenkan & Kijun
                mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false, lastValueVisible: false }).setData(formatLineData(ichimokuData.tenkan, klines));
                mainChart.addLineSeries({ color: '#D50000', lineWidth: 1, priceLineVisible: false, lastValueVisible: false }).setData(formatLineData(ichimokuData.kijun, klines));
            }
        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(150));
        charts.push(rsiChart);
        const rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2, lastValueVisible: true, priceLineVisible: false });
        rsiSeries.setData(formatLineData(calculatedData.rsi.values, klines));
        rsiSeries.createPriceLine({ price: 70, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });
        rsiSeries.createPriceLine({ price: 30, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(150));
        charts.push(stochChart);
        const stochData = calculatedData.stoch;
        const stochKSeries = stochChart.addLineSeries({ color: '#2196F3', lineWidth: 2, title: '', lastValueVisible: true, priceLineVisible: false });
        stochKSeries.setData(formatLineData(stochData.kLine, klines, stochData.dOffset));
        stochChart.addLineSeries({ color: '#FF9800', lineWidth: 2, title: '', lastValueVisible: true, priceLineVisible: false }).setData(formatLineData(stochData.dLine, klines, stochData.dOffset));
        stochKSeries.createPriceLine({ price: 80, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });
        stochKSeries.createPriceLine({ price: 20, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '' });

        // [PERBAIKAN] Menggunakan nama fungsi yang benar: getChartBaseOptions
        const rocChart = LightweightCharts.createChart(document.getElementById('roc-chart-container'), getChartBaseOptions(150));
        charts.push(rocChart);
        const rocSeries = rocChart.addLineSeries({ color: '#f472b6', lineWidth: 2, lastValueVisible: true, priceLineVisible: false });
        rocSeries.setData(rocPlotData);
        rocSeries.createPriceLine({ price: 0, color: '#9E9E9E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: '0' });        
        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(150));
        charts.push(macdChart);
        macdChart.addHistogramSeries({ base: 0 }).setData(histogramPlotData);
        macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: 'MACD', lastValueVisible: false, priceLineVisible: false }).setData(macdLinePlotData);
        macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: 'Signal', lastValueVisible: false, priceLineVisible: false }).setData(signalLinePlotData);
        const allCharts = [mainChart, volumeChart, rsiChart, stochChart, macdChart, rocChart];
        
        // Sinkronisasi Crosshair dan Time Range
        syncCharts(...allCharts);

        const initialRange = mainChart.timeScale().getVisibleRange();
        if (initialRange) {
            allCharts.forEach(chart => {
                if (chart !== mainChart && chart) {
                    chart.timeScale().setVisibleRange(initialRange);
                }
            });
        }
    }
    
// [PERBAIKAN] Fungsi kalkulasi untuk plotting Bollinger Bands
    function calculateBollingerBands_forPlot(closes, period = 20, stdDev = 2, klines) {
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const middle = calculateSMA(closes, period);
        const upper = [], middleData = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                continue;
            }
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            const time = klines[i][0] / 1000;
            upper.push({ time, value: middle[i] + (stdev * stdDev) });
            lower.push({ time, value: middle[i] - (stdev * stdDev) });
            middleData.push({ time, value: middle[i] });
        }
        return { upper: upper.filter(d => d), middle: middleData.filter(d => d.value !== undefined), lower: lower.filter(d => d) };
    }
// =======================================================
    function calculateROC_forPlot(closes, period = 12) {
        if (closes.length < period + 1) return [];
        const rocData = [];
        for (let i = period; i < closes.length; i++) {
            const currentClose = closes[i];
            const pastClose = closes[i - period];
            if (pastClose !== 0) {
                const roc = ((currentClose - pastClose) / pastClose) * 100;
                rocData.push({ time: analysisCache.klines[i][0] / 1000, value: roc });
            }
        }
        return rocData;
    }

    // [PERBAIKAN] Fungsi kalkulasi Linear Regression Channel
    function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
        const closes = klines.map(k => parseFloat(k[4]));
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const upper = [], middle = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            const y = closes.slice(i - period + 1, i + 1);
            const n = period; 
            const sumX = (n * (n - 1)) / 2;
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
            const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate Standard Deviation from regression error
            let sumErrSq = 0;
            for (let j = 0; j < n; j++) {
                const predictedY = intercept + slope * j;
                sumErrSq += Math.pow(y[j] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middleValue = intercept + slope * (n - 1);
            middle.push({ time: klines[i][0] / 1000, value: middleValue });
            upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
            lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) }); 
        }
        return { upper, middle, lower };
    }

    // Fungsi baru untuk mendeteksi pola harga pada Bollinger Bands
    function analyzeBollingerBandsPriceAction(klines, bbData) {
        if (!klines || klines.length < 2 || !bbData || bbData.upper.length < 2) {
            return { rejection: 'Tidak Ada', walkTheBands: 'Tidak Ada' };
        }

        const lastKline = klines[klines.length - 1];
        const prevKline = klines[klines.length - 2];
        const lastUpper = bbData.upper.pop()?.value;
        const lastLower = bbData.lower.pop()?.value;
        const prevUpper = bbData.upper.pop()?.value;
        const prevLower = bbData.lower.pop()?.value;

        const lastClose = parseFloat(lastKline[4]);
        const prevClose = parseFloat(prevKline[4]);

        let rejection = 'Tidak Ada';
        // Logika Rejection Bullish
        if (prevClose < prevLower && lastClose > lastLower && lastClose > prevClose) {
            rejection = 'Bullish Rejection (Lower BB)';
        }
        // Logika Rejection Bearish
        if (prevClose > prevUpper && lastClose < lastUpper && lastClose < prevClose) {
            rejection = 'Bearish Rejection (Upper BB)';
        }

        let walkTheBands = 'Tidak Ada';
        // Logika Walk the Bands Bullish
        if (lastClose >= lastUpper && prevClose >= prevUpper) {
            walkTheBands = 'Bullish (Upper BB)';
        }
        // Logika Walk the Bands Bearish
        if (lastClose <= lastLower && prevClose <= prevLower) {
            walkTheBands = 'Bearish (Lower BB)';
        }
        
        return { rejection, walkTheBands };
    }
// =======================================================
    function destroyCharts() {
    // 1. Hapus semua chart utama (LightweightCharts)
        charts.forEach(chart => {
            if (chart) {
                chart.remove();
            }
        });
        charts = [];
        candlestickSeries = null;
        
        // 2. Kosongkan HANYA kontainer chart utama
        const mainChartContainers = [
            'main-chart-container', 
            'rsi-chart-container', 
            'stoch-chart-container', 
            'macd-chart-container',
            'roc-chart-container'
        ];
        mainChartContainers.forEach(id => {
            const container = document.getElementById(id);
            if (container) {
                container.innerHTML = '';
            }
        });
    }
// =======================================================
    // HAPUS SEMUA VERSI LAMA DARI processQueues DAN GANTI DENGAN INI:

const processQueues = () => {
    // 1. Proses Antrian Kline (Candlestick) dengan aman
    if (klineQueue.length > 0) {
        try {
            const latestKlineMessage = klineQueue.pop();
            klineQueue = [];
            if (candlestickSeries && latestKlineMessage) {
                const candle = latestKlineMessage.k;
                const formattedCandle = {
                    time: candle.t / 1000,
                    open: parseFloat(candle.o), high: parseFloat(candle.h),
                    low: parseFloat(candle.l), close: parseFloat(candle.c)
                };
                candlestickSeries.update(formattedCandle);
                if (candle.x) {
                    analysisCache.klines.shift();
                    analysisCache.klines.push([candle.t, candle.o, candle.h, candle.l, candle.c, candle.v, candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B]);
                    updateRealTimeIndicators(analysisCache.klines);
                }
            }
        } catch (error) {
            console.error("Error saat memproses kline:", error);
        }
    }

    // 2. Proses Antrian Trade (untuk CVD dan Harga Live) dengan aman
    if (tradeQueue.length > 0) {
        try {
            const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
            // <<< LOGIKA LENGKAP DIMASUKKAN DI SINI >>>
            tradesToProcess.forEach(trade => {
                const quantity = parseFloat(trade.q);
                const price = parseFloat(trade.p);
                const navPriceEl = document.getElementById('nav-price');
                const navIdrEl = document.getElementById('nav-price-idr');
                if (navPriceEl && navIdrEl) {
                    navPriceEl.textContent = formatPrice(price);
                    navIdrEl.textContent = `Rp ${(price * (analysisCache.usdToIdrRate || 0)).toLocaleString('id-ID', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
                }
                if (cvdChartInstance) {
                    if (isNaN(quantity) || quantity === 0) return;
                    const sign = trade.m ? -1 : 1;
                    liveCvdValue += quantity * sign;
                    liveCvdValueUsdt += (quantity * price) * sign;
                    const newPoint = { x: trade.T, y_coin: liveCvdValue, y_usdt: liveCvdValueUsdt };
                    cvdChartInstance.data.datasets[0].data.push(newPoint);
                    liveCvdData.push(newPoint);
                    while (cvdChartInstance.data.datasets[0].data.length > 300) {
                        cvdChartInstance.data.datasets[0].data.shift();
                        liveCvdData.shift();
                    }
                    cvdChartInstance.update('none');
                    updateCvdTableLive();
                }
            });
        } catch (error) {
            console.error("Error saat memproses trade:", error);
        }
    }

    // 3. Proses Antrian Depth (Order Book) dengan aman
    if (depthQueue.length > 0) {
        try {
            const updatesToProcess = depthQueue.splice(0, depthQueue.length);
            // <<< LOGIKA LENGKAP DIMASUKKAN DI SINI >>>
            updatesToProcess.forEach(update => {
                if (update.b) {
                    update.b.forEach(([price, qty]) => {
                        const existingIndex = latestBids.findIndex(bid => bid[0] === price);
                        if (parseFloat(qty) === 0) {
                            if (existingIndex !== -1) latestBids.splice(existingIndex, 1);
                        } else {
                            if (existingIndex !== -1) latestBids[existingIndex] = [price, qty];
                            else latestBids.push([price, qty]);
                        }
                    });
                }
                if (update.a) {
                    update.a.forEach(([price, qty]) => {
                        const existingIndex = latestAsks.findIndex(ask => ask[0] === price);
                        if (parseFloat(qty) === 0) {
                            if (existingIndex !== -1) latestAsks.splice(existingIndex, 1);
                        } else {
                            if (existingIndex !== -1) latestAsks[existingIndex] = [price, qty];
                            else latestAsks.push([price, qty]);
                        }
                    });
                }
            });
            latestBids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
            latestAsks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
            const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
            const precision = getPrecisionForAsset(parseFloat(latestPrice));
            const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
            renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
        } catch (error) {
            console.error("Error saat memproses depth:", error);
        }
    }
};



function populateCurrentStateWidget() {
    const { tickerData, coinGeckoData, usdToIdrRate, globalData, openInterestData, fundingRateData, binanceSymbol } = analysisCache;
    
    // Mengisi Navigasi Atas
    document.getElementById('nav-symbol').textContent = binanceSymbol;
    const navChange24hEl = document.getElementById('nav-change-24h');
    const navChange1hEl = document.getElementById('nav-change-1h');
    
    const change24h = parseFloat(tickerData.priceChangePercent);
    if (navChange24hEl) {
        navChange24hEl.textContent = `${change24h.toFixed(2)}%`;
        navChange24hEl.className = `font-semibold ${change24h >= 0 ? 'positive' : 'negative'}`;
    }
    
    if (navChange1hEl && coinGeckoData?.market_data) {
        const change1h = coinGeckoData.market_data.price_change_percentage_1h_in_currency.usd || 0;
        navChange1hEl.textContent = `${change1h.toFixed(2)}%`;
        navChange1hEl.className = `font-semibold ${change1h >= 0 ? 'positive' : 'negative'}`;
    }
    navVolume24h.textContent = `$${parseFloat(tickerData.quoteVolume).toLocaleString('en-US', { notation: 'compact' })}`;
    if (coinGeckoData?.market_data) {
        navAth.textContent = formatPrice(coinGeckoData.market_data.ath.usd);
        navAtl.textContent = formatPrice(coinGeckoData.market_data.atl.usd);
    }

    // Mengisi Kartu DATA DASAR yang Disederhanakan
    if (coinGeckoData?.market_data) {
        document.getElementById('market-cap').textContent = formatPrice(coinGeckoData.market_data.market_cap.usd);
    }
    if (globalData?.data) {
        document.getElementById('btc-dominance').textContent = `${globalData.data.market_cap_percentage.btc.toFixed(2)}%`;
    }

    // Mengisi Bagian Lain yang Masih Ada di Dasbor
    document.getElementById('current-state-title').innerHTML = `<span class="text-yellow-500 font-semibold">💲 ${binanceSymbol}</span>`;
    document.getElementById('range-24h').textContent = `${formatPrice(parseFloat(tickerData.lowPrice)).replace('$', '')} - ${formatPrice(parseFloat(tickerData.highPrice)).replace('$', '')}`;
    
    const futuresContainer = document.getElementById('futures-data-container');
    const price = parseFloat(tickerData.lastPrice);
    if (marketTypeSelect.value === 'futures' && openInterestData && fundingRateData) {
        futuresContainer.classList.remove('hidden');
        document.getElementById('open-interest').textContent = `$${(parseFloat(openInterestData.openInterest) * price).toLocaleString('en-US', { notation: 'compact' })}`;
        document.getElementById('funding-rate').textContent = `${(parseFloat(fundingRateData.lastFundingRate) * 100).toFixed(4)}%`;
        if (fundingRateData.nextFundingTime) {
            startFundingRateTimer(fundingRateData.nextFundingTime);
        } else {
            document.getElementById('funding-rate-interval').textContent = '-';
        }
    } else {
        futuresContainer.classList.add('hidden');
    }
}
    function renderCvdChart() {
        const { cvdData } = analysisCache;
        if (!cvdData || cvdData.length === 0) return;

        // Inisialisasi data live dengan format baru yang lengkap
        liveCvdData = cvdData.map(d => ({ 
            x: d.time * 1000, 
            y_coin: d.cvd_coin,
            y_usdt: d.cvd_usdt 
        }));
        
        // Inisialisasi nilai kumulatif terakhir
        if (liveCvdData.length > 0) {
            const lastPoint = liveCvdData[liveCvdData.length - 1];
            liveCvdValue = lastPoint.y_coin;
            liveCvdValueUsdt = lastPoint.y_usdt;
        }

        const ctx = document.getElementById('cvdChart').getContext('2d');
        if (cvdChartInstance) cvdChartInstance.destroy();
        
        const isDarkMode = document.documentElement.classList.contains('dark');
        const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
        const negativeColor = isDarkMode ? '#f87171' : '#dc2626';

        cvdChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'CVD (USDT)',
                    data: liveCvdData,
                    parsing: {
                        yAxisKey: 'y_usdt' // <-- PENTING: Memberitahu chart untuk menggunakan nilai USDT
                    },
                    fill: false, tension: 0.1, pointRadius: 0, borderWidth: 2,
                    segment: {
                        borderColor: ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor,
                    }
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'time', time: { tooltipFormat: 'MMM dd, HH:mm:ss', unit: 'second' }, grid: { display: false }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563', source: 'auto', maxRotation: 0, autoSkip: true } },
                    y: { grid: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563' } }
                },
                plugins: { legend: { display: false } },
                interaction: { mode: 'index', intersect: false }
            }
        });

        // Perbarui tabel dengan data awal
        updateCvdTableLive(liveCvdData);
    }
    
    const reconnectDelay = 5000; // Coba sambung kembali setiap 5 detik

// --- FUNGSI KALKULASI BARU ---

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { value: 0, status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { value: 0, status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { value: roc, status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { value: 0, status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { value: sar, status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }

    function calculateLinearRegressionChannel(closes, period = 14, stdDev = 2) {
        if (closes.length < period) return { upper: 0, middle: 0, lower: 0, status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        // Calculate Standard Deviation from regression error
        let sumErrSq = 0;
        for (let i = 0; i < n; i++) {
            const predictedY = intercept + slope * i;
            sumErrSq += Math.pow(y[i] - predictedY, 2);
        }
        const stdErr = Math.sqrt(sumErrSq / (n - 2));

        const middle = intercept + slope * (n - 1);
        const upper = middle + (stdDev * stdErr);
        const lower = middle - (stdDev * stdErr);
        
        const lastClose = closes[closes.length - 1];
        let status = "In Channel";
        if(lastClose > upper) status = "Upper Line Channel";
        if(lastClose < lower) status = "Lower Line Channel";

        return { upper, middle, lower, status };
    }
// [BARU] Tambahkan fungsi yang hilang ini untuk plot PSAR
    function calculateParabolicSAR_forPlot(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return [];
        let sar = parseFloat(klines[0][3]);
        let ep = parseFloat(klines[0][2]);
        let af = step;
        let isUptrend = true;
        const sarData = [];

        for (let i = 1; i < klines.length; i++) {
            const time = klines[i][0] / 1000;
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevSar = sar;

            if (isUptrend) {
                sar = prevSar + af * (ep - prevSar);
                if (low < sar) {
                    isUptrend = false;
                    sar = ep;
                    ep = low;
                    af = step;
                } else {
                    if (high > ep) {
                        ep = high;
                        af = Math.min(max, af + step);
                    }
                }
            } else { // Downtrend
                sar = prevSar - af * (prevSar - ep);
                if (high > sar) {
                    isUptrend = true;
                    sar = ep;
                    ep = high;
                    af = step;
                } else {
                    if (low < ep) {
                        ep = low;
                        af = Math.min(max, af + step);
                    }
                }
            }
            sarData.push({ time, value: sar });
        }
        return sarData;
    }
 
    // Salin dan tempel fungsi utilitas dan kalkulasi yang dibutuhkan dari projector.html
    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) {
                obv.push(obv[i - 1] + volume);
            } else if (close < prevClose) {
                obv.push(obv[i - 1] - volume);
            } else {
                obv.push(obv[i - 1]);
            }
        }
        return obv;
    };

    // DENGAN FUNGSI BARU INI
function calculateVWAP(klines, mode = 'rolling', period = 20) {
    if (!klines || klines.length === 0) return 0;

    let sumPV = 0; // sum(Price * Volume)
    let sumV = 0;  // sum(Volume)
    let vwapValues = [];

    if (mode === 'rolling') {
        const recentKlines = klines.slice(-period);
        recentKlines.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;

    } else if (mode === 'session') {
        const todayUTC = new Date().toISOString().slice(0, 10);
        const sessionKlines = klines.filter(k => new Date(k[0]).toISOString().slice(0, 10) === todayUTC);
        if (sessionKlines.length === 0) return 0; // Tidak ada data untuk sesi hari ini
        
        sessionKlines.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;

    } else if (mode === 'anchored') {
        const anchorLookback = 200; // Mencari titik terendah dalam 200 candle terakhir
        const recentSlice = klines.slice(-anchorLookback);
        if (recentSlice.length === 0) return 0;

        let lowestLow = Infinity;
        let anchorIndex = -1;
        
        recentSlice.forEach((k, index) => {
            const low = parseFloat(k[3]);
            if (low < lowestLow) {
                lowestLow = low;
                anchorIndex = klines.length - anchorLookback + index;
            }
        });

        const anchoredKlines = klines.slice(anchorIndex);
        anchoredKlines.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;
    }
    return 0; // Fallback
}

    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR KORELASI (MULAI) ==
    // =======================================================
    function calculateCorrelation(dataX, dataY) {
        if (dataX.length !== dataY.length || dataX.length === 0) {
            return null;
        }
        const n = dataX.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += dataX[i];
            sumY += dataY[i];
            sumXY += dataX[i] * dataY[i];
            sumX2 += dataX[i] * dataX[i];
            sumY2 += dataY[i] * dataY[i];
        }

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        if (denominator === 0) {
            return 0; // Tidak ada variasi, korelasi netral
        }
        
        return numerator / denominator;
    }

    /**
     * Mengisi widget korelasi dengan data dari analysisCache.
     */
    function populateCorrelationWidget() {
        const valueEl = document.getElementById('correlation-value');
        const textEl = document.getElementById('correlation-text');
        
        const correlationData = analysisCache.correlationData;

        if (correlationData === null || correlationData === undefined) {
            valueEl.textContent = '-';
            textEl.textContent = 'Data tidak cukup untuk menghitung korelasi.';
            valueEl.className = 'text-lg font-sbold text-gray-400 dark:text-gray-500';
            return;
        }

        const value = correlationData;
        valueEl.textContent = value.toFixed(2);

        let text = 'Tidak Ada Korelasi';
        let colorClass = 'text-gray-400 dark:text-gray-500';

        if (value >= 0.7) { text = 'Korelasi Positif Kuat'; colorClass = 'positive'; } 
        else if (value >= 0.4) { text = 'Korelasi Positif Sedang'; colorClass = 'positive'; } 
        else if (value >= 0.1) { text = 'Korelasi Positif Lemah'; colorClass = 'text-yellow-400'; } 
        else if (value <= -0.7) { text = 'Korelasi Negatif Kuat'; colorClass = 'negative'; } 
        else if (value <= -0.4) { text = 'Korelasi Negatif Sedang'; colorClass = 'negative'; } 
        else if (value <= -0.1) { text = 'Korelasi Negatif Lemah'; colorClass = 'text-yellow-400'; }
        
        textEl.textContent = text;
        valueEl.className = `text-lg font-semibold ${colorClass}`;
    }

    // =======================================================
    // == BLOK FUNGSI BARU UNTUK FITUR KORELASI (SELESAI) ==
    // =======================================================
// === FUNGSI RESET BARU ===
    function resetDashboard() {
        console.log("Mereset dasbor...");
        // Hentikan semua proses real-time
        WebSocketManager.resetSubscriptions();
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (fundingRateTimer) clearInterval(fundingRateTimer);
        
        // Sembunyikan dasbor & tampilkan placeholder
        dashboardContent.classList.add('hidden');
        initialPlaceholder.classList.remove('hidden');

        // Sembunyikan elemen navigasi
        document.getElementById('nav-info-container').classList.add('hidden');
        document.getElementById('nav-stats-container').classList.add('hidden');
        document.getElementById('trade-link').classList.add('hidden');
        
        // Hancurkan chart & reset state
        destroyCharts();
        analysisCache = {};
        klineCache = {}; // Kosongkan juga cache kline
        
        // Gulir kembali ke atas
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    // =======================================================
    function updateVwapDisplay(mode) {
        if (!analysisCache.klines) return;
        
        // Gunakan klines yang sesuai dengan timeframe
        const vwapValue = calculateVWAP(analysisCache.klines, mode);
        const lastPrice = parseFloat(analysisCache.tickerData.lastPrice);
        
        // Simpan ke cache untuk digunakan oleh skor konfluensi dan AI
        analysisCache.calculatedData.vwap = {
            status: lastPrice > vwapValue ? 'Bullish' : 'Bearish',
            value: vwapValue
        };
        
        // Perbarui tampilan di panel Data Timeframe
        document.getElementById('vwap-20d').textContent = formatPrice(vwapValue);

        // Panggil ulang update skor konfluensi agar ikut berubah
        updateQuickConfluenceWidget();
    }
    // =======================================================
    // BAGIAN 5: EVENT LISTENER UTAMA  
    // =======================================================  
    document.addEventListener('DOMContentLoaded', () => {
        fetchTopMovers();
        loadSettings();
        loadWatchlist();
        scanWatchlist();
        adjustContentPadding();
        setupToggle('toggle-market-state-btn', 'current-state-content-wrapper', 'toggle-market-state-icon', true);
        setupToggle('toggle-confluence-btn', 'confluence-content-wrapper', 'toggle-confluence-icon', false);
        setupToggle('toggle-onchain-btn', 'onchain-content-wrapper', 'toggle-onchain-icon', false);        
        setupToggle('toggle-settings-btn', 'settings-content-wrapper', 'toggle-settings-icon', false);
        setupToggle('toggle-ai-verdict-btn', 'ai-verdict-content-wrapper', 'toggle-ai-verdict-icon', true);
        window.addEventListener('resize', adjustContentPadding); 
        document.getElementById('save-settings-btn').addEventListener('click', saveSettings);
        
        themeToggleBtn.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            darkIcon.classList.toggle('hidden');
            lightIcon.classList.toggle('hidden');
            localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                if (isChartsVisible) { 
                    destroyCharts();
                    renderAllCharts();
                }
                if (cvdChartInstance) {
                    const isDarkMode = document.documentElement.classList.contains('dark');
                    const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
                    const negativeColor = isDarkMode ? '#f87171' : '#dc2626';
                    cvdChartInstance.data.datasets[0].segment.borderColor = ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor;
                    cvdChartInstance.options.scales.x.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                    cvdChartInstance.options.scales.y.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                    cvdChartInstance.options.scales.y.grid.color = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                    cvdChartInstance.update();
                }
        });

        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
            darkIcon.classList.remove('hidden');
        } else {
            lightIcon.classList.remove('hidden');
        }

        apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
        apiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', apiKeyInput.value));
        analyzeBtn.addEventListener('click', runFullAnalysis);
        assetInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') runFullAnalysis(); });

        document.getElementById('vwap-mode-buttons').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const mode = e.target.dataset.mode;
                document.querySelectorAll('.vwap-mode-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                updateVwapDisplay(mode);
            }
        });

        document.getElementById('run-comprehensive-ai-btn').addEventListener('click', runComprehensiveAIAnalysis);
        
        tradeLink.addEventListener('click', (e) => {
            e.preventDefault();
            const binanceSymbol = analysisCache.binanceSymbol;
            if (!binanceSymbol) return;
            const marketType = marketTypeSelect.value;
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            const desktopUrl = marketType === 'futures' ? `https://www.binance.com/en/futures/${binanceSymbol}` : `https://www.binance.com/en/trade/${binanceSymbol}`;
            const mobileUrl = marketType === 'futures' ? `binance://futures/trade?symbol=${binanceSymbol}` : `binance://trade?symbol=${binanceSymbol}`;
            if (isMobile) {
                window.location.href = mobileUrl;
                setTimeout(() => { window.location.href = desktopUrl; }, 1500);
            } else {
                window.open(desktopUrl, '_blank');
            }
        });

        marketTypeSelect.addEventListener('change', () => initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message)));
        initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message));
        toggleChartsBtn.addEventListener('click', () => toggleChartsVisibility());
        saveWatchlistBtn.addEventListener('click', saveWatchlist);
        scanWatchlistBtn.addEventListener('click', scanWatchlist);
        resetBtn.addEventListener('click', resetDashboard);
        const tooltipElement = document.createElement('div');
        tooltipElement.id = 'custom-tooltip';
        document.body.appendChild(tooltipElement);

        const showTooltip = (e) => {
            const target = e.currentTarget;
            const tooltipContent = target.getAttribute('data-tooltip');
            if (!tooltipContent) return;
            
            const [title, ...body] = tooltipContent.split('|');
            const formattedContent = `<strong>${title}</strong><p>${body.join('<br>')}</p>`;
            tooltipElement.innerHTML = formattedContent;

            const targetRect = target.getBoundingClientRect();
            tooltipElement.style.opacity = '1';
            tooltipElement.style.visibility = 'visible';
            
            const tooltipRect = tooltipElement.getBoundingClientRect();
            let top = targetRect.top - tooltipRect.height - 10;
            let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);

            if (left < 10) left = 10;
            if (left + tooltipRect.width > window.innerWidth - 10) {
                left = window.innerWidth - tooltipRect.width - 10;
            }
            if (top < 10) {
                top = targetRect.bottom + 10;
                tooltipElement.style.setProperty('--arrow-top', '-6px');
                tooltipElement.style.setProperty('--arrow-border-color', 'transparent transparent #2d3748 transparent');
            } else {
                tooltipElement.style.setProperty('--arrow-top', '100%');
                tooltipElement.style.setProperty('--arrow-border-color', '#2d3748 transparent transparent transparent');
            }

            tooltipElement.style.left = `${left}px`;
            tooltipElement.style.top = `${top + window.scrollY}px`;
        };

        const hideTooltip = () => {
            tooltipElement.style.opacity = '0';
            tooltipElement.style.visibility = 'hidden';
        };

        const triggers = document.querySelectorAll('[data-tooltip]');
        triggers.forEach(trigger => {
            trigger.classList.add('tooltip-trigger');
            trigger.addEventListener('mouseenter', showTooltip);
            trigger.addEventListener('mouseleave', hideTooltip);
            
            let isTooltipVisible = false;
            trigger.addEventListener('click', (e) => {
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    e.preventDefault();
                    if (!isTooltipVisible) {
                        showTooltip(e);
                        isTooltipVisible = true;
                    } else {
                        hideTooltip();
                        isTooltipVisible = false;
                    }
                }
            });
        });

        document.body.addEventListener('click', (e) => {
            if (!e.target.hasAttribute('data-tooltip')) {
                hideTooltip();
                triggers.forEach(trigger => trigger.isTooltipVisible = false);
            }
        }, true);
    });
</script>

</body>
</html>