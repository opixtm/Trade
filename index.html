 <!DOCTYPE html>
<html lang="id" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASHBOARD</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF7;
            color: #342d27;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .card {
            background-color: #FFFFFF;
            border: 1px solid #EAE5E0;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            transition: all 0.3s ease-in-out;
        }
        .btn-primary {
            background-color: #c97c00;
            color: #2b2a28;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary:hover { background-color: #eb9413 }
        .btn-primary:disabled { background-color: #333333; cursor: not-allowed; }
        .input-primary {
            background-color: #F8F5F1;
            border: 1px solid #DCD6CF;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #3D352E;
        }
        .input-primary:focus {
            outline: none;
            border-color: #747462;
            box-shadow: 0 0 0 2px rgba(34, 55, 40, 0.2);
        }
        .tag { padding: 0.25rem 0.625rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; }
        .tag-green { background-color: #E6F4EA; color: #4A7C59; }
        .tag-red { background-color: #FCE8E8; color: #A83A3A; }
        .tag-yellow { background-color: #FFF8E1; color: #B5840F; }
        .tag-gray { background-color: #F1F3F4; color: #5F6368; }

        /* Dark Mode Styles */
        .dark body { background-color: #000000; color: #E0E0E0; }
        .dark .card { background-color: #151414; border-color: #333; }
        .dark .input-primary { background-color: #1c1b1b; border-color: #444; color: #E0E0E0; }
        .dark .input-primary:focus { border-color: #2b2d2b; box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.3); }
        .dark .tag-green { background-color: rgba(74, 124, 89, 0.2); color: #69b37f; }
        .dark .tag-red { background-color: rgba(168, 58, 58, 0.2); color: #d17474; }
        .dark .tag-yellow { background-color: rgba(181, 132, 15, 0.2); color: #e0c273; }
        .dark .tag-gray { background-color: rgba(95, 99, 104, 0.2); color: #9aa0a6; }
        .dark .text-gray-800 { color: #E0E0E0; }
        .dark .text-gray-500 { color: #d8d2d2; }
        .dark .text-gray-600 { color: #dddddd; }
        .dark .text-gray-700 { color: #e0e0e0; }
        .dark hr { border-color: #3e4946; }
        .dark .positive { color: #69b37f; }
        .dark .negative { color: #d17474; }


        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px; 
        }

        .dot {
            width: 14px;
            height: 14px;
            background-color: #e1e1e1; 
            border-radius: 50%;
            animation: bounce 1.0s infinite ease-in-out both;
        }

        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1.5);
            }
        }
        
        .positive { color: #16a34a; }
        .dark .positive { color: #4ade80; }
        .negative { color: #dc2626; }
        .dark .negative { color: #f87171; }
        .blinking-text-animation { animation: blinking-text 1.0s infinite; }
        @keyframes blinking-text { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        #button-loader .dot {
            width: 8px;
            height: 8px;
        }

        /* Style untuk tombol toggle indikator */
        .toggle-btn {
            background-color: #E7A13B;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #d1d5db;
        }
        .toggle-btn:hover {
            background-color: #d1d5db;
        }
        .toggle-btn.active {
            background-color: #1755c6;
            color: #121010;
            border-color: #1c295c;
        }
        .dark .toggle-btn {
            background-color: #1c1b1b;
            color: #d1d5db;
            border-color: #444;
        }
        .dark .toggle-btn:hover {
            background-color: #444;
        }
        .dark .toggle-btn.active {
            background-color: #4f3e01;
            color: #ffffff;
            border-color: #4A7C59;
        }
        .projection-results-container .card {
            background-color: #1c1b1b;
            border-color: #444;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .projection-results-container h4 {
            font-size: 1rem;
            color: #008c38;
        }
        .projection-results-container p {
            color: #e0e0e0;
        }
        .btn-yellow {
            background-color: #f59e0b; 
            color: #1f2937; 
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-yellow:hover {
            background-color: #b5a38d;
        }
        
        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }
        #trade-link:hover {
            text-decoration: none;
        }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (MULAI) === */
        .status-uptrend { color: #34d399; }
        .dark .status-uptrend { color: #4ade80; }
        .status-downtrend { color: #ef4444; }
        .dark .status-downtrend { color: #f87171; }
        .status-chop { color: #fbbf24; }
        .dark .status-chop { color: #fcd34d; }

        .confluence-bar-container {
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            height: 30px;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .dark .confluence-bar-container { background-color: #374151; }

        .confluence-bar {
            height: 100%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
            color: #111827;
        }

        .confluence-bar-bullish { background: linear-gradient(to right, #22c55e, #86efac); }
        .confluence-bar-bearish { background: linear-gradient(to right, #ef4444, #fca5a5); }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (SELESAI) === */
        .dark .btn-yellow {
            color: #120f0f;
        }
        /* === TAMBAHKAN BLOK CSS DI BAWAH INI === */
        .btn-secondary {
            background-color: #ff1869; /* gray-500 */
            color: #070707;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-secondary:hover {
            background-color: #226756; /* gray-600 */
        }
        .dark .btn-secondary {
            background-color: lab(42.97% -24.5 -10.46); /* gray-600 */
        }
        .dark .btn-secondary:hover {
            background-color: hsl(189, 95%, 25%); /* gray-700 */
        }   
        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dashed rgba(128, 128, 128, 0.5);
        }

        #ai-narrative-content .prose h3 {
            margin-top: 1.25rem; /* Beri jarak di atas setiap judul (###) */
            margin-bottom: 0.5rem;
        }

        #ai-narrative-content .prose ul {
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        #ai-narrative-content .prose li {
            margin-bottom: 0.5rem; /* Beri jarak antar poin-poin (*) */
        }
        .vwap-mode-btn {
            background-color: #4a5568; /* gray-600 */
            color: #e2e8f0; /* gray-200 */
            border: 1px solid #718096; /* gray-500 */
            opacity: 0.6;
        }
        .vwap-mode-btn.active {
            background-color: #f59e0b; /* yellow-500 */
            color: #1f2937; /* gray-800 */
            opacity: 1;
            font-weight: bold;
        }
        .hybrid-bar {
            background-color: #2d3748;
            border-radius: 4px;
            height: 12px;
            width: 100px;
            position: relative;
            overflow: hidden;
            border: 1px solid #4a5568;
        }
        .pump-strength {
            background-color: #48bb78;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }
        .dump-risk {
            background-color: #f56565;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }
        /* === CSS BARU UNTUK SKOR TENSI (MULAI) === */
        .tension-bar-bg {
            background-color: #374151; /* dark:bg-gray-700 */
            border-radius: 9999px;
            height: 8px;
            width: 100%;
            margin: 4px auto 0;
            overflow: hidden;
            border: 1px solid #4b5563;
        }
        .tension-bar-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
            background: linear-gradient(to right, #fcd34d, #f59e0b, #ef4444); /* yellow to orange to red */
        }
        /* === CSS BARU UNTUK SKOR TENSI (SELESAI) === */
        /* === CSS BARU UNTUK KALKULATOR BINANCE STYLE (MULAI) === */
        .calc-binance-style .btn-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 1.5rem;
        }
        .calc-binance-style .btn-group button {
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            color: #e0e0e0;
            font-weight: 500;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .calc-binance-style .btn-group button:hover {
            background-color: #3a3f4a;
        }
        .calc-binance-style .btn-group button.active {
            background-color: #f0b90b;
            color: #14151a;
            border-color: #f0b90b;
        }
        .calc-binance-style .input-group {
            position: relative;
            margin-bottom: 1rem;
        }
        .calc-binance-style .input-field {
            width: 100%;
            padding: 12px 12px 12px 12px;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1.1em;
        }
        .calc-binance-style .input-label-top {
            font-size: 0.8em;
            color: #848e9c;
            margin-bottom: 8px;
        }
        .calc-binance-style .input-suffix {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #848e9c;
            font-weight: 600;
        }
        .calc-binance-style .margin-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #3a3f4a;
            outline: none;
            border-radius: 2px;
            margin: 1.5rem 0;
        }
        .calc-binance-style .margin-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #f0b90b;
            cursor: pointer;
            border-radius: 50%;
        }
        .calc-binance-style .slider-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #848e9c;
            padding: 0 2px;
        }
        .calc-binance-style .tpsl-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #3a3f4a;
        }
        .calc-binance-style .exec-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 1.5rem;
        }
        .calc-binance-style .exec-buttons button {
            padding: 14px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .calc-binance-style .btn-buy { background-color: #2ebd85; color: white; }
        .calc-binance-style .btn-sell { background-color: #f6465d; color: white; }
        .calc-binance-style .calc-result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 1rem;
            font-size: 0.85em;
            color: #848e9c;
        }
        .calc-binance-style .calc-result-grid span:nth-child(even) {
            text-align: right;
            font-weight: 600;
            color: #e0e0e0;
        }
        /* === CSS BARU UNTUK KALKULATOR BINANCE STYLE (SELESAI) === */
        /* === CSS UNTUK MODAL TRAILING STOP === */
        #ts-modal-content .input-field {
            width: 100%;
            padding: 12px;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1.1em;
        }
        #ts-modal-close-btn {
            font-size: 2rem;
            line-height: 1;
        }
        .mtf-clickable-box {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .mtf-clickable-box:hover {
            background-color: #4b5563; /* Sesuaikan warna hover jika perlu */
        }
        /* Dark Mode Styles */
        .dark .positive { color: #4ade80; }
        .dark .negative { color: #f87171; }
        .dark .text-gray-800 { color: #E0E0E0; }
        .dark .text-gray-500 { color: #d8d2d2; }
        .dark .text-gray-600 { color: #dddddd; }
        .dark .text-gray-700 { color: #e0e0e0; }

        /* Chart Container Styles */
        .chart-container { position: relative; width: 100%; }
        #main-chart-container { height: 450px; }
        .pane-chart-container { height: 150px; margin-top: 8px; border-top: 1px solid rgba(128, 128, 128, 0.2); padding-top: 8px;}
        .pane-title { position: absolute; top: 15px; left: 15px; z-index: 10; font-size: 12px; font-weight: bold; color: #dddddd; }
        .dark .pane-title { color: #d9d5d5; }
        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }
        /* Blinking Green Slow */
        .blinking-green-slow {
            animation: blinking-green-slow-animation 0.5s infinite;
        }

        @keyframes blinking-green-slow-animation {
            0%, 100% {
                color: #16a34a; /* Warna hijau solid */
                opacity: 1;
            }
            50% {
                color: #4ade80; /* Warna hijau terang saat berkedip */
                opacity: 0.7;
            }
        }

        .dark .blinking-green-slow {
            animation: blinking-green-slow-animation-dark 1s infinite;
        }

        @keyframes blinking-green-slow-animation-dark {
            0%, 100% {
                color: #4ade80;
                opacity: 1;
            }
            50% {
                color: #16a34a;
                opacity: 0.6;
            }
        }
        /* Blinking Yellow Slow */
        .blinking-yellow-slow {
            animation: blinking-yellow-slow-animation 0.5s infinite;
        }

        @keyframes blinking-yellow-slow-animation {
            0%, 100% {
                color: #f59e0b; /* Warna kuning solid (yellow-500) */
                opacity: 1;
            }
            50% {
                color: #fcd34d; /* Warna kuning terang (yellow-300) */
                opacity: 0.6;
            }
        }

        .dark .blinking-yellow-slow {
            animation: blinking-yellow-slow-animation-dark 1s infinite;
        }

        @keyframes blinking-yellow-slow-animation-dark {
            0%, 100% {
                color: #fcd34d;
                opacity: 1;
            }
            50% {
                color: #f59e0b;
                opacity: 0.7;
            }
        }
        /* ... CSS yang sudah ada ... */
.status-chop { color: #fbbf24; }
.dark .status-chop { color: #fcd34d; }

/* ▼▼▼ TAMBAHKAN STYLE BARU INI ▼▼▼ */
.status-lowvolatility { color: #a78bfa; } /* ungu muda */
.dark .status-lowvolatility { color: #c4b5fd; }
/* Tambahkan/Ubah Style ini di bagian bawah <style> */
.dark #dna-details {
    background-color: #1c1b1b; /* Gunakan warna gelap yang konsisten */
    border: 1px solid #333;
    color: #E0E0E0; /* Pastikan warna teks terang */
}
.dark #dna-details h4 {
    color: #F59E0B; /* Warna judul/header di DNA Details */
}
    </style>
</head>
<body class="antialiased">

    <div id="sticky-nav-wrapper" class="sticky top-0 z-50 bg-[#FDFBF7]/80 dark:bg-[#121212]/80 backdrop-blur-lg border-b border-gray-200/50 dark:border-gray-700/50 shadow-sm">
        <div class="flex items-center justify-between py-2 px-4 sm:px-6 lg:px-8">
            
            <div class="flex items-center gap-3">

                <div class="flex items-center gap-3">
                    <div id="nav-info-container" class="items-center gap-2 hidden md:flex">
                        <div class="flex flex-col">
                            <div class="font-mono text-[10px]">
                                <span class="text-gray-400">VOL 24H:</span>
                                <span id="nav-volume-24h" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                            </div>
                        </div>
                        <div class="flex flex-col text-left text-xs">
                            <span id="nav-change-24h" class="font-semibold positive">-</span>
                            <span id="nav-change-1h" class="font-semibold positive">-</span>
                        </div>
                    </div>
                </div>

                <div id="nav-stats-container" class="items-center gap-3 font-mono text-[10px] hidden md:flex">
                    <div class="flex flex-col text-left">
                        <div>
                            <span class="text-gray-400">ATH:</span>
                            <span id="nav-ath" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">ATL:</span>
                            <span id="nav-atl" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                    </div>
                </div>
            </div>
            <a href="#" id="trade-link" class="text-right no-underline hidden flex items-baseline gap-2">
                <span id="nav-timeframe" class="text-base font-semibold blinking-yellow-slow mr-2"></span>
                <span id="nav-symbol" class="text-base font-bold text-blue-500 dark:text-green-500"></span>
                <span id="nav-price" class="text-yellow-500 text-lg">-</span>
            </a>
        </div>
        <div id="candle-countdown-container" class="w-full h-1 bg-gray-200 dark:bg-gray-700 hidden">
            <div id="candle-countdown-bar" class="h-full bg-yellow-500" style="width: 0%; transition: width 1s linear;"></div>
        </div>
    </div>

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <header class="py-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-gray-800">DASHBOARD</h1>
                <p class="text-yellow-500 font-mono mt-1 text-sm">🏁</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none">
                <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414 1.414zM-.707 7.072l.707-.707a1 1 0 10-1.414-1.414l-.707.707a1 1 0 001.414 1.414zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z"></path></svg>
            </button>
        </header>

    <main>

        <div class="space-y-6 mb-8">
            <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-3 items-start">
                <div>
                    <input type="password" id="gemini-api-key" class="input-primary" placeholder="Your API Key...">
                    <p class="text-sm text-gray-400 mt-1">API 🔑 <a href="https://aistudio.google.com/app/apikey" target="_blank" class="underline hover:text-blue-500">GET KEY 👆🏻</a>.</p>
                </div>
            </section>

            <section id="settings-card" class="card p-4">
                <button id="toggle-settings-btn" class="w-full flex justify-between items-center text-left">
                    <h2 class="text-lg font-bold">Indicators Settings</h2>
                    <svg id="toggle-settings-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="settings-content-wrapper" class="collapsible-content">
                    <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                            <div>
                                <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Parameter Indikator</h3>
                                <div class="space-y-2 text-sm">
                                    <div class="flex items-center justify-between">
                                        <label for="setting-rsi-period" class="text-gray-500">Periode RSI</label>
                                        <input type="number" id="setting-rsi-period" class="input-primary !w-20 text-center" value="14">
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <label for="setting-stoch-rsi-period" class="text-gray-500">Stoch RSI (RSI/Stoch/K/D)</label>
                                        <div class="flex gap-1">
                                            <input type="number" id="setting-stoch-rsi-period" class="input-primary !w-12 text-center" value="14">
                                            <input type="number" id="setting-stoch-stoch-period" class="input-primary !w-12 text-center" value="14">
                                            <input type="number" id="setting-stoch-k-smooth" class="input-primary !w-12 text-center" value="3">
                                            <input type="number" id="setting-stoch-d-smooth" class="input-primary !w-12 text-center" value="3">
                                        </div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <label for="setting-macd-fast" class="text-gray-500">MACD Fast/Slow/Signal</label>
                                        <div class="flex gap-1">
                                            <input type="number" id="setting-macd-fast" class="input-primary !w-16 text-center" value="12">
                                            <input type="number" id="setting-macd-slow" class="input-primary !w-16 text-center" value="26">
                                            <input type="number" id="setting-macd-signal" class="input-primary !w-16 text-center" value="9">
                                        </div>
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <label for="setting-weight-obv-divergence" class="text-gray-500">Bobot Divergensi OBV</label>
                                        <input type="number" step="0.1" id="setting-weight-obv-divergence" class="input-primary !w-20 text-center" value="3.0">
                                    </div>
                                </div>
                            </div>
                            
                            <div>
                                <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Bobot Skor Konfluensi</h3>
                                <div class="space-y-2 text-sm">
                                    <div class="flex items-center justify-between">
                                        <label for="setting-weight-divergence" class="text-gray-500">Bobot Divergensi RSI</label>
                                        <input type="number" step="0.1" id="setting-weight-divergence" class="input-primary !w-20 text-center" value="2.5">
                                    </div>
                                    <div class="flex items-center justify-between">
                                        <label for="setting-weight-macd" class="text-gray-500">Bobot MACD Cross</label>
                                        <input type="number" step="0.1" id="setting-weight-macd" class="input-primary !w-20 text-center" value="2.0">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                            <div class="flex items-center justify-between">
                                <label for="preset-select" class="font-semibold text-gray-700 dark:text-gray-300">TradingStyle</label>
                                <select id="preset-select" class="input-primary !w-auto text-sm">
                                    <option value="default">Default</option>
                                    <option value="scalper">Scalper</option>
                                    <option value="dayTrader">Day Trader</option>
                                    <option value="swingTrader">Swing Trader</option>
                                </select>
                            </div>
                        </div>
                        <div class="text-right mt-4">
                            <button id="save-settings-btn" class="btn-primary">💾</button>
                        </div>
                        <p id="settings-saved-msg" class="text-green-500 text-sm mt-2 text-center hidden">SAVED!</p>
                    </div>
                </div>
            </section>

            <div id="initial-placeholder" class="text-center py-5"></div>

            <div id="loader-overlay" class="... flex-col ...">
                <div class="loader">
                    <div class="dot"></div>
                    <p class="text-4xl font-mono text-gray-500">SPOT</p>
                    <div class="dot"></div>
                    <p class="text-4xl font-mono text-gray-500">PERPETUAL</p>
                    <div class="dot"></div>
                </div>
                <p id="loader-text" class="text-white font-semibold mt-4 text-center blinking-text-animation">Let's Go........</p>
            </div>

<section id="top-movers-section" class="card p-6">
    <button id="toggle-top-movers-btn" class="w-full flex justify-between items-center text-left mb-4">
        <h2 class="text-2xl font-semibold blinking-green-slow">TOP PERFORMERS</h2>
        <svg id="toggle-top-movers-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
        </svg>
    </button>
    
    <div id="top-movers-content-wrapper" class="collapsible-content">
        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2">
                <div id="top-movers-controls" class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                    <div id="top-movers-timeframe-selector" class="flex flex-wrap gap-2">
                        <button data-timeframe="1m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">1m</button>
                        <button data-timeframe="3m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">3m</button>
                        <button data-timeframe="5m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">5m</button>
                        <button data-timeframe="15m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">15m</button>
                        <button data-timeframe="1h" class="top-movers-tf-btn toggle-btn text-xs !p-1.5 active">1H</button>
                        <button data-timeframe="24h" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">24H</button>
                    </div>
                    <div class="flex gap-2 items-center">
                        <select id="refresh-interval-select" class="input-primary text-xs !w-auto !p-1">
                            <option value="5000">5s</option>
                            <option value="10000">10s</option>
                            <option value="30000">30s</option>
                            <option value="60000">60s</option>
                            <option value="120000" selected>120s</option>
                        </select>
                        <span id="refresh-countdown" class="text-xs text-gray-500 w-24 text-center"></span>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-1 gap-3">
                <div>
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">Top Movers (by TF)</h3>
                    <div id="gainers-list" class="space-y-2"></div>
                </div>
            </div>
        </div>
    </div>
</section>

            <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-3 items-start">
                <div>
                    <div class="flex flex-col sm:flex-row gap-3">
                        <input type="text" id="asset-input" list="asset-list" class="input-primary text-sm flex-grow uppercase" placeholder="Ketik Simbol Aset (cth: BTCUSDT)" value="BTCUSDT">
                        <datalist id="asset-list"></datalist>
                        <select id="market-type-select" class="input-primary text-sm !w-auto">
                            <option value="spot">Spot</option>
                            <option value="futures" selected>Perp</option>
                        </select>
                        <select id="timeframe-select" class="input-primary text-sm !w-auto">
                            <option value="1m">1m</option>
                            <option value="3m">3m</option>
                            <option value="5m"selected>5m</option>
                            <option value="15m">15m</option>
                            <option value="30m">30m</option>
                            <option value="1h">1h</option>
                            <option value="2h">2h</option>
                            <option value="4h">4h</option>
                            <option value="1d">1d</option>
                            <option value="1w">W</option>
                        </select>
                    </div>
                </div>
                <div class="col-span-12 lg:col-span-4 xl:col-span-3">
                    <div class="card p-4 h-full flex flex-col">
                        <h3 class="text-lg font-semibold mb-3 border-b border-gray-200 pb-2">⚙️ DNA Juara (Import & Detail)</h3>
                        
                        <label for="dna-file-input" class="block text-sm font-medium text-gray-700 mb-2">Import File DNA (.json)</label>
                        <input type="file" id="dna-file-input" accept=".json" class="w-full text-sm text-gray-700
                            file:mr-4 file:py-2 file:px-4
                            file:rounded-full file:border-0
                            file:text-sm file:font-semibold
                            file:bg-[#F2D7B4] file:text-[#342d27]
                            hover:file:bg-[#EAE5E0] cursor-pointer
                        ">
                        
                        <p id="dna-status" class="mt-2 text-sm text-gray-500">Status: Belum ada DNA yang dimuat.</p>

                        <div id="dna-details" class="mt-4 p-3 bg-[#F7F5F3] rounded-lg flex-grow">
                            <h4 class="font-bold text-gray-900 mb-2 text-base">Metadata DNA:</h4>
                            <p class="text-xs">Tipe: <span id="dna-type-display" class="font-medium">-</span></p>
                            <p class="text-xs">Aset: <span id="dna-asset-display" class="font-medium">-</span></p>
                            <p class="text-xs">Timeframe: <span id="dna-tf-display" class="font-medium">-</span></p>
                            <hr class="my-2 border-gray-200">
                            <h4 class="font-bold text-gray-900 mb-2 text-sm">QC Validation:</h4>
                            <p class="text-xs">PNL Rata-rata: <span id="dna-pnl-avg-display" class="font-medium">-</span></p>
                            <p class="text-xs">Prob. Loss: <span id="dna-loss-prob-display" class="font-medium">-</span></p>
                            <p class="text-xs">Threshold Bias: <span id="dna-threshold-display" class="font-medium">-</span></p>
                        </div>
                    </div>
                </div>
                <div class="md:col-span-2 flex gap-3">
                    <button id="analyze-asset-btn" class="btn-primary w-full font-bold text-xl">
                        <span id="button-text">GET DATA</span>
                        <div id="button-loader" class="loader hidden">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                    </button>
                    <p id="asset-error" class="text-red-600 text-sm mt-2 text-center hidden"></p>
                    <button id="reset-btn" class="btn-secondary !w-auto">RESET</button>
                </div>
            </section>
        </div>

        <div id="dashboard-content" class="hidden">
            <div class="space-y-8">               
                <div class="flex flex-col gap-3">
                    <section id="charts-wrapper" class="card p-6" style="display: none;">
                        <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                        <div class="chart-container relative">
                            <div class="pane-title">Price</div>
                            <div id="main-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">Volume</div>
                            <div id="volume-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">RSI (14)</div>
                            <div id="rsi-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">Stochastic RSI</div>
                            <div id="stoch-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">MACD</div>
                            <div id="macd-chart-container"></div>
                        </div>
                        <div class="chart-container pane-chart-container relative">
                            <div class="pane-title">Rate of Change (ROC)</div>
                            <div id="roc-chart-container"></div>
                        </div>
                    </section>
                    <button id="toggle-charts-btn" class="btn-yellow w-full">SHOW CHART</button>

                    <section id="onchain-card" class="card p-6">
                        <button id="toggle-onchain-btn" class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-xl font-bold">On-Chain</h2>
                            <svg id="toggle-onchain-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="onchain-content-wrapper" class="collapsible-content">
                            <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                <div id="specific-token-analysis" class="mb-4">
                                    <h3 id="specific-token-title" class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Analisis Token Spesifik</h3>
                                    <div id="specific-token-content" class="text-sm space-y-1">
                                        <p class="text-xs text-gray-500 text-center">SEARCHING...</p>
                                    </div>
                                </div>
                                <div>
                                    <h3 class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Pool Trending Teratas</h3>
                                    <div id="trending-pools-content" class="text-sm space-y-2">
                                        <div class="text-center py-2">
                                            <div class="loader mx-auto h-6 w-6"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    

                    <section id="ai-analysis-section" class="card p-6 relative">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-xl font-bold">AI ANALYZER</h2>
                        </div>
                        
                        <div id="ai-content-container" class="hidden space-y-6">
                            <div id="ai-narrative-content" class="prose prose-sm dark:prose-invert max-w-none text-gray-600 space-y-4"></div>
                            <div>
                                <h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">🔮 Proyeksi Harga</h3>
                                <div id="projection-results-container" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
                            </div>
                            <div>
                                <h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">♟️ Saran Strategis</h3>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                    <div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg">
                                        <h4 class="font-semibold text-green-500 mb-2">Untuk Calon Buyer</h4>
                                        <p id="saran-buyer" class="text-lg font-bold"></p>
                                        <p id="alasan-buyer" class="text-sm text-gray-500 mt-1"></p>
                                    </div>
                                    <div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg">
                                        <h4 class="font-semibold text-blue-500 mb-2">Untuk Holder</h4>
                                        <p id="saran-holder" class="text-lg font-bold"></p>
                                        <p id="alasan-holder" class="text-sm text-gray-500 mt-1"></p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>
                    <button id="toggle-ai-btn" class="btn-primary w-full mb-4">
                        <span>ASK AI</span>
                        <div class="loader w-5 h-5 hidden">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                    </button>

                    <section id="sentiment-display-container" class="card p-6">
                        <button id="toggle-sentiment-btn" class="w-full flex justify-between items-center text-left mb-4">
                            <h2 class="text-xl font-bold">Bitcoin Sentiment</h2>
                            <svg id="toggle-sentiment-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                            </svg>
                        </button>
                        <div id="sentiment-content-wrapper" class="collapsible-content">
                            <p class="text-center text-gray-500"></p>
                        </div>
                    </section>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-3">
                    <div class="flex flex-col gap-3">
                        <section id="current-state-section" class="card p-6">
                            <button id="toggle-market-state-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 id="current-state-title" class="text-xl font-semibold">Current Market</h2>
                                <svg id="toggle-market-state-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            <div id="current-state-content-wrapper" class="collapsible-content expanded">
                                <div class="space-y-6">
                                    <h2 class="text-lg font-semibold text-center">Calculated Timeframe <span id="quick-confluence-timeframe">5m</span></h2>
                                    <div class="flex items-center gap-3 my-2">
                                        <div id="quick-finalBearishScore" class="text-2xl font-bold status-downtrend text-right w-1/5">🐻 0%</div>
                                        <div class="confluence-bar-container w-3/5">
                                            <div id="quick-confluenceBarBearish" class="confluence-bar confluence-bar-bearish" style="width: 50%;"></div>
                                            <div id="quick-confluenceBarBullish" class="confluence-bar confluence-bar-bullish" style="width: 50%;"></div>
                                        </div>
                                        <div id="quick-finalBullishScore" class="text-2xl font-bold status-uptrend text-left w-1/5">0% 🐂</div>
                                    </div>
                                    <div id="verdict-and-regime-container" class="text-center space-y-3 mt-3">
                                    </div>
                                    <div id="confluence-breakdown-container" class="mt-4 text-xs text-center space-y-2 hidden">
                                        <div class="grid grid-cols-2 gap-2 text-left">
                                            <div id="top-bullish-contributors"></div>
                                            <div id="top-bearish-contributors"></div>
                                        </div>
                                    </div>
                                    <div class="space-y-2 pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                            <div class="h-16 flex items-center justify-center my-2"></div>
                                            <p id="candlestick-pattern" class="font-semibold">NONE</p>
                                        </div>
                                        <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                            <p id="chart-pattern-label" class="text-xs text-gray-500">Chart Pattern</p>
                                            <p id="chart-pattern" class="font-semibold">NONE</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                        <section id="confluence-details-section" class="card p-6">
                            <button id="toggle-confluence-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-lg font-bold">Timeframe [ NOW ] -<span id="confluence-timeframe-display"> 5m</span></h2>
                                <svg id="toggle-confluence-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            <div id="confluence-content-wrapper" class="collapsible-content">
                                <div>
                                    <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">KEY LEVEL</h3>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between">
                                                <span class="text-red-500">VAH</span>
                                                <span id="vpvr-vah" class="font-mono">-</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="font-bold text-blue-500" data-tooltip="Point of Control (POC)|...">Point of Control (POC)</span>
                                                <span id="vpvr-poc" class="font-mono font-bold">-</span>
                                            </div>
                                            <div class="flex justify-between">
                                                <span class="text-green-500">VAL</span>
                                                <span id="vpvr-val" class="font-mono">-</span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">24H</span>
                                                <span id="range-24h" class="font-mono font-semibold">-</span>
                                            </div>

                                            <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500" data-tooltip="Daily Pivot (P)|...">Daily Pivot (P)</span>
                                                    <span id="pivot-p" class="font-mono font-semibold text-blue-500">-</span>
                                                </div>
                                                <div id="pivot-levels-container" class="text-xs text-gray-400 space-y-1 mt-1 pl-4 hidden">
                                                    <div class="flex justify-between">
                                                        <span>R1 / S1</span>
                                                        <span id="pivot-r1s1" class="font-mono">-</span>
                                                    </div>
                                                    <div class="flex justify-between">
                                                        <span>R2 / S2</span>
                                                        <span id="pivot-r2s2" class="font-mono">-</span>
                                                    </div>
                                                    <div class="flex justify-between">
                                                        <span>R3 / S3</span>
                                                        <span id="pivot-r3s3" class="font-mono">-</span>
                                                    </div>
                                                </div>
                                            </div>

                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500" data-tooltip="VWAP (Volume-Weighted Average Price)|...">VWAP</span>
                                                <div class="flex items-center gap-2">
                                                    <div id="vwap-mode-buttons" class="flex text-xs">
                                                        <button data-mode="rolling" class="vwap-mode-btn active px-2 py-0.5 rounded-l-md" data-tooltip="Rolling VWAP|...">R</button>
                                                        <button data-mode="session" class="vwap-mode-btn px-2 py-0.5" data-tooltip="Session VWAP|...">S</button>
                                                        <button data-mode="anchored" class="vwap-mode-btn px-2 py-0.5 rounded-r-md" data-tooltip="Anchored VWAP|...">A</button>
                                                    </div>
                                                    <span id="vwap-20d" class="font-mono text-yellow-500">-</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">MOMENTUM</h3>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">RSI (14)</span>
                                                <div>
                                                    <span id="rsi-value" class="font-mono text-xs">-</span>
                                                    <span id="rsi-status" class="tag tag-gray"></span>
                                                </div>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">Stoch RSI (%K/%D)</span>
                                                <div>
                                                    <span id="stoch-value" class="font-mono text-xs">-</span>
                                                    <span id="stoch-status" class="tag tag-gray"></span>
                                                </div>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">MACD</span>
                                                <div>
                                                    <span id="macd-status" class="font-mono font-semibold">-</span>
                                                    <span id="macd-hist" class="font-mono text-xs ml-1">-</span>
                                                </div>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-blue-500" data-tooltip="Bollinger Squeeze|...">Bollinger Squeeze</span>
                                                <span id="bollinger-squeeze-status" class="font-mono">-</span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-yellow-500">BB Reversal</span>
                                                <span id="bollinger-rejection-status" class="font-mono">-</span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">BB Walk the Bands</span>
                                                <span id="bollinger-walk-status" class="font-mono">-</span>
                                            </div>
                                            <div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500">Bollinger Bands</span>
                                                    <span id="bollinger-bands-status" class="font-mono">-</span>
                                                </div>
                                                <div class="text-right text-xs text-gray-400 font-mono">
                                                    <span id="bb-upper-value">-</span> / <span id="bb-middle-value">-</span> / <span id="bb-lower-value">-</span>
                                                </div>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500" data-tooltip="RSI Divergence|...">RSI Divergence</span>
                                                <span id="rsi-divergence" class="font-mono font-semibold text-xs">-</span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500" data-tooltip="Linear Regression Channel|...">LinReg Channel</span>
                                                <span id="linreg-status" class="font-mono">-</span>
                                            </div>
                                            <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                <span class="text-gray-500" data-tooltip="On-Balance Volume|Indikator momentum yang menggunakan volume untuk memprediksi perubahan harga.">OBV</span>
                                                <span id="obv-value" class="font-mono font-semibold">-</span>
                                            </div>
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500" data-tooltip="Ichimoku Bias|...">Ichimoku Bias</span>
                                                <span id="ichimoku-bias" class="font-mono font-semibold">-</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                        <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Asset Info</h3>
                                        <div class="hidden">
                                            <input type="text" id="correlation-asset-input" class="input-primary" value="BTCUSDT">
                                        </div>
                                        <div class="space-y-1 text-sm">
                                            <div class="flex justify-between items-center">
                                                <span class="text-gray-500">BTC Correlation (30D)</span>
                                                <div>
                                                    <span id="correlation-value" class="font-mono font-semibold text-gray-300">-</span>
                                                    <span id="correlation-text" class="text-xs text-gray-500 ml-1">...</span>
                                                </div>
                                            </div>
                                            <div class="space-y-1 text-sm">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-gray-500">BTC Dominance</span>
                                                    <span id="btc-dominance" class="font-mono">-</span>
                                                </div>
                                                <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                                    <span class="text-gray-500">Market Cap</span>
                                                    <span id="market-cap" class="font-mono">-</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="order-book-cvd-section" class="card p-6">
                            <button id="toggle-order-book-cvd-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-sm font-bold linking-text-animation">Order Book & CVD</h2>
                                <svg id="toggle-order-book-cvd-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            <div id="order-book-cvd-content-wrapper" class="collapsible-content">
                                <div>
                                    <hr class="border-gray-200 dark:border-gray-700/50 my-4">
                                    <div>
                                        <h3 class="text-xl font-bold mb-4 text-center">Order Book</h3>
                                        <div id="full-order-book-container" class="space-y-2 text-sm">
                                            <p class="text-center text-gray-500">FETCHING DATA...</p>
                                        </div>
                                        <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                            <span class="text-gray-500">Order Book Bias</span>
                                            <span id="order-book-bias" class="font-mono">-</span>
                                        </div>
                                    </div>
                                    <hr class="border-gray-200 dark:border-gray-700/50 my-4">
                                    <div>
                                        <h3 class="text-lg font-bold mb-4 text-center">CVD Order Flow</h3>
                                        <div class="chart-container" style="height: 150px;">
                                            <canvas id="cvdChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>

                    <div class="flex flex-col gap-3">
                        <section id="scalping-setup-section" class="card p-6">
                            <button id="toggle-scalping-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-xl font-bold">Scalping <span id="scalping-timeframe-display"></span></h2>
                                <svg id="toggle-scalping-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            <div id="scalping-content-wrapper" class="collapsible-content expanded">
                                <div>
                                    <section id="current-regime-status-container" class="card p-4">
                
                                        <div class="space-y-1 text-sm">
                                            <p class="flex justify-between">
                                                <span>Status AI (Sensor):</span> 
                                                <span id="ai-status" class="font-medium text-gray-400">MEMUAT...</span>
                                            </p>
                                            <p class="flex justify-between !mt-2 border-t border-gray-700 pt-2">
                                                <span class="font-bold text-base">Market Regime:</span> 
                                                <span id="active-regime-display" class="font-bold text-base text-gray-500">MENUNGGU DATA...</span>
                                            </p>
                                        </div>
                                    </section>
                                    <div id="hybrid-breakdown-module" class="mb-4">
                                        <div class="flex items-center justify-between text-xs text-gray-400">
                                            <span>Bullish Momentum</span>
                                            <span>Bearish Pressure Score</span>
                                        </div>
                                        <div class="confluence-bar-container w-full h-8 mt-1">
                                            <div id="main-pump-bar" class="confluence-bar confluence-bar-bullish" style="width: 0%;"></div>
                                            <div id="main-dump-bar" class="confluence-bar confluence-bar-bearish" style="width: 0%;"></div>
                                        </div>
                                        <div class="flex items-center justify-between text-sm mt-1">
                                            <span id="main-pump-score" class="positive font-bold">0%</span>
                                            <span id="main-dump-score" class="negative font-bold">0/10</span>
                                        </div>
                                        <p class="text-center text-[10px] text-gray-500 mt-1 blinking-yellow-slow">⚠ PLEASE CHECK YOU ARE IN THE RIGHT TIMEFRAME ⚠️</p>
                                        <details>
                                            <summary class="cursor-pointer text-xs text-gray-400 hover:text-white transition-colors flex justify-between items-center border-b border-gray-500">
                                                <span>Bearish Pressure Score Trigger▾</span>
                                                <select id="dump-trigger-timeframe-select" class="input-primary !text-xs !w-auto !p-1 bg-gray-900/50 border-gray-600" onclick="event.stopPropagation()">
                                                    <option value="1m">1m</option>
                                                    <option value="3m">3m</option>
                                                    <option value="5m" selected="">5m</option>
                                                    <option value="15m">15m</option>
                                                    <option value="30m">30m</option>
                                                    <option value="1h">1h</option>
                                                </select>
                                            </summary>
                                            <div id="trigger-breakdown-list" class="mt-2 pt-2 border-t border-gray-700/50 text-sm space-y-1">
                                                <p class="text-xs text-center text-gray-600">Pilih timeframe...</p>
                                            </div>
                                        </details>
                                    </div>
                                    <div class="pt-2 mt-2 border-t border-dashed border-gray-700/50">
                                        <div id="scalping-resistance-info" class="flex justify-between items-center text-sm">
                                            <span class="text-gray-500">Nearest Resistance</span>
                                            <span class="font-mono font-semibold text-red-400">-</span>
                                        </div>
                                        <div id="scalping-wall-container" class="text-center text-xs pt-2 space-y-1">
                                            <div id="buy-wall-display" class="text-green-500 font-semibold">— No Buy Wall Detected —</div>
                                            <div id="sell-wall-display" class="text-red-500 font-semibold">— No Sell Wall Detected —</div>
                                        </div>
                                    </div>
                                    <div id="tf-alignment-summary" class="pt-2 mt-2 border-t border-dashed border-gray-600/50"></div>
                                    <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                        <div class="flex justify-between items-center text-xs">
                                            <span class="text-gray-500">EMA 21/50</span>
                                            <span id="ma-status" class="font-mono font-semibold">-</span>
                                        </div>
                                        <div class="text-right text-xs text-gray-400 font-mono">
                                            <span id="ema-21-value">-</span> / <span id="ema-50-value">-</span>
                                        </div>
                                    </div>
                                    <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50 text-sm">
                                        <details>
                                            <summary class="cursor-pointer text-gray-500 text-sm mb-2 list-none underline">↕ More Indicator</summary>
                                            <div class="mt-2">
                                                <div class="space-y-1">
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500">Parabolic SAR</span>
                                                        <span id="psar-status" class="font-mono text-sm">-</span>
                                                    </div>
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500" data-tooltip="Rate of Change (ROC)|...">Rate of Change (ROC)</span>
                                                        <span id="roc-status" class="font-mono text-sm">-</span>
                                                    </div>
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-gray-500 text-sm" data-tooltip="Kekuatan Tren (ADX)|...">ADX 14</span>
                                                        <div>
                                                            <span id="adx-value" class="font-mono font-semibold text-sm">-</span>
                                                            <span class="text-xs positive" id="plus-di-value"></span> /
                                                            <span class="text-xs negative" id="minus-di-value"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="mt-2 pt-2 border-t border-dashed border-gray-700/20 space-y-1">
                                                    <div class="flex justify-between items-start">
                                                        <div>
                                                            <span class="text-gray-500 text-sm">A T R</span>
                                                            <span id="atr-status-badge" class="tag tag-gray ml-2">...</span>
                                                        </div>
                                                        <div class="text-right">
                                                            <p id="atr-percent-value" class="font-mono text-blue-500 font-semibold">-</p>
                                                            <p id="atr-absolute-value" class="font-mono text-xs text-gray-400">-</p>
                                                        </div>
                                                    </div>
                                                    <div id="ls-umum-container" class="flex justify-between items-center">
                                                        <span class="text-gray-500">L/S Ratio</span>
                                                        <span id="ls-ratio-umum" class="font-mono">-</span>
                                                    </div>
                                                    <div id="ls-top-container" class="flex justify-between items-center">
                                                        <span class="text-gray-500">L/S Ratio (Top)</span>
                                                        <span id="ls-ratio-top" class="font-mono">-</span>
                                                    </div>
                                                    <div id="futures-data-container" class="hidden space-y-1">
                                                        <div class="flex justify-between items-center">
                                                            <span class="text-gray-500">Funding Interval</span>
                                                            <span id="funding-rate-interval" class="font-mono">-</span>
                                                        </div>
                                                        <div class="flex justify-between items-center">
                                                            <span class="text-yellow-500">Funding Rate</span>
                                                            <span id="funding-rate" class="font-mono text-yellow-500">-</span>
                                                        </div>
                                                        <div class="flex justify-between items-center">
                                                            <span class="text-gray-500">Open Interest</span>
                                                            <span id="open-interest">-</span>
                                                        </div>
                                                        <div id="fib-targets-container" class="mt-4 pt-4 border-t border-dashed border-gray-700">
                                                            </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </details>
                                    </div>
                                    <div id="scalping-setup-content" class="text-center mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                        <p class="text-sm text-gray-500">FETCHING DATA...</p>
                                    </div>
                                    
                                </div>
                            </div>

                        </section>

                        <section id="trailing-stop-calc-section" class="card p-6">
                            <button id="toggle-ts-calc-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-xl font-bold">Kalkulator Eksekusi</h2>
                                <svg id="toggle-ts-calc-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            
                            <div id="ts-calc-content-wrapper" class="collapsible-content">
                                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 calc-binance-style">
                                    <button id="autofill-ts-btn" class="btn-primary w-full mb-4">
                                        ⚡️ Auto-fill dari Setup Scalping
                                    </button>
                                    <div class="btn-group">
                                        <button id="ts-mode-cross" class="active">Cross</button>
                                        <input type="number" id="ts-leverage" value="20" class="input-field text-center" style="padding-right: 2.5rem;">
                                        <button id="ts-mode-isolated" class="">Isolated</button>
                                        <button id="ts-trailing-stop-options">⚙️ TS</button>
                                    </div>

                                    <div class="grid grid-cols-2 gap-3">
                                        <div class="input-group">
                                            <label for="ts-wallet-balance" class="input-label-top">Available Balance ($)</label>
                                            <input type="number" id="ts-wallet-balance" class="input-field" value="1000">
                                        </div>
                                        <div class="input-group">
                                            <label for="ts-cost" class="input-label-top">Cost / Modal ($)</label>
                                            <input type="number" id="ts-cost" class="input-field" placeholder="0.00">
                                        </div>
                                    </div>

                                    <div>
                                        <input type="range" min="0" max="100" value="0" class="margin-slider" id="ts-margin-slider">
                                        <div class="slider-ticks">
                                            <span>0%</span>
                                            <span>25%</span>
                                            <span>50%</span>
                                            <span>75%</span>
                                            <span>100%</span>
                                        </div>
                                    </div>

                                    <div class="input-group mt-6">
                                        <label for="ts-market-price" class="input-label-top">Harga Pasar Saat Ini ($)</label>
                                        <input type="number" id="ts-market-price" class="input-field" placeholder="Harga market saat ini...">
                                    </div>

                                    <div class="tpsl-section">
                                        <div class="flex items-center gap-2">
                                            <input type="checkbox" id="ts-tpsl-toggle" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 text-yellow-500">
                                            <label for="ts-tpsl-toggle" class="text-sm">TP/SL</label>
                                        </div>
                                        <div id="ts-tpsl-inputs" class="hidden mt-4 space-y-4">
                                            <div class="input-group">
                                                <label for="ts-take-profit" class="input-label-top">Take Profit</label>
                                                <input type="number" id="ts-take-profit" class="input-field" placeholder="Mark">
                                            </div>
                                            <div class="input-group">
                                                <label for="ts-stop-loss" class="input-label-top">Stop Loss</label>
                                                <input type="number" id="ts-stop-loss" class="input-field" placeholder="Mark">
                                            </div>
                                        </div>
                                    </div>

                                    <div class="exec-buttons">
                                        <button class="btn-buy" id="ts-buy-long-btn">Buy/Long</button>
                                        <button class="btn-sell" id="ts-sell-short-btn">Sell/Short</button>
                                    </div>

                                    <div class="calc-result-grid">
                                        <span>Cost</span>
                                        <span id="ts-result-cost">--</span>
                                        <span>Max</span>
                                        <span id="ts-result-max">--</span>
                                        <span>Position Size</span>
                                        <span id="ts-result-position-size">--</span>
                                        <span>Liq. Price</span>
                                        <span id="ts-result-liq-price">--</span>
                                        <span class="pt-2 border-t border-dashed border-gray-700">Status TS</span>
                                        <span id="ts-result-status" class="pt-2 border-t border-dashed border-gray-700">--</span>
                                        <span>Harga Stop Loss TS</span>
                                        <span id="ts-result-sl-price">--</span>
                                        <span>Potensi ROE</span>
                                        <span id="ts-result-roe">--</span>
                                    </div>
                                </div>
                            </div>

                            <div id="ts-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
                                <div id="ts-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-lg font-bold">Pengaturan Trailing Stop</h3>
                                        <button id="ts-modal-close-btn" class="text-gray-400 hover:text-white">&times;</button>
                                    </div>
                                    <div class="space-y-4">
                                        <div class="form-group">
                                            <label for="ts-modal-callback-rate">Callback Rate (%)</label>
                                            <input type="number" id="ts-modal-callback-rate" class="input-field" placeholder="cth: 0.5">
                                        </div>
                                        <div class="form-group">
                                            <label for="ts-modal-activation-price">Harga Aktivasi ($)</label>
                                            <input type="number" id="ts-modal-activation-price" class="input-field" placeholder="cth: 65000">
                                        </div>
                                    </div>
                                    <div class="mt-6 text-right">
                                        <button id="ts-modal-save-btn" class="btn-primary">Simpan Pengaturan</button>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="paper-trading-section" class="card p-6">
                            <button id="toggle-paper-trading-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-xl font-bold">Trading Simulation</h2>
                                <svg id="toggle-paper-trading-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>

                            <div id="paper-trading-content-wrapper" class="collapsible-content">
                                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-center">
                                        <div>
                                            <p class="text-xs text-gray-500">Equity</p>
                                            <p id="sim-equity" class="font-mono font-bold text-lg text-blue-400">$1,000.00</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-500">Unrealized PNL</p>
                                            <p id="sim-unrealized-pnl" class="font-mono font-bold text-lg text-gray-400">$0.00</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-500">Available Margin</p>
                                            <p id="sim-available-margin" class="font-mono font-bold text-lg text-gray-400">$1,000.00</p>
                                        </div>
                                        <div class="flex items-center justify-center">
                                            <button id="sim-reset-account-btn" class="btn-secondary !text-xs !py-1 !px-2">Reset Account</button>
                                        </div>
                                    </div>

                                    <div id="sim-active-position-container" class="hidden">
                                        <h3 class="font-semibold text-yellow-400 mb-2">Active Position</h3>
                                        <div class="p-3 rounded-md bg-gray-800/50 text-sm space-y-2">
                                            <div class="flex justify-between items-center">
                                                <span id="sim-position-header" class="font-bold text-lg">LONG / 20x</span>
                                                <button id="sim-close-position-btn" class="btn-primary !bg-red-600 !text-xs !py-1 !px-3">Close Position</button>
                                            </div>
                                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                                <div>
                                                    <span class="text-gray-400">Size:</span>
                                                    <span id="sim-position-size" class="font-mono"></span>
                                                </div>
                                                <div>
                                                    <span class="text-gray-400">Entry:</span>
                                                    <span id="sim-position-entry" class="font-mono"></span>
                                                </div>
                                                <div>
                                                    <span class="text-gray-400">Mark:</span>
                                                    <span id="sim-position-mark" class="font-mono"></span>
                                                </div>
                                                <div>
                                                    <span class="text-gray-400">Liq:</span>
                                                    <span id="sim-position-liq" class="font-mono"></span>
                                                </div>
                                            </div>
                                            <div class="pt-2 border-t border-dashed border-gray-700">
                                                <span class="text-gray-400">PNL (ROE %):</span>
                                                <span id="sim-position-pnl" class="font-mono font-bold text-lg ml-2"></span>
                                            </div>
                                        </div>
                                    </div>

                                    <div>
                                        <div class="flex justify-between items-center mb-2">
                                            <h3 class="font-semibold text-gray-400">Trade History</h3>
                                            <div class="flex gap-2">
                                                <button id="sim-export-btn" class="btn-secondary !text-[10px] !py-0.5 !px-2">Export CSV</button>
                                                <button id="sim-import-btn" class="btn-secondary !text-[10px] !py-0.5 !px-2">Import CSV</button>
                                                <input type="file" id="sim-import-input" class="hidden" accept=".csv">
                                            </div>
                                        </div>
                                        <div id="sim-trade-history-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                                            <p class="text-center text-gray-600">No trade history yet.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>
                    </div>
                </div>
                </div>
        </div>
    </main>

<script>
    // ===================================================================
    let regimeSensorModel = null;
    let userSettings = {
        active: {
            weights: {}, 
            indicatorParams: {} 
        },
        presets: {
            'default': {
                weights: { 
                    ma: 2, 
                    pivot: 2, 
                    vwap: 2, 
                    ichimoku: 3, 
                    rsi: 1.5, 
                    stoch: 1, 
                    macd: 2, 
                    candlePattern: 1.5, 
                    psar: 1, 
                    linreg: 1, 
                    roc: 1, 
                    bollingerBands: 1, 
                    rsiDivergence: 2.5, 
                    obvDivergence: 3.0, 
                    openInterest: 1, 
                    fundingRate: 1, 
                    lsRatio: 1, 
                    orderBookBias: 1, 
                    bbSqueeze: 1.5 
                },
                indicatorParams: { 
                    rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9,
                    stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 
                }
            },
            
            // ===== PRESET BARU UNTUK REZIM PASAR =====
            'bullTrend': {
                weights: { 
                    ma: 3.0,          // Sangat penting dalam tren
                    ichimoku: 3.0,    // Sangat penting dalam tren
                    psar: 2.5,        // Sangat penting dalam tren
                    vwap: 2.5,
                    rsiDivergence: 1.0, // Kurang relevan saat tren kuat
                    stoch: 0.5,       // Osilator kurang berguna
                    bbSqueeze: 0.5   // Tidak relevan
                }
            },
            'bearTrend': {
                weights: { 
                    ma: 3.0,
                    ichimoku: 3.0,
                    psar: 2.5,
                    vwap: 2.5,
                    rsiDivergence: 1.0,
                    stoch: 0.5,
                    bbSqueeze: 0.5
                }
            },
            'lowVolatility': {
                weights: { 
                    bbSqueeze: 3.5,   // Sinyal paling penting!
                    rsi: 2.0,         // Berguna untuk melihat momentum yang mulai terbentuk
                    macd: 2.0,        // Cross MACD bisa jadi konfirmasi awal breakout
                    ma: 1.0,          // MA kurang relevan saat sideways
                    ichimoku: 1.0     // Awan Ichimoku biasanya datar dan tidak informatif
                }
            },
            'ranging': {
                weights: { 
                    rsi: 2.5,         // Osilator sangat berguna
                    stoch: 2.0,       // Sangat berguna untuk kondisi overbought/oversold
                    rsiDivergence: 3.0, // Divergensi adalah sinyal pembalikan yang kuat di pasar ranging
                    bollingerBands: 2.5, // Pantulan dari batas atas/bawah BB sangat relevan
                    ma: 1.0,          // Kurang relevan
                    psar: 1.0         // Kurang relevan
                }
            }
        }
    };
    let candleCountdownInterval = null;
    let newCandleJustStarted = false;
    let klineCache = {};
    let latestBids = [];
    let latestAsks = [];
    let liveAnalysisScores = {};
    let coinListCache = null;
    let exchangeInfoCache = { spot: null, futures: null };
    let cvdChartInstance = null;
    let liveCvdValue = 0;
    let liveCvdData = [];
    let liveCvdValueUsdt = 0;
    let periodicUpdateInterval = null;
    let latestCalculatedData = {};
    let lastUiUpdateTime = 0;
    let tradeQueue = [];
    let depthQueue = [];
    let klineQueue = [];
    let processingInterval = null;
    let fundingRateTimer = null;
    let orderBookDOMElements = null;
    let orderBookHistory = {
        avgVolumes: [], 
        maxSize: 50     
    };
    let topMoversInterval = null;
    let topMoversCountdown = null;
    let currentTimeframe = "1h";
    let currentInterval = 60000; // default 10 detik
    let remainingTime = currentInterval / 1000;
    let isTooltipActive = false;
    let lastCvdDipCalculationTime = 0;
    let lastCvdDipResult = { triggered: false, points: 0 }; 
    let cvdAggregator = {
        currentBucketTimestamp: 0,
        currentBucketDelta: 0,
        history: [], // Akan berisi [timestamp, totalDelta]
        lastTriggerResult: { triggered: false, points: 0 }
    };
    let charts = [];
    let candlestickSeries = null;
    let isChartsVisible = false;
    let activeStrategy = null;
    let chartSeries = {
        candlestick: null, volume: null, rsi: null, stochK: null, stochD: null,
        ema50: null, bbUpper: null, bbMiddle: null, bbLower: null,
        macdLine: null, signalLine: null, macdHist: null, roc: null
    };        
    let currentFibMode = 'extension';
// 
// BAGIAN 1: DEKLARASI SEMUA ELEMEN DOM
// 
    const gainersList = document.getElementById('gainers-list');
    const losersList = document.getElementById('losers-list');
    const navWrapper = document.getElementById('sticky-nav-wrapper');
    const mainContent = document.getElementById('main-content-container');
    const toggleAiVerdictBtn = document.getElementById('toggle-ai-verdict-btn');
    const toggleAiVerdictIcon = document.getElementById('toggle-ai-verdict-icon');
    const aiVerdictContentWrapper = document.getElementById('ai-verdict-content-wrapper');
    const assetInput = document.getElementById('asset-input');
    const apiKeyInput = document.getElementById('gemini-api-key');
    const timeframeSelect = document.getElementById('timeframe-select');
    const marketTypeSelect = document.getElementById('market-type-select');
    const analyzeBtn = document.getElementById('analyze-asset-btn');
    const buttonText = document.getElementById('button-text');
    const buttonLoader = document.getElementById('button-loader');
    const assetError = document.getElementById('asset-error');
    const dashboardContent = document.getElementById('dashboard-content');
    const initialPlaceholder = document.getElementById('initial-placeholder');
    const loaderOverlay = document.getElementById('loader-overlay');
    const loaderText = document.getElementById('loader-text');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const darkIcon = document.getElementById('theme-toggle-dark-icon');
    const lightIcon = document.getElementById('theme-toggle-light-icon');
    const projectionResultsContainer = document.getElementById('projection-results-container');
    const specificTokenTitle = document.getElementById('specific-token-title');
    const specificTokenContent = document.getElementById('specific-token-content');
    const trendingPoolsContent = document.getElementById('trending-pools-content');
    const fullOrderBookContainer = document.getElementById('full-order-book-container');
    const tradeLink = document.getElementById('trade-link');
    const navVolume24h = document.getElementById('nav-volume-24h');
    const navAth = document.getElementById('nav-ath');
    const navAtl = document.getElementById('nav-atl');
    const resetBtn = document.getElementById('reset-btn');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');
    const WebSocketManager = {
        ws: null,
        mainSubscriptions: new Set(),
        moverSubscriptions: new Set(),
        messageHandlers: {},
        reconnectBaseDelay: 5000, 
        reconnectAttempts: 0,
        maxReconnectDelay: 60000,
        isConnecting: false,
        
        handleOpen() {
            this.isConnecting = false;
            this.reconnectAttempts = 0; 
        },

        handleMessage(event) {
            const message = JSON.parse(event.data);
            if (message.result !== undefined) return;

            if (message.stream && message.data) {
                const streamName = message.stream;
                const payload = message.data;
                const symbol = streamName.split('@')[0].toUpperCase();


                if (this.moverSubscriptions.has(symbol)) {
                    onNewMoverData(symbol, streamName, payload);
                }
                
                if (realtimeCache.main.symbol && realtimeCache.main.symbol === symbol) {
                    if (streamName.includes('@kline')) {
                        if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                    } else if (streamName.includes('@aggTrade')) {
                        if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                    } else if (streamName.includes('@depth')) {
                        if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                    } else if (streamName.includes('@bookTicker')) {
                        if (this.messageHandlers['bookTicker']) this.messageHandlers['bookTicker'](payload);
                    }
                }
            }
        },

        handleClose() {
            this.isConnecting = false;
            if (this.mainSubscriptions.size > 0 || this.moverSubscriptions.size > 0) {
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectBaseDelay * (2 ** this.reconnectAttempts), this.maxReconnectDelay);
                setTimeout(() => this.connect(), delay);
            }
        },

        handleError(error) {
            console.error("Kesalahan WebSocket:", error);
            this.isConnecting = false;
            if (this.ws) this.ws.close();
        },

        connect() {
            if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) return;
            this.isConnecting = true;
            
            const moverStreams = Array.from(this.moverSubscriptions).flatMap(s => [`${s.toLowerCase()}@kline_1h`, `${s.toLowerCase()}@aggTrade`, `${s.toLowerCase()}@depth20`]);
            const mainStreams = Array.from(this.mainSubscriptions);
            const allSubscriptions = new Set([...mainStreams, ...moverStreams]);
            
            const streamNames = Array.from(allSubscriptions).join('/');
            
            if (streamNames.length === 0) {
                this.isConnecting = false;
                return;
            }
            const url = `wss://fstream.binance.com/stream?streams=${streamNames}`;
            this.ws = new WebSocket(url);
            this.ws.onopen = this.handleOpen.bind(this);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);
        },
        
        subscribe(streams) { // Hanya untuk panel utama
            this.mainSubscriptions.clear();
            streams.forEach(stream => this.mainSubscriptions.add(stream));
            this.reconnect();
        },

        // NEW CODE (AFTER PATCH)
        resetSubscriptions() { // Sekarang mereset SEMUA langganan
            this.mainSubscriptions.clear();
            this.moverSubscriptions.clear(); 
            this.reconnect();
        },

        subscribeToMovers(symbols) {
            const newSubs = new Set(symbols);
            if (new Set([...newSubs]).size === this.moverSubscriptions.size && [...newSubs].every(s => this.moverSubscriptions.has(s))) {
                return; // NONE perubahan, tidak perlu reconnect
            }
            this.moverSubscriptions = newSubs;
            this.reconnect();
        },

        reconnect() {
            if (this.ws) {
                this.ws.onclose = null;
                this.ws.close();
            }
            this.connect();
        },

        registerHandler(streamName, handler) {
            this.messageHandlers[streamName] = handler;
        }
    };
// 
// BAGIAN 2: KONSTANTA KONFIGURASI
// 
    const UI_UPDATE_INTERVAL = 500;
    const KLINE_CACHE_DURATION = 5 * 60 * 1000; // Cache berlaku 5 menit
    const CVD_DIP_DEBOUNCE_MS = 5000; 
    const timeframeParameterMap = {
        // Kategori Scalping (Timeframe <= 15m) -> Stoch RSI lebih sensitif
        '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        // Kategori Day Trading (Timeframe > 15m dan <= 4h) -> Stoch RSI standar
        '30m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '2h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        // Kategori Swing Trading (Timeframe > 4h) -> Stoch RSI lebih stabil
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1w': { rsi_period: 25, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 25, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };
    const CVD_AGGREGATION_INTERVAL_MS = 10000; // Agregasi data setiap 5 detik
    const CVD_HISTORY_LENGTH = 50; // Menyimpan histori 50 keranjang data (50 * 5 detik = 250 detik)
    const DEFAULT_WEIGHTS = {
        // Bobot utama yang sering disetel
        "ma": 2.0, 
        "macd": 2.0,
        "rsi": 1.5,
        "stoch": 1.0,

        // Bobot Konfluensi & Divergensi
        "rsiDivergence": 2.5,
        "obvDivergence": 3.0, // Ditemukan di DNA Generik
        "candlePattern": 1.5,
        "bollingerBands": 1.0,
        "bbSqueeze": 1.5,
        
        // Bobot Level/Support/Resistance
        "pivot": 2.0,
        "vwap": 2.0,
        "ichimoku": 1.5,
        "psar": 1.0,

        // Bobot Momentum
        "roc": 1.0,
        "linreg": 1.0,
        
        // *Tambahan Opsional yang tidak ditemukan di DNA Anda, tapi standar*
        // "openInterest": 0, 
        // "fundingRate": 0
    };
// 
// BAGIAN 3: DEKLARASI STATE & VARIABEL GLOBAL
// 
    const realtimeCache = {
    main: {
        symbol: null,
        tickerData: {},
        klines: [],
        calculatedData: {},
        // === TAMBAHAN KRITIS FINAL INI ===
        liveScores: { pumpStrength: 0, dumpRisk: 0 }, 
        // =================================
    },
    movers: {}
};
    const reconnectDelay = 5000; // Coba sambung kembali setiap 5 detik
    const REGIME_LABELS = ['BULL_TREND', 'BEAR_TREND', 'RANGING', 'LOW_VOLATILITY'];
    const MODEL_ARTIFACTS_JSON_STRING = `
            {
                "format": "layers-model",
                "generatedBy": "TensorFlow.js tfjs-layers v4.2.0",
                "convertedBy": null,
                "modelTopology": {"class_name":"Sequential","config":{"name":"sequential_1","layers":[{"class_name":"LSTM","config":{"name":"lstm_LSTM1","trainable":true,"batch_input_shape":[null,10,12],"dtype":"float32","units":64,"activation":"relu","recurrent_activation":"hard_sigmoid","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"recurrent_initializer":{"class_name":"Orthogonal","config":{"gain":1,"seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"unit_forget_bias":null,"kernel_regularizer":null,"recurrent_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"recurrent_constraint":null,"bias_constraint":null,"dropout":0,"recurrent_dropout":0,"implementation":null,"return_sequences":false,"return_state":false,"go_backwards":false,"stateful":false,"unroll":false}},{"class_name":"Dropout","config":{"rate":0.2,"noise_shape":null,"seed":null,"name":"dropout_Dropout1","trainable":true}},{"class_name":"Dense","config":{"units":32,"activation":"relu","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense1","trainable":true}},{"class_name":"Dense","config":{"units":4,"activation":"softmax","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense2","trainable":true}}]},"keras_version":"tfjs-layers 4.2.0","backend":"tensor_flow.js"},
                    "weightsManifest": [
                        {
                            "paths": ["weights.bin"],
                            "weights": [
                                {"name": "lstm_LSTM1/kernel", "shape": [12, 256], "dtype": "float32"},
                                {"name": "lstm_LSTM1/recurrent_kernel", "shape": [64, 256], "dtype": "float32"}, 
                                {"name": "lstm_LSTM1/bias", "shape": [256], "dtype": "float32"},
                                {"name": "dense_Dense1/kernel", "shape": [64, 32], "dtype": "float32"},
                                {"name": "dense_Dense1/bias", "shape": [32], "dtype": "float32"},
                                {"name": "dense_Dense2/kernel", "shape": [32, 4], "dtype": "float32"},
                                {"name": "dense_Dense2/bias", "shape": [4], "dtype": "float32"}
                            ]
                        }
                    ]
            }
    `;
    const WEIGHTS_BASE64_STRING = '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'; // <--- PASTIKAN TANDA INI ADA
// 
    const processQueues = async () => {
        let shouldUpdateMainUI = false;
        let shouldUpdateScalpingUI = false;

        // 1. Proses antrean KLINE (Logika Baru)
        if (klineQueue.length > 0) {
            const klinesToProcess = klineQueue.splice(0, klineQueue.length);

            klinesToProcess.forEach(message => {
                const candle = message.k;
                const timeframe = candle.i; // Timeframe dari pesan (cth: '5m', '1h')
                const mainTimeframe = timeframeSelect.value;
                const dumpTimeframe = document.getElementById('dump-trigger-timeframe-select').value;

                const formattedCandle = [
                    candle.t, candle.o, candle.h, candle.l, candle.c, candle.v,
                    candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B
                ];

                // Cek apakah ini untuk timeframe utama
                if (timeframe === mainTimeframe && realtimeCache.main.klines) {
                    const klinesCache = realtimeCache.main.klines;
                    if (candle.x) { 
                        klinesCache.shift();
                        klinesCache.push(formattedCandle);
                        newCandleJustStarted = true;
                    } else { 
                        klinesCache[klinesCache.length - 1] = formattedCandle;
                        if (newCandleJustStarted) {
                            startCandleCountdown(); 
                            newCandleJustStarted = false; 
                        }
                    }
                    shouldUpdateMainUI = true;
                    updateLiveCharts(candle);
                }
                
                else if (timeframe === dumpTimeframe && realtimeCache.main.multiTfKlines[dumpTimeframe]) {
                    const klinesCache = realtimeCache.main.multiTfKlines[dumpTimeframe];
                    if (candle.x) { 
                        klinesCache.shift();
                        klinesCache.push(formattedCandle);
                    } else { 
                        klinesCache[klinesCache.length - 1] = formattedCandle;
                    }
                    shouldUpdateScalpingUI = true;
                }
            });
        }
        // 2. Proses antrean TRADE (Logika Lama yang Dikembalikan)
        if (tradeQueue.length > 0) {
            try {
                const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
                tradesToProcess.forEach(trade => {
                    const quantity = parseFloat(trade.q);
                    const price = parseFloat(trade.p);

    
                    // 1. Perbarui harga di cache utama agar simulasi bisa membacanya
                    if (realtimeCache.main.tickerData) {
                        realtimeCache.main.tickerData.lastPrice = price;
                    }

                    // 2. Perbarui harga di input kalkulator secara real-time
                    const marketPriceInput = tsCalc.elements.marketPrice;
                    // Hanya update jika pengguna tidak sedang mengetik di dalamnya
                    if (document.activeElement !== marketPriceInput) {
                        marketPriceInput.value = price.toFixed(getPrecisionForAsset(price));
                    }

                    // 3. Perbarui harga di header navigasi (kode lama yang dipertahankan)
                    const navPriceEl = document.getElementById('nav-price');
                    if (navPriceEl) {
                        navPriceEl.textContent = formatPrice(price);
                    }

                    const now = trade.T;
                    const bucketTimestamp = Math.floor(now / CVD_AGGREGATION_INTERVAL_MS) * CVD_AGGREGATION_INTERVAL_MS;
                    if (bucketTimestamp > cvdAggregator.currentBucketTimestamp) {
                        if (cvdAggregator.currentBucketTimestamp > 0) {
                            cvdAggregator.history.push({ 
                                time: cvdAggregator.currentBucketTimestamp, 
                                delta: cvdAggregator.currentBucketDelta 
                            });
                            if (cvdAggregator.history.length > CVD_HISTORY_LENGTH) {
                                cvdAggregator.history.shift();
                            }
                        }
                        cvdAggregator.currentBucketTimestamp = bucketTimestamp;
                        cvdAggregator.currentBucketDelta = 0;
                    }
                    const sign = trade.m ? -1 : 1;
                    cvdAggregator.currentBucketDelta += (quantity * price * sign);
                    
                    if (cvdChartInstance) {
                        if (isNaN(quantity) || quantity === 0) return;
                        liveCvdValue += quantity * sign;
                        liveCvdValueUsdt += (quantity * price) * sign;
                        const newPoint = { x: trade.T, y_coin: liveCvdValue, y_usdt: liveCvdValueUsdt };
                        cvdChartInstance.data.datasets[0].data.push(newPoint);
                        liveCvdData.push(newPoint);
                        while (cvdChartInstance.data.datasets[0].data.length > 300) {
                            cvdChartInstance.data.datasets[0].data.shift();
                            liveCvdData.shift();
                        }
                        cvdChartInstance.update('none');
                        updateCvdTableLive();
                    }
                });
            } catch (error) {
                console.error("Error saat memproses trade:", error);
            }
        }

        // 3. Proses antrean DEPTH/Order Book (Logika Lama yang Dikembalikan)
        if (depthQueue.length > 0) {
            try {
                const updatesToProcess = depthQueue.splice(0, depthQueue.length);
                updatesToProcess.forEach(update => {
                    if (update.b) {
                        update.b.forEach(([price, qty]) => {
                            const existingIndex = latestBids.findIndex(bid => bid[0] === price);
                            if (parseFloat(qty) === 0) {
                                if (existingIndex !== -1) latestBids.splice(existingIndex, 1);
                            } else {
                                if (existingIndex !== -1) latestBids[existingIndex] = [price, qty];
                                else latestBids.push([price, qty]);
                            }
                        });
                    }
                    if (update.a) {
                        update.a.forEach(([price, qty]) => {
                            const existingIndex = latestAsks.findIndex(ask => ask[0] === price);
                            if (parseFloat(qty) === 0) {
                                if (existingIndex !== -1) latestAsks.splice(existingIndex, 1);
                            } else {
                                if (existingIndex !== -1) latestAsks[existingIndex] = [price, qty];
                                else latestAsks.push([price, qty]);
                            }
                        });
                    }
                });
                latestBids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
                latestAsks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
                const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
                const precision = getPrecisionForAsset(parseFloat(latestPrice));
                const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
                renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
            } catch (error) {
                console.error("Error saat memproses depth:", error);
            }
        }

        // 4. Panggil fungsi update UI berdasarkan data mana yang baru (Logika Baru)
        const now = Date.now();
        if (shouldUpdateMainUI && (now - lastUiUpdateTime > 3000)) { 
            lastUiUpdateTime = now;
            await updateRealTimeIndicators(realtimeCache.main.klines);
        } else if (shouldUpdateScalpingUI) {
            // Jika hanya data scalping yang berubah, cukup update panel scalping
            calculateAndDisplayScalpingSetup();
        }
    };
// == BLOK FUNGSI KALKULASI INDIKATOR 
// 
    const calculateEMA = (data, period) => {
        if (!data || data.length < period) return [];
        const k = 2 / (period + 1);
        let emaArray = Array(period - 1).fill(undefined);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        let currentEma = sum / period;
        emaArray.push(currentEma);
        for (let i = period; i < data.length; i++) {
            currentEma = (data[i] * k) + (currentEma * (1 - k));
            emaArray.push(currentEma);
        }
        return emaArray;
    };
// 
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) return [];
        let sma = Array(period - 1).fill(undefined);
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            sma.push(slice.reduce((a, b) => a + b, 0) / period);
        }
        return sma;
    };

    const calculateRSI = (closes, period = userSettings.active.indicatorParams.rsi_period) => {
        if (!closes || closes.length <= period) return Array(closes?.length || 0).fill(undefined);
        let gains = [], losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        if (avgLoss === 0) return Array(closes.length).fill(100);
        let rsi = [100 - (100 / (1 + (avgGain / avgLoss)))];
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            if (avgLoss === 0) { rsi.push(100); } 
            else { rsi.push(100 - (100 / (1 + (avgGain / avgLoss)))); }
        }
        return Array(period).fill(undefined).concat(rsi);
    };
// 
    const calculateMACD = (closes, fast = userSettings.active.indicatorParams.macd_fast, slow = userSettings.active.indicatorParams.macd_slow, signal = userSettings.active.indicatorParams.macd_signal) => {
        if (closes.length < slow + signal) {
            return { status: 'Netral', hist: 'Netral', class: 'text-gray-500', macdLine: [], signalLine: [], histogram: [] };
        }
    const emaFast = calculateEMA(closes, fast);
    const emaSlow = calculateEMA(closes, slow);
        
    const macdLine = emaSlow.map((slowVal, i) => {
        if (slowVal !== undefined && emaFast[i] !== undefined) {
            return emaFast[i] - slowVal;
        }
            return undefined;
        });

        const signalLine = calculateEMA(macdLine.filter(v => v !== undefined), signal);
        const histogram = macdLine.map((macdVal, i) => {
            const signalIndex = i - (slow - 1); 
            if (macdVal !== undefined && signalLine[signalIndex] !== undefined) {
                const histValue = macdVal - signalLine[signalIndex];
                const prevHistValue = (i > 0 && macdLine[i-1] !== undefined && signalLine[signalIndex-1] !== undefined) 
                                    ? (macdLine[i-1] - signalLine[signalIndex-1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        });

        const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
        const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
        const lastHist = histogram.filter(v => v !== undefined).pop()?.value || 0;
        const prevMacdLine = macdLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        const prevSignalLine = signalLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        
        let status = 'Netral', macdClass = 'text-gray-500';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) { 
            status = 'Bullish Cross'; 
            macdClass = 'positive'; 
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) { 
            status = 'Bearish Cross'; 
            macdClass = 'negative'; 
        }
        
        return { 
            status, 
            hist: lastHist > 0 ? '(Naik)' : '(Turun)', 
            class: macdClass, 
            macdLine, 
            signalLine, 
            histogram 
        };
    };
// 
    const calculateStochasticRSI = (closes, 
        rsiPeriod = userSettings.active.indicatorParams.stoch_rsi_period, 
        stochPeriod = userSettings.active.indicatorParams.stoch_stoch_period, 
        kSmooth = userSettings.active.indicatorParams.stoch_k_smooth, 
        dSmooth = userSettings.active.indicatorParams.stoch_d_smooth
    ) => {
        const rsiValues = calculateRSI(closes, rsiPeriod).filter(v => v !== undefined);
        if (rsiValues.length < stochPeriod) {
            return { k: 50, d: 50, status: 'Netral', class: 'tag-gray', kLine: [], dLine: [], kOffset: 0, dOffset: 0 };
        }
        const stochArr = [];
        for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
            const window = rsiValues.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((rsiValues[i] - minR) / denom) * 100);
        }
        const kLine = calculateSMA(stochArr, kSmooth);
        const dLine = calculateSMA(kLine.filter(v => v !== undefined), dSmooth);
        const lastK = kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = dLine.filter(v => v !== undefined).pop() || 50;
        let status = 'Netral', stochClass = 'tag-yellow';
        if (lastK > 80 && lastD > 80) { status = 'Overbought'; stochClass = 'tag-red'; }
        else if (lastK < 20 && lastD < 20) { status = 'Oversold'; stochClass = 'tag-green'; }
        const kOffset = closes.length - kLine.length;
        const dOffset = closes.length - dLine.length;
        return {
            k: lastK.toFixed(2), d: lastD.toFixed(2), status, class: stochClass,
            kLine, dLine, kOffset, dOffset
        };
    };
// 
    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) return { upper: [], middle: [], lower: [], width: [], status: 'N/A' };
        const middle = calculateSMA(closes, period);
        let upper = Array(period - 1).fill(undefined);
        let lower = Array(period - 1).fill(undefined);
        let width = Array(period - 1).fill(undefined);

        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                width.push(undefined);
                continue;
            };
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            upper.push(middle[i] + (stdev * stdDev));
            lower.push(middle[i] - (stdev * stdDev));
            width.push((middle[i] + (stdev * stdDev)) - (middle[i] - (stdev * stdDev))); 
        }

        const lastClose = closes[closes.length - 1];
        const lastUpper = upper.filter(v => v !== undefined).pop();
        const lastLower = lower.filter(v => v !== undefined).pop();
        const lastWidth = width.filter(v => v !== undefined).pop();

        let status = 'INSIDE';
        if (lastClose > lastUpper) status = 'Above';
        if (lastClose < lastLower) status = 'Below';

        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            const recentWidths = width.slice(-50);
            const minWidth = Math.min(...recentWidths);
            const avgWidth = recentWidths.reduce((a, b) => a + b, 0) / recentWidths.length;
            if (lastWidth < avgWidth * 0.7) { 
                squeezeStatus = 'Squeeze!';
            }
        }

        return { upper, middle, lower, width, status, squeezeStatus }; 
    };
// 
    const calculateVPVR = (klines, numRows = 70, valueAreaPercent = 0.70) => {
        if (!klines || klines.length === 0) return { poc: 0, vah: 0, val: 0 };
        let overallLow = Infinity, overallHigh = -Infinity;
        const candles = klines.map(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]);
            if (high > overallHigh) overallHigh = high;
            if (low < overallLow) overallLow = low;
            return { high, low, volume: parseFloat(k[5]) };
        });
        const rowSize = (overallHigh - overallLow) / numRows;
        let profile = Array.from({ length: numRows }, (_, i) => ({ price: overallLow + (i * rowSize), volume: 0 }));
        let totalVolume = 0;
        candles.forEach(c => {
            totalVolume += c.volume;
            const startIdx = Math.max(0, Math.floor((c.low - overallLow) / rowSize));
            const endIdx = Math.min(numRows - 1, Math.floor((c.high - overallLow) / rowSize));
            const volPerRow = c.volume / (endIdx - startIdx + 1);
            for (let i = startIdx; i <= endIdx; i++) profile[i].volume += volPerRow;
        });
        if (totalVolume === 0) return { poc: 0, vah: 0, val: 0 };
        let pocIndex = profile.reduce((maxIdx, row, idx, arr) => row.volume > arr[maxIdx].volume ? idx : maxIdx, 0);
        const poc = profile[pocIndex].price + (rowSize / 2);
        const targetVolume = totalVolume * valueAreaPercent;
        let vaVolume = profile[pocIndex].volume;
        let upperIdx = pocIndex, lowerIdx = pocIndex;
        while (vaVolume < targetVolume) {
            const volAbove = (upperIdx + 1 < numRows) ? profile[upperIdx + 1].volume : -1;
            const volBelow = (lowerIdx - 1 >= 0) ? profile[lowerIdx - 1].volume : -1;
            if (volAbove === -1 && volBelow === -1) break;
            if (volAbove > volBelow) {
                upperIdx++;
                vaVolume += profile[upperIdx].volume;
            } else {
                lowerIdx--;
                vaVolume += profile[lowerIdx].volume;
            }
        }
        return { poc, vah: profile[upperIdx].price + rowSize, val: profile[lowerIdx].price };
    };
// 
    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { adx: 'N/A', plusDI: 'N/A', minusDI: 'N/A' };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
    // =============================================
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { adx: adxValues.filter(v=>v!==undefined).pop()?.toFixed(2) || 'N/A', plusDI: plusDIs.pop()?.toFixed(2) || 'N/A', minusDI: minusDIs.pop()?.toFixed(2) || 'N/A' };
    };
// 
    const findCandlestickPatterns = (klines) => {        
        if (!klines || klines.length < 3) {            
            return { pattern: 'NONE', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: null };
        }
               
        const lastCandleTimestamp = klines[klines.length - 1][0];
        const getCandleDetails = (k) => {
            const [open, high, low, close] = k.slice(1, 5).map(parseFloat);
            return { open, high, low, close, body: Math.abs(close - open), isGreen: close > open, isRed: close < open };
        };

        const c1 = getCandleDetails(klines[klines.length - 1]); 
        const c2 = getCandleDetails(klines[klines.length - 2]);
        const c3 = getCandleDetails(klines[klines.length - 3]);

        
        let result = { pattern: 'NONE', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: lastCandleTimestamp };

        if (c3.isGreen && c2.isGreen && c1.isGreen && c1.close > c2.close && c2.close > c3.close) {
            result = { pattern: 'THREE WHITE SOLDIERS', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('THREE_WHITE_SOLDIERS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.isRed && c1.isRed && c1.close < c2.close && c2.close < c3.close) {
            result = { pattern: 'THREE BLACK CROWS', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('THREE_BLACK_CROWS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.body < c3.body * 0.3 && c1.isGreen && c1.close > c3.open) {
            result = { pattern: 'MORNING STAR', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('MORNING_STAR'), timestamp: lastCandleTimestamp };
        } else if (c3.isGreen && c2.body < c3.body * 0.3 && c1.isRed && c1.close < c3.open) {
            result = { pattern: 'EVENING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('EVENING_STAR'), timestamp: lastCandleTimestamp };
        }

        if (result.pattern === 'NONE') {
            if (c2.isRed && c1.isGreen && c1.close > c2.open && c1.open < c2.close) {
                result = { pattern: 'BULLISH ENGULFING', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.close < c2.open && c1.open > c2.close) {
                result = { pattern: 'BEARISH ENGULFING', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.close && c1.close < c2.open && c1.close > (c2.open + c2.body/2)) {
                result = { pattern: 'DARK CLOUD COVER', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('DARK_CLOUD_COVER'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.close && c1.close > c2.open && c1.close < (c2.open - c2.body/2)) {
                result = { pattern: 'PIERCING LINE', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('PIERCING_LINE'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close) {
                result = { pattern: 'BEARISH HARAMI', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close) {
                result = { pattern: 'BULLISH HARAMI', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.high - c2.high) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER TOP', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('TWEEZER_TOP'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.low - c2.low) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER BOTTOM', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('TWEEZER_BOTTOM'), timestamp: lastCandleTimestamp };
            }
        }

        if (result.pattern === 'NONE') {
            const lowerWick = Math.min(c1.open, c1.close) - c1.low;
            const upperWick = c1.high - Math.max(c1.open, c1.close);
            if (lowerWick > c1.body * 2 && upperWick < c1.body * 0.5) {
                result = { pattern: 'HAMMER', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('HAMMER'), timestamp: lastCandleTimestamp };
            } else if (upperWick > c1.body * 2 && lowerWick < c1.body * 0.5) {
                result = { pattern: 'SHOOTING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('SHOOTING_STAR'), timestamp: lastCandleTimestamp };
            }
        }
        
        return result;
    };
// 
    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE', class: 'text-gray-500' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPeaks = (data, isHigh) => {
            let peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    peaks.push({ index: i, value: data[i] });
                }
            }
            return peaks;
        };
        const priceLows = findPeaks(recentCloses, false), priceHighs = findPeaks(recentCloses, true);
        const rsiLows = findPeaks(recentRSI, false), rsiHighs = findPeaks(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };
// 
    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };

    const calculateCVD = (trades) => {
        let cumulativeDeltaCoin = 0;
        let cumulativeDeltaUsdt = 0;
        return trades.map(t => {
            const quantity = parseFloat(t.q);
            const price = parseFloat(t.p);
            const sign = t.m ? -1 : 1; 
            
            cumulativeDeltaCoin += quantity * sign;
            cumulativeDeltaUsdt += (quantity * price) * sign;

            return { 
                time: t.T / 1000, 
                cvd_coin: cumulativeDeltaCoin,
                cvd_usdt: cumulativeDeltaUsdt 
            };
        });
    };

    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) {
                obv.push(obv[i - 1] + volume);
            } else if (close < prevClose) {
                obv.push(obv[i - 1] - volume);
            } else {
                obv.push(obv[i - 1]);
            }
        }
        return obv;
    };

    function CVDanalyze(klines, cvdData) {
        if (!klines || klines.length < 2 || !cvdData || cvdData.length < 2) {
        return { trend: 'N/A', divergence: 'N/A', summary: 'Data tidak cukup untuk analisa CVD.' };
        }

        const firstPrice = parseFloat(klines[0][4]);
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const priceTrend = lastPrice > firstPrice ? 'Naik' : (lastPrice < firstPrice ? 'Turun' : 'Datar');

        const firstCvd = cvdData[0].cvd_usdt;
        const lastCvd = cvdData[cvdData.length - 1].cvd_usdt;
        const cvdTrend = lastCvd > firstCvd ? 'Naik' : (lastCvd < firstCvd ? 'Turun' : 'Datar');

        let divergence = 'NONE';
        let summary = `Tren harga dan CVD bergerak selaras (${priceTrend}).`;

            if (priceTrend === 'Naik' && cvdTrend === 'Turun') {
                divergence = 'Bearish 👎';
                summary = 'Harga naik tetapi tekanan beli melemah. Hati-hati, ini adalah sinyal divergensi bearish.';
            } else if (priceTrend === 'Turun' && cvdTrend === 'Naik') {
                divergence = 'Bullish 👍';
                summary = 'Harga turun tetapi tekanan beli menguat. Ini adalah sinyal divergensi bullish yang potensial.';
            }

            return {
                trend: cvdTrend,
                divergence: divergence,
                summary: summary
            };
    }

    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline || prevDayKline.length < 5) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);

        if (isNaN(high) || isNaN(low) || isNaN(close)) {
            console.error("Gagal menghitung Pivot: Salah satu data (H, L, C) bukan angka yang valid.", {high, low, close});
            return null;
        }

        const P = (high + low + close) / 3;
        const R1 = (2 * P) - low;
        const S1 = (2 * P) - high;
        const R2 = P + (high - low);
        const S2 = P - (high - low);
        const R3 = high + 2 * (P - low);
        const S3 = low - 2 * (high - P);

        return { P, R1, S1, R2, S2, R3, S3 };
    }
// 
    function calculateKeltnerChannels(klines, period = 20, multiplier = 2, atrPeriod = 10) {
        if (!klines || klines.length < period) return { upper: [], middle: [], lower: [], width: [] };
        const closes = klines.map(k => parseFloat(k[4]));
        const emaMiddle = calculateEMA(closes, period);
        const atr = calculateATR(klines, atrPeriod).value; 

        const upper = emaMiddle.map(val => val !== undefined ? val + (atr * multiplier) : undefined);
        const lower = emaMiddle.map(val => val !== undefined ? val - (atr * multiplier) : undefined);
        const width = upper.map((u, i) => (u !== undefined && lower[i] !== undefined) ? u - lower[i] : undefined);
        
        return { upper, middle: emaMiddle, lower, width };
    }
// 
    function calculateIchimokuCloud(klines, tenkanP = 9, kijunP = 26, senkouP = 52) {
        if (klines.length < senkouP) return null;
        
        const result = { tenkan: [], kijun: [], senkouA: [], senkouB: [], chikou: [], status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= tenkanP - 1 ? getHighLow(klines.slice(i - tenkanP + 1, i + 1)) : { high: 0, low: 0 };
            result.tenkan.push(i >= tenkanP - 1 ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= kijunP - 1 ? getHighLow(klines.slice(i - kijunP + 1, i + 1)) : { high: 0, low: 0 };
            result.kijun.push(i >= kijunP - 1 ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
            result.chikou.push(parseFloat(klines[i][4]));
        }
        for (let i = 0; i < klines.length; i++) {
            const senkouA_val = (result.tenkan[i] !== undefined && result.kijun[i] !== undefined) ? (result.tenkan[i] + result.kijun[i]) / 2 : undefined;
            result.senkouA.push(senkouA_val);
            const senkouB_HighLow = i >= senkouP - 1 ? getHighLow(klines.slice(i - senkouP + 1, i + 1)) : { high: 0, low: 0 };
            result.senkouB.push(i >= senkouP - 1 ? (senkouB_HighLow.high + senkouB_HighLow.low) / 2 : undefined);
        }

        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = result.tenkan[result.tenkan.length - 1];
        const lastKijun = result.kijun[result.kijun.length - 1];
        
        const currentSenkouA = result.senkouA[klines.length - 1 - kijunP];
        const currentSenkouB = result.senkouB[klines.length - 1 - kijunP];
        
        const pastPriceForChikou = parseFloat(klines[klines.length - 1 - kijunP][4]);

        const isBullish = lastPrice > currentSenkouA && lastPrice > currentSenkouB &&
                        lastTenkan > lastKijun &&
                        lastPrice > pastPriceForChikou;

        const isBearish = lastPrice < currentSenkouA && lastPrice < currentSenkouB &&
                        lastTenkan < lastKijun &&
                        lastPrice < pastPriceForChikou;

        if (isBullish) {
            result.status = "Bullish";
        } else if (isBearish) {
            result.status = "Bearish";
        }
        
        return result;
    }
// 
    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A', atrPercent: 0 };
        }

        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }

        const rma = (data, p) => {
            let smoothed = [];
            let sum = 0;
            for(let i=0; i<data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    if (i === p - 1) smoothed.push(sum/p);
                    else smoothed.push(undefined);
                } else if (smoothed[i-1] !== undefined) {
                    smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return smoothed;
        };
        
        const atrValues = rma(trs, period);
        const atr = atrValues.pop() || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
        
        let status;
        if (atrPercent > 5) {
            status = 'Very High';
        } else if (atrPercent > 2.5) {
            status = 'High';
        } else if (atrPercent < 1) {
            status = 'Low';
        } else {
            status = 'Normal';
        }
        
        return { value: atr, status: status, atrPercent: atrPercent }; 
    }

    function calculateATRPercentage(klines, period = 14) {
        if (!klines || klines.length === 0) {
            return 0; 
        }
        const atrResult = calculateATR(klines, period);
        return atrResult.atrPercent;
    }

    function calculateROC(closes, period = 12) {
        if (!closes || closes.length < period + 1) {
            return { values: [], value: 0, status: 'N/A' };
        }

        const rocValues = [];

        for (let i = period; i < closes.length; i++) {
            const currentClose = closes[i];
            const pastClose = closes[i - period];
            rocValues.push(pastClose !== 0 ? ((currentClose - pastClose) / pastClose) * 100 : 0);
        }

        const lastRoc = rocValues[rocValues.length - 1] || 0;
        const status = lastRoc > 0 ? 'Positif' : 'Negatif';

        return { values: rocValues, value: lastRoc, status: status };
    }
// 
    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { value: 0, status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { value: sar, status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }
// 
    function calculateLinearRegressionChannel(closes, period = 14, stdDev = 2) {
        if (closes.length < period) return { upper: 0, middle: 0, lower: 0, status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        let sumErrSq = 0;
        for (let i = 0; i < n; i++) {
            const predictedY = intercept + slope * i;
            sumErrSq += Math.pow(y[i] - predictedY, 2);
        }
        const stdErr = Math.sqrt(sumErrSq / (n - 2));

        const middle = intercept + slope * (n - 1);
        const upper = middle + (stdDev * stdErr);
        const lower = middle - (stdDev * stdErr);
        
        const lastClose = closes[closes.length - 1];
        let status = "In Channel";
        if(lastClose > upper) status = "Upper Line Channel";
        if(lastClose < lower) status = "Lower Line Channel";

        return { upper, middle, lower, status };
    }
// 
    function calculateVWAP(klines, mode = 'rolling', period = 20) {
        if (!klines || klines.length === 0) return 0;

        let sumPV = 0; // sum(Price * Volume)
        let sumV = 0;  // sum(Volume)
        let vwapValues = [];

        if (mode === 'rolling') {
            const recentKlines = klines.slice(-period);
            recentKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;

        } else if (mode === 'session') {
            const todayUTC = new Date().toISOString().slice(0, 10);
            const sessionKlines = klines.filter(k => new Date(k[0]).toISOString().slice(0, 10) === todayUTC);
            if (sessionKlines.length === 0) return 0; // NONE data untuk sesi hari ini
            
            sessionKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;

        } else if (mode === 'anchored') {
            const anchorLookback = 200; // Mencari titik terendah dalam 200 candle terakhir
            const recentSlice = klines.slice(-anchorLookback);
            if (recentSlice.length === 0) return 0;

            let lowestLow = Infinity;
            let anchorIndex = -1;
            
            recentSlice.forEach((k, index) => {
                const low = parseFloat(k[3]);
                if (low < lowestLow) {
                    lowestLow = low;
                    anchorIndex = klines.length - anchorLookback + index;
                }
            });

            const anchoredKlines = klines.slice(anchorIndex);
            anchoredKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;
        }
        return 0; // Fallback
    }

    function analyzeBollingerBandsPriceAction(klines, bbData) {
        if (!klines || klines.length < 2 || !bbData || bbData.upper.length < 2) {
            return { rejection: 'NONE', walkTheBands: 'NONE' };
        }

        const lastKline = klines[klines.length - 1];
        const prevKline = klines[klines.length - 2];
        const lastUpper = bbData.upper.pop()?.value;
        const lastLower = bbData.lower.pop()?.value;
        const prevUpper = bbData.upper.pop()?.value;
        const prevLower = bbData.lower.pop()?.value;
        const lastClose = parseFloat(lastKline[4]);
        const prevClose = parseFloat(prevKline[4]);

        let rejection = 'NONE';
        if (prevClose < prevLower && lastClose > lastLower && lastClose > prevClose) {
            rejection = 'Bullish Rejection (Lower BB)';
        }
        if (prevClose > prevUpper && lastClose < lastUpper && lastClose < prevClose) {
            rejection = 'Bearish Rejection (Upper BB)';
        }

        let walkTheBands = 'NONE';
        if (lastClose >= lastUpper && prevClose >= prevUpper) {
            walkTheBands = 'Bullish (Upper BB)';
        }
        if (lastClose <= lastLower && prevClose <= prevLower) {
            walkTheBands = 'Bearish (Lower BB)';
        }
        
        return { rejection, walkTheBands };
    }

    function getPatternSVG(patternName) {
        const svgHeader = `<svg viewBox="0 0 110 60" class="w-24 h-auto mx-auto my-2">`;
        const svgFooter = `</svg>`;
        const green = '#26a69a', red = '#ef5350', gray = '#2A1E27';

        let content = '';

        const createCandle = (x, open, high, low, close, color) => {
            const bodyY = Math.min(open, close);
            const bodyHeight = Math.abs(open - close);
            return `
                <line x1="${x+10}" y1="${high}" x2="${x+10}" y2="${low}" stroke="${color}" stroke-width="1"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" fill="${color}"/>
            `;
        };

        switch(patternName) {
            // --- POLA BULLISH ---
            case 'BULLISH_ENGULFING':
                content = createCandle(20, 40, 45, 25, 30, red) + createCandle(50, 28, 55, 10, 50, green);
                break;
            case 'HAMMER':
                content = createCandle(40, 50, 52, 10, 48, red);
                break;
            case 'MORNING_STAR':
                content = createCandle(10, 50, 55, 15, 20, red) + createCandle(40, 15, 20, 5, 12, gray) + createCandle(70, 18, 50, 15, 45, green);
                break;
            case 'THREE_WHITE_SOLDIERS':
                content = createCandle(10, 25, 35, 10, 30, green) + createCandle(40, 32, 45, 28, 40, green) + createCandle(70, 42, 55, 38, 50, green);
                break;
            case 'BULLISH_HARAMI':
                content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                break;
            case 'TWEEZER_BOTTOM':
                content = createCandle(20, 40, 45, 10, 20, red) + createCandle(50, 22, 48, 10, 35, green);
                break;
            // --- POLA BEARISH ---
            case 'BEARISH_ENGULFING':
                content = createCandle(20, 20, 45, 15, 40, green) + createCandle(50, 42, 55, 10, 15, red);
                break;
            case 'SHOOTING_STAR':
                content = createCandle(40, 12, 50, 10, 15, green);
                break;
            case 'EVENING_STAR':
                content = createCandle(10, 15, 50, 10, 45, green) + createCandle(40, 52, 58, 48, 50, gray) + createCandle(70, 48, 50, 15, 20, red);
                break;
            case 'THREE_BLACK_CROWS':
                content = createCandle(10, 50, 55, 30, 45, red) + createCandle(40, 42, 48, 20, 25, red) + createCandle(70, 22, 28, 5, 10, red);
                break;
            case 'BEARISH_HARAMI':
                content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                break;
            case 'TWEEZER_TOP':
                content = createCandle(20, 20, 55, 15, 40, green) + createCandle(50, 38, 55, 18, 25, red);
                break;
            default:
                return ''; 
        }

        return svgHeader + content + svgFooter;
    }
// 
    function findPivots(klines, lookback = 10) {
        const pivots = [];
        if (klines.length < lookback * 2 + 1) return [];

        for (let i = lookback; i < klines.length - lookback; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            let isHigh = true, isLow = true;

            for (let j = 1; j <= lookback; j++) {
                if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
            }
            if (isHigh) pivots.push({ type: 'high', price: high, index: i });
            else if (isLow) pivots.push({ type: 'low', price: low, index: i });
        }
        return pivots;
    }
// 
    function calculateSlope(p1, p2) {
        if (p2.index === p1.index) return Infinity;
        return (p2.price - p1.price) / (p2.index - p1.index);
    }  
// 
    function detectHeadAndShoulders(pivots) {
        for (let i = 4; i < pivots.length; i++) {
            const p1 = pivots[i-4], p2 = pivots[i-3], p3 = pivots[i-2], p4 = pivots[i-1], p5 = pivots[i];
            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high' && p4.type === 'low' && p5.type === 'high') {
                if (p3.price > p1.price && p3.price > p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'HEAD & SHOULDERS', class: 'negative blinking-text-animation' };
                }
            }
           
            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low' && p4.type === 'high' && p5.type === 'low') {
                 if (p3.price < p1.price && p3.price < p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'INVERSE H&S', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }
// 
    function detectDoubles(pivots) {
        for (let i = 2; i < pivots.length; i++) {
            // Cek Double Top: H, L, H
            const p1_dt = pivots[i-2], p2_dt = pivots[i-1], p3_dt = pivots[i];
            if (p1_dt.type === 'high' && p2_dt.type === 'low' && p3_dt.type === 'high') {
                if (Math.abs(p1_dt.price - p3_dt.price) / p3_dt.price < 0.03 && p2_dt.price < p1_dt.price) {
                    return { pattern: 'DOUBLE TOP', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Double Bottom: L, H, L
            const p1_db = pivots[i-2], p2_db = pivots[i-1], p3_db = pivots[i];
            if (p1_db.type === 'low' && p2_db.type === 'high' && p3_db.type === 'low') {
                if (Math.abs(p1_db.price - p3_db.price) / p3_db.price < 0.03 && p2_db.price > p1_db.price) {
                    return { pattern: 'DOUBLE BOTTOM', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }
// 
    function detectTriangles(pivots) {
        const recentPivots = pivots.slice(-7); 
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lastLow = lows[lows.length - 1], prevLow = lows[lows.length - 2];
            const lastHigh = highs[highs.length - 1], prevHigh = highs[highs.length - 2];

            const isLowsAscending = lastLow.price > prevLow.price;
            const isHighsFlat = Math.abs(lastHigh.price - prevHigh.price) / prevHigh.price < 0.015; // Toleransi 1.5%
            if (isLowsAscending && isHighsFlat) return { pattern: 'ASCENDING TRIANGLE', class: 'positive' };

            const isHighsDescending = lastHigh.price < prevHigh.price;
            const isLowsFlat = Math.abs(lastLow.price - prevLow.price) / prevLow.price < 0.015; // Toleransi 1.5%
            if (isHighsDescending && isLowsFlat) return { pattern: 'DESCENDING TRIANGLE', class: 'negative' };

            if (isLowsAscending && isHighsDescending) return { pattern: 'SYMMETRICAL TRIANGLE', class: 'text-yellow-400' };
        }
        return null;
    }
// 
    function detectWedges(pivots) {
        const recentPivots = pivots.slice(-7);
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lowSlope = calculateSlope(lows[lows.length - 2], lows[lows.length - 1]);
            const highSlope = calculateSlope(highs[highs.length - 2], highs[highs.length - 1]);

            
            if (lowSlope > 0 && highSlope > 0 && lowSlope > highSlope) {
                 return { pattern: 'RISING WEDGE', class: 'negative blinking-text-animation' };
            }
            
            if (lowSlope < 0 && highSlope < 0 && Math.abs(highSlope) > Math.abs(lowSlope)) {
                return { pattern: 'FALLING WEDGE', class: 'positive blinking-text-animation' };
            }
        }
        return null;
    }
// 
    function detectFlags(klines) {
        const lookback = 30; 
        const flagLength = 10;
        if (klines.length < lookback + flagLength) return null;
        
        const closes = klines.map(k => parseFloat(k[4]));
        const poleStartPrice = closes[closes.length - flagLength - lookback];
        const poleEndPrice = closes[closes.length - flagLength];
        const priceChange = (poleEndPrice - poleStartPrice) / poleStartPrice;
        
        
        if (priceChange > 0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            
            if (flagLow > poleStartPrice + (poleEndPrice - poleStartPrice) * 0.5) {
                return { pattern: 'BULL FLAG', class: 'positive' };
            }
        }
        
        if (priceChange < -0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);

            if (flagHigh < poleStartPrice - (poleStartPrice - poleEndPrice) * 0.5) {
                return { pattern: 'BEAR FLAG', class: 'negative' };
            }
        }
        return null;
    }
// 
    function findChartPatterns(klines) {
        if (!klines || klines.length < 50) {
            return { pattern: 'Data Kurang', class: 'text-gray-500' };
        }
        
        const pivots = findPivots(klines, 10);
        let pattern;
            
        pattern = detectHeadAndShoulders(pivots);
        if (pattern) return pattern;

        pattern = detectDoubles(pivots);
        if (pattern) return pattern;
        
        pattern = detectWedges(pivots);
        if (pattern) return pattern;

        pattern = detectTriangles(pivots);
        if (pattern) return pattern;

        pattern = detectFlags(klines);
        if (pattern) return pattern;

        return { pattern: 'Tidak Terdeteksi', class: 'text-gray-500' };
    }

    function findLastSignificantSwing(klines) {
        
        const pivots = findPivots(klines.slice(-300), 5);
        
        if (pivots.length < 3) return null;

        // Loop mundur dari pivot paling akhir untuk mencari pola yang valid
        for (let i = pivots.length - 1; i >= 2; i--) {
            const p3 = pivots[i];     // Ini adalah kandidat titik C
            const p2 = pivots[i - 1]; // Ini adalah kandidat titik B
            const p1 = pivots[i - 2]; // Ini adalah kandidat titik A

            // Mencari pola NAIK (Low -> High -> Higher Low)
            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low') {
                // Kondisi krusial: Titik C harus lebih tinggi dari A
                if (p3.price > p1.price) {
                    // Pola valid ditemukan! Langsung kembalikan hasilnya.
                    return { A: p1, B: p2, C: p3, type: 'UP' };
                }
            }

            // Mencari pola TURUN (High -> Low -> Lower High)
            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high') {
                // Kondisi krusial: Titik C harus lebih rendah dari A
                if (p3.price < p1.price) {
                    return { A: p1, B: p2, C: p3, type: 'DOWN' };
                }
            }
        }

        return null;
    }

    function calculateAdvancedFibonacciExtension(swing) {
        if (!swing || !swing.A?.price || !swing.B?.price || !swing.C?.price || !swing.type) {
            return null;
        }

        const priceA = parseFloat(swing.A.price);
        const priceB = parseFloat(swing.B.price);
        const priceC = parseFloat(swing.C.price);

        if (isNaN(priceA) || isNaN(priceB) || isNaN(priceC)) {
            return null;
        }

        const impulseMove = Math.abs(priceB - priceA);
        const fibLevels = [0, 0.618, 1.0, 1.272, 1.618, 2.618];
        const calculatedLevels = {};

        fibLevels.forEach(level => {
            let targetPrice;
            if (swing.type === 'UP') {
                targetPrice = priceC + (impulseMove * level);
            } else { 
                targetPrice = priceC - (impulseMove * level);
            }
            calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
        });

        return {
            swingPoints: { A: priceA, B: priceB, C: priceC },
            type: swing.type,
            levels: calculatedLevels
        };
    }
// 
    function displayFibonacciTargets() {
        const extData = realtimeCache.main.fibExtensions;
        const retData = realtimeCache.main.fibRetracements;
        const container = document.getElementById('fib-targets-container');

        if (!container) return;

        const fibData = (currentFibMode === 'extension') ? extData : retData;
        const modeTitle = (currentFibMode === 'extension') ? 'Extension' : 'Retracement';

        if (!fibData || !fibData.levels) {
            container.style.display = 'none';
            return;
        }

        container.style.display = 'block';

        const isUptrend = fibData.type === 'UP';
        const titleColor = isUptrend ? 'positive' : 'negative';
        
        let html = `
            <div class="flex justify-between items-center mb-2">
                <h4 class="text-sm font-semibold ${titleColor}">🎯 Fibonacci ${modeTitle} Targets (${fibData.type})</h4>
                <button id="toggle-fibo-mode-btn" class="btn-secondary !text-xs !py-1 !px-3">
                    ${currentFibMode === 'extension' ? 'Show Retracement' : 'Show Extension'}
                </button>
            </div>
        `;
        
        html += '<div class="grid grid-cols-2 md:grid-cols-3 gap-2 text-xs">';

        for (const key in fibData.levels) {
            const levelName = key.replace('level_', '').replace('.', '_');
            const price = fibData.levels[key];
            
            html += `
                <div class="flex justify-between items-center p-1 bg-gray-800/50 rounded">
                    <span class="font-semibold text-gray-300">${levelName.replace('_', '.')}</span>
                    <span class="font-mono ${titleColor}">${formatPrice(price)}</span>
                </div>
            `;
        }

        html += '</div>';
        container.innerHTML = html;

        const toggleBtn = document.getElementById('toggle-fibo-mode-btn');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                currentFibMode = (currentFibMode === 'extension') ? 'retracement' : 'extension';
                displayFibonacciTargets();
                renderAllCharts(); 
            });
        }
    }

    function calculateFibonacciRetracement(swing) {
        if (!swing || !swing.A?.price || !swing.B?.price) {
            return null;
        }

        const priceA = parseFloat(swing.A.price);
        const priceB = parseFloat(swing.B.price);

        if (isNaN(priceA) || isNaN(priceB)) {
            return null;
        }

        const impulseMove = Math.abs(priceB - priceA);
        const retracementLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
        const calculatedLevels = {};

        retracementLevels.forEach(level => {
            let targetPrice;
            // Untuk tren NAIK (A rendah, B tinggi), retracement dihitung turun dari B.
            if (swing.type === 'UP') {
                targetPrice = priceB - (impulseMove * level);
            } else { // 'DOWN' (A tinggi, B rendah), retracement dihitung naik dari B.
                targetPrice = priceB + (impulseMove * level);
            }
            calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
        });

        return {
            swingPoints: { A: priceA, B: priceB },
            type: swing.type,
            levels: calculatedLevels
        };
    }
// ===============================================================
// --- FUNGSI UTAMA AI ---
// ===============================================================
    function extractLSTMFeatures(klines) {
        const LSTM_LOOKBACK_WINDOW = 10;
        const NUM_FEATURES = 12;

        // Pastikan kita punya cukup data historis sebelum window yang kita analisis
        if (!klines || klines.length < LSTM_LOOKBACK_WINDOW + 15) { // Ditambah buffer untuk kalkulasi indikator awal
            console.warn(`[AI PREP] Data tidak cukup untuk ekstraksi fitur LSTM. Perlu > ${LSTM_LOOKBACK_WINDOW + 15}, tersedia: ${klines.length}`);
            return null;
        }

        // Ambil 10 kline terakhir untuk dianalisis sebagai sequence
        const sequenceKlines = klines.slice(-LSTM_LOOKBACK_WINDOW);
        if (sequenceKlines.length !== LSTM_LOOKBACK_WINDOW) return null;

        // Ambil data historis yang lebih panjang untuk kalkulasi indikator yang akurat
        const historicalKlines = klines.slice(-(LSTM_LOOKBACK_WINDOW + 20)); // Ambil 30 candle terakhir
        const historicalCloses = historicalKlines.map(k => parseFloat(k[4]));

        // --- PERBAIKAN UTAMA: Hitung semua indikator SEKALI saja pada data historis ---
        const rsiValues = calculateRSI(historicalCloses, 5);
        const macdData = calculateMACD(historicalCloses, 5, 8, 3);
        const bbData = calculateBollingerBands(historicalCloses, 5);
        const emaValues = calculateEMA(historicalCloses, 5);
        const stochRsiData = calculateStochasticRSI(rsiValues, 5, 5, 3, 3);

        // Ambil 10 nilai terakhir dari setiap hasil indikator
        const last10_RSI = rsiValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Line = macdData.macdLine.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Sig = macdData.signalLine.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Hist = macdData.histogram.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_BB_Upper = bbData.upper.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_BB_Lower = bbData.lower.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_BB_Middle = bbData.middle.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_EMA = emaValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_StochK = stochRsiData.kLine.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_StochD = stochRsiData.dLine.slice(-LSTM_LOOKBACK_WINDOW);

        let sequenceData = [];

        // Loop 10 kali untuk membangun setiap langkah dalam sequence
        for (let j = 0; j < LSTM_LOOKBACK_WINDOW; j++) {
            const klineForJ = sequenceKlines[j];
            const closeJ = parseFloat(klineForJ[4]);
            
            // Kalkulasi ATR & VWAP pada snapshot yang relevan hingga titik 'j'
            const klinesUpToJ = klines.slice(0, klines.length - LSTM_LOOKBACK_WINDOW + j + 1);
            const vwap_j = calculateVWAP(klinesUpToJ, 5);
            const atr_j = calculateATR(klinesUpToJ, 5).atrPercent;

            // Ambil nilai indikator yang sudah dihitung sebelumnya
            const rsi_j = last10_RSI[j] || 0;
            const ema_j = last10_EMA[j] || 0;
            const macd_line_j = last10_MACD_Line[j] || 0;
            const signal_line_j = last10_MACD_Sig[j] || 0;
            const macd_hist_j = last10_MACD_Hist[j]?.value || 0;
            const bb_upper_j = last10_BB_Upper[j] || closeJ;
            const bb_lower_j = last10_BB_Lower[j] || closeJ;
            const bb_middle_j = last10_BB_Middle[j] || closeJ;
            const k_j = last10_StochK[j] || 0;
            const d_j = last10_StochD[j] || 0;

            // --- Fitur Turunan (Derived Features) ---
            const macd_cross_j = (macd_line_j > signal_line_j) ? 1 : -1;
            const ema_dist_j = (ema_j > 0) ? (closeJ - ema_j) / ema_j : 0;
            const bb_width_j = (bb_middle_j > 0) ? (bb_upper_j - bb_lower_j) / bb_middle_j : 0;
            const bb_pos_j = (bb_upper_j - bb_lower_j) > 0 ? (closeJ - bb_lower_j) / (bb_upper_j - bb_lower_j) : 0.5;
            const vwap_dist_j = (vwap_j > 0) ? (closeJ - vwap_j) / vwap_j : 0;
            
            const prev_k = (j > 0) ? last10_StochK[j-1] || 0 : 0;
            const prev_d = (j > 0) ? last10_StochD[j-1] || 0 : 0;
            const stoch_cross_j = (prev_k <= prev_d && k_j > d_j) ? 1 : ((prev_k >= prev_d && k_j < d_j) ? -1 : 0);
            const stoch_state_j = (k_j > 80 && d_j > 80) ? 1 : ((k_j < 20 && d_j < 20) ? -1 : 0);

            // Kumpulkan semua 12 fitur menjadi satu array
            const featureArray = [
                rsi_j, macd_cross_j, macd_hist_j, ema_dist_j,
                bb_width_j, bb_pos_j, vwap_dist_j, atr_j,
                k_j, d_j, stoch_cross_j, stoch_state_j
            ].map(v => isFinite(v) ? v : 0); // Pastikan tidak ada nilai non-numerik

            if (featureArray.length === NUM_FEATURES) {
                sequenceData.push(featureArray);
            }
        }

        // Hanya kembalikan jika sequence lengkap (10 langkah)
        if (sequenceData.length === LSTM_LOOKBACK_WINDOW) {
            return sequenceData;
        }

        return null; // Kembalikan null jika gagal, ini akan memicu FALLBACK
    }

    async function loadRegimeSensorModel() {
        if (regimeSensorModel || typeof tf === 'undefined') {
            document.getElementById('ai-status').textContent = 'SIAP (Bunglon)'; 
            return;
        }

        console.log("🧠 Memuat Model Sensor Rezim (vFinal)...");
        try {
            const base64Handler = {
                load: async () => {
                    const modelArtifacts = JSON.parse(MODEL_ARTIFACTS_JSON_STRING);
                    const binaryString = window.atob(WEIGHTS_BASE64_STRING);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const weightData = bytes.buffer;

                    return {
                        modelTopology: modelArtifacts.modelTopology, 
                        weightSpecs: modelArtifacts.weightsManifest[0].weights, 
                        weightData: weightData
                    };
                }
            };

            regimeSensorModel = await tf.loadLayersModel(base64Handler);
            console.log('✅ Model Sensor Rezim berhasil dimuat dan siap bekerja!');
            document.getElementById('ai-status').textContent = 'SIAP (TF.js)';

        } catch (error) {
            console.error("❌ GAGAL memuat Model Sensor Rezim:", error);
            document.getElementById('ai-status').textContent = 'ERROR';
            regimeSensorModel = null;
        }
    }

    function calculatePredictionInput(klinesSnapshot) {
        if (klinesSnapshot.length < 50 || typeof tf === 'undefined') return null; 
        const closes = klinesSnapshot.map(k => parseFloat(k[4]));
        const currentClose = closes[closes.length - 1];
        const rsiValues = calculateRSI(closes, 14);
        const stochRsiData = calculateStochasticRSI(closes);
        const macdData = calculateMACD(closes);
        const bbData = calculateBollingerBands(closes);
        const vwap = calculateVWAP(klinesSnapshot, 20);
        const atrData = calculateATR(klinesSnapshot);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const lastK = stochRsiData.kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = stochRsiData.dLine.filter(v => v !== undefined).pop() || 50;
        const prevK = stochRsiData.kLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
        const prevD = stochRsiData.dLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
        const macdLine = macdData.macdLine.filter(v => v !== undefined).pop() || 0;
        const signalLine = macdData.signalLine.filter(v => v !== undefined).pop() || 0;
        const macdHist = macdData.histogram.filter(v => v !== undefined).pop()?.value || 0;
        const ema50 = calculateEMA(closes, 50).pop() || currentClose;
        const bbUpper = bbData.upper.filter(v => v !== undefined).pop() || currentClose;
        const bbLower = bbData.lower.filter(v => v !== undefined).pop() || currentClose;
        const bbMiddle = bbData.middle.filter(v => v !== undefined).pop() || currentClose; // Perlu untuk BB width

        const features = {
            rsi: lastRsi,
            macd_cross: macdLine > signalLine ? 1 : -1,
            macd_hist: macdHist,
            ema_dist: (currentClose - ema50) / ema50,
            bb_width: (bbUpper - bbLower) / bbMiddle,
            bb_pos: (bbUpper - bbLower) > 0 ? (currentClose - bbLower) / (bbUpper - bbLower) : 0.5,
            vwap_dist: vwap > 0 ? (currentClose - vwap) / vwap : 0,
            atr_percent: atrData.atrPercent,
            stoch_rsi_k: lastK,
            stoch_rsi_d: lastD,
            stoch_rsi_cross: (prevK <= prevD && lastK > lastD) ? 1 : ((prevK >= prevD && lastK < lastD) ? -1 : 0),
            stoch_rsi_state: (lastK > 80 && lastD > 80) ? 1 : ((lastK < 20 && lastD < 20) ? -1 : 0)
        };
        
        const featureOrder = ['rsi','macd_cross','macd_hist','ema_dist','bb_width','bb_pos','vwap_dist','atr_percent','stoch_rsi_k','stoch_rsi_d','stoch_rsi_cross','stoch_rsi_state'];
        const inputArray = featureOrder.map(key => features[key] || 0);

        if (inputArray.some(val => !isFinite(val))) {
            return null;
        }
        return inputArray;
    }

    async function predictMarketRegime(klinesSnapshot) {
        const featureSequence = extractLSTMFeatures(klinesSnapshot);
        const LSTM_LOOKBACK_WINDOW = 10;
        const NUM_FEATURES = 12;

        if (!regimeSensorModel || !featureSequence || featureSequence.length !== LSTM_LOOKBACK_WINDOW) {
            return 'RANGING'; // Fallback aman
        }

        // Mengubah array 2D [10, 12] menjadi Tensor 3D [1, 10, 12]
        return tf.tidy(() => {
            const inputTensor = tf.tensor3d([featureSequence], [1, LSTM_LOOKBACK_WINDOW, NUM_FEATURES]);
            const prediction = regimeSensorModel.predict(inputTensor);
            const predictedClassIndex = prediction.argMax(-1).dataSync()[0];
            const predictedLabel = REGIME_LABELS[predictedClassIndex];
            return predictedLabel || 'RANGING'; 
        });
    }
  
    function getRegimeColorClass(key) {
    switch(key) {
        case 'BULL_TREND': return 'text-green-400';
        case 'BEAR_TREND': return 'text-red-400';
        case 'RANGING': return 'text-yellow-400';
        case 'LOW_VOLATILITY': return 'text-blue-400';
        default: return 'text-gray-500';
    }
}
// BAGIAN 4: DEFINISI FUNGSI-FUNGSI
// 
    function getTimeAgo(date) {
        if (!(date instanceof Date) || isNaN(date)) {
            return 'beberapa saat lalu'; 
        }
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 0) return 'baru saja'; 
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " tahun lalu";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " bulan lalu";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " hari lalu";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " jam lalu";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " menit lalu";
        return Math.floor(seconds) + " detik lalu";
    }
// 
    function getExplorerUrl(networkName) {
        const explorerMap = {
            'eth': 'https://etherscan.io', 
            'ethereum': 'https://etherscan.io',
            'solana': 'https://solscan.io',
            'bsc': 'https://bscscan.com',
            'arbitrum': 'https://arbiscan.io',
            'base': 'https://basescan.org'
        };
        const baseUrl = explorerMap[networkName] || `https://${networkName}.info`;
        // Kembalikan URL terpisah untuk dompet dan transaksi
        return {
            address: `${baseUrl}/address/`,
            tx: `${baseUrl}/tx/`
        };
    }
// 
    function getHolderCategory(usdValue) {
        if (usdValue >= 500000) return { name: 'Humpback', class: 'text-purple-400' };
        if (usdValue >= 100000) return { name: 'Whale', class: 'text-blue-400' };
        if (usdValue >= 50000) return { name: 'Tuna', class: 'text-teal-400' };
        if (usdValue >= 10000) return { name: 'Dolphin', class: 'text-cyan-400' };
        if (usdValue >= 1000) return { name: 'Crab', class: 'text-yellow-400' };
        return { name: 'Shrimp', class: 'text-gray-400' };
    } 
    
    function setButtonState(button, isLoading, text = null) {
        const btnText = button.querySelector('span');
        const btnLoader = button.querySelector('.loader');
        
        button.disabled = isLoading;
        if (btnText) btnText.classList.toggle('hidden', isLoading);
        if (btnLoader) btnLoader.classList.toggle('hidden', !isLoading);
        
        if (text && btnText && !isLoading) {
            btnText.textContent = text;
        }
    }
// 
    function getSignClass(value, positiveClass = 'positive', negativeClass = 'negative') {
        return value >= 0 ? positiveClass : negativeClass;
    } 
//        
    function startCandleCountdown() {
            if (candleCountdownInterval) clearInterval(candleCountdownInterval);

            const countdownContainer = document.getElementById('candle-countdown-container');
            const countdownBar = document.getElementById('candle-countdown-bar');
            const klines = realtimeCache.main.klines;

            if (!klines || klines.length === 0) {
                countdownContainer.classList.add('hidden');
                return;
            }

            countdownContainer.classList.remove('hidden');

            const lastCandle = klines[klines.length - 1];
            const candleOpenTime = lastCandle[0];
            const candleCloseTime = lastCandle[6];
            const candleDuration = candleCloseTime - candleOpenTime;

            // Set interval untuk update bar setiap detik
            candleCountdownInterval = setInterval(() => {
                const now = Date.now();

                // Jika waktu saat ini sudah melewati waktu tutup candle
                if (now > candleCloseTime) {
                    countdownBar.style.width = '100%';
                    clearInterval(candleCountdownInterval);
                    return;
                }

                const elapsedTime = now - candleOpenTime;
                const percentage = (elapsedTime / candleDuration) * 100;

                countdownBar.style.width = `${Math.min(100, percentage)}%`;

            }, 1000); // Update setiap 1 detik
        }
// 
    function adaptIndicatorParamsToTimeframe(timeframe) {
        const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];

        userSettings.active.indicatorParams = { ...userSettings.presets['default'].indicatorParams, ...params };

        document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
        document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
        document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
        document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
        document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;       
    }
// 
    function applyPreset(presetName) {
            if (!userSettings.presets[presetName]) return;

            userSettings.active.weights = { ...userSettings.presets['default'].weights, ...userSettings.presets[presetName].weights };

            document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
            document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
            document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;
            
            if (realtimeCache.main.calculatedData) {
                updateQuickConfluenceWidget();
            }
        }
// 
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }
// 
    function determineMarketRegime(klines, closes) {
        if (!klines || klines.length < 200) {
            return { regime: 'RANGING', reason: 'Data kurang' };
        }

        const adxData = calculateADX(klines, 14);
        const ema200 = calculateEMA(closes, 200).pop();
        const lastPrice = closes[closes.length - 1];
        
        const isTrending = parseFloat(adxData.adx) > 25;

        if (isTrending) {
            if (lastPrice > ema200) {
                return { regime: 'TRENDING_UP', reason: `ADX (${adxData.adx}) > 25 & Harga > EMA 200` };
            } else {
                return { regime: 'TRENDING_DOWN', reason: `ADX (${adxData.adx}) > 25 & Harga < EMA 200` };
            }
        } else {
            return { regime: 'RANGING', reason: `ADX (${adxData.adx}) < 25` };
        }
    }
// 
    function displaySentimentDataInDashboard(data) {
        const container = document.getElementById('sentiment-display-container');

        const netflowClass = data.netflow < 0 ? 'positive' : 'negative';
        const netflowText = data.netflow < 0 ? `Outflow (Bullish)` : `Inflow (Bearish)`;

        const oiClass = data.oiChange > 0 ? 'positive' : 'negative';
        const oiText = data.oiChange > 0 ? `Naik` : `Turun`;

        const fundingClass = Math.abs(data.fundingRate) > 0.02 ? 'negative' : 'text-gray-400';
        const fundingText = Math.abs(data.fundingRate) > 0.02 ? `Ekstrem` : `Sehat`;

        const lsParts = data.lsRatio24h.split('/');
        const longRatio = parseFloat(lsParts[0]);
        const shortRatio = parseFloat(lsParts[1]);
        const lsClass = longRatio > shortRatio ? 'positive' : (shortRatio > longRatio ? 'negative' : 'text-gray-400');
        const lsText = longRatio > shortRatio ? `Dominan Long` : (shortRatio > longRatio ? `Dominan Short` : `Seimbang`);

        container.innerHTML = `
            <h3 class="text-lg font-bold mb-4 text-center">🌡️ Sentimen Pasar (via AI)</h3>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between items-center"><span class="text-gray-400">Aliran Bursa (Netflow BTC)</span><span class="font-bold ${netflowClass}">${data.netflow.toFixed(2)} BTC (${netflowText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Perubahan Open Interest</span><span class="font-bold ${oiClass}">${data.oiChange.toFixed(2)}% (${oiText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rata-rata Funding Rate</span><span class="font-bold ${fundingClass}">${(data.fundingRate * 100).toFixed(4)}% (${fundingText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rasio Long/Short (24j)</span><span class="font-bold ${lsClass}">${data.lsRatio24h} (${lsText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Likuidasi (Long vs Short)</span><span class="font-bold text-gray-200">${data.liquidations}</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">MVRV Z-Score</span><span class="font-bold text-yellow-400">${data.mvrv_z_score.toFixed(2)}</span></div>
                <p class="text-center text-xs text-gray-500 pt-2">Data diambil oleh AI pada: ${new Date().toLocaleTimeString('id-ID')}</p>
            </div>
        `;
    }
// 
    function saveSettings() {
        userSettings.active.indicatorParams.rsi_period = parseInt(document.getElementById('setting-rsi-period').value);
        userSettings.active.indicatorParams.macd_fast = parseInt(document.getElementById('setting-macd-fast').value);
        userSettings.active.indicatorParams.macd_slow = parseInt(document.getElementById('setting-macd-slow').value);
        userSettings.active.indicatorParams.macd_signal = parseInt(document.getElementById('setting-macd-signal').value);
        
        userSettings.active.weights.rsiDivergence = parseFloat(document.getElementById('setting-weight-divergence').value);
        userSettings.active.weights.macd = parseFloat(document.getElementById('setting-weight-macd').value);
        userSettings.active.weights.obvDivergence = parseFloat(document.getElementById('setting-weight-obv-divergence').value);

        localStorage.setItem('ultimateAppSettings', JSON.stringify(userSettings.active)); 
        const msgEl = document.getElementById('settings-saved-msg');
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 2000);
    }
// 
    function loadSettings() {
        const savedActiveSettings = localStorage.getItem('ultimateAppSettings');
        
        applyPreset('default'); 
        
        if (savedActiveSettings) {
            try {
                const parsed = JSON.parse(savedActiveSettings);
                if (parsed.weights) userSettings.active.weights = { ...userSettings.active.weights, ...parsed.weights };
                if (parsed.indicatorParams && Object.keys(parsed.indicatorParams).length > 0) {
                    userSettings.active.indicatorParams = { ...userSettings.active.indicatorParams, ...parsed.indicatorParams };
                }
            } catch (e) {
                console.error("Gagal parse pengaturan.", e);
            }
        }

        if (Object.keys(userSettings.active.indicatorParams).length === 0) {
            adaptIndicatorParamsToTimeframe(timeframeSelect.value);
        }

        document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
        document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
        document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
        document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
        document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;
        document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
        document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
        document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;
    }
// 
    function showError(message) {
        assetError.textContent = message;
        assetError.classList.remove('hidden');
    }
// 
    function hideError() {
        assetError.classList.add('hidden');
    }
// 
    function showLoader(show, text = '') {
        if (show) {
            loaderText.textContent = text;
            loaderOverlay.classList.remove('hidden');
            loaderOverlay.classList.add('flex');
        } else {
            loaderOverlay.classList.add('hidden');
            loaderOverlay.classList.remove('flex');
        }
        setButtonState(analyzeBtn, show);
    }
// 
    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) {
            console.error('Elemen toggle tidak ditemukan untuk:', buttonId);
            return;
        }
        contentWrapper.classList.add('collapsible-content');
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };
        let isVisible = startVisible;
        applyState(isVisible);
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }
// 
    function adjustContentPadding() {
        if (navWrapper && mainContent) {
            const navHeight = navWrapper.offsetHeight;
            mainContent.style.paddingTop = `${navHeight}px`;
        }
    }
// 
    const formatPrice = (price) => {
        if (typeof price !== 'number' || isNaN(price)) {
            return price; 
        }

        if (price >= 1) {
            return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }
        const priceString = price.toString();
        const decimalPart = priceString.includes('.') ? priceString.split('.')[1] : '';
        if (decimalPart.length === 0) return `$${price.toFixed(2)}`;
        
        let nonZeroIndex = -1;
        for (let i = 0; i < decimalPart.length; i++) {
            if (decimalPart[i] !== '0') {
                nonZeroIndex = i;
                break;
            }
        }
        if (nonZeroIndex !== -1) {
            const significantDigits = 4;
            return `$${price.toFixed(nonZeroIndex + significantDigits)}`;
        }
        return `$${price.toFixed(8)}`;
    };
// 
    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 7;
        return 8;
    }
// 
    function getUltimateSignalScore(indicator, signalData) {
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const mapRange = (x, inMin, inMax, outMin, outMax) => {
            const t = (x - inMin) / (inMax - inMin);
            return outMin + clamp(t, 0, 1) * (outMax - outMin);
        };       
        const confidence = (typeof signalData?.confidence === 'number')
            ? clamp(signalData.confidence, 0, 1)
            : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const biasSigned = (typeof signalData?.biasSigned === 'number')
            ? Math.sign(signalData.biasSigned)
            : null;
        
        if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            
            if (text.includes('OVERSOLD')) return +1 * confidence; 
            if (text.includes('OVERBOUGHT')) return -1 * confidence; 

            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }

        if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }

        if (indicator === 'openInterest') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('UP')) return +1 * confidence;
            if (text.includes('DOWN')) return -1 * confidence;
            return 0;
        }

        if (indicator === 'funding' || indicator === 'fundingRate') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 0; // ex: 0.0005 = 0.05%
            const s = Math.max(-1, Math.min(1, v / 0.0025));
            return s * confidence;
            }

        if (indicator === 'lsr' || indicator === 'lsRatio') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 1;
            const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
            return s * confidence;
            }

        if (indicator === 'orderBookBias') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BID')) return +1 * confidence;
            if (text.includes('ASK')) return -1 * confidence;
            return 0;
        }

        if (indicator === 'bbSqueeze') {
            const st = (signalData?.status || '').toString().toUpperCase();
            if (st.includes('RELEASE')) return +1 * confidence; 
            if (st.includes('ON')) return 0; 
            if (st.includes('OFF')) return 0.3 * confidence; 
            return 0;
        }

        return 0;
    }
// 
    async function updateQuickConfluenceWidget() {
console.log('🏁 CHECKPOINT 3: Entering updateQuickConfluenceWidget. Data received:', realtimeCache.main.calculatedData);        
        const data = realtimeCache.main.calculatedData;
        // Safety check: Pastikan data kalkulasi sudah siap
        if (!data || !data.marketRegime) {
            return;
        }

        // --- 1. DAPATKAN REZIM DARI HASIL PREDIKSI AI ---
        // (Dengan asumsi `recalculateAllIndicators` sudah di-upgrade untuk memanggil AI)
        const currentRegime = data.marketRegime; // Contoh: 'BULL_TREND'

        // --- 2. PILIH BOBOT STRATEGI SESUAI REZIM ---
        // Konversi 'BULL_TREND' (dari AI) menjadi 'bullTrend' (untuk kunci objek)
        const regimeWeightsKey = currentRegime.toLowerCase().replace(/_(\w)/g, (match, letter) => letter.toUpperCase());
        const regimeWeights = userSettings.presets[regimeWeightsKey]?.weights || {};
        const activeWeights = { ...userSettings.presets['default'].weights, ...regimeWeights };

        // --- 3. KALKULASI SKOR BULL vs BEAR (Logika ini tetap sama seperti di index.html Anda) ---
        const marketType = marketTypeSelect.value;
        const mtfAlignmentScore = realtimeCache.main.tfAlignmentSummary?.score || 0;
        const mtfMultiplier = 1 + (Math.abs(mtfAlignmentScore) / 4) * 0.25;
        
        let totalBullScore = 0;
        let totalBearScore = 0;
        let maxPossibleScore = 0;

        for (const indicator in activeWeights) {
            if (['fundingRate', 'lsRatio', 'openInterest'].includes(indicator) && marketType !== 'futures') continue;
            
            const weight = activeWeights[indicator] || 0;
            const signalData = indicator === 'bbSqueeze' ? data.bollingerBands : data[indicator];

            if (signalData) {
                const rawScore = getUltimateSignalScore(indicator, signalData);
                
                let finalWeight = weight;
                if (rawScore > 0 && mtfAlignmentScore > 0) finalWeight *= mtfMultiplier;
                else if (rawScore < 0 && mtfAlignmentScore < 0) finalWeight *= mtfMultiplier;
                
                const weightedScore = rawScore * finalWeight;

                if (weightedScore > 0) totalBullScore += weightedScore;
                if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
            }
            maxPossibleScore += Math.abs(weight);
        }

        const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
        const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;
        
        realtimeCache.main.quickConfluenceScore = { score: bullPercentage - bearPercentage, bull: bullPercentage, bear: bearPercentage };
        
        document.getElementById('quick-finalBullishScore').textContent = `${bullPercentage.toFixed(0)}% 🐂`;
        document.getElementById('quick-finalBearishScore').textContent = `🐻 ${bearPercentage.toFixed(0)}%`;
        const totalStrength = bullPercentage + bearPercentage;
        const bullWidthPercentage = totalStrength > 0 ? (bullPercentage / totalStrength) * 100 : 50;
        document.getElementById('quick-confluenceBarBullish').style.width = `${bullWidthPercentage}%`;
        document.getElementById('quick-confluenceBarBearish').style.width = `${100 - bullWidthPercentage}%`;

        // --- 4. TAMPILKAN HASIL KE UI ---
        const container = document.getElementById('verdict-and-regime-container');
        if (!container) return; 

        const { text: verdict, class: verdictClass } = generateShortVerdict(bullPercentage, bearPercentage);
        const mtfScoreText = mtfAlignmentScore > 0 ? `+${mtfAlignmentScore}` : mtfAlignmentScore;
        const mtfHtml = `<div class="text-xs text-center text-gray-400 mt-2">Multi-Timeframe Trend Confirmation: <span class="font-bold ${mtfAlignmentScore > 0 ? 'positive' : (mtfAlignmentScore < 0 ? 'negative' : '')}">${mtfScoreText}</span></div>`;
        const verdictHtml = `<p class="font-semibold">${verdict} <span class="text-sm font-mono ${verdictClass}">(${(bullPercentage - bearPercentage).toFixed(0)})</span></p>${mtfHtml}`;

        const tensionScore = Math.min(100, bullPercentage + bearPercentage);
        let tensionText = "Low";
        if (tensionScore > 50) tensionText = "Medium";
        if (tensionScore > 75) tensionText = "High";
        if (tensionScore > 90) tensionText = "Extreme";
        const tensionHtml = `
            <div class="text-xs">
                <span class="text-gray-400">Market Tension: <strong>${tensionText}</strong> (${tensionScore.toFixed(0)}/100)</span>
                <div class="tension-bar-bg">
                    <div class="tension-bar-fill" style="width: ${tensionScore}%;"></div>
                </div>
            </div>
        `;

        // BARU: Logika untuk menampilkan rezim dari AI
        const regimeInfo = {
            'BULL_TREND':     { text: "BULL TREND", icon: "🐂", class: "status-uptrend" },
            'BEAR_TREND':     { text: "BEAR TREND", icon: "🐻", class: "status-downtrend" },
            'RANGING':       { text: "RANGING", icon: "🐒", class: "status-chop" },
            'LOW_VOLATILITY': { text: "LOW VOLATILITY", icon: "🪫", class: "status-lowvolatility" }
        };
        const activeRegime = regimeInfo[currentRegime] || { text: "UNKNOWN", icon: "❓", class: "text-gray-500" };
        const regimeHtml = `<div class="text-xs font-mono">[ Active Model: <span class="${activeRegime.class} font-bold">${activeRegime.icon} ${activeRegime.text}</span> ]</div>`;

        container.innerHTML = verdictHtml + tensionHtml + regimeHtml;

        analyzeAndDisplayConfluenceContributors();
        const regimeDisplayEl = document.getElementById('active-regime-display');
        const regimeStatusEl = document.getElementById('ai-status');

        if (regimeDisplayEl && regimeStatusEl) {
            regimeStatusEl.textContent = 'SIAP (TF.js)'; // Pastikan status AI benar
            regimeDisplayEl.textContent = currentRegime.replace(/_/g, ' ');
            
            // Gunakan fungsi helper baru untuk mengubah warna teks sesuai rezim
            const colorClass = getRegimeColorClass(currentRegime);
            regimeDisplayEl.className = `font-bold text-base ${colorClass}`;
        }
    }
// 
    function updateCvdTableLive() {
        const tableBody = document.getElementById('cvd-table-body');
        if (!tableBody || liveCvdData.length === 0) return;

        const lastDataPoint = liveCvdData[liveCvdData.length - 1];
        const newRow = tableBody.insertRow(0);       
        const date = new Date(lastDataPoint.x);
        const formattedTime = date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        const prevUsdt = liveCvdData.length > 1 ? liveCvdData[liveCvdData.length - 2].y_usdt : 0;
        const colorClass = lastDataPoint.y_usdt > prevUsdt ? 'positive' : 'negative';

        newRow.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${formattedTime}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">${lastDataPoint.y_coin.toFixed(4)}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">$${lastDataPoint.y_usdt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        `;

        while (tableBody.rows.length > 5) {
            tableBody.deleteRow(tableBody.rows.length - 1);
        }
    }
// 
    async function updateRealTimeIndicators(klines) {
        if (!klines || klines.length < 50) return;
        realtimeCache.main.calculatedData = await recalculateAllIndicators(
            klines,
            realtimeCache.main.tickerData,
            null, 
            marketTypeSelect.value,
            realtimeCache.main.cvdData,
            realtimeCache.main.orderBookData,
            realtimeCache.main.fundingRateData,
            realtimeCache.main.lsRatioUmumData,
            realtimeCache.main.openInterestData
        );
console.log('✅ CHECKPOINT 2: calculatedData received. Has marketRegime property?', realtimeCache.main.calculatedData.hasOwnProperty('marketRegime'));
        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        await updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// 
    async function updatePeriodicData() {
        try {
            const binanceSymbol = realtimeCache.main.binanceSymbol;
            if (!binanceSymbol || marketTypeSelect.value !== 'futures') return;

            const [lsRatioUmumData, lsRatioTopData] = await Promise.all([
                 fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                 fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            ]);

            realtimeCache.main.lsRatioUmumData = lsRatioUmumData;
            realtimeCache.main.lsRatioTopData = lsRatioTopData;

            if (lsRatioUmumData?.[0]) {
                document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            }
            if (lsRatioTopData?.[0]) {
                document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
            }

        } catch(error) {
            console.error("Gagal memperbarui data periodik:", error);
        }
    }
// 
    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
        const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = `Binance API error for ${endpoint} (${marketType}): ${errorData.msg || response.statusText}`;
                throw new Error(errorMessage);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from ${url}: ${error.message}`);
            throw new Error(`Gagal mengambil data untuk ${endpoint} dari Binance ${marketType.toUpperCase()}.`);
        }
    }
// 
    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }
// 
    async function fetchCoinGeckoData(coinId) {
        if (!coinId) return null;
        const url = `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) return null;
            return response.json();
        } catch (error) { return null; }
    }
// 
    async function getCoinGeckoId(baseAssetSymbol) {
        if (!coinListCache) {
            const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
            if (!response.ok) throw new Error('Gagal unduh daftar koin CoinGecko.');
            coinListCache = await response.json();
        }
        const assetSymbolLower = baseAssetSymbol.toLowerCase();
        const priorityMap = {
            'btc': 'bitcoin', 'eth': 'ethereum', 'bnb': 'binancecoin', 'weth': 'wrapped-ether',
            'sol': 'solana', 'wbtc': 'wrapped-bitcoin', 'uni': 'uniswap', 'shib': 'shiba-inu',
            'pepe': 'pepe', 'cross': 'cross-2', 'ada': 'cardano', 'xrp': 'ripple', 'ava': 'avant-usd', 'ethw': 'ethereum-pow-iou',
            'avax': 'avalanche-2'
        };
        if (priorityMap[assetSymbolLower]) return priorityMap[assetSymbolLower];

        let match = coinListCache.find(coin => coin.symbol === assetSymbolLower);
        if (match) return match.id;

        try {
            const searchResult = await fetchGeckoTerminal(`search/pools?query=${baseAssetSymbol}`);
            if (searchResult.data && searchResult.data.length > 0) {
                const topResult = searchResult.data[0];
                if (topResult.relationships.base_token.data.id) {
                    const coinId = topResult.relationships.base_token.data.id.split('_')[1];
                    if (coinId) return coinId;
                }
            }
        } catch (e) { console.error("Pencarian cerdas gagal:", e); }

        throw new Error(`Simbol "${baseAssetSymbol}" tidak ditemukan di CoinGecko.`);
    }
// 
    async function initializeExchangeInfo(marketType) {
        if (exchangeInfoCache[marketType]) return;
        const url = marketType === 'spot' ? 'https://api.binance.com/api/v3/exchangeInfo' : 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
        const data = await response.json();
        exchangeInfoCache[marketType] = data.symbols;
        if (document.getElementById('market-type-select').value === marketType) {
            populateAssetDatalist(data.symbols, marketType);
        }
    }
// 
    function populateAssetDatalist(symbols, marketType) {
        const dataList = document.getElementById('asset-list');
        if (!dataList) return;
        dataList.innerHTML = '';
        const filterFn = s => s.quoteAsset === 'USDT' && s.status === 'TRADING' && (marketType === 'spot' || s.contractType === 'PERPETUAL');
        symbols.filter(filterFn).sort((a, b) => a.symbol.localeCompare(b.symbol)).forEach(s => {
            const option = document.createElement('option');
            option.value = s.symbol;
            dataList.appendChild(option);
        });
    }
// 
    async function validateBinanceSymbol(symbol, marketType) {
        if (!exchangeInfoCache[marketType]) {
            await initializeExchangeInfo(marketType);
        }
        
        const symbolData = exchangeInfoCache[marketType].find(s => s.symbol === symbol);
        if (!symbolData || symbolData.status !== 'TRADING') {
            throw new Error(`Simbol "${symbol}" tidak valid atau tidak aktif di Binance ${marketType}.`);
        }
    }
// 
    async function callGemini(parts, isJsonOutput = true) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) throw new Error("PASTE API Key!!!!!!!");
        const model = 'gemini-2.5-flash-preview-05-20';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts }] };
        if (isJsonOutput) {
            payload.generationConfig = {
                "response_mime_type": "application/json",
                "max_output_tokens": 8192
            };
        }
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(`Google AI API error: ${errorBody?.error?.message || response.statusText}`);
        }
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
        throw new Error("Respons dari AI tidak valid atau kosong.");
    }

    function renderTrendingPools(poolsData) {
        let html = '';
        const topPools = poolsData.slice(0, 5); 

        topPools.forEach(pool => {
            const attributes = pool.attributes;
            const priceChange = parseFloat(attributes.price_change_percentage.h24);
            const colorClass = priceChange >= 0 ? 'positive' : 'negative';
            const volume = parseFloat(attributes.volume_usd.h24);

            html += `
                <div class="p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                    <div class="flex justify-between items-center font-semibold">
                        <span>${attributes.name}</span>
                        <span class="${colorClass}">${priceChange.toFixed(2)}%</span>
                    </div>
                    <div class="text-xs text-gray-400 flex justify-between mt-1">
                        <span>Vol 24j: $${(volume / 1_000_000).toFixed(2)}jt</span>
                        <span>Jaringan: ${pool.relationships.network.data.id}</span>
                    </div>
                </div>
            `;
        });
        trendingPoolsContent.innerHTML = html;
    }

    async function fetchGeckoTerminal(endpoint) {
        const baseUrl = 'https://api.geckoterminal.com/api/v2';
        const url = `${baseUrl}/${endpoint}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GeckoTerminal API error: ${errorData.errors?.[0]?.title || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from GeckoTerminal ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari GeckoTerminal.`);
        }
    }
// 
    async function runFullAnalysis(symbol = null) {
        // 1. CLEAR & INITIAL SETUP
        if (candleCountdownInterval) clearInterval(candleCountdownInterval);
        adaptIndicatorParamsToTimeframe(timeframeSelect.value); 
        
        // Setup WebSocket Handlers
        WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
        WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
        WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));

        orderBookDOMElements = null;
        hideError();
        showLoader(true, 'Please Wait! AWACS Engine Running (Optimized).............');
        destroyCharts();
        specificTokenTitle.innerHTML = 'Analisis Token Spesifik';
        specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Mencari data on-chain...</p>`;
        trendingPoolsContent.innerHTML = `<div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div>`;
    
        try {
            const aiContentContainer = document.getElementById('ai-content-container');
            if (aiContentContainer) aiContentContainer.classList.add('hidden');
            const comprehensiveBtn = document.getElementById('toggle-ai-btn');
            if (comprehensiveBtn) {
                const btnText = comprehensiveBtn.querySelector('span');
                const btnLoader = comprehensiveBtn.querySelector('.loader');
                btnText.classList.remove('hidden');
                btnLoader.classList.add('hidden');
                comprehensiveBtn.disabled = false;
            }

        const binanceSymbol = (symbol || assetInput.value.trim() || 'BTCUSDT').toUpperCase();

        if (symbol) { 
            assetInput.value = symbol;
        }
        
        const correlationAsset = document.getElementById('correlation-asset-input').value.trim().toUpperCase() || 'BTCUSDT';
        const marketType = marketTypeSelect.value;
        const selectedTimeframe = timeframeSelect.value;
        
        await validateBinanceSymbol(binanceSymbol, marketType);

        showLoader(true, 'Fetching Market Data...');
        const baseAsset = binanceSymbol.replace(/USDT$|^\d+/g, '');
    
        // 2. DAFTAR LENGKAP PROMISES (Dari file yang Anda kirimkan)
        let promisesToRun = [
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: selectedTimeframe, limit: 1000 }, marketType), // 0: Klines Utama
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1h', limit: 500 }, marketType), // 1: 1H Klines
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '15m', limit: 500 }, marketType), // 2: 15m Klines
            fetchBinanceAPIData('ticker/24hr', { symbol: binanceSymbol }, marketType), // 3: Ticker
            fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 500 }, marketType), // 4: Daily Klines
            fetchBinanceAPIData('klines', { symbol: correlationAsset, interval: '1d', limit: 500 }, 'spot'), // 5: BTC Daily Klines
            fetchBinanceAPIData('depth', { symbol: binanceSymbol, limit: 100 }, marketType), // 6: Depth/Order Book
            fetch('https://api.coingecko.com/api/v3/global').then(res => res.json()), // 7: Global Data
            (async () => {
                try {
                    const coinGeckoId = await getCoinGeckoId(baseAsset);
                    return await fetchCoinGeckoData(coinGeckoId);
                } catch (e) {
                    console.warn(`Gagal mengambil data CoinGecko: ${e.message}`);
                    return null; 
                }
            })(), // 8: CoinGecko Data
        ];

        if (marketType === 'futures') {
            promisesToRun.push(
                fetchBinanceAPIData('openInterest', { symbol: binanceSymbol }, 'futures'), // 9
                fetchBinanceAPIData('premiumIndex', { symbol: binanceSymbol }, 'futures'), // 10
                fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()), // 11
                fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()) // 12
            );
        }

        const results = await Promise.allSettled(promisesToRun);
        
        // 3. EKSTRAKSI DATA (Menggunakan index dari file Anda)
        const rawKlines = results[0].status === 'fulfilled' ? results[0].value : null;
        if (!rawKlines || rawKlines.length < 550) { 
            throw new Error(`Data historis tidak cukup untuk pemanasan (min 550 candle).`);
        }

        const klines = rawKlines.slice(-500); // Klines utama yang digunakan
        const klines1h = results[1].status === 'fulfilled' ? results[1].value.slice(-200) : null;
        const klines15m = results[2].status === 'fulfilled' ? results[2].value.slice(-200) : null;
        const tickerData = results[3].status === 'fulfilled' ? results[3].value : null;
        const assetDailyKlines = results[4].status === 'fulfilled' ? results[4].value : null;
        const btcDailyKlines = results[5].status === 'fulfilled' ? results[5].value : null;
        const orderBookData = results[6].status === 'fulfilled' ? results[6].value : null;
        const prevDayKline = assetDailyKlines && assetDailyKlines.length >= 2 ? assetDailyKlines[assetDailyKlines.length - 2] : null;

        let openInterestData = null, fundingRateData = null, lsRatioUmumData = null, lsRatioTopData = null;
        if (marketType === 'futures' && results.length > 9) { 
                openInterestData = results[9].status === 'fulfilled' ? results[9].value : null;  
                fundingRateData = results[10].status === 'fulfilled' ? results[10].value : null;  
                lsRatioUmumData = results[11].status === 'fulfilled' ? results[11].value : null;  
                lsRatioTopData = results[12].status === 'fulfilled' ? results[12].value : null;
        }

        // 4. Persiapan Cache dan CVD
        const allTrades = await fetchBinanceAPIData('aggTrades', { symbol: binanceSymbol, limit: 1000 }, marketType);
        const cvdData = calculateCVD(allTrades);

        const correlationValue = calculateCorrelation(assetDailyKlines.map(k=>parseFloat(k[4])), btcDailyKlines.map(k=>parseFloat(k[4])));
        
        // 5. UPDATE CACHE UTAMA DENGAN SEMUA DATA MENTAH
        //realtimeCache.main = { 
            //symbol: binanceSymbol, tickerData, klines, klines1h, klines15m, orderBookData, 
            //cvdData, openInterestData, fundingRateData, lsRatioUmumData, lsRatioTopData, 
            //binanceSymbol, selectedTimeframe, correlationData: correlationValue,
           // multiTfKlines: { [selectedTimeframe]: klines },
            //liveScores: { pumpStrength: 0, dumpRisk: 0 } 
       // };
        realtimeCache.main = { 
            symbol: binanceSymbol, 
            tickerData, 
            klines, 
            klines1h, 
            klines15m, 
            orderBookData, 
            cvdData, 
            openInterestData, 
            fundingRateData, 
            lsRatioUmumData, 
            lsRatioTopData, 
            binanceSymbol, 
            selectedTimeframe, 
            correlationData: correlationValue,
            // BARIS KRITIS YANG HILANG:
            globalData: results[7].status === 'fulfilled' ? results[7].value : null,  // Tambahkan Global Data
            coinGeckoData: results[8].status === 'fulfilled' ? results[8].value : null, // Tambahkan CoinGecko Data
            // END BARIS KRITIS
            multiTfKlines: { [selectedTimeframe]: klines },
            liveScores: { pumpStrength: 0, dumpRisk: 0 } 
        };
        // 6. CACHE HIT / CACHE MISS (PENGHEMATAN CPU KRITIS)
        showLoader(true, 'Calculating Indicators (Optimizing CPU)...');
        const cacheKey = generateIndicatorCacheKey({ symbol: binanceSymbol, timeframe: selectedTimeframe });

        // >>> BARIS KRITIS: Menggantikan kalkulasi penuh dengan fungsi Cache/Hit <<<
        realtimeCache.main.calculatedData = await fetchOrCalculateIndicators(
            klines, tickerData, prevDayKline, marketType,
            realtimeCache.main.cvdData, realtimeCache.main.orderBookData, 
            realtimeCache.main.fundingRateData, realtimeCache.main.lsRatioUmumData, 
            realtimeCache.main.openInterestData,
            cacheKey, selectedTimeframe
        );

        // 7. FINAL LOGIC EXECUTION
        const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
        realtimeCache.main.tfAlignmentSummary = tfAlignmentSummary;
        realtimeCache.main.marketRegime = determineMarketRegime(klines, klines.map(k => parseFloat(k[4])));
        const swing = findLastSignificantSwing(klines);
        realtimeCache.main.fibExtensions = calculateAdvancedFibonacciExtension(swing);
        realtimeCache.main.fibRetracements = calculateFibonacciRetracement(swing);

        realtimeCache.main.calculatedData.fibExtensions = realtimeCache.main.fibExtensions;
        realtimeCache.main.calculatedData.fibRetracements = realtimeCache.main.fibRetracements;
        
        // 8. UPDATE UI
        await updateDashboardUI();
        startCandleCountdown(); 
        document.getElementById('scalping-setup-section').scrollIntoView({ behavior: 'smooth', block: 'start' });
        
        const navPriceEl = document.getElementById('nav-price');
        if (navPriceEl) {
            navPriceEl.textContent = formatPrice(parseFloat(tickerData.lastPrice));
        }
        
        if (orderBookData) {
            latestBids = orderBookData.bids;
            latestAsks = orderBookData.asks;
            const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
            const precision = getPrecisionForAsset(parseFloat(latestPrice));
            const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
            renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
        }

        const symbolLower = binanceSymbol.toLowerCase();
        const streamsToSub = [
            `${symbolLower}@kline_${selectedTimeframe}`,
            `${symbolLower}@aggTrade`,
            `${symbolLower}@depth20@100ms`
        ];
        WebSocketManager.subscribe(streamsToSub);

        // --- Logika tambahan CoinGecko dan GeckoTerminal (DIBIARKAN SAMA) ---
        (async () => {
            try {
                const searchQuery = (await getCoinGeckoId(baseAsset).then(id => fetchCoinGeckoData(id)).catch(() => null))?.platforms?.ethereum || baseAsset;
                specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span>`;
                const searchResult = await fetchGeckoTerminal(`search/pools?query=${searchQuery}`);
                if (searchResult.data && searchResult.data.length > 0) {
                    searchResult.data.sort((a, b) => parseFloat(b.attributes.reserve_in_usd) - parseFloat(b.attributes.reserve_in_usd));
                    const topPool = searchResult.data[0];
                    const attrs = topPool.attributes;
                    const networkName = topPool.id.split('_')[0];
                    const dexName = topPool.relationships?.dex?.data?.id.split('_').join(' ') || attrs.name.split(' ').pop();
                    if (networkName.includes('sepolia')) {
                        document.getElementById('onchain-card').style.display = 'none';
                        return;
                    } else {
                        document.getElementById('onchain-card').style.display = 'block';
                    }
                    specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span> <span class="text-xs text-gray-400 capitalize">(${networkName} / ${dexName})</span>`;
                    const price = formatPrice(parseFloat(attrs.base_token_price_usd));
                    const volume = (parseFloat(attrs.volume_usd.h24) / 1000000).toFixed(2);
                    const liquidity = attrs.reserve_in_usd ? (parseFloat(attrs.reserve_in_usd) / 1000000).toFixed(2) : 'N/A';
                    let staticContentHtml = `<div class="flex justify-between items-baseline"><span class="text-gray-500 capitalize">Harga DEX (${dexName})</span><span class="font-bold text-lg text-yellow-400">${price}</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Volume 24j DEX</span><span>$${volume}jt</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Likuiditas Pool</span><span>$${liquidity}jt</span></div>`;
                    specificTokenContent.innerHTML = staticContentHtml;

                    try {
                        const poolAddress = attrs.address;
                        const tradesData = await fetchGeckoTerminal(`networks/${networkName}/pools/${poolAddress}/trades`);
                        const tradeEvents = tradesData.data.filter(trade => trade.attributes.kind === 'buy' || trade.attributes.kind === 'sell').map(trade => ({ kind: trade.attributes.kind, usd: parseFloat(trade.attributes.volume_in_usd), price: parseFloat(trade.attributes.price_in_usd || attrs.base_token_price_usd), time: new Date(trade.attributes.block_timestamp), trader: trade.attributes.tx_from_address, network: topPool.id.split('_')[0] })).filter(event => event.usd >= 5000).slice(0, 100);
                        if (tradeEvents.length > 0) {
                            let buyVolume = 0, sellVolume = 0;
                            let buyCount = 0, sellCount = 0;
                            tradeEvents.forEach(event => { if (event.kind === 'buy') { buyVolume += event.usd; buyCount++; } else { sellVolume += event.usd; sellCount++; } });
                            realtimeCache.main.onChainSummary = { totalBuyVolume: buyVolume, totalSellVolume: sellVolume, buyTransactions: buyCount, sellTransactions: sellCount, sentiment: buyVolume > sellVolume ? 'Dominan Beli' : 'Dominan Jual', netVolume: buyVolume - sellVolume };
                            let html = '<hr class="border-slate-700/50 my-3"/><h4 class="text-lg font-semibold mb-2">100 Trans Terbaru di DEX >$5000 </h4>';
                            tradeEvents.forEach(event => {
                                const category = getHolderCategory(event.usd);
                                const timeAgo = getTimeAgo(event.time);
                                const specificTime = event.time.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
                                const walletLink = `https://dexcheck.ai/app/wallet-analyzer/${event.trader}`;
                                const bgColor = event.kind === 'buy' ? 'bg-green-900/40 dark:bg-green-800/20' : 'bg-red-900/40 dark:bg-red-800/20';
                                const amountColor = event.kind === 'buy' ? 'text-green-400' : 'text-red-400';
                                const icon = event.kind === 'buy' ? '🟢' : '🔴';
                                const actionText = event.kind === 'buy' ? 'BELI' : 'JUAL';
                                html += `<div class="p-2 rounded-md ${bgColor}"><div class="flex justify-between items-center font-semibold"><span>${icon} ${actionText}</span><span class="${amountColor}">$${event.usd.toLocaleString('en-US', {maximumFractionDigits: 0})}</span></div><div class="text-xs text-gray-400 flex justify-between items-center mt-1"><span class="${category.class} font-bold">[${category.name}]</span><span class="font-mono text-yellow-400">@ ${formatPrice(event.price)}</span><span>${timeAgo} <span class="text-gray-500">(${specificTime})</span></span><a href="${walletLink}" target="_blank" class="underline hover:text-white">Lihat Dompet 🔗</a></div></div>`;
                            });
                            specificTokenContent.innerHTML += html;
                        } else {
                        realtimeCache.main.onChainSummary = null;
                        specificTokenContent.innerHTML += `<p class="text-xs text-gray-500 text-center pt-2">NONE transaksi jual/beli signifikan baru-baru ini.</p>`;
                        }
                    } catch (tradeError) {
                        specificTokenContent.innerHTML += `<p class="text-xs text-red-500 text-center pt-2">Gagal memuat jejak trader: ${tradeError.message}</p>`;
                    }
                } else {
                    specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Tidak ditemukan pool on-chain untuk ${baseAsset.toUpperCase()}.</p>`;
                }
            } catch (dexError) {
                specificTokenContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data token spesifik: ${dexError.message}</p>`;
            }
        })();

        (async () => {
            try {
                const trendingData = await fetchGeckoTerminal('networks/trending_pools');
                renderTrendingPools(trendingData.data);
            } catch (trendingError) {
                trendingPoolsContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data trending: ${trendingError.message}</p>`;
            }
        })();
        
        } catch (error) {
            console.error("Analisis Gagal:", error);
            showError(error.message);
        } finally {
            showLoader(false);
            if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
            if (processingInterval) clearInterval(processingInterval);
            periodicUpdateInterval = setInterval(updatePeriodicData, 300000);
            processingInterval = setInterval(processQueues, 500);
        }
    }
// ===========end of async function runFullAnalysis(symbol = null) 
    function generateIndicatorCacheKey(settings) {
        // Membuat kunci unik berdasarkan Symbol, Timeframe, dan Parameter utama
        return 'indexIndicatorCache_' + JSON.stringify({
            symbol: settings.symbol,
            timeframe: settings.timeframe,
            rsi: userSettings.active.indicatorParams.rsi_period,
            macd: userSettings.active.indicatorParams.macd_fast 
        });
    }

    async function fetchOrCalculateIndicators(klines, tickerData, prevDayKline, marketType, cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData, cacheKey, selectedTimeframe) {
    
    // 1. Coba baca dari cache
    try {
        const cachedData = localStorage.getItem(cacheKey);
        if (cachedData) {
            return JSON.parse(cachedData);
        }
    } catch (e) {
        console.warn("Gagal membaca cache, akan melakukan kalkulasi ulang.");
    }

    // 2. Kalkulasi Ulang (jika Cache Miss)
    // ▼▼▼ PERBAIKAN KRUSIAL ADA DI SINI ▼▼▼
    const calculatedData = await recalculateAllIndicators(
        klines, tickerData, prevDayKline, marketType,
        cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData
    );
    // ▲▲▲ AKHIR DARI PERBAIKAN ▲▲▲

    // 3. Simpan ke cache
    try {
        localStorage.setItem(cacheKey, JSON.stringify(calculatedData));
    } catch (e) {
        console.error("Gagal menyimpan ke cache (localStorage penuh).", e);
    }
    
    return calculatedData;
}
// 
    async function getConfluenceScoreForSymbol(symbol) {
        try {
            // Sekarang hanya mengambil data ticker 24 jam yang ringan
            const tickerData = await fetchBinanceAPIData('ticker/24hr', { symbol }, 'spot');
            
            return {
                symbol,
                price: parseFloat(tickerData.lastPrice),
                change24h: parseFloat(tickerData.priceChangePercent),
            };
        } catch (error) {
            console.error(`Gagal memindai ${symbol}:`, error);
            return { symbol, error: error.message };
        }
    }
// 
    async function runComprehensiveAIAnalysis() {
        if (!realtimeCache.main.tickerData) {
            showError("Jalankan 'GET DATA' terlebih dahulu untuk memuat data.");
            return;
        }

        const comprehensiveBtn = document.getElementById('toggle-ai-btn');
        const btnText = comprehensiveBtn.querySelector('span');
        const btnLoader = comprehensiveBtn.querySelector('.loader');
        const aiNarrativeEl = document.getElementById('ai-narrative-content');

        btnText.classList.add('hidden');
        btnLoader.classList.remove('hidden');
        comprehensiveBtn.disabled = true;

        document.getElementById('projection-results-container').innerHTML = '';
        document.getElementById('saran-buyer').textContent = '-';
        document.getElementById('alasan-buyer').textContent = '';
        document.getElementById('saran-holder').textContent = '-';
        document.getElementById('alasan-holder').textContent = '';
        
        try {
            const { 
                binanceSymbol, 
                calculatedData, 
                tickerData, 
                correlationData,
                onChainSummary
            } = realtimeCache.main;
            
            const marketType = marketTypeSelect.value;
            const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
            const klines1d = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 200 }, marketType);
            const vwap20d = calculateVWAP(klines1d, 'rolling', 20);
            const obvValues = calculateOBV(klines1d);
            const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik (Akumulasi)' : 'Turun (Distribusi)';
            const vwapStatus = parseFloat(tickerData.lastPrice) > vwap20d ? 'Di Atas VWAP (Bullish)' : 'Di Bawah VWAP (Bearish)';
            
            const volumeAnalysisData = {
                vwap_20d: vwapStatus,
                obv_trend: obvTrend
            };
           
            const prompt = constructHybridAIPrompt(
                binanceSymbol, 
                calculatedData, 
                tfAlignmentSummary, 
                volumeAnalysisData, 
                onChainSummary, 
                correlationData
            );
            
            const aiResponseText = await callGemini([{ text: prompt }], false);
            const parsedData = parseAIResponseWithTags(aiResponseText);
            
            displayComprehensiveResults(parsedData);
            
        } catch (error) {
            aiNarrativeEl.innerHTML = `<p class="text-red-500">Gagal mendapatkan analisa AI: ${error.message}</p>`;
            isAiAnalysisVisible = false;
            document.querySelector('#toggle-ai-btn span').textContent = 'ASK AI';
        } finally {
            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            comprehensiveBtn.disabled = false;
        }
    }
// 
    function constructHybridAIPrompt(symbol, singleTfData, multiTfData, volumeData, onChainSummary, correlationData) {
        const mainPriceContext = {
            current_price: formatPrice(parseFloat(realtimeCache.main.tickerData.lastPrice))
        };
        const cleanSingleTfData = {
            timeframe: timeframeSelect.value,
            candlestick_pattern: singleTfData.candlePattern,
            chart_pattern: singleTfData.chartPattern,
            rsi_divergence: singleTfData.rsiDivergence,
            obv_divergence: singleTfData.obvDivergence.status,
            volatilitas_atr: singleTfData.atr,
            order_book_bias: realtimeCache.main.orderBookBias,
            bollinger_squeeze: singleTfData.bollingerBands.squeezeStatus,
            pivot_harian_bias: singleTfData.pivot.status + (singleTfData.pivot.data?.P ? ` (Pivot @ ${formatPrice(singleTfData.pivot.data.P)})` : ' (Data N/A)'),
            vwap_20d_bias: singleTfData.vwap.status,
            ichimoku_bias: singleTfData.ichimoku.status,
            squeeze_pro_bb_kc: (singleTfData.bollingerBands.width.slice(-1)[0] < singleTfData.keltnerChannels.width.slice(-1)[0]) ? 'Terdeteksi!' : 'Tidak Aktif'
        };
        const fundamentalData = {
            market_cap: realtimeCache.main.coinGeckoData?.market_data?.market_cap?.usd?.toLocaleString() || 'N/A'
        };
        const correlationText = correlationData !== null ? correlationData.toFixed(2) : 'N/A (Aset adalah BTC atau data tidak cukup)';
        const mvrvPromptData = realtimeCache.main.mvrvData 
            ? {
                status: "Data MVRV disediakan pengguna",
                nilai_z_score: realtimeCache.main.mvrvData.value,
                tanggal_data: realtimeCache.main.mvrvData.date
            }
            : "Data MVRV tidak disediakan pengguna.";

        const ema9 = calculateEMA(realtimeCache.main.klines.map(k=>parseFloat(k[4])), 9).pop();
        const ema21 = calculateEMA(realtimeCache.main.klines.map(k=>parseFloat(k[4])), 21).pop();
        const scalpingBias = ema9 > ema21 ? 'LONG' : 'SHORT';
        const scalpingSetupData = {
            bias_sesaat: scalpingBias,
            timeframe: timeframeSelect.value
        };

        return `Sebagai seorang analis kuantitatif (Quant Analyst) senior, berikan analisis pasar yang komprehensif untuk ${symbol}.

        TUGAS UTAMA:
        1.  **CARI DATA EKSTERNAL TERBARU:** Sebelum melakukan analisis, cari data sentimen pasar TERBARU (tidak lebih dari 24 jam terakhir) untuk BITCOIN dari sumber on-chain (Glassnode, CryptoQuant, Coinglass). Sertakan data-data berikut:
            a.  **MVRV Z-Score:** Cari nilai Z-Score terbaru.
            b.  **Data Sentimen Coinglass:** Cari data Netflow, Perubahan OI, Funding Rate, Rasio L/S 24 jam, dan Likuidasi.
            c.  **Format hasilnya HANYA dalam bentuk JSON** di dalam tag [SENTIMEN_DATA_JSON_START]. Strukturnya harus: {\"mvrv_z_score\":1.23, \"netflow\":-57.82, \"oiChange\":-0.89, \"fundingRate\":0.0050, \"lsRatio24h\":\"50.9% / 49.1%\", \"liquidations\":\"215.30M vs 89.10M\"}
        2.  **ANALISIS SEMUA DATA:** Lanjutkan dengan menganalisis SEMUA data yang diberikan di bawah ini untuk mengisi sisa tag output.
        3.  **GUNAKAN JANGKAR HARGA:** Gunakan 'current_price' dari DATA #0 sebagai satu-satunya titik acuan untuk SEMUA PROYEKSI HARGA.
        4.  **GAYA PENULISAN:** Gunakan bahasa yang padat, fokus pada data kunci, dan hindari kalimat berlebihan. Buat dalam bentuk poin-poin.

        **DATA #0: KONTEKS HARGA UTAMA (JANGKAR)**
        ${JSON.stringify(mainPriceContext, null, 2)}

        **DATA #1: Analisis Detail Timeframe Utama (${cleanSingleTfData.timeframe})**
        ${JSON.stringify(cleanSingleTfData, null, 2)}

        **DATA #2: Ringkasan Keselarasan Tren Multi-Timeframe (EMA 21/50)**
        ${JSON.stringify(multiTfData, null, 2)}

        **DATA #3: Analisis Berbasis Volume (CEX - Harian)**
        ${JSON.stringify(volumeData, null, 2)}

        **DATA #4: Data Fundamental Dasar**
        ${JSON.stringify(fundamentalData, null, 2)}

        **DATA #5: Ringkasan Aktivitas On-Chain (DEX - Transaksi >$5000)**
        ${onChainSummary ? JSON.stringify(onChainSummary, null, 2) : '"Data on-chain tidak tersedia untuk aset ini."'}

        **DATA #6: Korelasi Pasar (vs. BTCUSDT 30 Hari)**
        ${JSON.stringify({ correlation_coefficient: correlationText }, null, 2)}

        **DATA #7: Metrik Makro On-Chain (MVRV Z-Score)**
        ${JSON.stringify(mvrvPromptData, null, 2)}

        INSTRUKSI OUTPUT (WAJIB IKUTI FORMAT TAG DAN STRUKTUR MARKDOWN DI BAWAH INI):

        [SENTIMEN_DATA_JSON_START]
        (Letakkan hasil pencarian data sentimen Coinglass dalam format JSON murni di sini)
        [SENTIMEN_DATA_JSON_END]
        
        [NARASI_PASAR_START]
        (Berikan analisis narasi pasar. WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT. Setiap poin harus berupa kalimat singkat dan padat berisi data.
        ### 🟥 Argumen Bearish (Jangka Pendek)
        * ### 🟩 Argumen Bullish (Tersembunyi)
        * ### ⚖️ Kesimpulan Narasi
        * )
        [NARASI_PASAR_END]

        [ANALISIS_RISIKO_START]
        (Berikan analisis risiko dalam 1-2 kalimat singkat.)
        [ANALISIS_RISIKO_END]

        [SMC_NARRATIVE_START]
        (Berikan analisis struktur pasar (SMC) dalam poin-poin singkat.
        ### 🟥 Sinyal Bearish (Distribusi)
        * ### 🟩 Sinyal Bullish (Akumulasi)
        * ### 🎯 Target & Konfirmasi Berikutnya
        * )
        [SMC_NARRATIVE_END]

        [SMC_POI_BULLISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bullish terdekat. Contoh: 'Order Block H4 di $50000 - $51000')
        [SMC_POI_BULLISH_END]

        [SMC_POI_BEARISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bearish terdekat. Contoh: 'Supply zone H1 di $60000 - $61000')
        [SMC_POI_BEARISH_END]

        [PROYEKSI_LENGKAP_JSON_START]
        [
            { "periode": "Micro Scalp (1-4 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Sangat Pendek (24-48 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Pendek (1-7 hari)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Menengah (1-4 minggu)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Panjang (6-12 bulan)", "target_harga": "...", "alasan": "..." },
            { "periode": "Siklus Makro (1-3 tahun)", "target_harga": "...", "alasan": "..." }
        ]
        [PROYEKSI_LENGKAP_JSON_END]

        [SARAN_HOLDER_START]
        (Pilih salah satu: TAHAN, JUAL, TAMBAH, KURANGI SEBAGIAN)
        [SARAN_HOLDER_END]

        [ALASAN_HOLDER_START]
        (Berikan 2-3 poin alasan teknikal singkat.)
        [ALASAN_HOLDER_END]

        [SARAN_BUYER_START]
        (Pilih salah satu: BELI SEKARANG, TUNGGU DI AREA, JANGAN MASUK)
        [SARAN_BUYER_END]

        [ALASAN_BUYER_START]
        (Berikan 2-3 poin alasan teknikal singkat. Jika TUNGGU, berikan rentang harga ideal.)
        [ALASAN_BUYER_END]
        `;
    }
// 
    function parseAIResponseWithTags(rawText) {
        const result = {};
        const tags = [
            "SENTIMEN_DATA_JSON",
            "PUTUSAN_FINAL", "TINGKAT_KEYAKINAN", "NARASI_PASAR", "ANALISIS_SCALPING", "ANALISIS_RISIKO",
            "SMC_NARRATIVE", "SMC_POI_BULLISH", "SMC_POI_BEARISH",
            "PROYEKSI_LENGKAP_JSON", "SARAN_HOLDER", "ALASAN_HOLDER",
            "SARAN_BUYER", "ALASAN_BUYER"
        ];

        tags.forEach(tag => {
            const regex = new RegExp(`\\[${tag}_START\\]([\\s\\S]*?)\\[${tag}_END\\]`, 'i');
            const match = rawText.match(regex);
            const content = match ? match[1].trim() : null;
            
            const key = tag.toLowerCase();
            if (key === "proyeksi_lengkap_json" && content) {
                try {
                    result[key] = JSON.parse(content);
                } catch (e) {
                    console.error(`Gagal parse JSON untuk tag ${tag}:`, e);
                    result[key] = [];
                }
            } else {
                result[key] = content;
            }
        });
        return result;
    }
// 
    function displayComprehensiveResults(data) {    
        const aiNarrativeEl = document.getElementById('ai-narrative-content');
        const projectionContainer = document.getElementById('projection-results-container');
        const buyerSaranEl = document.getElementById('saran-buyer');
        const buyerAlasanEl = document.getElementById('alasan-buyer');
        const holderSaranEl = document.getElementById('saran-holder');
        const holderAlasanEl = document.getElementById('alasan-holder');
        
        aiNarrativeEl.innerHTML = '';
        projectionContainer.innerHTML = '';
        buyerSaranEl.textContent = '-';
        buyerAlasanEl.textContent = '';
        holderSaranEl.textContent = '-';
        holderAlasanEl.textContent = '';

        if (!data || Object.keys(data).length === 0) {
            aiNarrativeEl.innerHTML = '<p class="text-red-500 text-center">AI gagal memberikan analisis yang bisa diproses. Coba lagi.</p>';
            return;
        }

        if (data.sentimen_data_json) {
            try {
                const sentimentData = { ...JSON.parse(data.sentimen_data_json), lastUpdated: new Date() };
                realtimeCache.main.shortTermSentiment = sentimentData;
                displaySentimentDataInDashboard(sentimentData);
            } catch (e) {
                console.error("Gagal parse JSON sentimen dari AI:", e);
                const sentimentContainer = document.getElementById('sentiment-display-container');
                if(sentimentContainer) {
                    sentimentContainer.innerHTML = `<p class="text-xs text-center text-red-500">AI gagal memberikan data sentimen dalam format JSON yang benar.</p>`;
                }
            }
        }
        
        let shortVerdictHtml = '';
        if (realtimeCache.main.quickConfluenceScore) {
            const { bull, bear } = realtimeCache.main.quickConfluenceScore;
            const { text, class: verdictClass } = generateShortVerdict(bull, bear);
            shortVerdictHtml = `<p class="text-center font-bold text-2xl mb-4 ${verdictClass}">${text}</p>`;
        }

        const narrativeHtml = data.narasi_pasar ? marked.parse(data.narasi_pasar) : '';
        const smcHtml = data.smc_narrative ? marked.parse(data.smc_narrative) : '';

        let detailsHtml = `
            <div class="space-y-4 text-sm">
                ${narrativeHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md">${narrativeHtml}</div>` : ''}
                ${data.analisis_risiko ? `<div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border border-dashed border-yellow-500/50"><strong>Analisis Risiko:</strong> ${data.analisis_risiko}</div>` : ''}
                ${smcHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md mt-3">${smcHtml}</div>` : ''}
            </div>
        `;

        aiNarrativeEl.innerHTML = shortVerdictHtml + detailsHtml;

        if (data.proyeksi_lengkap_json && data.proyeksi_lengkap_json.length > 0) {
            data.proyeksi_lengkap_json.forEach(p => {
                projectionContainer.innerHTML += `
                    <div class="card p-3 bg-gray-50 dark:bg-gray-800/50">
                        <h4 class="font-semibold text-blue-400 text-sm">${p.periode}</h4>
                        <p class="font-bold text-base text-gray-800 dark:text-white">${p.target_harga}</p>
                        <p class="text-xs text-gray-500 mt-1">${p.alasan}</p>
                    </div>`;
            });
            projectionContainer.className = `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3`;
        } else {
            projectionContainer.innerHTML = '<p class="text-xs text-gray-500 col-span-full">Proyeksi harga tidak tersedia.</p>';
        }

        buyerSaranEl.textContent = data.saran_buyer || 'N/A';
        buyerAlasanEl.innerHTML = (data.alasan_buyer || 'NONE alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
        holderSaranEl.textContent = data.saran_holder || 'N/A';
        holderAlasanEl.innerHTML = (data.alasan_holder || 'NONE alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
    }
// 
    function generateShortVerdict(bullPercentage, bearPercentage) {
        let verdict = "NETRAL / CONSOLIDATION";
        let verdictClass = "text-yellow-400";
        
        if (bullPercentage > bearPercentage * 1.8 && bullPercentage > 40) {
            verdict = "STRONG BULLISH";
            verdictClass = "positive";
        } else if (bearPercentage > bullPercentage * 1.8 && bearPercentage > 40) {
            verdict = "STRONG BEARISH";
            verdictClass = "negative";
        } else if (bullPercentage > bearPercentage) {
            verdict = "SLIGHTLY BULLISH";
            verdictClass = "positive";
        } else if (bearPercentage > bullPercentage) {
            verdict = "SLIGHTLY BEARISH";
            verdictClass = "negative";
        }
        return { text: verdict, class: verdictClass };
    }
// 
    function analyzeAndDisplayConfluenceContributors() {
        const data = realtimeCache.main.calculatedData;
        if (!data) return;

        let contributors = [];
        const indicatorsToInclude = ['vwap', 'pivot', 'ichimoku', 'macd', 'rsiDivergence', 'obvDivergence'];
    
        for (const indicator of indicatorsToInclude) {
            if (data[indicator]) {
                const score = getUltimateSignalScore(indicator, data[indicator]);
                if (score !== 0) {
                    contributors.push({ 
                        name: indicator.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()), 
                        score: score 
                    });
                }
            }
        }

        contributors.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));

        const topBullish = contributors.filter(c => c.score > 0).slice(0, 3);
        const topBearish = contributors.filter(c => c.score < 0).slice(0, 3);

        let bullishHtml = '<h4 class="font-bold positive mb-1">👍 Pro Bullish</h4><ul class="space-y-1 text-gray-400">';
        if (topBullish.length > 0) {
            topBullish.forEach(item => {
                bullishHtml += `<li class="flex justify-between"><span>• ${item.name}</span> <span class="font-mono text-xs positive">+${item.score.toFixed(2)}</span></li>`;
            });
        } else {
            bullishHtml += '<li class="text-xs italic text-gray-600">NONE.</li>';
        }
        bullishHtml += '</ul>';
        document.getElementById('top-bullish-contributors').innerHTML = bullishHtml;

        let bearishHtml = '<h4 class="font-bold negative mb-1">👎 Pro Bearish</h4><ul class="space-y-1 text-gray-400">';
        if (topBearish.length > 0) {
            topBearish.forEach(item => {
                bearishHtml += `<li class="flex justify-between"><span>• ${item.name}</span> <span class="font-mono text-xs negative">${item.score.toFixed(2)}</span></li>`;
            });
        } else {
            bearishHtml += '<li class="text-xs italic text-gray-600">NONE.</li>';
        }
        bearishHtml += '</ul>';
        document.getElementById('top-bearish-contributors').innerHTML = bearishHtml;
        
        document.getElementById('confluence-breakdown-container').classList.remove('hidden');
    }
// 
    async function createTFAlignmentSummary(symbol, marketType) {
        const timeframes = ['1m', '5m', '15m', '1h', '4h'];
        const summary = {};
        
        let score = 0; 
        
        const klinesPromises = timeframes.map(tf => 
            fetchBinanceAPIData('klines', { symbol, interval: tf, limit: 51 }, marketType)
        );
        const klinesResults = await Promise.all(klinesPromises);

        klinesResults.forEach((klines, index) => {
            const tf = timeframes[index];
            if (klines && klines.length >= 50) {
                const closes = klines.map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21).pop();
                const ema50 = calculateEMA(closes, 50).pop();
                // Logika ini tetap menghasilkan 'UPTREND'/'DOWNTREND' untuk dependensi ke Bias Kontekstual
                summary[tf] = ema21 > ema50 ? 'UPTREND' : 'DOWNTREND';
            } else {
                summary[tf] = 'N/A';
            }
            
            // Kalkulasi skor (tidak diubah)
            if (summary[tf] === 'UPTREND') {
                score++;
            } else if (summary[tf] === 'DOWNTREND') {
                score--;
            }
        });

        realtimeCache.main.tfAlignmentSummary = { summary, score };

        // Tampilkan di UI
        const alignmentContainer = document.getElementById('tf-alignment-summary');
        let alignmentHtml = '<h4 class="font-semibold text-gray-300 mt-2 mb-1">Multi TF Alignment (EMA 21/50)</h4><div class="flex justify-center gap-1">';
        
        for(const tf in summary){
            const trend = summary[tf];
            const colorClass = trend === 'UPTREND' ? 'positive' : (trend === 'DOWNTREND' ? 'negative' : 'text-gray-500');
            
            // --- PERUBAHAN 1: Definisikan ikon berdasarkan teks tren ---
            const trendIcon = trend === 'UPTREND' ? '▲' : (trend === 'DOWNTREND' ? '▼' : '—');
            
            // --- PERUBAHAN 2: Gunakan variabel ikon, bukan teks, dan perbesar ukurannya ---
            alignmentHtml += `
                <div class="text-center p-1 rounded-md bg-gray-800/50 flex-1 mtf-clickable-box" data-timeframe="${tf}">
                    <span class="font-semibold">${tf}</span><br>
                    <span class="text-sm ${colorClass}">${trendIcon}</span>
                </div>`;
        }
        
        alignmentHtml += '</div>';
        if(alignmentContainer) alignmentContainer.innerHTML = alignmentHtml;

        return { summary, score };
    }
// 
    async function updateDashboardUI() {
        if (!realtimeCache.main.tickerData) return;
        const navInfoContainer = document.getElementById('nav-info-container');
        const navStatsContainer = document.getElementById('nav-stats-container');
        const tradeLinkContainer = document.getElementById('trade-link');

        const navTimeframeEl = document.getElementById('nav-timeframe');
        if (navTimeframeEl) {
            navTimeframeEl.textContent = timeframeSelect.value.toUpperCase();
        }

        if (navInfoContainer) {
            navInfoContainer.classList.remove('hidden');
            navInfoContainer.classList.add('md:flex');
        }
        if (navStatsContainer) {
            navStatsContainer.classList.remove('hidden');
            navStatsContainer.classList.add('md:flex');
        }
        if (tradeLinkContainer) {
            tradeLinkContainer.classList.remove('hidden');
        }
        initialPlaceholder.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
        const navHeight = document.getElementById('sticky-nav-wrapper').offsetHeight;
        
        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        populateCorrelationWidget(); 
        
        if (isChartsVisible) {
            renderAllCharts();
        } else {
            destroyCharts(); 
            toggleChartsBtn.textContent = 'SHOW CHART';
        }
        
        renderCvdChart();
        await updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
        displayFibonacciTargets();
    }
// 
    function startFundingRateTimer(nextFundingTime) {
        if (fundingRateTimer) clearInterval(fundingRateTimer);

        const updateTimer = () => {
            const timeRemaining = formatTimeRemaining(nextFundingTime);
            document.getElementById('funding-rate-interval').textContent = timeRemaining;

            // Jika waktu sudah habis, hentikan timer
            if (timeRemaining === '00:00:00') {
                clearInterval(fundingRateTimer);
            }
        };

        updateTimer(); 
        fundingRateTimer = setInterval(updateTimer, 1000);
    }
// 
    function formatTimeRemaining(timestamp) {
        const now = new Date().getTime();
        const nextFunding = new Date(timestamp);
        const diff = nextFunding - now;

        if (diff <= 0) return '00:00:00';

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        const pad = (num) => num.toString().padStart(2, '0');

        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }
// 
    function populateConfluenceDetailsWidget() {  
        const { calculatedData, tickerData, orderBookData, lsRatioUmumData, lsRatioTopData } = realtimeCache.main;
        if (!calculatedData || !calculatedData.vpvr || !calculatedData.pivot) {
            // Jika data inti belum siap, jangan lakukan apa-apa dan keluar dari fungsi.
            // Ini akan mencegah error 'TypeError'.
            return; 
        }
        const pivotContainer = document.getElementById('pivot-levels-container');
        const pivotPEl = document.getElementById('pivot-p');
        const pivotData = calculatedData.pivot?.data;

        if (pivotData && pivotData.P) {
            pivotPEl.textContent = formatPrice(pivotData.P);
            
            document.getElementById('pivot-r1s1').textContent = `${formatPrice(pivotData.R1)} / ${formatPrice(pivotData.S1)}`;
            document.getElementById('pivot-r2s2').textContent = `${formatPrice(pivotData.R2)} / ${formatPrice(pivotData.S2)}`;
            document.getElementById('pivot-r3s3').textContent = `${formatPrice(pivotData.R3)} / ${formatPrice(pivotData.S3)}`;
            
            pivotContainer.classList.remove('hidden');
        }

        if (calculatedData.vwap) {
            document.getElementById('vwap-20d').textContent = formatPrice(calculatedData.vwap.value);
        }
        if (calculatedData.ichimoku) {
            const ichiBiasEl = document.getElementById('ichimoku-bias');
            ichiBiasEl.textContent = calculatedData.ichimoku.status;
            ichiBiasEl.className = `font-mono font-semibold ${calculatedData.ichimoku.status === 'Bullish' ? 'positive' : (calculatedData.ichimoku.status === 'Bearish' ? 'negative' : 'text-gray-500')}`;
        }
        
        if (calculatedData.obv?.value !== undefined) {
            const obv = calculatedData.obv;
            const obvEl = document.getElementById('obv-value');
            const formattedObv = (obv.value / 1_000_000).toFixed(2) + 'M'; // Format ke jutaan
            obvEl.textContent = `${formattedObv} (${obv.trend})`;
            obvEl.className = `font-mono font-semibold ${obv.trend === 'Naik' ? 'positive' : 'negative'}`;
        }

        document.getElementById('confluence-timeframe-display').textContent = timeframeSelect.value;
        document.getElementById('vpvr-vah').textContent = formatPrice(calculatedData.vpvr.vah);
        document.getElementById('vpvr-poc').textContent = formatPrice(calculatedData.vpvr.poc);
        document.getElementById('vpvr-val').textContent = formatPrice(calculatedData.vpvr.val);
        
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = calculatedData.ma.status;
        maStatusEl.className = `font-mono font-semibold ${calculatedData.ma.class}`;
        
        document.getElementById('ema-21-value').textContent = `EMA21: ${formatPrice(calculatedData.ma.value21)}`;
        document.getElementById('ema-50-value').textContent = `EMA50: ${formatPrice(calculatedData.ma.value50)}`;
        document.getElementById('rsi-value').textContent = calculatedData.rsi.last;
        
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = calculatedData.rsi.status;
        rsiStatusEl.className = `tag ${calculatedData.rsi.class}`;
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = calculatedData.rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${calculatedData.rsiDivergence.class}`;
        
        document.getElementById('stoch-value').textContent = `${calculatedData.stoch.k}/${calculatedData.stoch.d}`;
        
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = calculatedData.stoch.status;
        stochStatusEl.className = `tag ${calculatedData.stoch.class}`;
        
        document.getElementById('macd-status').textContent = calculatedData.macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${calculatedData.macd.class}`;
        document.getElementById('macd-hist').textContent = calculatedData.macd.hist;
        document.getElementById('bollinger-bands-status').textContent = calculatedData.bollingerBands.status;
        
        const bbData = calculatedData.bollingerBands;
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop();
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop();
        const lastLower = bbData.lower.filter(v => v !== undefined).pop();
        
        document.getElementById('bb-upper-value').textContent = `U: ${formatPrice(lastUpper)}`;
        document.getElementById('bb-middle-value').textContent = `M: ${formatPrice(lastMiddle)}`;
        document.getElementById('bb-lower-value').textContent = `L: ${formatPrice(lastLower)}`;
        
        const { atr, atrPercent } = calculatedData;
        const atrStatusBadge = document.getElementById('atr-status-badge');
        const statusClassMap = { 'Low': 'tag-green', 'Normal': 'tag-yellow', 'High': 'tag-red', 'Very High': 'tag-red' };
        atrStatusBadge.textContent = atr.status;
        atrStatusBadge.className = `tag ${statusClassMap[atr.status] || 'tag-gray'} ml-2`;
        
        document.getElementById('atr-percent-value').textContent = `${atrPercent.toFixed(2)}%`;
        document.getElementById('atr-absolute-value').textContent = atr.value.toFixed(6);
        
        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const candleResult = calculatedData.candlePattern;
        let biasClass = '';
        if (candleResult.bias === 'BULLISH') biasClass = 'positive';
        if (candleResult.bias === 'BEARISH') biasClass = 'negative';
        const formattedTime = candleResult.timestamp ? new Date(candleResult.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Candlestick Pattern</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            
            <div class="h-16 flex items-center justify-center my-2">
                ${candleResult.svg || ''}
            </div>
            
            <p id="candlestick-pattern" class="text-xs font-semibold ${candleResult.class}">${candleResult.pattern}</p>
            ${candleResult.bias !== 'NETRAL' ? `<p class="text-xs font-semibold ${biasClass}">${candleResult.bias}</p>` : ''}
        `;
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = calculatedData.chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${calculatedData.chartPattern.class}`;
        const psarStatusEl = document.getElementById('psar-status');
        
        psarStatusEl.textContent = calculatedData.psar.status;
        psarStatusEl.className = `font-mono font-semibold ${calculatedData.psar.status === 'Bullish' ? 'positive' : 'negative'}`;
        
        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${calculatedData.roc.value.toFixed(2)}% (${calculatedData.roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${calculatedData.roc.status === 'Positif' ? 'positive' : 'negative'}`;
        
        document.getElementById('linreg-status').textContent = calculatedData.linreg.status;
        const bbWidth = calculatedData.bollingerBands.width.slice(-1)[0];
        const kcWidth = calculatedData.keltnerChannels.width.slice(-1)[0];
        const bbSqueezeEl = document.getElementById('bollinger-squeeze-status');
        if (bbWidth < kcWidth) {
            bbSqueezeEl.textContent = 'SQUEEZE PRO!';
            bbSqueezeEl.className = 'font-mono font-bold negative blinking-text-animation';
        } else if (calculatedData.bollingerBands.squeezeStatus === 'Squeeze!') {
            bbSqueezeEl.textContent = 'Squeeze!';
            bbSqueezeEl.className = 'font-mono font-bold text-yellow-500 blinking-text-animation';
        } else {
            bbSqueezeEl.textContent = 'Normal';
            bbSqueezeEl.className = 'font-mono text-gray-500';
        }
        
        document.getElementById('bollinger-rejection-status').textContent = calculatedData.bollingerBands.rejection;
        document.getElementById('bollinger-walk-status').textContent = calculatedData.bollingerBands.walkTheBands;
        if (calculatedData.adx) {
            document.getElementById('adx-value').textContent = calculatedData.adx.adx;
            document.getElementById('plus-di-value').textContent = calculatedData.adx.plusDI;
            document.getElementById('minus-di-value').textContent = calculatedData.adx.minusDI;
        }
        const lsUmumContainer = document.getElementById('ls-umum-container'), lsTopContainer = document.getElementById('ls-top-container');
        if (marketTypeSelect.value === 'futures' && lsRatioUmumData?.[0] && lsRatioTopData?.[0]) {
            lsUmumContainer.classList.remove('hidden');
            lsTopContainer.classList.remove('hidden');
            document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
        } else {
            lsUmumContainer.classList.add('hidden');
            lsTopContainer.classList.add('hidden');
        }
        if (orderBookData?.bids && orderBookData?.asks) {
            const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
            const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
            let biasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (BUYER LIMIT)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (SELLER LIMIT)' : 'Netral');
            document.getElementById('order-book-bias').textContent = biasText;
            realtimeCache.main.orderBookBias = biasText;
        } else {
            document.getElementById('order-book-bias').textContent = 'N/A';
            realtimeCache.main.orderBookBias = 'N/A';
        }
        //baru simulasi
        tsCalc.elements.marketPrice.value = parseFloat(realtimeCache.main.tickerData.lastPrice).toFixed(getPrecisionForAsset(parseFloat(realtimeCache.main.tickerData.lastPrice)));

        const resistanceContainer = document.getElementById('scalping-resistance-info');
        if (resistanceContainer && tickerData) {
            const currentPrice = parseFloat(tickerData.lastPrice);
            const pivots = calculatedData.pivot.data; // Simpan data pivot di variabel agar lebih rapi

            const potentialResistances = [
                { name: 'VAH', value: calculatedData.vpvr.vah },
                { name: '24H High', value: parseFloat(tickerData.highPrice) },
                // Menambahkan SEMUA level resistance pivot (P, R1, R2, R3) sebagai kandidat
                { name: 'Pivot', value: pivots?.P },
                { name: 'R1', value: pivots?.R1 },
                { name: 'R2', value: pivots?.R2 },
                { name: 'R3', value: pivots?.R3 }
            ].filter(r => r.value && r.value > currentPrice); // Filter hanya yang di atas harga saat ini
            if (potentialResistances.length > 0) {
                const nearestResistance = potentialResistances.reduce((prev, curr) => 
                    (Math.abs(curr.value - currentPrice) < Math.abs(prev.value - currentPrice) ? curr : prev)
                );
                resistanceContainer.querySelector('span:last-child').innerHTML = `${formatPrice(nearestResistance.value)} <span class="text-gray-500 text-xs">(${nearestResistance.name})</span>`;
            } else {
                resistanceContainer.querySelector('span:last-child').textContent = 'N/A';
            }
        }
    }
// 
    function detectAndDisplayWall(bids, asks) {
        const symbolInfo = exchangeInfoCache[marketTypeSelect.value]?.find(s => s.symbol === realtimeCache.main.binanceSymbol);
        const priceFilter = symbolInfo?.filters.find(f => f.filterType === 'PRICE_FILTER');
        const lotSizeFilter = symbolInfo?.filters.find(f => f.filterType === 'LOT_SIZE');       
        const tickSize = priceFilter ? parseFloat(priceFilter.tickSize) : 0.01;
        const stepSize = lotSizeFilter ? parseFloat(lotSizeFilter.stepSize) : 0.001;

        let smoothedAvgVolume = 0;
        if (orderBookHistory.avgVolumes.length > 0) {
            smoothedAvgVolume = orderBookHistory.avgVolumes.reduce((sum, vol) => sum + vol, 0) / orderBookHistory.avgVolumes.length;
        } else {
            const initialLevels = [...bids.slice(0,15), ...asks.slice(0,15)];
            if(initialLevels.length > 0) {
            smoothedAvgVolume = initialLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / initialLevels.length;
            }
        }

        const classifyWall = (volume, mediumThreshold, thickThreshold) => {
            if (volume >= thickThreshold) return 'Thick';
            if (volume >= mediumThreshold) return 'Medium';
            return 'Thin';
        };

        const findWallCluster = (levels) => {
            if (!levels || levels.length < 5 || smoothedAvgVolume === 0) return null;
            
            const topLevels = levels.slice(0, 15).map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...topLevels);
            const thinThreshold   = Math.max(smoothedAvgVolume * 3, maxVolume * 0.2);
            const mediumThreshold = Math.max(smoothedAvgVolume * 7, maxVolume * 0.5);
            const thickThreshold  = Math.max(smoothedAvgVolume * 15, maxVolume * 0.7);

            let currentWall = null;
            let walls = [];

            for (let i = 0; i < levels.length; i++) {
                const price = parseFloat(levels[i][0]);
                const volume = parseFloat(levels[i][1]);

                if (volume >= thinThreshold) {
                    if (!currentWall) {
                        currentWall = {
                            priceStart: price,
                            priceEnd: price,
                            totalVolume: volume,
                            levels: 1,
                            levelPrices: [price]
                        };
                    } else {
                        if (Math.abs(price - currentWall.priceEnd) <= (tickSize * 2)) {
                            currentWall.priceEnd = price;
                            currentWall.totalVolume += volume;
                            currentWall.levels++;
                            currentWall.levelPrices.push(price);
                        } else {
                            if (currentWall.levels >= 2) walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                            currentWall = { priceStart: price, priceEnd: price, totalVolume: volume, levels: 1, levelPrices: [price] };
                        }
                    }
                } else {
                    if (currentWall && currentWall.levels >= 2) {
                        walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                    }
                    currentWall = null;
                }
            }
            
            if (currentWall && currentWall.levels >= 2) {
                walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
            }

            if (walls.length > 0) {
                return walls.reduce((max, w) => (w.totalVolume > max.totalVolume ? w : max), walls[0]);
            }
            return null;
        };
        
        
        const findSingleWall = (levels) => {
            if (!levels || levels.length === 0 || smoothedAvgVolume === 0) return null;
            
            const volumes = levels.slice(0, 20).map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...volumes);

            if (maxVolume > smoothedAvgVolume * 20) { 
                const idx = volumes.findIndex(v => v === maxVolume);
                return {
                    priceStart: parseFloat(levels[idx][0]),
                    priceEnd: parseFloat(levels[idx][0]),
                    totalVolume: maxVolume,
                    levels: 1,
                    wallType: 'Thick'
                };
            }
            return null;
        };

        const buyWallCluster = findWallCluster(bids);
        const sellWallCluster = findWallCluster(asks);
        const buyWallSingle  = findSingleWall(bids);
        const sellWallSingle = findSingleWall(asks);

        return {
            buyWall: buyWallCluster || buyWallSingle,
            sellWall: sellWallCluster || sellWallSingle
        };
    }
// 
    function renderFullOrderBook(bids, asks, wallInfo, precision) {
        const numLevels = 10;
        if (!orderBookDOMElements) {
            let asksHtml = Array.from({ length: numLevels }).map(() => `
                <div class="flex items-center text-xs mt-1 relative z-0">
                    <div class="ask-bar absolute inset-0 bg-red-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                    <span class="ask-price w-1/2 text-left font-mono"></span>
                    <span class="ask-qty w-1/2 text-right font-mono"></span>
                </div>
            `).join('');

            let bidsHtml = Array.from({ length: numLevels }).map(() => `
                <div class="flex items-center text-xs mt-1 relative z-0">
                    <div class="bid-bar absolute inset-0 bg-green-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                    <span class="bid-qty w-1/2 text-left font-mono"></span>
                    <span class="bid-price w-1/2 text-right font-mono"></span>
                </div>
            `).join('');

            fullOrderBookContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <h4 class="text-red-500 font-bold">ASKs (Jual)</h4>
                        <div id="asks-container">${asksHtml}</div>
                    </div>
                    <div>
                        <h4 class="text-green-500 font-bold">BIDs (Beli)</h4>
                        <div id="bids-container">${bidsHtml}</div>
                    </div>
                </div>
                <div id="main-ob-wall-container" class="text-center text-xs mt-4 space-y-1">
                    <div id="main-ob-buy-wall" class="h-4 flex items-center justify-center"></div>
                    <div id="main-ob-sell-wall" class="h-4 flex items-center justify-center"></div>
                </div>
            `;
            
            orderBookDOMElements = {
                asks: Array.from(document.querySelectorAll('#asks-container > div')).map(row => ({
                    row, bar: row.querySelector('.ask-bar'), price: row.querySelector('.ask-price'), qty: row.querySelector('.ask-qty')
                })).reverse(), 
                bids: Array.from(document.querySelectorAll('#bids-container > div')).map(row => ({
                    row, bar: row.querySelector('.bid-bar'), price: row.querySelector('.bid-price'), qty: row.querySelector('.bid-qty')
                })),
                // PERBAIKAN: Tambahkan elemen baru untuk ditarget
                mainObBuyWall: document.getElementById('main-ob-buy-wall'),
                mainObSellWall: document.getElementById('main-ob-sell-wall')
            };
        }

        const topLevels = [...bids.slice(0, 15), ...asks.slice(0, 15)];
        if (topLevels.length > 0) {
            const currentAvgVolume = topLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / topLevels.length;
        
        
        orderBookHistory.avgVolumes.push(currentAvgVolume);
        
        while (orderBookHistory.avgVolumes.length > orderBookHistory.maxSize) {
            orderBookHistory.avgVolumes.shift();
        }
    }
        
        const totalMaxVolume = Math.max(
            ...bids.slice(0, numLevels).map(b => parseFloat(b[1])), 
            ...asks.slice(0, numLevels).map(a => parseFloat(a[1]))
        );

        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.asks[i];
            const data = asks[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.sellWall && price >= wallInfo.sellWall.priceStart && price <= wallInfo.sellWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `ask-price w-1/2 text-left font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-red-500' : 'text-red-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.bids[i];
            const data = bids[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.buyWall && price >= wallInfo.buyWall.priceStart && price <= wallInfo.buyWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `bid-price w-1/2 text-right font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-green-500' : 'text-green-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        const buyWallDisplay = document.getElementById('buy-wall-display');
        const sellWallDisplay = document.getElementById('sell-wall-display');
        const fullOrderBookWallInfo = orderBookDOMElements.wallInfo;

        let buyWallText = '<span class="text-gray-600 font-normal">— No Buy Wall Detected —</span>';
        if (wallInfo.buyWall) {
            buyWallText = `<span class="font-normal ">BUY WALL ${wallInfo.buyWall.wallType.toUpperCase()}</span> DETECTED ${formatPrice(wallInfo.buyWall.priceStart)} TO ${formatPrice(wallInfo.buyWall.priceEnd)} (Vol: $${(wallInfo.buyWall.totalVolume * parseFloat(bids[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        buyWallDisplay.innerHTML = buyWallText;

        let sellWallText = '<span class="text-gray-600 font-normal">— No Sell Wall Detected —</span>';
        if (wallInfo.sellWall) {
            sellWallText = `<span class="font-normal">SELL WALL ${wallInfo.sellWall.wallType.toUpperCase()}</span> DETECTED ${formatPrice(wallInfo.sellWall.priceStart)} TO ${formatPrice(wallInfo.sellWall.priceEnd)} (Vol: $${(wallInfo.sellWall.totalVolume * parseFloat(asks[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        sellWallDisplay.innerHTML = sellWallText;

        // (Opsional) Update juga info di panel Order Book besar
        if (fullOrderBookWallInfo) {
            let combinedText = '';
            if (wallInfo.buyWall) combinedText += buyWallDisplay.innerHTML + '<br>';
            if (wallInfo.sellWall) combinedText += sellWallDisplay.innerHTML;
            fullOrderBookWallInfo.innerHTML = combinedText;
        }
    }
// CHART RENDERING ENGINE 
    function getChartBaseOptions(height) {
        const isDarkMode = document.documentElement.classList.contains('dark');
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 48,
            height: height,
            layout: { background: { color: isDarkMode ? '#0e0d0d' : '#FFFFFF' }, textColor: isDarkMode ? '#D1D5DB' : '#374151' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                secondsVisible: false, 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                lockVisibleTimeRangeOnResize: true,
                rightOffset: -30, 
                barSpacing: 6,
                minBarSpacing: 3,
                horzTouchDrag: true, 
                vertTouchDrag: false, 
                mouseScroll: false, 
                pinchToZoom: true, 
                tickMarkFormatter: (time) => {
                    const date = new Date(time * 1000);
                    return date.toLocaleTimeString('id-ID', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
            },
            crosshair: { 
                mode: LightweightCharts.CrosshairMode.Normal,
                horzLine: {
                    visible: true,
                    labelVisible: true
                },
                vertLine: {
                    visible: true,
                    labelVisible: true
                }
            },
            rightPriceScale: { 
                borderColor: isDarkMode ? '#4B5563' : '#D1D5DB',
                visible: true,
                scaleMargins: {
                    top: 0.1,
                    bottom: 0.1
                }
            },
            localization: {
                timeFormatter: (time) => {
                    const date = new Date(time * 1000);
                    return date.toLocaleString('id-ID', {
                        year: 'numeric', month: 'short', day: 'numeric',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        timeZone: 'Asia/Jakarta'
                    });
                }
            }
        };
    }
// 
    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if(!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (chart !== otherChart && otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }   
//
    function renderAllCharts() {
        if (!realtimeCache.main.klines) return;

        destroyCharts();

        const { klines, calculatedData } = realtimeCache.main;
        const closes = klines.map(k => parseFloat(k[4]));    
        const formattedKlines = klines
            .filter(k => k && k.length >= 5 && k.slice(1, 5).every(v => v !== null && !isNaN(parseFloat(v))))
            .map(d => ({ 
                time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]), 
                low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5])
            }));

        if (formattedKlines.length === 0) return;

        const formatLineData = (data, klineSource = klines, offset = 0) => data
            .map((value, index) => {
                const val = (typeof value === 'object' && value !== null) ? value.value : value;
                const klineIndex = index + offset;
                if (klineSource[klineIndex] && val !== undefined && !isNaN(val)) {
                    const time = klineSource[klineIndex][0] / 1000;
                    if (typeof value === 'object' && value !== null) {
                        return { ...value, time };
                    }
                    return { time, value: val };
                }
                return null;
            }).filter(Boolean);

        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);

        chartSeries.candlestick = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false, wickUpColor: '#26a69a', wickDownColor: '#ef5350' });
        chartSeries.candlestick.setData(formattedKlines);

        // --- Indikator di Grafik Utama ---
        const bbData = calculatedData.bollingerBands;
        chartSeries.ema50 = mainChart.addLineSeries({ color: 'yellow', lineWidth: 2, priceLineVisible: false, title: 'EMA50' });
        chartSeries.bbUpper = mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lineStyle: LightweightCharts.LineStyle.Dashed });
        chartSeries.bbMiddle = mainChart.addLineSeries({ color: 'white', lineWidth: 1, priceLineVisible: false, lineStyle: LightweightCharts.LineStyle.Dotted });
        chartSeries.bbLower = mainChart.addLineSeries({ color: 'gray', lineWidth: 1, priceLineVisible: false, lineStyle: LightweightCharts.LineStyle.Dashed });

        chartSeries.ema50.setData(formatLineData(calculateEMA(closes, 50)));
        chartSeries.bbUpper.setData(formatLineData(bbData.upper, klines, klines.length - bbData.upper.length));
        chartSeries.bbMiddle.setData(formatLineData(bbData.middle, klines, klines.length - bbData.middle.length));
        chartSeries.bbLower.setData(formatLineData(bbData.lower, klines, klines.length - bbData.lower.length));

        // --- Panel Volume ---
        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
        charts.push(volumeChart);
        chartSeries.volume = volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } });
        chartSeries.volume.setData(formattedKlines.map(d => ({ time: d.time, value: d.volume, color: d.close >= d.open ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' })));

        // --- Panel RSI ---
        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(150));
        charts.push(rsiChart);
        chartSeries.rsi = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 });
        chartSeries.rsi.setData(formatLineData(calculatedData.rsi.values));
        // [PERBAIKAN] Garis harga dibuat di SERIES, bukan di CHART
        chartSeries.rsi.createPriceLine({ price: 70, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '70' });
        chartSeries.rsi.createPriceLine({ price: 30, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '30' });

        // --- Panel Stochastic RSI ---
        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(150));
        charts.push(stochChart);
        const stochData = calculatedData.stoch;
        chartSeries.stochK = stochChart.addLineSeries({ color: '#2196F3', lineWidth: 2, title: '%K' });
        chartSeries.stochD = stochChart.addLineSeries({ color: '#FF9800', lineWidth: 2, title: '%D' });
        chartSeries.stochK.setData(formatLineData(stochData.kLine, klines, stochData.kOffset));
        chartSeries.stochD.setData(formatLineData(stochData.dLine, klines, stochData.dOffset));
        // [PERBAIKAN] Garis harga dibuat di SERIES, bukan di CHART
        chartSeries.stochK.createPriceLine({ price: 80, color: '#ef5350', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '80' });
        chartSeries.stochK.createPriceLine({ price: 20, color: '#26a69a', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: false, title: '20' });

        // --- Panel MACD ---
        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(150));
        charts.push(macdChart);
        const macdData = calculatedData.macd;
        chartSeries.macdHist = macdChart.addHistogramSeries({ base: 0 });
        chartSeries.macdLine = macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2 });
        chartSeries.signalLine = macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2 });
        chartSeries.macdHist.setData(formatLineData(macdData.histogram, klines, klines.length - macdData.histogram.length));
        chartSeries.macdLine.setData(formatLineData(macdData.macdLine, klines, klines.length - macdData.macdLine.length));
        chartSeries.signalLine.setData(formatLineData(macdData.signalLine, klines, klines.length - macdData.signalLine.length));

        // --- Panel ROC ---
        const rocChart = LightweightCharts.createChart(document.getElementById('roc-chart-container'), getChartBaseOptions(150));
        charts.push(rocChart);
        chartSeries.roc = rocChart.addLineSeries({ color: '#f472b6', lineWidth: 2 });
        const rocValues = calculateROC(closes).values;
        chartSeries.roc.setData(formatLineData(rocValues, klines, klines.length - rocValues.length));
        // [PERBAIKAN] Garis harga dibuat di SERIES, bukan di CHART
        chartSeries.roc.createPriceLine({ price: 0, color: '#9E9E9E', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, axisLabelVisible: true, title: '0' });

        syncCharts(mainChart, volumeChart, rsiChart, stochChart, macdChart, rocChart);
    } 

    function updateLiveCharts(kline) {
        if (!isChartsVisible || !chartSeries.candlestick) return;

        const formattedCandle = {
            time: kline.t / 1000, open: parseFloat(kline.o), high: parseFloat(kline.h),
            low: parseFloat(kline.l), close: parseFloat(kline.c)
        };
        const formattedVolume = {
            time: formattedCandle.time, value: parseFloat(kline.v),
            color: formattedCandle.close >= formattedCandle.open ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)'
        };

        if (chartSeries.candlestick) chartSeries.candlestick.update(formattedCandle);
        if (chartSeries.volume) chartSeries.volume.update(formattedVolume);

        const closes = realtimeCache.main.klines.map(k => parseFloat(k[4]));

        const lastRsi = calculateRSI(closes).pop();
        if (lastRsi && chartSeries.rsi) chartSeries.rsi.update({ time: formattedCandle.time, value: lastRsi });

        const stoch = calculateStochasticRSI(closes);
        const lastStochK = stoch.kLine.pop();
        const lastStochD = stoch.dLine.pop();
        if (lastStochK && chartSeries.stochK) chartSeries.stochK.update({ time: formattedCandle.time, value: lastStochK });
        if (lastStochD && chartSeries.stochD) chartSeries.stochD.update({ time: formattedCandle.time, value: lastStochD });

        const lastEma50 = calculateEMA(closes, 50).pop();
        if (lastEma50 && chartSeries.ema50) chartSeries.ema50.update({ time: formattedCandle.time, value: lastEma50 });

        const macd = calculateMACD(closes);
        const lastMacdLine = macd.macdLine.pop();
        const lastSignalLine = macd.signalLine.pop();
        const lastMacdHist = macd.histogram.pop();
        if (lastMacdLine && chartSeries.macdLine) chartSeries.macdLine.update({ time: formattedCandle.time, value: lastMacdLine });
        if (lastSignalLine && chartSeries.signalLine) chartSeries.signalLine.update({ time: formattedCandle.time, value: lastSignalLine });
        if (lastMacdHist && chartSeries.macdHist) chartSeries.macdHist.update({ time: formattedCandle.time, value: lastMacdHist.value, color: lastMacdHist.color });

        const roc = calculateROC(closes).values.pop();
        if (roc && chartSeries.roc) chartSeries.roc.update({ time: formattedCandle.time, value: roc });
    }

    function calculateBollingerBands_forPlot(closes, period = 20, stdDev = 2, klines) {
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const middle = calculateSMA(closes, period);
        const upper = [], middleData = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                continue;
            }
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            const time = klines[i][0] / 1000;
            upper.push({ time, value: middle[i] + (stdev * stdDev) });
            lower.push({ time, value: middle[i] - (stdev * stdDev) });
            middleData.push({ time, value: middle[i] });
        }
        return { upper: upper.filter(d => d), middle: middleData.filter(d => d.value !== undefined), lower: lower.filter(d => d) };
    }
// 
    function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
        const closes = klines.map(k => parseFloat(k[4]));
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const upper = [], middle = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            const y = closes.slice(i - period + 1, i + 1);
            const n = period; 
            const sumX = (n * (n - 1)) / 2;
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
            const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            let sumErrSq = 0;
            for (let j = 0; j < n; j++) {
                const predictedY = intercept + slope * j;
                sumErrSq += Math.pow(y[j] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middleValue = intercept + slope * (n - 1);
            middle.push({ time: klines[i][0] / 1000, value: middleValue });
            upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
            lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) }); 
        }
        return { upper, middle, lower };
    }

    function calculateROC_forPlot(closes, period = 12) {
        if (closes.length < period + 1) return [];
        const rocData = [];
        for (let i = period; i < closes.length; i++) {
            const currentClose = closes[i];
            const pastClose = closes[i - period];
            if (pastClose !== 0) {
                const roc = ((currentClose - pastClose) / pastClose) * 100;
                rocData.push({ time: realtimeCache.main.klines[i][0] / 1000, value: roc });
            }
        }
        return rocData;
    }

    function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
        const closes = klines.map(k => parseFloat(k[4]));
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const upper = [], middle = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            const y = closes.slice(i - period + 1, i + 1);
            const n = period; 
            const sumX = (n * (n - 1)) / 2;
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
            const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            let sumErrSq = 0;
            for (let j = 0; j < n; j++) {
                const predictedY = intercept + slope * j;
                sumErrSq += Math.pow(y[j] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middleValue = intercept + slope * (n - 1);
            middle.push({ time: klines[i][0] / 1000, value: middleValue });
            upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
            lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) }); 
        }
        return { upper, middle, lower };
    }

    function calculateParabolicSAR_forPlot(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return [];
        let sar = parseFloat(klines[0][3]);
        let ep = parseFloat(klines[0][2]);
        let af = step;
        let isUptrend = true;
        const sarData = [];

        for (let i = 1; i < klines.length; i++) {
            const time = klines[i][0] / 1000;
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevSar = sar;

            if (isUptrend) {
                sar = prevSar + af * (ep - prevSar);
                if (low < sar) {
                    isUptrend = false;
                    sar = ep;
                    ep = low;
                    af = step;
                } else {
                    if (high > ep) {
                        ep = high;
                        af = Math.min(max, af + step);
                    }
                }
            } else { 
                sar = prevSar - af * (prevSar - ep);
                if (high > sar) {
                    isUptrend = true;
                    sar = ep;
                    ep = high;
                    af = step;
                } else {
                    if (low < ep) {
                        ep = low;
                        af = Math.min(max, af + step);
                    }
                }
            }
            sarData.push({ time, value: sar });
        }
        return sarData;
    }
// 
    function destroyCharts() {
        charts.forEach(chart => {
            if (chart) {
                chart.remove();
            }
        });
        charts = [];
        candlestickSeries = null;
        
        const mainChartContainers = [
            'main-chart-container', 
            'rsi-chart-container', 
            'stoch-chart-container', 
            'macd-chart-container',
            'roc-chart-container'
        ];
        mainChartContainers.forEach(id => {
            const container = document.getElementById(id);
            if (container) {
                container.innerHTML = '';
            }
        });
    }
// 
    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleChartsBtn.textContent = 'HIDE CHART';

            const observer = new ResizeObserver(entries => {
                for (let entry of entries) {
                    const { width } = entry.contentRect;
                    if (width > 0) {
                        renderAllCharts();
                        observer.unobserve(entry.target); // Hentikan observer setelah chart dirender
                    }
                }
            });
            observer.observe(chartsWrapper); // Mulai mengamati div charts-wrapper
        } else {
            chartsWrapper.style.display = 'none';
            toggleChartsBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }
// 
    function populateCurrentStateWidget() {
        const { tickerData, coinGeckoData, globalData, openInterestData, fundingRateData, binanceSymbol } = realtimeCache.main;
        
        document.getElementById('nav-symbol').textContent = binanceSymbol;
        const navChange24hEl = document.getElementById('nav-change-24h');
        const navChange1hEl = document.getElementById('nav-change-1h');
        
        const change24h = parseFloat(tickerData.priceChangePercent);
        if (navChange24hEl) {
            navChange24hEl.textContent = `${change24h.toFixed(2)}%`;
            navChange24hEl.className = `font-semibold ${getSignClass(change24h)}`;
        }
        
        if (navChange1hEl && coinGeckoData?.market_data) {
            const change1h = coinGeckoData.market_data.price_change_percentage_1h_in_currency.usd || 0;
            navChange1hEl.textContent = `${change1h.toFixed(2)}%`;
            navChange1hEl.className = `font-semibold ${getSignClass(change1h)}`;
        }
        navVolume24h.textContent = `$${parseFloat(tickerData.quoteVolume).toLocaleString('en-US', { notation: 'compact' })}`;
        if (coinGeckoData?.market_data) {
            navAth.textContent = formatPrice(coinGeckoData.market_data.ath.usd);
            navAtl.textContent = formatPrice(coinGeckoData.market_data.atl.usd);
        }

        if (coinGeckoData?.market_data) {
            document.getElementById('market-cap').textContent = formatPrice(coinGeckoData.market_data.market_cap.usd);
        }
        if (globalData?.data) {
            document.getElementById('btc-dominance').textContent = `${globalData.data.market_cap_percentage.btc.toFixed(2)}%`;
        }

        document.getElementById('current-state-title').innerHTML = `Current State<span class="text-yellow-500 font-semibold ml-2">💲 ${binanceSymbol}</span>`;
        document.getElementById('range-24h').textContent = `${formatPrice(parseFloat(tickerData.lowPrice)).replace('$', '')} - ${formatPrice(parseFloat(tickerData.highPrice)).replace('$', '')}`;
        
        const futuresContainer = document.getElementById('futures-data-container');
        const price = parseFloat(tickerData.lastPrice);
        if (marketTypeSelect.value === 'futures' && openInterestData && fundingRateData) {
            futuresContainer.classList.remove('hidden');
            if (openInterestData && parseFloat(openInterestData.openInterest) > 0) {
                const oiValue = parseFloat(openInterestData.openInterest) * price;
                document.getElementById('open-interest').textContent = `$${oiValue.toLocaleString('en-US', { notation: 'compact' })}`;
            } else {
                document.getElementById('open-interest').textContent = '-';
            }
            document.getElementById('funding-rate').textContent = `${(parseFloat(fundingRateData.lastFundingRate) * 100).toFixed(4)}%`;
            if (fundingRateData.nextFundingTime) {
                startFundingRateTimer(fundingRateData.nextFundingTime);
            } else {
                document.getElementById('funding-rate-interval').textContent = '-';
            }
        } else {
            futuresContainer.classList.add('hidden');
        }
    }
// 
    function renderCvdChart() {
        const { cvdData } = realtimeCache.main;
        if (!cvdData || cvdData.length === 0) return;

        // Inisialisasi data live dengan format baru yang lengkap
        liveCvdData = cvdData.map(d => ({ 
            x: d.time * 1000, 
            y_coin: d.cvd_coin,
            y_usdt: d.cvd_usdt 
        }));
        
        // Inisialisasi nilai kumulatif terakhir
        if (liveCvdData.length > 0) {
            const lastPoint = liveCvdData[liveCvdData.length - 1];
            liveCvdValue = lastPoint.y_coin;
            liveCvdValueUsdt = lastPoint.y_usdt;
        }

        const ctx = document.getElementById('cvdChart').getContext('2d');
        if (cvdChartInstance) cvdChartInstance.destroy();
        
        const isDarkMode = document.documentElement.classList.contains('dark');
        const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
        const negativeColor = isDarkMode ? '#f87171' : '#dc2626';

        cvdChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'CVD (USDT)',
                    data: liveCvdData,
                    parsing: {
                        yAxisKey: 'y_usdt' // <-- PENTING: Memberitahu chart untuk menggunakan nilai USDT
                    },
                    fill: false, tension: 0.1, pointRadius: 0, borderWidth: 2,
                    segment: {
                        borderColor: ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor,
                    }
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'time', time: { tooltipFormat: 'MMM dd, HH:mm:ss', unit: 'second' }, grid: { display: false }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563', source: 'auto', maxRotation: 0, autoSkip: true } },
                    y: { grid: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563' } }
                },
                plugins: { legend: { display: false } },
                interaction: { mode: 'index', intersect: false }
            }
        });

    
        updateCvdTableLive(liveCvdData);
    }   
// 
    function calculateCorrelation(dataX, dataY) {
        if (dataX.length !== dataY.length || dataX.length === 0) {
            return null;
        }
        const n = dataX.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += dataX[i];
            sumY += dataY[i];
            sumXY += dataX[i] * dataY[i];
            sumX2 += dataX[i] * dataX[i];
            sumY2 += dataY[i] * dataY[i];
        }

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        if (denominator === 0) {
            return 0; 
        }
        
        return numerator / denominator;
    }
// 
    async function recalculateAllIndicators(klines, tickerData, prevDayKline, marketType, cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData) {
        if (!klines || klines.length < 50) return {};

        const closes = klines.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        const rsiValues = calculateRSI(closes);
        const ema21Values = calculateEMA(closes, 21);
        const ema50Values = calculateEMA(closes, 50);
        const lastEma21 = ema21Values.filter(v => v !== undefined).pop();
        const lastEma50 = ema50Values.filter(v => v !== undefined).pop();
        const pivotPoints = calculatePivotPoints(prevDayKline);
        const ichimoku = calculateIchimokuCloud(klines);
        const keltnerChannels = calculateKeltnerChannels(klines);
        const activeMode = document.querySelector('.vwap-mode-btn.active')?.dataset.mode || 'rolling';
        const vwapValue = calculateVWAP(klines, activeMode);
        const atr = calculateATR(klines); // Panggil fungsi yang lebih akurat
        const atrPercent = calculateATRPercentage(klines); // Dapatkan persentase ATR

        let trendStatus = 'Netral';
        let trendClass = 'text-yellow-400';
        if (lastEma21 > lastEma50) {
            trendStatus = (lastPrice > lastEma21) ? 'Strong Uptrend' : 'Correction in Uptrend';
            trendClass = (lastPrice > lastEma21) ? 'positive' : 'text-yellow-400';
        } else if (lastEma50 > lastEma21) {
            trendStatus = (lastPrice < lastEma21) ? 'Strong Downtrend' : 'Downtrend Rally';
            trendClass = (lastPrice < lastEma21) ? 'negative' : 'text-yellow-400';
        }

        let orderBookBiasText = 'N/A';
        if (orderBookData?.bids && orderBookData?.asks) {
            const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
            const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
            orderBookBiasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (Buyer Limit)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (Seller Limit)' : 'Netral');
        }

        const openInterestStatus = (marketType === 'futures' && openInterestData?.openInterest > 0 && tickerData?.priceChangePercent)
            ? (parseFloat(tickerData.priceChangePercent) > 0 ? 'Bullish' : 'Bearish')
            : 'Netral';

        const bb = calculateBollingerBands(closes);
        const bbPriceAction = analyzeBollingerBandsPriceAction(klines, bb);
        const obvValues = calculateOBV(klines);
        const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik' : 'Turun';
        const lastObv = obvValues.length > 0 ? obvValues[obvValues.length - 1] : 0;
        const marketRegime = await predictMarketRegime(klines);
console.log('✅ CHECKPOINT 1: AI Prediction SUCCESS. Regime:', marketRegime);
        return {
            adx: calculateADX(klines),
            cvd: CVDanalyze(klines, cvdData),
            vpvr: calculateVPVR(klines),
            ma: { status: trendStatus, class: trendClass, value21: lastEma21, value50: lastEma50 },
            rsi: {
                values: rsiValues,
                last: rsiValues.filter(v => v !== undefined).pop()?.toFixed(2) || 50,
                status: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'Overbought' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'Oversold' : 'Netral'),
                class: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'tag-red' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'tag-green' : 'tag-yellow')
            },
            rsiDivergence: detectRSIDivergence(closes, rsiValues),
            obvDivergence: detectOBVDivergence(closes, klines),
            stoch: calculateStochasticRSI(closes),
            macd: calculateMACD(closes),
            bollingerBands: { ...bb, rejection: bbPriceAction.rejection, walkTheBands: bbPriceAction.walkTheBands },
            obv: { value: lastObv, trend: lastObv > obvValues[obvValues.length - 2] ? 'Naik' : 'Turun' },
            pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
            atr: atr, // Menggunakan variabel atr yang sudah dihitung
            atrPercent: atrPercent, // Menggunakan variabel atrPercent yang sudah dihitung
            candlePattern: findCandlestickPatterns(klines),
            chartPattern: findChartPatterns(klines),
            roc: calculateROC(closes),
            psar: calculateParabolicSAR(klines),
            linreg: calculateLinearRegressionChannel(closes),
            vwap: { status: lastPrice > vwapValue ? 'Bullish' : 'Bearish', value: vwapValue },
            ichimoku: { status: ichimoku?.status || 'Netral', data: ichimoku },
            keltnerChannels: keltnerChannels,
            fundingRate: fundingRateData,
            lsRatio: lsRatioUmumData?.[0],
            openInterest: { status: openInterestStatus },
            orderBookBias: orderBookBiasText,
            obv: { value: lastObv, trend: obvTrend },
            marketRegime: marketRegime
        };
    }
// 
    function populateCorrelationWidget() {
        const valueEl = document.getElementById('correlation-value');
        const textEl = document.getElementById('correlation-text');        
        const correlationData = realtimeCache.main.correlationData;

        if (correlationData === null || correlationData === undefined) {
            valueEl.textContent = '-';
            textEl.textContent = 'NOT ENOUGH DATA TO CALCULATE.';
            valueEl.className = 'text-base font-sbold text-gray-400 dark:text-gray-500';
            return;
        }

        const value = correlationData;
        valueEl.textContent = value.toFixed(2);

        let text = 'NONE';
        let colorClass = 'text-gray-400 dark:text-gray-500';

        if (value >= 0.7) { text = 'Positif Strong'; colorClass = 'positive'; } 
        else if (value >= 0.4) { text = 'Positive Medium'; colorClass = 'positive'; } 
        else if (value >= 0.1) { text = 'Positive Weak'; colorClass = 'text-yellow-400'; } 
        else if (value <= -0.7) { text = 'Negative Strong'; colorClass = 'negative'; } 
        else if (value <= -0.4) { text = 'Negative Medium'; colorClass = 'negative'; } 
        else if (value <= -0.1) { text = 'Negative Weak'; colorClass = 'text-yellow-400'; }
        
        textEl.textContent = text;
        valueEl.className = `text-lg font-semibold ${colorClass}`;
    }
// 
    function resetDashboard() {
         if (candleCountdownInterval) clearInterval(candleCountdownInterval);
        WebSocketManager.resetSubscriptions();
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (fundingRateTimer) clearInterval(fundingRateTimer);
        
        dashboardContent.classList.add('hidden');
        initialPlaceholder.classList.remove('hidden');
        destroyCharts();
        realtimeCache.main = {};
        realtimeCache.movers = {}; 
        klineCache = {}; 
        orderBookHistory = { avgVolumes: [], maxSize: 30 };
    }
// 
    function updateVwapDisplay(mode) {
        if (!realtimeCache.main.klines) return;
        
        // Gunakan klines yang sesuai dengan timeframe
        const vwapValue = calculateVWAP(realtimeCache.main.klines, mode);
        const lastPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
        
        // Simpan ke cache untuk digunakan oleh skor konfluensi dan AI
        realtimeCache.main.calculatedData.vwap = {
            status: lastPrice > vwapValue ? 'Bullish' : 'Bearish',
            value: vwapValue
        };
        
        // Perbarui tampilan di panel Data Timeframe
        document.getElementById('vwap-20d').textContent = formatPrice(vwapValue);

        // Panggil ulang update skor konfluensi agar ikut berubah
        updateQuickConfluenceWidget();
    }
// 
    function renderTriggerBreakdown(breakdown) {
        const container = document.getElementById('trigger-breakdown-list');
        if (!container) return;

        const renderTrigger = (name, triggerData, valueText, conditionText = '') => {
            const safeTriggerData = triggerData || { triggered: false, points: 0 };
            const isTriggered = safeTriggerData.triggered;
            const points = safeTriggerData.points;
            const icon = isTriggered ? '✅' : '▫️';
            const pointsText = isTriggered ? `+${points.toFixed(1).replace('.0', '')} Poin` : `0 Poin`;
            const mainColor = isTriggered ? 'text-green-400' : 'text-gray-500';
            const pointColor = isTriggered ? 'text-green-400' : 'text-gray-500';
            
            return `
                <li class="flex justify-between items-center py-2 border-b border-gray-700/50 ${mainColor}">
                    <span>${icon} ${name}</span>
                    <div class="text-right text-xs">
                        <span class="font-semibold">${valueText}</span>
                        <span class="text-gray-600 ml-1">${conditionText}</span>
                        <br>
                        <span class="font-mono font-bold ${pointColor}">${pointsText}</span>
                    </div>
                </li>
            `;
        };

        let html = '<ul class="list-none">';
        
        html += renderTrigger('Red Candle after HH', breakdown.candleRed, breakdown.candleRed?.triggered ? 'Detected' : 'NONE');
        html += renderTrigger('Bearish Candle', breakdown.doji, breakdown.candlePattern, '(ex: Shooting Star)');
        html += renderTrigger('Volume Exhaustion', breakdown.volumeExhaustion, breakdown.volumeExhaustion?.triggered ? 'DETECTED!' : 'Normal', '(Vol Top < 60% Avg)');
        html += renderTrigger('CVD Nose Dive', breakdown.cvdDip, breakdown.cvdDip?.triggered ? 'Yes' : 'No');
        html += renderTrigger('CVD Divergence', breakdown.cvdDivergence, breakdown.cvdStatus, '');
        // Ganti baris lama dengan ini untuk menampilkan nilai U/M/L
        html += renderTrigger(
            'Rejection Bollinger Band', 
            breakdown.bbRejection, 
            `<span class="text-red-400">U: ${breakdown.bbUpper}</span> / <span class="text-blue-400">M: ${breakdown.bbMiddle}</span> / <span class="text-green-400">L: ${breakdown.bbLower}</span>`,
            breakdown.bbStatus
        );
        html += renderTrigger('MACD Bearish Cross', breakdown.macdCross, `Status: ${breakdown.macdStatus}`);
        html += renderTrigger('RSI Overbought', breakdown.rsiOverbought, `Value: ${breakdown.rsiValue}`, '');

        html += '</ul>';
        container.innerHTML = html;
    }
// 
    function detectSignificantSellWall(asks) {
        if (!asks || asks.length === 0) return null;
        
        let totalVolume = asks.reduce((sum, ask) => sum + parseFloat(ask[1]), 0);
        let avgVolume = totalVolume / asks.length;
        let sellWallVolume = 0;
        const wallThreshold = avgVolume * 5; 
        
        for (const ask of asks) {
            if (parseFloat(ask[1]) > wallThreshold) {
                sellWallVolume += parseFloat(ask[1]);
            }
        }
        
        if (sellWallVolume > totalVolume * 0.2) {
            return { volume: sellWallVolume, type: 'significant' };
        }
        
        return null;
    }
// 
    async function updateTopMovers(timeframe = "1h") {
        try {
            const topGainersList = document.getElementById('gainers-list');
            
            if (topGainersList && !topGainersList.hasChildNodes()) {
                const loaderHtml = `<div class="p-4 flex justify-center items-center"><div class="loader"></div></div>`;
                topGainersList.innerHTML = loaderHtml;
                if (losersList) losersList.innerHTML = loaderHtml;
            }

            if (!exchangeInfoCache.futures) await initializeExchangeInfo('futures');
            
            const tradingSymbols = new Set(exchangeInfoCache.futures
                .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
                .map(s => s.symbol)
            );
            
            const ticker24hData = await fetchBinanceAPIData('ticker/24hr', {}, 'futures');
            let usdtPairs = ticker24hData.filter(d => d.symbol.endsWith('USDT') && tradingSymbols.has(d.symbol));

            usdtPairs.forEach(d => {
                const priceChange24h = parseFloat(d.priceChangePercent);
                const volume24h = parseFloat(d.quoteVolume);
                d.strengthScore24h = priceChange24h * Math.log10(volume24h + 1);
            });
            usdtPairs.sort((a, b) => b.strengthScore24h - a.strengthScore24h);
            const candidates = usdtPairs.slice(0, 15);

            let finalSortedGainers;

            if (timeframe !== '24h') {
                const klinesPromises = candidates.map(d => 
                    fetchBinanceAPIData('klines', { symbol: d.symbol, interval: timeframe, limit: 100 }, 'futures').catch(() => null)
                );
                const klinesResults = await Promise.all(klinesPromises);

                candidates.forEach((pair, index) => {
                    const klines = klinesResults[index];
                    if (klines && klines.length > 1) {
                        const firstClose = parseFloat(klines[0][4]);
                        const lastClose = parseFloat(klines[klines.length - 1][4]);
                        const quoteVolume = klines.reduce((sum, k) => sum + (parseFloat(k[5]) * parseFloat(k[4])), 0);
                        const priceChange = firstClose > 0 ? ((lastClose - firstClose) / firstClose) * 100 : 0;
                        pair.strengthScore = priceChange * Math.log10(quoteVolume + 1);
                        pair.dynamicPriceChange = priceChange;
                    } else {
                        pair.strengthScore = -Infinity;
                        pair.dynamicPriceChange = 0;
                    }
                });
                
                candidates.sort((a, b) => b.strengthScore - a.strengthScore);
                finalSortedGainers = candidates.slice(0, 5);

            } else {
                finalSortedGainers = candidates.slice(0, 5);
                finalSortedGainers.forEach(d => d.dynamicPriceChange = parseFloat(d.priceChangePercent));
            }

            const calculateChange = (kData) => {
                if (!kData || kData.length < 2) return 'N/A';
                const prevClose = parseFloat(kData[0][4]);
                const currentClose = parseFloat(kData[1][4]);
                return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
            };

            const gainersWithDetails = await Promise.all(finalSortedGainers.map(async (mover) => {
                const [klines1h, klines15m, klines5m, aggTrades] = await Promise.all([
                    fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                    fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 200 }, 'futures').catch(() => null),
                    fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '5m', limit: 200 }, 'futures').catch(() => []),
                    fetchBinanceAPIData('aggTrades', { symbol: mover.symbol, limit: 1000 }, 'futures').catch(() => [])
                ]);

                realtimeCache.movers[mover.symbol] = { 
                    klines_1h: klines1h,
                    klines_5m: klines5m,
                    aggTrades: aggTrades,
                };

                return { 
                    ...mover, 
                    change1h: calculateChange(klines1h.slice(-2)), 
                    change15m: calculateChange(klines15m) 
                };
            }));

            // >>> AWAL BLOK PENAMBAHAN ASET PIN <<<
    const pinnedAssets = ['BTCUSDT', '1000PEPEUSDT'];
    
    // Filter aset pin yang belum ada di daftar top movers untuk menghindari duplikat
    const existingSymbols = new Set(gainersWithDetails.map(m => m.symbol));
    const assetsToFetch = pinnedAssets.filter(symbol => !existingSymbols.has(symbol));

    if (assetsToFetch.length > 0) {
        // Ambil data ticker untuk aset yang di-pin dari data yang sudah di-fetch
        const pinnedTickers = usdtPairs.filter(d => assetsToFetch.includes(d.symbol));

        // Ambil detail klines untuk aset yang di-pin (logika sama seperti top movers)
        const pinnedAssetsWithDetails = await Promise.all(pinnedTickers.map(async (mover) => {
            const [klines1h, klines15m, klines5m, aggTrades] = await Promise.all([
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 200 }, 'futures').catch(() => null),
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '5m', limit: 200 }, 'futures').catch(() => []),
                fetchBinanceAPIData('aggTrades', { symbol: mover.symbol, limit: 1000 }, 'futures').catch(() => [])
            ]);

            realtimeCache.movers[mover.symbol] = { 
                klines_1h: klines1h,
                klines_5m: klines5m,
                aggTrades: aggTrades,
            };

            // Dapatkan kembali fungsi helper 'calculateChange' jika tidak tersedia secara global
            const calculateChange = (kData) => {
                if (!kData || kData.length < 2) return 'N/A';
                const prevClose = parseFloat(kData[0][4]);
                const currentClose = parseFloat(kData[1][4]);
                return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
            };

            return { 
                ...mover, 
                change1h: calculateChange(klines1h.slice(-2)), 
                change15m: calculateChange(klines15m),
                dynamicPriceChange: parseFloat(mover.priceChangePercent)
            };
        }));
        
        // Gabungkan daftar top movers dengan daftar aset yang di-pin
        gainersWithDetails.push(...pinnedAssetsWithDetails);
    }
            renderMoversList('gainers-list', gainersWithDetails, true, timeframe);
            
            if (losersList) {
            }

            attachTopMoversListeners();
            WebSocketManager.subscribeToMovers(gainersWithDetails.map(m => m.symbol));
            
        } catch (error) {
            console.error("Failed Getting Top Movers Data:", error);
            document.getElementById('gainers-list').innerHTML = `<div class="text-red-500 text-xs p-2">Error: ${error.message}. Try Again Later...</div>`;
            if (losersList) losersList.innerHTML = '';
        }
    }
// 
    function renderMoversList(containerId, moversData, isGainer, timeframe) {
        const container = document.getElementById(containerId);
        if (!container) return; // Pengaman jika kontainer NONE

        let html = ""; 
        const maxStrengthScore = isGainer && moversData.length > 0 && moversData[0].strengthScore ? moversData[0].strengthScore : 1;

        moversData.forEach(item => {
            const priceChange24h = parseFloat(item.priceChangePercent);
            // Ganti text-white menjadi text-gray-800 dark:text-white
            let headerHtml = `<div class="flex justify-between items-center text-sm font-semibold"><span class="font-bold text-gray-800 dark:text-white cursor-pointer" onclick="runFullAnalysis('${item.symbol}')">${item.symbol}</span><span class="font-mono text-gray-800 dark:text-white" id="price-${item.symbol}">${formatPrice(parseFloat(item.lastPrice))}</span></div>`;
            let detailsHtml = '';

            if (isGainer) {
                const pumpStrengthPercentage = Math.max(0, item.dynamicPriceChange > 0 ? Math.min(100, item.dynamicPriceChange * 2) : 0);
                
                const formatChange = (val, lbl) => {
                    if (val === 'N/A' || isNaN(parseFloat(val))) return `<span class="text-gray-500">${lbl}: --</span>`;
                    const value = parseFloat(val);
                    const color = value >= 0 ? 'positive' : 'negative';
                    // Logika untuk menyorot timeframe aktif
                    const isPrimary = timeframe && timeframe.toUpperCase() === lbl;
                    return `<span class="${color} ${isPrimary ? 'font-bold underline' : ''}">${lbl}: ${value.toFixed(2)}%</span>`;
                };

                detailsHtml = `<div class="flex justify-between items-center">
                    <div class="flex items-center gap-2 text-xs font-mono">
                        ${formatChange(priceChange24h, '24H')} 
                        ${formatChange(item.change1h, '1H')} 
                        ${formatChange(item.change15m, '15M')}
                    </div>
                    <div class="hybrid-bar" id="hybrid-bar-${item.symbol}">
                        <div class="pump-strength" style="width: ${pumpStrengthPercentage}%"></div>
                        <div class="dump-risk" style="width:0%;"></div>
                    </div>
                </div>`;
            } else {
            }
            
            html += `<div class="flex flex-col bg-gray-100 dark:bg-gray-800 p-2 rounded gap-2 mover-item" data-symbol="${item.symbol}">${headerHtml}${detailsHtml}</div>`;
            });

        container.innerHTML = html || `<div class="text-xs text-gray-500 p-2">NONE data.</div>`;
    }
// 
    function calculateShortConfluenceScore(symbol, timeframe) {
        if (!symbol) return { score: 0, breakdown: {} };

        let klines;
        let aggTrades;

        if (symbol === realtimeCache.main.symbol) {
            klines = realtimeCache.main.multiTfKlines[timeframe];
            aggTrades = realtimeCache.main.cvdData ? null : realtimeCache.main.aggTrades;
        } else if (realtimeCache.movers[symbol]) {
            if (timeframe === '5m') {
                klines = realtimeCache.movers[symbol].klines_5m;
            } else {
                klines = realtimeCache.movers[symbol].klines_1h;
            }
            aggTrades = realtimeCache.movers[symbol].aggTrades;
        } else {
            console.error(`NONE data cache yang ditemukan untuk simbol ${symbol}`);
            return { score: 0, breakdown: {} };
        }
        
        if (!klines || klines.length < 50) {
            return { score: 0, breakdown: {} };
        }

        const closes = klines.map(k => parseFloat(k[4]));
        const cvdDataForAnalysis = (symbol === realtimeCache.main.symbol && realtimeCache.main.cvdData) 
            ? realtimeCache.main.cvdData 
            : calculateCVD(aggTrades || []);

        const bbData = calculateBollingerBands(closes);
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop() || 0;
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop() || 0;
        const lastLower = bbData.lower.filter(v => v !== undefined).pop() || 0;

        const indicators = {
            candlePattern: findCandlestickPatterns(klines),
            macd: calculateMACD(closes),
            rsi: calculateRSI(closes),
            bollingerBands: analyzeBollingerBandsPriceAction(klines, bbData), 
            cvd: CVDanalyze(klines, cvdDataForAnalysis),
            atr: calculateATR(klines)
        };
        
        const atrStatus = indicators.atr.status;
        let volatilityMultiplier = 1.0; 

        if (atrStatus === 'High') {
            volatilityMultiplier = 0.75;
        } else if (atrStatus === 'Very High') {
            volatilityMultiplier = 0.5;
        }

        const lastRsiValue = indicators.rsi.filter(v => v !== undefined).pop() || 50;
        let score = 0;
        
        let breakdown = {
            rsiValue: lastRsiValue.toFixed(2),
            macdStatus: indicators.macd.status,
            bbStatus: indicators.bollingerBands.rejection,
            bbUpper: formatPrice(lastUpper),
            bbMiddle: formatPrice(lastMiddle),
            bbLower: formatPrice(lastLower),
            cvdStatus: indicators.cvd.divergence,
            candlePattern: indicators.candlePattern.pattern,
            candleRed: { triggered: false, points: 0 },
            doji: { triggered: false, points: 0 },
            cvdDip: { triggered: false, points: 0 },
            cvdDivergence: { triggered: false, points: 0 },
            rsiOverbought: { triggered: false, points: 0 },
            bbRejection: { triggered: false, points: 0 },
            macdCross: { triggered: false, points: 0 },
            volumeExhaustion: { triggered: false, points: 0 }
        };

        const lookbackPeriod = 15;
        const recentKlines = klines.slice(-lookbackPeriod);
        
        if (recentKlines.length >= 3) {
            let peakIndex = 0;
            for (let i = 1; i < recentKlines.length; i++) {
                if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
            }

            if (peakIndex < lookbackPeriod - 2) {
                const triggerCandleArr = recentKlines[peakIndex + 1];
                if (triggerCandleArr) {
                    const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                    if (triggerCandle.Close < triggerCandle.Open) {
                        const points = 3 * volatilityMultiplier;
                        score += points;
                        breakdown.candleRed = { triggered: true, points: points };
                    }
                }
            }
            
            if (peakIndex > 4 && peakIndex < recentKlines.length - 1) {
                const pumpVolumeLookback = 5;
                const pumpCandles = recentKlines.slice(peakIndex - pumpVolumeLookback, peakIndex);
                
                if (pumpCandles.length > 0) {
                    const avgPumpVolume = pumpCandles.reduce((sum, k) => sum + parseFloat(k[5]), 0) / pumpCandles.length;
                    const peakVolume = parseFloat(recentKlines[peakIndex][5]);

                    if (peakVolume < (avgPumpVolume * 0.6)) {
                        const points = 2;
                        score += points;
                        breakdown.volumeExhaustion = { triggered: true, points: points };
                    }
                }
            }
        }
        
        if (indicators.candlePattern.bias === 'BEARISH') {
            const points = 1 * volatilityMultiplier;
            score += points;
            breakdown.doji = { triggered: true, points: points };
        }

        const now = Date.now();
        if (now - lastCvdDipCalculationTime > CVD_DIP_DEBOUNCE_MS) {
            lastCvdDipCalculationTime = now; 
            const cvdValues = cvdDataForAnalysis.map(d => d.cvd_usdt);
            const changeLookback = 50;
            const stdDevMultiplier = 1.3;

            if (cvdValues.length > changeLookback) {
                let cvdChanges = [];
                for (let i = cvdValues.length - changeLookback; i < cvdValues.length; i++) {
                    cvdChanges.push(cvdValues[i] - cvdValues[i - 1]);
                }
                const avgChange = cvdChanges.reduce((sum, val) => sum + val, 0) / changeLookback;
                const variance = cvdChanges.reduce((sum, val) => sum + Math.pow(val - avgChange, 2), 0) / changeLookback;
                const stdDev = Math.sqrt(variance);
                const lastChange = cvdChanges[cvdChanges.length - 1];
                if (lastChange < (avgChange - (stdDevMultiplier * stdDev))) {
                    const points = 0.09 * volatilityMultiplier;
                    lastCvdDipResult = { triggered: true, points: points }; 
                } else {
                    lastCvdDipResult = { triggered: false, points: 0 };
                }
            } else {
                lastCvdDipResult = { triggered: false, points: 0 };
            }
        }
        
        if(lastCvdDipResult.triggered) {
            score += lastCvdDipResult.points;
        }
        breakdown.cvdDip = lastCvdDipResult;

        if (indicators.cvd.divergence.includes('Bearish')) {
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.cvdDivergence = { triggered: true, points: points };
        }
        
        if (lastRsiValue > 70) {
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.rsiOverbought = { triggered: true, points: points };
        }

        if (indicators.bollingerBands.rejection === 'Bearish Rejection (Upper BB)') {
            score += 3;
            breakdown.bbRejection = { triggered: true, points: 3 };
        }
        if (indicators.macd.status === 'Bearish Cross') {
            score += 2;
            breakdown.macdCross = { triggered: true, points: 2 };
        }   
        return { score: Math.min(score, 10), breakdown };
    }
// 
    function getConfluenceAnalysis(klines) {
        if (!klines || klines.length < 50) {
            return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
        }

        let skorBullish = 0;
        let skorBearish = 0;
        const closes = klines.map(k => parseFloat(k[4]));

        // --- Kalkulasi Indikator Penting ---
        const rsiValues = calculateRSI(closes);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const macd = calculateMACD(closes);
        const candlePattern = findCandlestickPatterns(klines);
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);

        // --- Logika Penilaian Bearish ---
        if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
        if (macd.status === 'Bearish Cross') skorBearish += 2.0;
        if (lastRsi > 70) skorBearish += 1.5; // Overbought
        if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

        // --- Logika Penilaian Bullish ---
        if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
        if (macd.status === 'Bullish Cross') skorBullish += 2.0;
        if (lastRsi < 30) skorBullish += 1.5; // Oversold
        if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
        
        // Total skor maksimal adalah 8
        const totalPossibleScore = 8.0;

        return { 
            skorBullish: (skorBullish / totalPossibleScore) * 10,
            skorBearish: (skorBearish / totalPossibleScore) * 10,
            detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
        };
    }
// 
    function onNewMoverData(symbol, streamName, payload) {
        if (!realtimeCache.movers[symbol]) {
            realtimeCache.movers[symbol] = { klines_1h: [], aggTrades: [], orderBook: { bids: [], asks: [] } };
        }
        const moverData = realtimeCache.movers[symbol];

        // Blok untuk memproses update kline 1 jam
        if (streamName.includes('@kline_1h')) {
            const k = payload.k;
            // Format kline baru sebagai ARRAY agar konsisten dengan data awal
            const newKlineArray = [
                k.t, k.o, k.h, k.l, k.c, k.v, k.T, 
                k.q, k.n, k.V, k.Q, k.B
            ];

            // Cek kline terakhir berdasarkan timestamp di indeks [0]
            if (moverData.klines_1h && moverData.klines_1h.length > 0 && moverData.klines_1h[moverData.klines_1h.length - 1][0] === k.t) {
                // Update kline terakhir jika timestamp sama
                moverData.klines_1h[moverData.klines_1h.length - 1] = newKlineArray;
            } else {
                // Tambahkan kline baru jika ini candle baru
                moverData.klines_1h.push(newKlineArray);
            }
            
            // Jaga agar panjang array tidak melebihi batas
            if (moverData.klines_1h.length > 200) {
                moverData.klines_1h.shift();
            }
        } 
        // Blok untuk memproses update trade
        else if (streamName.includes('@aggTrade')) {
            moverData.aggTrades.push(payload);
            if (moverData.aggTrades.length > 1000) moverData.aggTrades.shift();
        } 
        // Blok untuk memproses update order book
        else if (streamName.includes('@depth20')) {
            moverData.orderBook = { bids: payload.bids, asks: payload.asks };
        }
        // ================== AWAL BLOK PERBAIKAN FINAL ==================
        // Menghitung dan memperbarui "Bullish Momentum" bar secara real-time untuk setiap mover
        let pumpStrengthPercentage = 0;
        const klines1h = moverData.klines_1h;
        if (klines1h && klines1h.length >= 2) {
            const prevClose = parseFloat(klines1h[klines1h.length - 2][4]);
            const lastClose = parseFloat(klines1h[klines1h.length - 1][4]);
            const change1h = prevClose > 0 ? ((lastClose - prevClose) / prevClose) * 100 : 0;
            // Kalkulasi sederhana: persentase kenaikan dikali 2, maks 100%
            pumpStrengthPercentage = Math.max(0, change1h > 0 ? Math.min(100, change1h * 2) : 0);
        }
        
        // Update langsung elemen UI (bar) untuk mover yang bersangkutan
        const pumpBarElement = document.querySelector(`#hybrid-bar-${symbol} .pump-strength`);
        if (pumpBarElement) {
            pumpBarElement.style.width = `${pumpStrengthPercentage}%`;
        }

        // Menghitung skor Dump Potention
        const scoreData = calculateShortConfluenceScore(symbol, '5m');

        if (scoreData !== null) {
            // Memperbarui UI skor Dump Potention
            updateShortScoreUI(symbol, scoreData.score, scoreData.breakdown);

            // Sinkronisasi dengan panel utama jika mover yang diupdate adalah aset yang sedang dianalisis
            if (realtimeCache.main.symbol === symbol) {
                const klines1h_sync = moverData.klines_1h;
                
                // Perbarui skor pump/dump di cache utama
                if (klines1h_sync.length >= 2) {
                    // Anda bisa menambahkan logika skor pump yang lebih kompleks di sini jika perlu
                    // Untuk sekarang, kita akan sinkronkan skor pump & dump
                }
                realtimeCache.main.liveScores.pumpStrength = pumpStrengthPercentage;
                realtimeCache.main.liveScores.dumpRisk = scoreData.score;
                
                // Sinkronkan data kline 1 jam terbaru ke cache utama SEBELUM render ulang
                realtimeCache.main.klines1h = klines1h_sync;

                // Panggil ulang render panel scalping dengan data terbaru
                calculateAndDisplayScalpingSetup();
            }
        }
    }
// 
function calculateAndDisplayScalpingSetup() {
    const selectedDumpTf = document.getElementById('dump-trigger-timeframe-select').value;
    const { klines, calculatedData, symbol, selectedTimeframe, tfAlignmentSummary } = realtimeCache.main;
    if (!klines || klines.length < 50 || !calculatedData) {
        document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Not Enough Data</p>';
        return;
    }
    
    // --- 1. AMBIL DATA DAN HITUNG SKOR UTAMA ---
    document.getElementById('scalping-timeframe-display').textContent = `💲${symbol} at TF ${selectedTimeframe}`;
    const scoreData = calculateShortConfluenceScore(symbol, selectedDumpTf) || { score: 0, breakdown: {} };
    const dumpRiskScore = scoreData.score;
    const triggerBreakdown = scoreData.breakdown;
    
    // Sinkronisasi Pump/Dump Score (Realtime)
    const pumpStrength = realtimeCache.main.liveScores.pumpStrength || 0;
    document.getElementById('main-pump-bar').style.width = `${pumpStrength}%`;
    document.getElementById('main-dump-bar').style.width = `${dumpRiskScore * 10}%`;
    document.getElementById('main-pump-score').textContent = `${pumpStrength.toFixed(0)}%`;
    document.getElementById('main-dump-score').textContent = `${dumpRiskScore}/10`;
    renderTriggerBreakdown(triggerBreakdown);

    const container = document.getElementById('scalping-setup-content');
    const closes = klines.map(k => parseFloat(k[4]));
    const lastPrice = closes[closes.length - 1];

    // --- 2. TENTUKAN BIAS KONTEKSTUAL BERDASARKAN QUICK CONF. SCORE (AI-WEIGHTED) ---
    let biasKontekstual = "NETRAL / CHOP";
    let biasClass = "status-chop";
    let biasDetail = "Waiting Signal...";
    let trenUtama = "CHOP";
    let trenUtamaClass = "status-chop";
    
    // Dapatkan skor Konfluensi yang telah diboboti oleh AI Regime
    const quickScore = realtimeCache.main.quickConfluenceScore;
    const skorBullish = quickScore?.bull || 0;
    const skorBearish = quickScore?.bear || 0;

    if (tfAlignmentSummary && tfAlignmentSummary.summary['1h']) {
        const trend1h = tfAlignmentSummary.summary['1h'];
        if (trend1h === 'UPTREND') { trenUtama = "UPTREND"; trenUtamaClass = "status-uptrend"; } 
        else if (trend1h === 'DOWNTREND') { trenUtama = "DOWNTREND"; trenUtamaClass = "status-downtrend"; }
    }

    biasDetail = `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`;

    const diff = skorBullish - skorBearish;
    const absDiff = Math.abs(diff);

    // Gunakan ambang batas absolut (15%) untuk memfilter sinyal lemah
    if (absDiff > 5) { 
        if (diff > 0) { // Bullish kuat
            if (trenUtama === 'UPTREND') { biasKontekstual = 'LONG (Follow Trend)'; biasClass = 'status-uptrend'; } 
            else { biasKontekstual = 'LONG (Counter Trend/Range)'; biasClass = 'status-uptrend'; }
        } else { // Bearish kuat
            if (trenUtama === 'DOWNTREND') { biasKontekstual = 'SHORT (Follow Trend)'; biasClass = 'status-downtrend'; } 
            else { biasKontekstual = 'SHORT (Counter Trend/Range)'; biasClass = 'status-downtrend'; }
        }
    } else {
        biasKontekstual = "NETRAL / CHOP";
        biasClass = "status-chop";
    }

    // --- 3. INISIALISASI VARIABEL SETUP ---
    let entryPrice = NaN, stopLoss = NaN, takeProfit1 = NaN, takeProfit2 = NaN;
    let entryPercent = '', slPercent = '', tp1Percent = '', tp2Percent = '';
    let slColorClass = 'text-gray-500', tpColorClass = 'text-gray-500';
    let finalVerdictHtml = '';
    let takeProfit3 = calculatedData.fibExtensions?.levels?.level_1_618; // Default ke Fib Extension

    // --- 4. KALKULASI ENTRY/SL/TP BERDASARKAN BIAS ---
    if (biasKontekstual !== "NETRAL / CHOP") {
        const biasKalkulator = biasKontekstual.startsWith('LONG') ? 'LONG' : 'SHORT';
        const ema9 = calculateEMA(closes, 9).pop();
        const pivots = calculatedData.pivot.data;
        const vpvr = calculatedData.vpvr;
        const atrValue = calculatedData.atr.value;

        entryPrice = ema9; // Entry di EMA9 (Pullback)

        let structuralSL, structuralTP1;

    if (biasKalkulator === 'LONG') {
        // LONG: SL harus Support, TP1 harus Resistance
        structuralSL = pivots?.S1 || vpvr.val; // Ambil nilai Support terdekat
        structuralTP1 = pivots?.R1 || vpvr.vah; // Ambil nilai Resistance terdekat
        
        stopLoss = structuralSL - atrValue;
        takeProfit1 = structuralTP1; 

        // CRITICAL CHECK: Jika TP1 ternyata lebih rendah dari Entry (kesalahan data/logika), 
        // kita paksa TP1 menggunakan TP2 (RR 1:1) dan SL harus valid.
        if (takeProfit1 <= entryPrice) {
            const risk = Math.abs(entryPrice - stopLoss);
            takeProfit1 = entryPrice + risk; // Paksa RR 1:1
        }
        
        const risk = Math.abs(entryPrice - stopLoss);
        takeProfit2 = entryPrice + (risk * 1.5);

        slColorClass = 'negative';
        tpColorClass = 'positive';
    } else { // SHORT
        // SHORT: SL harus Resistance, TP1 harus Support
        structuralSL = pivots?.R1 || vpvr.vah; // Ambil nilai Resistance terdekat
        structuralTP1 = pivots?.S1 || vpvr.val; // Ambil nilai Support terdekat

        stopLoss = structuralSL + atrValue;
        takeProfit1 = structuralTP1; 

        // CRITICAL CHECK: Jika TP1 ternyata lebih tinggi dari Entry (kesalahan data/logika), 
        // kita paksa TP1 menggunakan TP2 (RR 1:1) dan SL harus valid.
        if (takeProfit1 >= entryPrice) {
            const risk = Math.abs(stopLoss - entryPrice);
            takeProfit1 = entryPrice - risk; // Paksa RR 1:1
        }
        
        const risk = Math.abs(stopLoss - entryPrice);
        takeProfit2 = entryPrice - (risk * 1.5);
        
        slColorClass = 'negative';
        tpColorClass = 'positive';
    }
        const getPNLPercentage = (target, entry, bias) => {
                if (typeof target !== 'number' || entry === 0) return '';
                const change = (target - entry) / entry;
                
                // Jika TP (profit), selalu positif
                const isTP = (bias === 'LONG' && target > entry) || (bias === 'SHORT' && target < entry);
                if (isTP) {
                    return `(+${(Math.abs(change) * 100).toFixed(2)}%)`;
                }
                
                // Jika SL (loss), selalu negatif
                const isSL = (bias === 'LONG' && target < entry) || (bias === 'SHORT' && target > entry);
                if (isSL) {
                    return `(${(change * 100).toFixed(2)}%)`;
                }

                // Untuk Entry Percent, hitung murni
                return `(${(change * 100).toFixed(2)}%)`;
            };

            entryPercent = getPNLPercentage(entryPrice, lastPrice, biasKalkulator);
            slPercent = getPNLPercentage(stopLoss, entryPrice, biasKalkulator);
            tp1Percent = getPNLPercentage(takeProfit1, entryPrice, biasKalkulator);
            tp2Percent = getPNLPercentage(takeProfit2, entryPrice, biasKalkulator);

            slColorClass = 'negative';
            tpColorClass = 'positive';
            realtimeCache.main.latestScalpingSetup = { entry: entryPrice, sl: stopLoss, tp1: takeProfit1 };
        } else {
        finalVerdictHtml = `
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-center p-4 rounded-lg bg-gray-100 dark:bg-gray-800/50">
                <p class="font-semibold text-sm text-yellow-400">SIDEWAYS</p>
                <p class="text-sm text-gray-400 mt-1">No Feasible Long/Short Setup. Do Not Trade.</p>
            </div>
        `;
        realtimeCache.main.latestScalpingSetup = null;
    }
    
    // Format Display (Gunakan NaN check)
    const formatValue = (value, fallback = '--') => isNaN(value) ? fallback : formatPrice(value);

    const entryDisplay = formatValue(entryPrice);
    const slDisplay = formatValue(stopLoss);
    const tp1Display = formatValue(takeProfit1);
    const tp2Display = formatValue(takeProfit2);
    
    // Final TP3 Display (Jika ada Fib Extension)
    const tp3Formatted = formatValue(takeProfit3, 'N/A');
    const tp3Percent = calculatePercentage(takeProfit3, entryPrice);
    const tp3Display = takeProfit3 && !isNaN(takeProfit3) ? `${tp3Formatted}<br><span class="text-xs font-mono ${tpColorClass}">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';
    
    // --- 5. RENDER UI ---
    container.innerHTML = `
        <div class="grid grid-cols-3 gap-3 text-center items-start">
            <div class="col-span-1">
                <p class="text-xs text-gray-500">Contextual Bias (TF: 1H)</p>
                <p class="text-[10px] font-mono ${trenUtamaClass}">1H Trend: ${trenUtama}</p> 
                <p class="text-sm font-semiboldblinking-text-animation ${biasClass}">${biasKontekstual}</p>
                <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
            </div>
            <div class="col-span-2 grid grid-cols-2 gap-3">
                <div>
                    <p class="text-xs text-gray-500">Entry</p>
                    <p class="font-normal text-sm text-yellow-400">${entryDisplay}</p>
                    <p class="text-xs font-mono text-yellow-500">${entryPercent}</p>
                </div>
                <div>
                    <p class="text-sm text-gray-500">SL (Structural)</p>
                    <p class="font-normal text-sm ${slColorClass}">${slDisplay}</p>
                    <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                </div>
            </div>
        </div>
        <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-3 text-center items-start">
            <div>
                <p class="text-xs text-gray-500">TP 1 (Structural)</p>
                <p class="font-normal ${tpColorClass}">${tp1Display}</p>
                <p class="text-xs font-mono ${tpColorClass}">${tp1Percent}</p>
            </div>
            <div>
                <p class="text-xs text-gray-500">TP 2 (R:R 1:1.5)</p>
                <p class="font-normal ${tpColorClass}">${tp2Display}</p>
                <p class="text-xs font-mono ${tpColorClass}">${tp2Percent}</p>
            </div>
            <div>
                <p class="text-xs text-gray-500">TP 3 (Key Level)</p>
                <p class="font-semibold text-sm">${tp3Display}</p>
            </div>
        </div>
        <div class="min-h-[55px] flex flex-col justify-center">
            ${finalVerdictHtml}
        </div>
    `;
}
// 
    // --- Fungsi Pembantu (Helper) yang diperlukan oleh Scalping Setup ---
// TEMUKAN FUNGSI calculatePercentage dan GANTI SELURUHNYA
// TEMUKAN FUNGSI calculatePercentage (BARIS 1530) dan GANTI SELURUHNYA
function calculatePercentage(target, entry, biasKalkulator = 'LONG') { 
    if (typeof target !== 'number' || typeof entry !== 'number' || isNaN(target) || isNaN(entry) || entry === 0) {
        return '';
    }
    
    let change = (target - entry) / entry;
    
    // Perbaikan Kritis: Jika posisi adalah SHORT, balikkan tanda (Short profit = harga turun, PNL harus positif).
    if (biasKalkulator === 'SHORT') {
        change = -change; 
    }
    
    // Selalu tampilkan tanda negatif untuk Stop Loss (asumsi SL selalu dihitung agar menghasilkan change negatif)
    if (biasKalkulator !== 'NETRAL' && target < entry && Math.abs(change * 100) > 0.01 && biasKalkulator === 'LONG') {
         // Jika Target (SL Long) lebih rendah dari Entry, pastikan itu negatif
         return `(${(change * 100).toFixed(2)}%)`;
    }
    if (biasKalkulator !== 'NETRAL' && target > entry && Math.abs(change * 100) > 0.01 && biasKalkulator === 'SHORT') {
        // Jika Target (SL Short) lebih tinggi dari Entry, pastikan itu negatif
        return `(${(change * 100).toFixed(2)}%)`;
    }

    // Jika ini TP, atau SL yang sudah dibalikkan (di atas), tampilkan positif
    const sign = change >= 0 ? '' : '-'; // HANYA untuk kasus-kasus khusus seperti entry percent
    const absChange = Math.abs(change);
    
    // Periksa apakah ini SL (di mana kita ingin tanda negatif yang benar)
    // Cara terbaik adalah menghitung persentase SL terpisah tanpa membalikkan tanda, 
    // lalu memanggil fungsi ini untuk TP. Tapi karena ini satu fungsi, kita gunakan logika ini:
    
    // JIKA target adalah SL, kembalikan tanda negatif
    const isSL = (biasKalkulator === 'LONG' && target < entry) || (biasKalkulator === 'SHORT' && target > entry);
    if (isSL) {
        // Hitung persentase murni Entry ke Target dan pastikan negatif
        const pureChange = (target - entry) / entry * 100;
        return `(${pureChange.toFixed(2)}%)`;
    }

    // JIKA target adalah TP, kembalikan tanda positif
    return `(+${(absChange * 100).toFixed(2)}%)`;
}

    function updateShortScoreUI(symbol, score, breakdown) {
        const dumpRiskElement = document.querySelector(`#hybrid-bar-${symbol} .dump-risk`);
        if (dumpRiskElement) dumpRiskElement.style.width = `${score * 10}%`;
        const moverItem = document.querySelector(`.mover-item[data-symbol="${symbol}"]`);
        if (moverItem) {
            moverItem.dataset.dumpRiskScore = score;
            moverItem.dataset.breakdown = JSON.stringify(breakdown || {});
        }
    }
// 
    function attachTopMoversListeners() {
        document.querySelectorAll("#gainers-list .mover-item").forEach(el => {
            el.addEventListener("mouseenter", e => { showCustomTooltip(e.currentTarget); });
            el.addEventListener("mouseleave", () => { hideCustomTooltip(); });
            el.addEventListener("click", e => {
                if (!el.classList.contains("tooltip-active")) {
                    document.querySelectorAll('.mover-item.tooltip-active').forEach(activeEl => activeEl.classList.remove('tooltip-active'));
                    el.classList.add("tooltip-active");
                    showCustomTooltip(e.currentTarget);
                    e.stopPropagation();
                } else {
                    el.classList.remove("tooltip-active");
                    hideCustomTooltip();
                    runFullAnalysis(el.dataset.symbol);
                }
            });
        });
    }
// 
    function showCustomTooltip(target) {
        isTooltipActive = true;
        const tooltip = document.getElementById("custom-tooltip");
        const symbol = target.dataset.symbol;
        const score = target.dataset.dumpRiskScore || '0';
        const breakdown = JSON.parse(target.dataset.breakdown || '{}');

        tooltip.innerHTML = `
            <strong>${symbol} - Analisis Short</strong>
            <p>Skor Potensi Dump: ${score}/10</p>
            <ul class="list-none text-xs mt-2 space-y-1">
                <li>Candle Merah: ${breakdown.candleRed ? "✅" : "▫️"}</li>
                <li>CVD Menukik: ${breakdown.cvd ? "✅" : "▫️"}</li>
                <li>Shooting Star/Doji: ${breakdown.doji ? "✅" : "▫️"}</li>
                <li class="italic text-gray-500">Resistance & Sell Wall (di panel utama)</li>
            </ul>`;
        tooltip.style.opacity = 1;
        tooltip.style.visibility = "visible";
        const rect = target.getBoundingClientRect();
        tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
        tooltip.style.left = `${rect.left + window.scrollX}px`;
    }
// 
    function hideCustomTooltip() {
        isTooltipActive = false;
        const tooltip = document.getElementById("custom-tooltip");
        if(tooltip) {
            tooltip.style.opacity = 0;
            tooltip.style.visibility = "hidden";
        }
        document.querySelectorAll('.mover-item.tooltip-active').forEach(el => el.classList.remove('tooltip-active'));
    }
// 
    function initTopMoversTimeframeSelector() {
        document.querySelectorAll(".top-movers-tf-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                document.querySelectorAll(".top-movers-tf-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                const timeframe = btn.dataset.timeframe;
                startTopMoversAutoRefresh(timeframe, currentInterval);
            });
        });
    }
// 
    function initRefreshIntervalSelector() {
        const select = document.getElementById("refresh-interval-select");
        select.addEventListener("change", () => {
            const interval = parseInt(select.value, 10);
            startTopMoversAutoRefresh(currentTimeframe, interval);
        });
    }
// 
    async function startTopMoversAutoRefresh(timeframe = "1H", interval = 120000) {
        currentTimeframe = timeframe;
        currentInterval = interval;
        remainingTime = interval / 1000;

        if (topMoversInterval) clearInterval(topMoversInterval);
        if (topMoversCountdown) clearInterval(topMoversCountdown);
        
        const refreshMovers = async () => {
            if (!isTooltipActive) {
                try {
                    if (!exchangeInfoCache.futures) {
                        ////console.log("Menunggu info bursa futures untuk Top Movers...");
                        await initializeExchangeInfo('futures');
                    }
                    await updateTopMovers(timeframe);
                    remainingTime = interval / 1000;
                } catch (error) {
                    console.error("Gagal refresh Top Movers:", error);
                    const gainersList = document.getElementById('gainers-list');
                    if(gainersList) gainersList.innerHTML = `<div class="text-red-500 text-xs p-2">Error: ${error.message}</div>`;
                }
            }
        };

        await refreshMovers();
        
        // Atur interval untuk refresh berikutnya
        topMoversInterval = setInterval(refreshMovers, interval);
        
        topMoversCountdown = setInterval(() => {
            if (!isTooltipActive) {
                remainingTime--;
                if (remainingTime < 0) remainingTime = interval / 1000;
            }
            const countdownEl = document.getElementById("refresh-countdown");
            if (countdownEl) {
                countdownEl.textContent = isTooltipActive ? "⏸ Paused" : `⏱️ ${remainingTime}s`;
            }
        }, 1000);
    }
// 
    const tsCalc = {
        elements: {
            leverage: document.getElementById('ts-leverage'),
            cost: document.getElementById('ts-cost'),
            slider: document.getElementById('ts-margin-slider'),
            walletBalance: document.getElementById('ts-wallet-balance'),
            marketPrice: document.getElementById('ts-market-price'),
            tpslToggle: document.getElementById('ts-tpsl-toggle'),
            tpslInputs: document.getElementById('ts-tpsl-inputs'),
            takeProfit: document.getElementById('ts-take-profit'),
            stopLoss: document.getElementById('ts-stop-loss'),
            resultCost: document.getElementById('ts-result-cost'),
            resultMax: document.getElementById('ts-result-max'),
            resultPosSize: document.getElementById('ts-result-position-size'),
            resultLiqPrice: document.getElementById('ts-result-liq-price'),
            resultStatus: document.getElementById('ts-result-status'),
            resultSlPrice: document.getElementById('ts-result-sl-price'),
            resultRoe: document.getElementById('ts-result-roe'),
            crossBtn: document.getElementById('ts-mode-cross'),
            isolatedBtn: document.getElementById('ts-mode-isolated'),
            buyBtn: document.getElementById('ts-buy-long-btn'),
            sellBtn: document.getElementById('ts-sell-short-btn'),
            autofillBtn: document.getElementById('autofill-ts-btn'),
            tsOptionsBtn: document.getElementById('ts-trailing-stop-options'),
            // Elemen Modal
            modalContainer: document.getElementById('ts-modal-container'),
            modalCallbackRate: document.getElementById('ts-modal-callback-rate'),
            modalActivationPrice: document.getElementById('ts-modal-activation-price'),
            modalSaveBtn: document.getElementById('ts-modal-save-btn'),
            modalCloseBtn: document.getElementById('ts-modal-close-btn')
        },
        state: {
            marginMode: 'cross',
            leverage: 20,
            cost: 0,
            entryPrice: 0,
            walletBalance: 1000,
            tp: null,
            sl: null,
            callbackRate: null,
            activationPrice: null,
            positionType: 'long'
        },
        
        toggleModal: function(show) {
            if (show) {
                this.elements.modalContainer.classList.remove('hidden');
            } else {
                this.elements.modalContainer.classList.add('hidden');
            }
        },
        recalculate: function() {
            this.state.walletBalance = parseFloat(this.elements.walletBalance.value) || 0;
            this.state.leverage = parseFloat(this.elements.leverage.value) || 20;
            this.state.cost = parseFloat(this.elements.cost.value) || 0;
            const marketPrice = parseFloat(this.elements.marketPrice.value);

            const lastPrice = realtimeCache.main.tickerData?.lastPrice ? parseFloat(realtimeCache.main.tickerData.lastPrice) : this.state.entryPrice;
            if (lastPrice === 0 && !marketPrice) return;
            const entry = this.state.entryPrice || lastPrice;

            const positionSize = this.state.cost * this.state.leverage;
            const quantity = entry > 0 ? positionSize / entry : 0;
            
            this.elements.resultCost.textContent = `${this.state.cost.toFixed(2)} USDT`;
            this.elements.resultMax.textContent = `${this.state.walletBalance.toFixed(2)} USDT`;
            this.elements.resultPosSize.textContent = `${positionSize.toFixed(2)} USDT`;
            
            let liqPrice = 0;
            const maintenanceMarginRate = 0.004;
            if (positionSize > 0) {
                if (this.state.marginMode === 'isolated') {
                    const priceChange = (this.state.cost / positionSize) * (1 - maintenanceMarginRate);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                } else { // Cross
                    const priceChange = ((this.state.walletBalance) / positionSize) * (1 - maintenanceMarginRate);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                }
            }
            this.elements.resultLiqPrice.textContent = liqPrice > 0 ? `${liqPrice.toFixed(4)} USDT` : 'N/A';
            
            if (this.state.callbackRate && this.state.activationPrice && !isNaN(marketPrice)) {
                let isActive = false;
                let stopLossPrice = 0;

                if (this.state.positionType === 'long' ? marketPrice >= this.state.activationPrice : marketPrice <= this.state.activationPrice) {
                    isActive = true;
                    const rate = this.state.callbackRate / 100;
                    stopLossPrice = this.state.positionType === 'long' ? marketPrice * (1 - rate) : marketPrice * (1 + rate);
                    
                    this.elements.resultStatus.textContent = 'Aktif ✅';
                    this.elements.resultStatus.className = 'positive';
                    this.elements.resultSlPrice.textContent = `${stopLossPrice.toFixed(4)} USDT`;

                    const pnl = (this.state.positionType === 'long') ? (stopLossPrice - entry) * quantity : (entry - stopLossPrice) * quantity;
                    const roe = this.state.cost > 0 ? (pnl / this.state.cost) * 100 : 0;
                    this.elements.resultRoe.textContent = `${roe.toFixed(2)}%`;
                    this.elements.resultRoe.className = pnl >= 0 ? 'profit positive' : 'loss negative';
                } else {
                    this.elements.resultStatus.textContent = 'Belum Aktif';
                    this.elements.resultStatus.className = 'text-yellow-400';
                    this.elements.resultSlPrice.textContent = '--';
                    this.elements.resultRoe.textContent = '--';
                    this.elements.resultRoe.className = '';
                }
            } else {
                this.elements.resultStatus.textContent = 'Belum Diatur';
                this.elements.resultStatus.className = 'text-gray-500';
                this.elements.resultSlPrice.textContent = '--';
                this.elements.resultRoe.textContent = '--';
                this.elements.resultRoe.className = '';
            }
        },

        autofill: function() {
            
            const setup = realtimeCache.main.latestScalpingSetup; // Benar 'i'
            
            if (!setup || !setup.entry) { // Pengecekan lebih kuat
                alert("Setup scalping belum siap atau pasar sedang sideways. Tidak bisa auto-fill.");
                return;
            }
            
            // Tentukan tipe posisi dari setup
            const isLong = setup.tp1 > setup.entry;
            this.state.positionType = isLong ? 'long' : 'short';
            
            // Perbarui UI tombol Buy/Sell
            if(isLong) {
                this.elements.buyBtn.classList.remove('opacity-50');
                this.elements.sellBtn.classList.add('opacity-50');
            } else {
                this.elements.sellBtn.classList.remove('opacity-50');
                this.elements.buyBtn.classList.add('opacity-50');
            }
            
            // Dapatkan harga pasar saat ini dari cache
            const currentMarketPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
            const precision = getPrecisionForAsset(currentMarketPrice);

            // Isi semua field di kalkulator
            this.elements.marketPrice.value = currentMarketPrice.toFixed(precision); // Harga saat ini
            this.elements.takeProfit.value = setup.tp1.toFixed(precision); // TP dari scalping setup
            this.elements.stopLoss.value = setup.sl.toFixed(precision);   // SL dari scalping setup

            // Aktifkan toggle TP/SL
            this.elements.tpslToggle.checked = true;
            this.elements.tpslInputs.classList.remove('hidden');

            // Beri fokus ke input modal agar pengguna bisa langsung mengisi
            this.elements.cost.focus();
            this.recalculate(); // Hitung ulang semua nilai di kalkulator
            
            // Scroll ke kalkulator agar terlihat
            this.elements.leverage.scrollIntoView({ behavior: 'smooth', block: 'center' });
        },
    };
// 
    function initializeNewCalculator() {
        const { elements, state } = tsCalc;
        
        elements.sellBtn.classList.add('opacity-50');
        state.positionType = 'long';

        elements.crossBtn.addEventListener('click', () => {
            state.marginMode = 'cross';
            elements.crossBtn.classList.add('active');
            elements.isolatedBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.isolatedBtn.addEventListener('click', () => {
            state.marginMode = 'isolated';
            elements.isolatedBtn.classList.add('active');
            elements.crossBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.buyBtn.addEventListener('click', () => {
            state.positionType = 'long';
            elements.buyBtn.classList.remove('opacity-50');
            elements.sellBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi LONG simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('long', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
            
            tsCalc.recalculate();
        });
        elements.sellBtn.addEventListener('click', () => {
            state.positionType = 'short';
            elements.sellBtn.classList.remove('opacity-50');
            elements.buyBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi SHORT simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('short', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
                
            tsCalc.recalculate();
        });
        elements.tpslToggle.addEventListener('change', () => {
            elements.tpslInputs.classList.toggle('hidden', !elements.tpslToggle.checked);
        });
        elements.slider.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const percentage = parseFloat(elements.slider.value);
            const newCost = (currentWalletBalance * (percentage / 100));
            elements.cost.value = newCost.toFixed(2);
            tsCalc.recalculate();
        });
        ['cost', 'leverage', 'walletBalance', 'marketPrice'].forEach(id => {
            elements[id].addEventListener('input', () => tsCalc.recalculate());
        });
        elements.cost.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const costValue = parseFloat(elements.cost.value) || 0;
            const percentage = currentWalletBalance > 0 ? (costValue / currentWalletBalance) * 100 : 0;
            elements.slider.value = Math.min(100, percentage);
        });
        elements.autofillBtn.addEventListener('click', () => tsCalc.autofill());

        // --- LOGIKA BARU UNTUK MODAL TS ---
        elements.tsOptionsBtn.addEventListener('click', () => tsCalc.toggleModal(true));
        elements.modalCloseBtn.addEventListener('click', () => tsCalc.toggleModal(false));
        elements.modalContainer.addEventListener('click', (e) => {
            if (e.target === elements.modalContainer) tsCalc.toggleModal(false);
        });
        elements.modalSaveBtn.addEventListener('click', () => {
            state.callbackRate = parseFloat(elements.modalCallbackRate.value);
            state.activationPrice = parseFloat(elements.modalActivationPrice.value);
            tsCalc.toggleModal(false);
            tsCalc.recalculate();
        });

        tsCalc.recalculate();
    }
// === LOGIKA SIMULASI TRADING (MULAI) ===
    const paperTrade = {
        state: {
            balance: 1000,
            position: null, // { type: 'long'/'short', entryPrice: 65000, quantity: 0.1, leverage: 20, cost: 325 }
            history: []
        },
        elements: {
            equity: document.getElementById('sim-equity'),
            unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
            availableMargin: document.getElementById('sim-available-margin'),
            resetBtn: document.getElementById('sim-reset-account-btn'),
            
            positionContainer: document.getElementById('sim-active-position-container'),
            positionHeader: document.getElementById('sim-position-header'),
            closePositionBtn: document.getElementById('sim-close-position-btn'),
            positionSize: document.getElementById('sim-position-size'),
            positionEntry: document.getElementById('sim-position-entry'),
            positionMark: document.getElementById('sim-position-mark'),
            positionLiq: document.getElementById('sim-position-liq'),
            positionPnl: document.getElementById('sim-position-pnl'),
            
            tradeHistoryList: document.getElementById('sim-trade-history-list'),
        },

            init: function() {
                this.loadState();
                this.elements.resetBtn.addEventListener('click', () => this.resetAccount());
                this.elements.closePositionBtn.addEventListener('click', () => this.closePosition());
                
                const importBtn = document.getElementById('sim-import-btn');
                const importInput = document.getElementById('sim-import-input');
                document.getElementById('sim-export-btn').addEventListener('click', exportHistoryToCSV);
                importBtn.addEventListener('click', () => importInput.click());
                importInput.addEventListener('change', importHistoryFromCSV);
                
                setInterval(() => this.update(), 500);
                this.render();
            },

            openPosition: function(type, leverage, cost, entryPrice) {
                if (this.state.position) {
                    alert("Hanya 1 posisi yang bisa dibuka dalam satu waktu.");
                    return;
                }
                if (cost > this.state.balance) {
                    alert("Modal tidak cukup untuk membuka posisi.");
                    return;
                }

                const positionSize = cost * leverage;
                const quantity = entryPrice > 0 ? positionSize / entryPrice : 0;
                
                // Asumsi margin terisolasi untuk perhitungan likuidasi sederhana
                const maintenanceMarginRate = 0.005; 
                const liqPriceChange = (cost / positionSize) * (1 - maintenanceMarginRate);
                const liqPrice = type === 'long' 
                    ? entryPrice * (1 - liqPriceChange) 
                    : entryPrice * (1 + liqPriceChange);

                this.state.balance -= cost;
                this.state.position = {
                    type: type,
                    entryPrice: entryPrice,
                    quantity: quantity,
                    leverage: leverage,
                    cost: cost,
                    liqPrice: liqPrice
                };
                
                this.saveState();
                this.render();
            },

            closePosition: function() {
                if (!this.state.position) return;
                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) {
                    alert("Tidak bisa menutup posisi, harga pasar tidak tersedia.");
                    return;
                }
                
                const pos = this.state.position;
                const pnl = (pos.type === 'long') 
                    ? (markPrice - pos.entryPrice) * pos.quantity 
                    : (pos.entryPrice - markPrice) * pos.quantity;

                this.state.balance += (pos.cost + pnl);
                
                this.state.history.unshift({
                    symbol: realtimeCache.main.symbol,
                    type: pos.type,
                    entryPrice: pos.entryPrice,
                    closePrice: markPrice,
                    pnl: pnl,
                    roe: (pnl / pos.cost) * 100,
                    closedAt: new Date(),
                    liquidated: false
                });
                
                if (this.state.history.length > 20) this.state.history.pop();

                this.state.position = null;
                this.saveState();
                this.render();
            },

            update: function() {
                if (!this.state.position) return;
                
                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) return;
                
                const pos = this.state.position;
                const pnl = (pos.type === 'long') 
                    ? (markPrice - pos.entryPrice) * pos.quantity 
                    : (pos.entryPrice - markPrice) * pos.quantity;
                
                const equity = this.state.balance + pos.cost + pnl;
                
                this.elements.equity.textContent = formatPrice(equity);
                this.elements.unrealizedPnl.textContent = formatPrice(pnl);
                this.elements.unrealizedPnl.className = `font-mono font-bold text-lg ${pnl >= 0 ? 'positive' : 'negative'}`;
                this.elements.positionMark.textContent = formatPrice(markPrice);
                
                const roe = (pnl / pos.cost) * 100;
                this.elements.positionPnl.textContent = `${formatPrice(pnl)} (${roe.toFixed(2)}%)`;
                this.elements.positionPnl.className = `font-mono font-bold text-lg ml-2 ${pnl >= 0 ? 'positive' : 'negative'}`;

                if ((pos.type === 'long' && markPrice <= pos.liqPrice) || (pos.type === 'short' && markPrice >= pos.liqPrice)) {
                    alert(`Posisi ${pos.type.toUpperCase()} terlikuidasi!`);
                    this.state.history.unshift({
                        symbol: realtimeCache.main.symbol,
                        type: pos.type,
                        entryPrice: pos.entryPrice,
                        closePrice: markPrice,
                        pnl: -pos.cost,
                        roe: -100,
                        closedAt: new Date(),
                        liquidated: true
                    });
                    this.state.position = null;
                    this.saveState();
                    this.render();
                }
            },

            render: function() {
                const pos = this.state.position;
                
                if (pos) {
                    const equity = this.state.balance + pos.cost;
                    this.elements.equity.textContent = formatPrice(equity);
                    this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                    this.elements.positionContainer.classList.remove('hidden');
                    this.elements.positionHeader.textContent = `${pos.type.toUpperCase()} / ${pos.leverage}x`;
                    this.elements.positionHeader.className = `font-bold text-lg ${pos.type === 'long' ? 'positive' : 'negative'}`;
                    this.elements.positionSize.textContent = formatPrice(pos.cost * pos.leverage);
                    this.elements.positionEntry.textContent = formatPrice(pos.entryPrice);
                    this.elements.positionLiq.textContent = formatPrice(pos.liqPrice);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                } else {
                    this.elements.equity.textContent = formatPrice(this.state.balance);
                    this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                    this.elements.positionContainer.classList.add('hidden');
                }

                if (this.state.history.length > 0) {
                    this.elements.tradeHistoryList.innerHTML = this.state.history.map(trade => `
                        <div class="p-1.5 rounded-md ${trade.pnl >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'}">
                            <div class="flex justify-between items-center">
                                <div>
                                    <span class="font-bold ${trade.type === 'long' ? 'positive' : 'negative'}">${trade.symbol} ${trade.type.toUpperCase()}</span>
                                    <span class="text-gray-400 text-[10px] ml-2">${trade.closedAt.toLocaleTimeString()}</span>
                                </div>
                                <div class="font-mono text-right ${trade.pnl >= 0 ? 'positive' : 'negative'}">
                                    ${formatPrice(trade.pnl)} (${trade.roe.toFixed(2)}%) ${trade.liquidated ? '🔥' : ''}
                                </div>
                            </div>
                            <div class="text-gray-400 text-[10px] font-mono flex justify-between mt-1 pt-1 border-t border-gray-700/50">
                                <span>Entry: ${formatPrice(trade.entryPrice)}</span>
                                <span>Close: ${formatPrice(trade.closePrice)}</span>
                            </div>
                        </div>
                    `).join('');
                } else {
                    this.elements.tradeHistoryList.innerHTML = '<p class="text-center text-gray-600">No trade history yet.</p>';
                }
            },

            resetAccount: function() {
                if (confirm("Apakah Anda yakin ingin mereset akun simulasi? Semua riwayat akan hilang.")) {
                    this.state.balance = 1000;
                    this.state.position = null;
                    this.state.history = [];
                    this.saveState();
                    this.render();
                }
            },

            saveState: function() {
                localStorage.setItem('paperTradeState', JSON.stringify(this.state));
            },

            loadState: function() {
                const savedState = localStorage.getItem('paperTradeState');
                if (savedState) {
                    this.state = JSON.parse(savedState);
                    if (this.state.history) {
                        this.state.history.forEach(trade => trade.closedAt = new Date(trade.closedAt));
                    }
                }
            }
    };
// 
    function exportHistoryToCSV() {
        const history = paperTrade.state.history;
        if (history.length === 0) {
            alert("Tidak ada riwayat trading untuk diekspor.");
            return;
        }

        // Header baru dengan EntryPrice dan ClosePrice
        const headers = ["Symbol", "Type", "EntryPrice", "ClosePrice", "PNL", "ROE", "ClosedAt", "Liquidated"];
        let csvContent = headers.join(",") + "\r\n";

        // Tambahkan data baru ke setiap baris
        history.forEach(trade => {
            const row = [
                trade.symbol,
                trade.type,
                trade.entryPrice || 'N/A', // Tambahkan fallback jika data lama tidak ada
                trade.closePrice || 'N/A', // Tambahkan fallback
                trade.pnl,
                trade.roe,
                trade.closedAt.toISOString(),
                trade.liquidated ? 'TRUE' : 'FALSE'
            ];
            csvContent += row.join(",") + "\r\n";
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        const timestamp = new Date().toISOString().slice(0, 10);
        link.setAttribute("download", `trade_history_${timestamp}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
// 
    function importHistoryFromCSV(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= 1) {
                alert("File CSV kosong atau hanya berisi header.");
                return;
            }

            const importedHistory = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length < 8) continue; // Sekarang harus ada 8 kolom

                try {
                    const trade = {
                        symbol: values[0].trim(),
                        type: values[1].trim(),
                        entryPrice: parseFloat(values[2]),
                        closePrice: parseFloat(values[3]),
                        pnl: parseFloat(values[4]),
                        roe: parseFloat(values[5]),
                        closedAt: new Date(values[6].trim()),
                        liquidated: values[7].trim().toUpperCase() === 'TRUE'
                    };
                    importedHistory.push(trade);
                } catch (error) {
                    alert(`Error saat memproses baris ke-${i+1}. Cek format file Anda.`);
                    return;
                }
            }
            
            if (confirm(`Impor akan menimpa ${importedHistory.length} riwayat trading yang ada. Lanjutkan?`)) {
                paperTrade.state.history = importedHistory.reverse();
                paperTrade.saveState();
                paperTrade.render();
                alert("Impor riwayat trading berhasil!");
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function updateDnaDisplay(dna) {
        const qc = dna.metadata.qc_validation;
        const params = dna.parameters;

        document.getElementById('dna-type-display').textContent = dna.metadata.dnaType || '-';
        document.getElementById('dna-asset-display').textContent = dna.metadata.sourceAsset || '-';
        document.getElementById('dna-tf-display').textContent = dna.metadata.sourceTimeframe || '-';
        document.getElementById('dna-pnl-avg-display').textContent = qc ? `$${(qc.avgPnl_per_trade * 100).toFixed(2)}%` : '-';
        document.getElementById('dna-loss-prob-display').textContent = qc ? `${qc.loss_probability_percent.toFixed(1)}%` : '-';
        document.getElementById('dna-threshold-display').textContent = params ? params.biasThreshold : '-';
    }
// 
// BAGIAN 5: EVENT LISTENER UTAMA (GANTI SELURUH BLOK LAMA ANDA DENGAN INI)
// 
    document.addEventListener('DOMContentLoaded', async () => {
        
        loadSettings();
        initTopMoversTimeframeSelector();
        initRefreshIntervalSelector();
        adjustContentPadding();
        
        setupToggle('toggle-scalping-btn', 'scalping-content-wrapper', 'toggle-scalping-icon', true);
        setupToggle('toggle-sentiment-btn', 'sentiment-content-wrapper', 'toggle-sentiment-icon', false);
        setupToggle('toggle-market-state-btn', 'current-state-content-wrapper', 'toggle-market-state-icon', true);
        setupToggle('toggle-confluence-btn', 'confluence-content-wrapper', 'toggle-confluence-icon', true);
        setupToggle('toggle-onchain-btn', 'onchain-content-wrapper', 'toggle-onchain-icon', false);        
        setupToggle('toggle-settings-btn', 'settings-content-wrapper', 'toggle-settings-icon', false);
        setupToggle('toggle-order-book-cvd-btn', 'order-book-cvd-content-wrapper', 'toggle-order-book-cvd-icon', false);
        setupToggle('toggle-ts-calc-btn', 'ts-calc-content-wrapper', 'toggle-ts-calc-icon', false);
        setupToggle('toggle-paper-trading-btn', 'paper-trading-content-wrapper', 'toggle-paper-trading-icon', false);
        setupToggle('toggle-top-movers-btn', 'top-movers-content-wrapper', 'toggle-top-movers-icon', false);
        toggleChartsBtn.addEventListener('click', () => toggleChartsVisibility());
        window.addEventListener('resize', adjustContentPadding);
        document.getElementById('save-settings-btn').addEventListener('click', saveSettings);
        
        timeframeSelect.addEventListener('change', (e) => {
            adaptIndicatorParamsToTimeframe(e.target.value);
        });

        themeToggleBtn.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            darkIcon.classList.toggle('hidden');
            lightIcon.classList.toggle('hidden');
            localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            if (cvdChartInstance) {
                const isDarkMode = document.documentElement.classList.contains('dark');
                const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
                const negativeColor = isDarkMode ? '#f87171' : '#dc2626';
                cvdChartInstance.data.datasets[0].segment.borderColor = ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor;
                cvdChartInstance.options.scales.x.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                cvdChartInstance.options.scales.y.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                cvdChartInstance.options.scales.y.grid.color = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                cvdChartInstance.update();
            }
        });

        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
            darkIcon.classList.remove('hidden');
        } else {
            lightIcon.classList.remove('hidden');
        }

        apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
        apiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', apiKeyInput.value));
        
        const presetSelect = document.getElementById('preset-select');
        presetSelect.addEventListener('change', (e) => applyPreset(e.target.value));

        document.getElementById('vwap-mode-buttons').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const mode = e.target.dataset.mode;
                document.querySelectorAll('.vwap-mode-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                updateVwapDisplay(mode);
            }
        });
        
        tradeLink.addEventListener('click', (e) => {
            e.preventDefault();
            const binanceSymbol = realtimeCache.main.binanceSymbol;
            if (!binanceSymbol) return;
            const marketType = marketTypeSelect.value;
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            const desktopUrl = marketType === 'futures' ? `https://www.binance.com/en/futures/${binanceSymbol}` : `https://www.binance.com/en/trade/${binanceSymbol}`;
            const mobileUrl = marketType === 'futures' ? `binance://futures/trade?symbol=${binanceSymbol}` : `binance://trade?symbol=${binanceSymbol}`;
            if (isMobile) {
                window.location.href = mobileUrl;
                setTimeout(() => { window.location.href = desktopUrl; }, 1500);
            } else {
                window.open(desktopUrl, '_blank');
            }
        });
        
        resetBtn.addEventListener('click', resetDashboard);
        
        const toggleAiBtn = document.getElementById('toggle-ai-btn');
        const aiContentContainer = document.getElementById('ai-content-container');
        let isAiAnalysisVisible = false;

        toggleAiBtn.addEventListener('click', async () => {
            const aiNarrativeEl = document.getElementById('ai-narrative-content');
            
            if (isAiAnalysisVisible) {
                // Logika untuk menyembunyikan panel
                aiContentContainer.classList.add('hidden');
                document.querySelector('#toggle-ai-btn span').textContent = 'ASK AI';
                isAiAnalysisVisible = false;
                return;
            }

            // Jika panel tidak terlihat, periksa apakah konten sudah ada
            if (aiNarrativeEl.innerHTML.trim() === '' || !realtimeCache.main.calculatedData) {
                // Jika konten belum ada, jalankan analisis baru
                isAiAnalysisVisible = true;
                aiContentContainer.classList.remove('hidden');
                document.querySelector('#toggle-ai-btn span').textContent = 'HIDE ANALYSIS';
                aiNarrativeEl.innerHTML = '<p class="text-center text-gray-500">Analisa sedang diproses...</p>';
                await runComprehensiveAIAnalysis();
            } else {
                // Jika konten sudah ada, tampilkan saja tanpa memanggil API lagi
                isAiAnalysisVisible = true;
                aiContentContainer.classList.remove('hidden');
                document.querySelector('#toggle-ai-btn span').textContent = 'HIDE ANALYSIS';
            }
        });

        const tooltipElement = document.createElement('div');
        tooltipElement.id = 'custom-tooltip';
        document.body.appendChild(tooltipElement);
        
        const debouncedRunAnalysis = debounce(runFullAnalysis, 100); 
        analyzeBtn.addEventListener('click', () => {
            analyzeBtn.disabled = true;
            debouncedRunAnalysis();
        });
        assetInput.addEventListener('keypress', (e) => { 
            if (e.key === 'Enter') {
                analyzeBtn.disabled = true; 
                debouncedRunAnalysis();
            } 
        });
        
        const triggers = document.querySelectorAll('[data-tooltip]');
        const dumpTfSelect = document.getElementById('dump-trigger-timeframe-select');
        const triggerListDiv = document.getElementById('trigger-breakdown-list');
        const mtfAlignmentContainer = document.getElementById('tf-alignment-summary');
        mtfAlignmentContainer.addEventListener('click', (event) => {
            const clickedBox = event.target.closest('.mtf-clickable-box');
            if (clickedBox) {
                const newTimeframe = clickedBox.dataset.timeframe;
                const mainTimeframeSelect = document.getElementById('timeframe-select');
                const mainAnalyzeBtn = document.getElementById('analyze-asset-btn');
                if (mainAnalyzeBtn.disabled) return;
                mainTimeframeSelect.value = newTimeframe;
                mainAnalyzeBtn.click();
            }
        });
        
        dumpTfSelect.addEventListener('change', async () => {
            if (!realtimeCache.main.symbol) return;
            const selectedTf = dumpTfSelect.value;
            const symbol = realtimeCache.main.symbol;
            const marketType = marketTypeSelect.value;
            try {
                dumpTfSelect.disabled = true;
                triggerListDiv.innerHTML = `<p class="text-xs text-center text-yellow-400">Loading data ${selectedTf}...</p>`;
                if (!realtimeCache.main.multiTfKlines[selectedTf]) {
                    const newData = await fetchBinanceAPIData('klines', { symbol: symbol, interval: selectedTf, limit: 200 }, marketType);
                    realtimeCache.main.multiTfKlines[selectedTf] = newData;
                }
                calculateAndDisplayScalpingSetup();
                const symbolLower = symbol.toLowerCase();
                const mainTfStream = `${symbolLower}@kline_${realtimeCache.main.selectedTimeframe}`;
                const newDumpTfStream = `${symbolLower}@kline_${selectedTf}`;
                const newStreamsToSub = [`${symbolLower}@aggTrade`, `${symbolLower}@depth20@100ms`, mainTfStream];
                if (mainTfStream !== newDumpTfStream) newStreamsToSub.push(newDumpTfStream);
                WebSocketManager.subscribe(newStreamsToSub);
            } catch (error) {
                console.error(`Gagal mengambil data untuk ${selectedTf}:`, error);
                triggerListDiv.innerHTML = `<p class="text-xs text-center text-red-500">Failed Data Fetch.. ${selectedTf}.</p>`;
            } finally {
                dumpTfSelect.disabled = false;
            }
        });
        
        document.getElementById('dna-file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                document.getElementById('dna-status').textContent = 'Status: Import dibatalkan.';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const dna = JSON.parse(e.target.result);
                    if (!dna || !dna.metadata || !dna.parameters || !dna.weights) {
                        throw new Error("Struktur file DNA tidak valid.");
                    }

                    activeStrategy = dna;
                    updateDnaDisplay(dna);
                    
                    document.getElementById('dna-status').textContent = `✅ Berhasil memuat ${file.name}`;
                    document.getElementById('dna-status').classList.remove('text-gray-500');
                    document.getElementById('dna-status').classList.add('text-green-600');
                    
                    ////console.log("DNA Strategy berhasil dimuat:", activeStrategy);
                } catch (error) {
                    document.getElementById('dna-status').textContent = `❌ Error: ${error.message}`;
                    document.getElementById('dna-status').classList.remove('text-gray-500', 'text-green-600');
                    document.getElementById('dna-status').classList.add('text-red-600');
                    console.error("Gagal memuat DNA:", error);
                    activeStrategy = null;
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            activeStrategy = null;
            document.getElementById('dna-file-input').value = ''; // Reset input file
            document.getElementById('dna-status').textContent = 'Status: Belum ada DNA yang dimuat.';
            document.getElementById('dna-type-display').textContent = '-';
            document.getElementById('dna-asset-display').textContent = '-';
            document.getElementById('dna-tf-display').textContent = '-';
            document.getElementById('dna-pnl-avg-display').textContent = '-';
            document.getElementById('dna-loss-prob-display').textContent = '-';
            document.getElementById('dna-threshold-display').textContent = '-';
            
        });
        
        initializeNewCalculator();
        paperTrade.init();
        await loadRegimeSensorModel();
        // 2. Sekarang, muat data eksternal WAJIB secara berurutan
        try {
            // Langkah A: Download daftar koin futures dulu. INI KUNCINYA.
            await initializeExchangeInfo('futures');
            
            // Langkah B: Setelah daftar koin siap, BARU jalankan Top Movers.
            await startTopMoversAutoRefresh("1h", 120000);
            
            // Langkah C: Siapkan juga daftar koin spot
            await initializeExchangeInfo('spot'); 

        } catch (err) {
            console.error("Gagal inisialisasi awal:", err);
            const gainersList = document.getElementById('gainers-list');
            if(gainersList) gainersList.innerHTML = `<p class="text-red-500 text-xs p-2">Error: ${err.message}</p>`;
        }
        
        // Listener terakhir yang bergantung pada data di atas
        marketTypeSelect.addEventListener('change', () => initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message)));
    
       //updateSignalLogStatistics();
    });
</script>
</body>
</html>