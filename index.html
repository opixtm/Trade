 <!DOCTYPE html>
<html lang="id" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DASHBOARD</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF7;
            color: #342d27;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .card {
            background-color: #FFFFFF;
            border: 1px solid #EAE5E0;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            transition: all 0.3s ease-in-out;
        }
        .btn-primary {
            background-color: #c97c00;
            color: #2b2a28;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-primary:hover { background-color: #eb9413 }
        .btn-primary:disabled { background-color: #333333; cursor: not-allowed; }
        .input-primary {
            background-color: #F8F5F1;
            border: 1px solid #DCD6CF;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #3D352E;
        }
        .input-primary:focus {
            outline: none;
            border-color: #747462;
            box-shadow: 0 0 0 2px rgba(34, 55, 40, 0.2);
        }
        .tag { padding: 0.25rem 0.625rem; border-radius: 9999px; font-size: 0.75rem; font-weight: 600; }
        .tag-green { background-color: #E6F4EA; color: #4A7C59; }
        .tag-red { background-color: #FCE8E8; color: #A83A3A; }
        .tag-yellow { background-color: #FFF8E1; color: #B5840F; }
        .tag-gray { background-color: #F1F3F4; color: #5F6368; }

        /* Dark Mode Styles */
        .dark body { background-color: #000000; color: #E0E0E0; }
        .dark .card { background-color: #151414; border-color: #333; }
        .dark .input-primary { background-color: #1c1b1b; border-color: #444; color: #E0E0E0; }
        .dark .input-primary:focus { border-color: #2b2d2b; box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.3); }
        .dark .tag-green { background-color: rgba(74, 124, 89, 0.2); color: #69b37f; }
        .dark .tag-red { background-color: rgba(168, 58, 58, 0.2); color: #d17474; }
        .dark .tag-yellow { background-color: rgba(181, 132, 15, 0.2); color: #e0c273; }
        .dark .tag-gray { background-color: rgba(95, 99, 104, 0.2); color: #9aa0a6; }
        .dark .text-gray-800 { color: #E0E0E0; }
        .dark .text-gray-500 { color: #d8d2d2; }
        .dark .text-gray-600 { color: #dddddd; }
        .dark .text-gray-700 { color: #e0e0e0; }
        .dark hr { border-color: #3e4946; }
        .dark .positive { color: #69b37f; }
        .dark .negative { color: #d17474; }


        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px; 
        }

        .dot {
            width: 14px;
            height: 14px;
            background-color: #e1e1e1; 
            border-radius: 50%;
            animation: bounce 1.0s infinite ease-in-out both;
        }

        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }
        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1.5);
            }
        }
        
        .positive { color: #16a34a; }
        .dark .positive { color: #4ade80; }
        .negative { color: #dc2626; }
        .dark .negative { color: #f87171; }
        .blinking-text-animation { animation: blinking-text 1.0s infinite; }
        @keyframes blinking-text { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        #button-loader .dot {
            width: 8px;
            height: 8px;
        }

        /* Style untuk tombol toggle indikator */
        .toggle-btn {
            background-color: #E7A13B;
            color: #4b5563;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #d1d5db;
        }
        .toggle-btn:hover {
            background-color: #d1d5db;
        }
        .toggle-btn.active {
            background-color: #1755c6;
            color: #121010;
            border-color: #1c295c;
        }
        .dark .toggle-btn {
            background-color: #1c1b1b;
            color: #d1d5db;
            border-color: #444;
        }
        .dark .toggle-btn:hover {
            background-color: #444;
        }
        .dark .toggle-btn.active {
            background-color: #4f3e01;
            color: #ffffff;
            border-color: #4A7C59;
        }
        .projection-results-container .card {
            background-color: #1c1b1b;
            border-color: #444;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .projection-results-container h4 {
            font-size: 1rem;
            color: #008c38;
        }
        .projection-results-container p {
            color: #e0e0e0;
        }
        .btn-yellow {
            background-color: #f59e0b; 
            color: #1f2937; 
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-yellow:hover {
            background-color: #b5a38d;
        }
        
        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }
        #trade-link:hover {
            text-decoration: none;
        }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (MULAI) === */
        .status-uptrend { color: #34d399; }
        .dark .status-uptrend { color: #4ade80; }
        .status-downtrend { color: #ef4444; }
        .dark .status-downtrend { color: #f87171; }
        .status-chop { color: #fbbf24; }
        .dark .status-chop { color: #fcd34d; }

        .confluence-bar-container {
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            height: 30px;
            display: flex;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .dark .confluence-bar-container { background-color: #374151; }

        .confluence-bar {
            height: 100%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.875rem;
            color: #111827;
        }

        .confluence-bar-bullish { background: linear-gradient(to right, #22c55e, #86efac); }
        .confluence-bar-bearish { background: linear-gradient(to right, #ef4444, #fca5a5); }
        /* === CSS BARU UNTUK KONFLUENSI CEPAT (SELESAI) === */
        .dark .btn-yellow {
            color: #120f0f;
        }
        /* === TAMBAHKAN BLOK CSS DI BAWAH INI === */
        .btn-secondary {
            background-color: #ff1869; /* gray-500 */
            color: #070707;
            font-weight: 600;
            padding: 0.625rem 1.25rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .btn-secondary:hover {
            background-color: #ff0a0a; /* gray-600 */
        }
        .dark .btn-secondary {
            background-color: #bb3103; /* gray-600 */
        }
        .dark .btn-secondary:hover {
            background-color: #a21000; /* gray-700 */
        }   
        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dashed rgba(128, 128, 128, 0.5);
        }

        #custom-tooltip {
            position: absolute;
            background-color: #141517; /* dark:bg-gray-800 */
            color: #e2e8f0; /* dark:text-gray-200 */
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #e48005; /* dark:border-gray-600 */
            font-size: 0.875rem;
            line-height: 1.5;
            z-index: 100;
            max-width: 320px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            pointer-events: none;
        }

        #custom-tooltip::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: #2d3748 transparent transparent transparent;
        }

        #custom-tooltip strong {
            color: #63b3ed; /* dark:text-blue-400 */
            display: block;
            margin-bottom: 4px;
            border-bottom: 1px solid #4a5568;
            padding-bottom: 4px;
        }

        #ai-narrative-content .prose h3 {
            margin-top: 1.25rem; /* Beri jarak di atas setiap judul (###) */
            margin-bottom: 0.5rem;
        }

        #ai-narrative-content .prose ul {
            margin-top: 0.5rem;
            margin-bottom: 1rem;
        }

        #ai-narrative-content .prose li {
            margin-bottom: 0.5rem; /* Beri jarak antar poin-poin (*) */
        }
        .vwap-mode-btn {
            background-color: #4a5568; /* gray-600 */
            color: #e2e8f0; /* gray-200 */
            border: 1px solid #718096; /* gray-500 */
            opacity: 0.6;
        }
        .vwap-mode-btn.active {
            background-color: #f59e0b; /* yellow-500 */
            color: #1f2937; /* gray-800 */
            opacity: 1;
            font-weight: bold;
        }
        .hybrid-bar {
            background-color: #2d3748;
            border-radius: 4px;
            height: 12px;
            width: 100px;
            position: relative;
            overflow: hidden;
            border: 1px solid #4a5568;
        }
        .pump-strength {
            background-color: #48bb78;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }
        .dump-risk {
            background-color: #f56565;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
            transition: width 0.3s ease-in-out;
        }
        /* === CSS BARU UNTUK SKOR TENSI (MULAI) === */
        .tension-bar-bg {
            background-color: #374151; /* dark:bg-gray-700 */
            border-radius: 9999px;
            height: 8px;
            width: 100%;
            margin: 4px auto 0;
            overflow: hidden;
            border: 1px solid #4b5563;
        }
        .tension-bar-fill {
            height: 100%;
            border-radius: 9999px;
            transition: width 0.5s ease-in-out;
            background: linear-gradient(to right, #fcd34d, #f59e0b, #ef4444); /* yellow to orange to red */
        }
        /* === CSS BARU UNTUK SKOR TENSI (SELESAI) === */
        /* === CSS BARU UNTUK KALKULATOR BINANCE STYLE (MULAI) === */
        .calc-binance-style .btn-group {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 1.5rem;
        }
        .calc-binance-style .btn-group button {
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            color: #e0e0e0;
            font-weight: 500;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .calc-binance-style .btn-group button:hover {
            background-color: #3a3f4a;
        }
        .calc-binance-style .btn-group button.active {
            background-color: #f0b90b;
            color: #14151a;
            border-color: #f0b90b;
        }
        .calc-binance-style .input-group {
            position: relative;
            margin-bottom: 1rem;
        }
        .calc-binance-style .input-field {
            width: 100%;
            padding: 12px 12px 12px 12px;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1.1em;
        }
        .calc-binance-style .input-label-top {
            font-size: 0.8em;
            color: #848e9c;
            margin-bottom: 8px;
        }
        .calc-binance-style .input-suffix {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #848e9c;
            font-weight: 600;
        }
        .calc-binance-style .margin-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #3a3f4a;
            outline: none;
            border-radius: 2px;
            margin: 1.5rem 0;
        }
        .calc-binance-style .margin-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #f0b90b;
            cursor: pointer;
            border-radius: 50%;
        }
        .calc-binance-style .slider-ticks {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #848e9c;
            padding: 0 2px;
        }
        .calc-binance-style .tpsl-section {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px dashed #3a3f4a;
        }
        .calc-binance-style .exec-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 1.5rem;
        }
        .calc-binance-style .exec-buttons button {
            padding: 14px;
            font-size: 1.1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .calc-binance-style .btn-buy { background-color: #2ebd85; color: white; }
        .calc-binance-style .btn-sell { background-color: #f6465d; color: white; }
        .calc-binance-style .calc-result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 1rem;
            font-size: 0.85em;
            color: #848e9c;
        }
        .calc-binance-style .calc-result-grid span:nth-child(even) {
            text-align: right;
            font-weight: 600;
            color: #e0e0e0;
        }
        /* === CSS BARU UNTUK KALKULATOR BINANCE STYLE (SELESAI) === */
        /* === CSS UNTUK MODAL TRAILING STOP === */
        #ts-modal-content .input-field {
            width: 100%;
            padding: 12px;
            background-color: #2c2f36;
            border: 1px solid #3a3f4a;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 1.1em;
        }
        #ts-modal-close-btn {
            font-size: 2rem;
            line-height: 1;
        }
        .mtf-clickable-box {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .mtf-clickable-box:hover {
            background-color: #4b5563; /* Sesuaikan warna hover jika perlu */
        }
    </style>
</head>
<body class="antialiased">

    <div id="sticky-nav-wrapper" class="sticky top-0 z-50 bg-[#FDFBF7]/80 dark:bg-[#121212]/80 backdrop-blur-lg border-b border-gray-200/50 dark:border-gray-700/50 shadow-sm">
        <div class="flex items-center justify-between py-2 px-4 sm:px-6 lg:px-8">
            
            <div class="flex items-center gap-8">

                <div class="flex items-center gap-3">
                    <div id="nav-info-container" class="items-center gap-2 hidden md:flex">
                        <div class="flex flex-col">
                            <div class="font-mono text-[10px]">
                                <span class="text-gray-400">VOL 24H:</span>
                                <span id="nav-volume-24h" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                            </div>
                        </div>
                        <div class="flex flex-col text-left text-xs">
                            <span id="nav-change-24h" class="font-semibold positive">-</span>
                            <span id="nav-change-1h" class="font-semibold positive">-</span>
                        </div>
                    </div>
                </div>

                <div id="nav-stats-container" class="items-center gap-4 font-mono text-[10px] hidden md:flex">
                    <div class="flex flex-col text-left">
                        <div>
                            <span class="text-gray-400">ATH:</span>
                            <span id="nav-ath" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                        <div>
                            <span class="text-gray-400">ATL:</span>
                            <span id="nav-atl" class="font-semibold text-gray-800 dark:text-gray-200">-</span>
                        </div>
                    </div>
                </div>
            </div>
            <a href="#" id="trade-link" class="text-right no-underline hidden flex items-baseline gap-2">
                <span id="nav-symbol" class="text-base font-bold text-blue-500 dark:text-green-500"></span>
                <span id="nav-price" class="text-yellow-500 text-lg">-</span>
            </a>
        </div>
        <div id="candle-countdown-container" class="w-full h-1 bg-gray-200 dark:bg-gray-700 hidden">
            <div id="candle-countdown-bar" class="h-full bg-yellow-500" style="width: 0%; transition: width 1s linear;"></div>
        </div>
    </div>

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <header class="py-4 flex justify-between items-center">
            <div>
                <h1 class="text-xl font-bold text-gray-800">DASHBOARD</h1>
                <p class="text-yellow-500 font-mono mt-1 text-sm">🏁</p>
            </div>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-800 focus:outline-none">
                <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8 0 1010.586 10.586z"></path></svg>
                <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414 1.414zM-.707 7.072l.707-.707a1 1 0 10-1.414-1.414l-.707.707a1 1 0 001.414 1.414zM3 11a1 1 0 100-2H2a1 1 0 100 2h1z"></path></svg>
            </button>
        </header>

    <main>

                        <div class="space-y-6 mb-8">
                            <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                                <div>
                                    <input type="password" id="gemini-api-key" class="input-primary" placeholder="Your API Key...">
                                    <p class="text-sm text-gray-400 mt-1">API 🔑 <a href="https://aistudio.google.com/app/apikey" target="_blank" class="underline hover:text-blue-500">GET KEY 👆🏻</a>.</p>
                                </div>
                                
                            </section>
                            <section id="settings-card" class="card p-4">
                                <button id="toggle-settings-btn" class="w-full flex justify-between items-center text-left">
                                    <h2 class="text-lg font-bold">Indicators Settings</h2>
                                    <svg id="toggle-settings-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>                                
                                </button>
                                <div id="settings-content-wrapper" class="collapsible-content">
                                    <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                                            <div>
                                                <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Parameter Indikator</h3>
                                                <div class="space-y-2 text-sm">
                                                    <div class="flex items-center justify-between"><label for="setting-rsi-period" class="text-gray-500">Periode RSI</label><input type="number" id="setting-rsi-period" class="input-primary !w-20 text-center" value="14"></div>
                                                    <div class="flex items-center justify-between">
                                                        <label for="setting-stoch-rsi-period" class="text-gray-500">Stoch RSI (RSI/Stoch/K/D)</label>
                                                        <div class="flex gap-1">
                                                            <input type="number" id="setting-stoch-rsi-period" class="input-primary !w-12 text-center" value="14">
                                                            <input type="number" id="setting-stoch-stoch-period" class="input-primary !w-12 text-center" value="14">
                                                            <input type="number" id="setting-stoch-k-smooth" class="input-primary !w-12 text-center" value="3">
                                                            <input type="number" id="setting-stoch-d-smooth" class="input-primary !w-12 text-center" value="3">
                                                        </div>
                                                    </div>
                                                    <div class="flex items-center justify-between"><label for="setting-macd-fast" class="text-gray-500">MACD Fast/Slow/Signal</label><div class="flex gap-1"><input type="number" id="setting-macd-fast" class="input-primary !w-16 text-center" value="12"><input type="number" id="setting-macd-slow" class="input-primary !w-16 text-center" value="26"><input type="number" id="setting-macd-signal" class="input-primary !w-16 text-center" value="9"></div></div>
                                                    <div class="flex items-center justify-between">
                                                        <label for="setting-weight-obv-divergence" class="text-gray-500">Bobot Divergensi OBV</label>
                                                        <input type="number" step="0.1" id="setting-weight-obv-divergence" class="input-primary !w-20 text-center" value="3.0">
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <div>
                                                <h3 class="font-semibold mb-2 text-gray-700 dark:text-gray-300">Bobot Skor Konfluensi</h3>
                                                <div class="space-y-2 text-sm">
                                                    <div class="flex items-center justify-between"><label for="setting-weight-divergence" class="text-gray-500">Bobot Divergensi RSI</label><input type="number" step="0.1" id="setting-weight-divergence" class="input-primary !w-20 text-center" value="2.5"></div>
                                                    <div class="flex items-center justify-between"><label for="setting-weight-macd" class="text-gray-500">Bobot MACD Cross</label><input type="number" step="0.1" id="setting-weight-macd" class="input-primary !w-20 text-center" value="2.0"></div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                                            <div class="flex items-center justify-between">
                                                <label for="preset-select" class="font-semibold text-gray-700 dark:text-gray-300">TradingStyle</label>
                                                <select id="preset-select" class="input-primary !w-auto text-sm">
                                                    <option value="default">Default</option>
                                                    <option value="scalper">Scalper</option>
                                                    <option value="dayTrader">Day Trader</option>
                                                    <option value="swingTrader">Swing Trader</option>
                                                </select>
                                            </div>
                                        </div>
                                        <div class="text-right mt-4"><button id="save-settings-btn" class="btn-primary">💾</button></div>
                                        <p id="settings-saved-msg" class="text-green-500 text-sm mt-2 text-center hidden">SAVED!</p>
                                    </div>
                                </div>
                            </section>
                                <div id="initial-placeholder" class="text-center py-5">
                                
                                </div>
                            <div id="loader-overlay" class="... flex-col ...">
                                <div class="loader">
                                    <div class="dot"></div>
                                    <p class="text-4xl font-mono text-gray-500">SPOT</p>
                                    <div class="dot"></div>
                                    <p class="text-4xl font-mono text-gray-500">PERPETUAL</p>
                                    <div class="dot"></div>
                                </div>
                                <p id="loader-text" class="text-white font-semibold mt-4 text-center blinking-text-animation">Let's Go........</p>
                            </div>
                            <section id="top-movers-section" class="card p-6">
                                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-2">
                                    <h2 class="text-sm font-semibold">Top Performers</h2>
                                    <div id="top-movers-controls" class="flex flex-col sm:flex-row gap-2 items-start sm:items-center">
                                        <div id="top-movers-timeframe-selector" class="flex flex-wrap gap-2">
                                            <button data-timeframe="1m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">1m</button>
                                            <button data-timeframe="3m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">3m</button>
                                            <button data-timeframe="5m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">5m</button>
                                            <button data-timeframe="15m" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">15m</button>
                                            <button data-timeframe="1h" class="top-movers-tf-btn toggle-btn text-xs !p-1.5 active">1H</button>
                                            <button data-timeframe="24h" class="top-movers-tf-btn toggle-btn text-xs !p-1.5">24H</button>
                                        </div>
                                        <div class="flex gap-2 items-center">
                                            <select id="refresh-interval-select" class="input-primary text-xs !w-auto !p-1">
                                                <option value="5000">5s</option>
                                                <option value="10000">10s</option>
                                                <option value="30000">30s</option>
                                                <option value="60000">60s</option>
                                                <option value="120000" selected>120s</option>
                                            </select>
                                            <span id="refresh-countdown" class="text-xs text-gray-500 w-24 text-center"></span>
                                        </div>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 gap-4">
                                    <div>
                                        <h3 class="text-sm font-semibold text-gray-400 mb-2">Top Movers (by TF)</h3>
                                        <div id="gainers-list" class="space-y-2"></div>
                                    </div>                       
                                </div>
                            </section>
                            <section class="card p-6 grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                                <div>
                                    <div class="flex flex-col sm:flex-row gap-4">
                                        <input type="text" id="asset-input" list="asset-list" class="input-primary text-sm flex-grow uppercase" placeholder="Ketik Simbol Aset (cth: BTCUSDT)" value="BTCUSDT">
                                        <datalist id="asset-list"></datalist>
                                        <select id="market-type-select" class="input-primary text-sm !w-auto">
                                            <option value="spot">Spot</option>
                                            <option value="futures" selected>Perp</option>
                                        </select>
                                        <select id="timeframe-select" class="input-primary text-sm !w-auto">
                                            <option value="1m">1m</option><option value="3m">3m</option><option value="5m"selected>5m</option><option value="15m">15m</option><option value="30m">30m</option><option value="1h">1h</option><option value="2h">2h</option><option value="4h">4h</option><option value="1d">1d</option><option value="1w">W</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="md:col-span-2 flex gap-4">
                                    <button id="analyze-asset-btn" class="btn-primary w-full font-bold text-xl">
                                        <span id="button-text">GET DATA</span>
                                        <div id="button-loader" class="loader hidden">
                                        <div class="dot"></div>
                                        <div class="dot"></div>
                                        <div class="dot"></div>
                                        </div>
                                    </button>
                                    <p id="asset-error" class="text-red-600 text-sm mt-2 text-center hidden"></p>
                                    <button id="reset-btn" class="btn-secondary !w-auto">RESET</button>
                                </div>
                            </section>

                        </div>

            <div id="dashboard-content" class="hidden">
                <div class="space-y-8">               
                <div class="flex flex-col gap-8">

                <section id="current-state-section" class="card p-6">
                    <button id="toggle-market-state-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 id="current-state-title" class="text-xl font-semibold">Current Market Condition</h2>
                        <svg id="toggle-market-state-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                        </svg>
                    </button>
                    <div id="current-state-content-wrapper" class="collapsible-content expanded">
                        <div class="space-y-6">
                            <h2 class="text-lg font-semibold text-center">Calculated Timeframe <span id="quick-confluence-timeframe">5m</span></h2>
                            <div class="flex items-center gap-4 my-2">
                                <div id="quick-finalBearishScore" class="text-2xl font-bold status-downtrend text-right w-1/5">🐻 0%</div>
                                <div class="confluence-bar-container w-3/5">
                                    <div id="quick-confluenceBarBearish" class="confluence-bar confluence-bar-bearish" style="width: 50%;"></div>
                                    <div id="quick-confluenceBarBullish" class="confluence-bar confluence-bar-bullish" style="width: 50%;"></div>
                                </div>
                                <div id="quick-finalBullishScore" class="text-2xl font-bold status-uptrend text-left w-1/5">0% 🐂</div>
                            </div>
                            <div id="verdict-container" class="text-center">
                                <p id="quick-finalVerdict" class="font-semibold"></p>
                                <div id="tension-score-container" class="mt-3 text-xs"></div>
                            </div>
                            <div id="confluence-breakdown-container" class="mt-4 text-xs text-center space-y-2 hidden">
                                <div class="grid grid-cols-2 gap-2 text-left">
                                    <div id="top-bullish-contributors"></div>
                                    <div id="top-bearish-contributors"></div>
                                </div>
                            </div>
                            <div class="space-y-2 pt-6 border-t border-gray-200 dark:border-gray-700">
                                <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                    <div class="h-16 flex items-center justify-center my-2"></div>
                                    <p id="candlestick-pattern" class="font-semibold">NONE</p>
                                </div>
                                <div class="text-center p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                                    <p id="chart-pattern-label" class="text-xs text-gray-500">Chart Pattern</p>
                                    <p id="chart-pattern" class="font-semibold">NONE</p>
                                </div>
                            </div>
                            <hr class="border-gray-200 dark:border-gray-700/50 my-4">
                            <div>
                                <h3 class="text-xl font-bold mb-4 text-center">Order Book</h3>
                                <div id="full-order-book-container" class="space-y-2 text-sm"><p class="text-center text-gray-500">FETCHING DATA...</p></div>
                                <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                    <span class="text-gray-500">Order Book Bias</span><span id="order-book-bias" class="font-mono">-</span>
                                </div>
                            </div>
                            <hr class="border-gray-200 dark:border-gray-700/50 my-4">
                            <div>
                                <h3 class="text-lg font-bold mb-4 text-center">CVD Order Flow</h3>
                                <div class="chart-container" style="height: 150px;"><canvas id="cvdChart"></canvas></div>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="confluence-details-section" class="card p-6">
                    <button id="toggle-confluence-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-lg font-bold">Timeframe [ NOW ] -<span id="confluence-timeframe-display"> 5m</span></h2>
                        <svg id="toggle-confluence-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>
                    <div id="confluence-content-wrapper" class="collapsible-content">
                        <div>
                            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">KEY LEVEL</h3>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between"><span class="text-red-500">VAH</span><span id="vpvr-vah" class="font-mono">-</span></div>
                                    <div class="flex justify-between"><span class="font-bold text-blue-500" data-tooltip="Point of Control (POC)|...">Point of Control (POC)</span><span id="vpvr-poc" class="font-mono font-bold">-</span></div>
                                    <div class="flex justify-between"><span class="text-green-500">VAL</span><span id="vpvr-val" class="font-mono">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500">24H</span><span id="range-24h" class="font-mono font-semibold">-</span></div>

                                    <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                        <div class="flex justify-between items-center">
                                            <span class="text-gray-500" data-tooltip="Daily Pivot (P)|...">Daily Pivot (P)</span>
                                            <span id="pivot-p" class="font-mono font-semibold text-blue-500">-</span>
                                        </div>
                                        <div id="pivot-levels-container" class="text-xs text-gray-400 space-y-1 mt-1 pl-4 hidden">
                                            <div class="flex justify-between"><span>R1 / S1</span><span id="pivot-r1s1" class="font-mono">-</span></div>
                                            <div class="flex justify-between"><span>R2 / S2</span><span id="pivot-r2s2" class="font-mono">-</span></div>
                                            <div class="flex justify-between"><span>R3 / S3</span><span id="pivot-r3s3" class="font-mono">-</span></div>
                                        </div>
                                    </div>

                                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="VWAP (Volume-Weighted Average Price)|...">VWAP</span><div class="flex items-center gap-2"><div id="vwap-mode-buttons" class="flex text-xs"><button data-mode="rolling" class="vwap-mode-btn active px-2 py-0.5 rounded-l-md" data-tooltip="Rolling VWAP|...">R</button><button data-mode="session" class="vwap-mode-btn px-2 py-0.5" data-tooltip="Session VWAP|...">S</button><button data-mode="anchored" class="vwap-mode-btn px-2 py-0.5 rounded-r-md" data-tooltip="Anchored VWAP|...">A</button></div><span id="vwap-20d" class="font-mono text-yellow-500">-</span></div></div>
                                </div>
                            </div>
                            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">MOMENTUM</h3>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between items-center"><span class="text-gray-500">RSI (14)</span><div><span id="rsi-value" class="font-mono text-xs">-</span> <span id="rsi-status" class="tag tag-gray"></span></div></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500">Stoch RSI (%K/%D)</span><div><span id="stoch-value" class="font-mono text-xs">-</span> <span id="stoch-status" class="tag tag-gray"></span></div></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500">MACD</span><div><span id="macd-status" class="font-mono font-semibold">-</span> <span id="macd-hist" class="font-mono text-xs ml-1">-</span></div></div>
                                    <div class="flex justify-between items-center"><span class="text-blue-500" data-tooltip="Bollinger Squeeze|...">Bollinger Squeeze</span><span id="bollinger-squeeze-status" class="font-mono">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-yellow-500">BB Reversal</span><span id="bollinger-rejection-status" class="font-mono">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500">BB Walk the Bands</span><span id="bollinger-walk-status" class="font-mono">-</span></div>
                                    <div><div class="flex justify-between items-center"><span class="text-gray-500">Bollinger Bands</span><span id="bollinger-bands-status" class="font-mono">-</span></div><div class="text-right text-xs text-gray-400 font-mono"><span id="bb-upper-value">-</span> / <span id="bb-middle-value">-</span> / <span id="bb-lower-value">-</span></div></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="RSI Divergence|...">RSI Divergence</span><span id="rsi-divergence" class="font-mono font-semibold text-xs">-</span></div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Linear Regression Channel|...">LinReg Channel</span><span id="linreg-status" class="font-mono">-</span></div>
                                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50">
                                        <span class="text-gray-500" data-tooltip="On-Balance Volume|Indikator momentum yang menggunakan volume untuk memprediksi perubahan harga.">OBV</span>
                                        <span id="obv-value" class="font-mono font-semibold">-</span>
                                    </div>
                                    <div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Ichimoku Bias|...">Ichimoku Bias</span><span id="ichimoku-bias" class="font-mono font-semibold">-</span></div>
                                </div>
                            </div>
                            <div class="pt-6 border-t border-gray-200 dark:border-gray-700">
                                <h3 class="font-semibold text-gray-700 dark:text-slate-400 mb-2">Asset Info</h3>
                                <div class="hidden">
                                    <input type="text" id="correlation-asset-input" class="input-primary" value="BTCUSDT">
                                </div>

                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between items-center">
                                        <span class="text-gray-500">BTC Correlation (30D)</span>
                                        <div>
                                            <span id="correlation-value" class="font-mono font-semibold text-gray-300">-</span>
                                            <span id="correlation-text" class="text-xs text-gray-500 ml-1">...</span>
                                        </div>
                                    </div>
                                <div class="space-y-1 text-sm">
                                    <div class="flex justify-between items-center"><span class="text-gray-500">BTC Dominance</span><span id="btc-dominance" class="font-mono">-</span></div>
                                    <div class="flex justify-between items-center pt-2 mt-2 border-t border-dashed border-gray-600/50"><span class="text-gray-500">Market Cap</span><span id="market-cap" class="font-mono">-</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="scalping-setup-section" class="card p-6">
                    <button id="toggle-scalping-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">Scalping <span id="scalping-timeframe-display"></span></h2>
                        <svg id="toggle-scalping-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>
                    <div id="scalping-content-wrapper" class="collapsible-content expanded">
                        <div>
                            <div id="hybrid-breakdown-module" class="mb-4">
                                <div class="flex items-center justify-between text-xs text-gray-400"><span>Bullish Momentum</span><span>Bearish Pressure Score</span></div>
                                <div class="confluence-bar-container w-full h-8 mt-1"><div id="main-pump-bar" class="confluence-bar confluence-bar-bullish" style="width: 0%;"></div><div id="main-dump-bar" class="confluence-bar confluence-bar-bearish" style="width: 0%;"></div></div>
                                <div class="flex items-center justify-between text-sm mt-1"><span id="main-pump-score" class="positive font-bold">0%</span><span id="main-dump-score" class="negative font-bold">0/10</span></div>
                                <p class="text-center text-[10px] text-gray-500 mt-1 blinking-text-animation">⚠ PLEASE CHECK YOU ARE IN THE RIGHT TIMEFRAME ⚠️</p>
                                <details class="mt-3"><summary class="cursor-pointer text-xs text-gray-400 hover:text-white transition-colors flex justify-between items-center"><span>Bearish Pressure Score Trigger▾</span><select id="dump-trigger-timeframe-select" class="input-primary !text-xs !w-auto !p-1 bg-gray-900/50 border-gray-600" onclick="event.stopPropagation()"><option value="1m">1m</option><option value="3m">3m</option><option value="5m" selected="">5m</option><option value="15m">15m</option><option value="30m">30m</option><option value="1h">1h</option></select></summary><div id="trigger-breakdown-list" class="mt-2 pt-2 border-t border-gray-700/50 text-sm space-y-1"><p class="text-xs text-center text-gray-600">Pilih timeframe...</p></div></details>
                            </div>
                            <div class="pt-2 mt-2 border-t border-dashed border-gray-700/50"><div id="scalping-resistance-info" class="flex justify-between items-center text-sm"><span class="text-gray-500">Nearest Resistance</span><span class="font-mono font-semibold text-red-400">-</span></div><div id="scalping-wall-container" class="text-center text-xs pt-2 space-y-1"><div id="buy-wall-display" class="text-green-500 font-semibold">— No Buy Wall Detected —</div><div id="sell-wall-display" class="text-red-500 font-semibold">— No Sell Wall Detected —</div></div></div>
                            <div id="tf-alignment-summary" class="pt-2 mt-2 border-t border-dashed border-gray-600/50"></div>
                            <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50"><div class="flex justify-between items-center text-sm"><span class="text-gray-500">EMA 21/50</span><span id="ma-status" class="font-mono font-semibold">-</span></div><div class="text-right text-xs text-gray-400 font-mono"><span id="ema-21-value">-</span> / <span id="ema-50-value">-</span></div></div>
                            <div class="pt-2 mt-2 border-t border-dashed border-gray-600/50 text-sm"><details><summary class="cursor-pointer text-center text-gray-500 text-xs mb-2 list-none">👇🏻 Click for More 👇🏻</summary><div class="mt-2"><div class="space-y-1"><div class="flex justify-between items-center"><span class="text-gray-500">Parabolic SAR</span><span id="psar-status" class="font-mono text-sm">-</span></div><div class="flex justify-between items-center"><span class="text-gray-500" data-tooltip="Rate of Change (ROC)|...">Rate of Change (ROC)</span><span id="roc-status" class="font-mono text-sm">-</span></div><div class="flex justify-between items-center"><span class="text-gray-500 text-sm" data-tooltip="Kekuatan Tren (ADX)|...">ADX 14</span><div><span id="adx-value" class="font-mono font-semibold text-sm">-</span><span class="text-xs positive" id="plus-di-value"></span> /<span class="text-xs negative" id="minus-di-value"></span></div></div></div><div class="mt-2 pt-2 border-t border-dashed border-gray-700/20 space-y-1"><div class="flex justify-between items-start"><div><span class="text-gray-500 text-sm">A T R</span><span id="atr-status-badge" class="tag tag-gray ml-2">...</span></div><div class="text-right"><p id="atr-percent-value" class="font-mono text-blue-500 font-semibold">-</p><p id="atr-absolute-value" class="font-mono text-xs text-gray-400">-</p></div></div><div id="ls-umum-container" class="flex justify-between items-center"><span class="text-gray-500">L/S Ratio</span><span id="ls-ratio-umum" class="font-mono">-</span></div><div id="ls-top-container" class="flex justify-between items-center"><span class="text-gray-500">L/S Ratio (Top)</span><span id="ls-ratio-top" class="font-mono">-</span></div><div id="futures-data-container" class="hidden space-y-1"><div class="flex justify-between items-center"><span class="text-gray-500">Funding Interval</span><span id="funding-rate-interval" class="font-mono">-</span></div><div class="flex justify-between items-center"><span class="text-yellow-500">Funding Rate</span><span id="funding-rate" class="font-mono text-yellow-500">-</span></div><div class="flex justify-between items-center"><span class="text-gray-500">Open Interest</span><span id="open-interest">-</span></div></div></div></div></details></div>
                            <div id="scalping-setup-content" class="text-center mt-4 pt-4 border-t border-gray-200 dark:border-gray-700"><p class="text-sm text-gray-500">FETCHING DATA...</p></div>
                        </div>
                    </div>
                </section>
            
                <section id="onchain-card" class="card p-6">
                    <button id="toggle-onchain-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">On-Chain</h2>
                        <svg id="toggle-onchain-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>
                    <div id="onchain-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <div id="specific-token-analysis" class="mb-4"><h3 id="specific-token-title" class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Analisis Token Spesifik</h3><div id="specific-token-content" class="text-sm space-y-1"><p class="text-xs text-gray-500 text-center">SEARCHING...</p></div></div>
                            <div><h3 class="font-semibold text-gray-400 border-b border-dashed border-gray-200 dark:border-gray-700 pb-2 mb-2">Pool Trending Teratas</h3><div id="trending-pools-content" class="text-sm space-y-2"><div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div></div></div>
                        </div>
                    </div>
                </section>
            
                <section id="sentiment-display-container" class="card p-6">
                    <button id="toggle-sentiment-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">BTC Sentiment (via AI)</h2>
                        <svg id="toggle-sentiment-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>
                    <div id="sentiment-content-wrapper" class="collapsible-content">
                        <p class="text-center text-gray-500">Ask AI first....</p>
                    </div>
                </section>
            
                <section id="ai-analysis-section" class="card p-6 relative">
                    <div class="flex justify-between items-center mb-4"><h2 class="text-xl font-bold">AI ANALYZER</h2></div>
                    <div id="ai-verdict-content-wrapper" class="collapsible-content expanded">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                            <button id="run-comprehensive-ai-btn" class="btn-primary w-full mb-4"><span>ASK AI</span><div class="loader w-5 h-5 hidden"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div></button>
                            <div id="ai-content-container" class="hidden space-y-6">
                                <div id="ai-narrative-content" class="prose prose-sm dark:prose-invert max-w-none text-gray-600 space-y-4"></div>
                                <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">🔮 Proyeksi Harga</h3><div id="projection-results-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div></div>
                                <div><h3 class="text-lg font-bold mt-4 mb-2 text-gray-800 dark:text-gray-200">♟️ Saran Strategis</h3><div class="grid grid-cols-1 md:grid-cols-2 gap-4"><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-green-500 mb-2">Untuk Calon Buyer</h4><p id="saran-buyer" class="text-lg font-bold"></p><p id="alasan-buyer" class="text-sm text-gray-500 mt-1"></p></div><div class="bg-gray-100 dark:bg-gray-800/50 p-4 rounded-lg"><h4 class="font-semibold text-blue-500 mb-2">Untuk Holder</h4><p id="saran-holder" class="text-lg font-bold"></p><p id="alasan-holder" class="text-sm text-gray-500 mt-1"></p></div></div></div>
                            </div>
                        </div>
                    </div>
                    <div class="absolute bottom-2 right-2"><button id="toggle-ai-verdict-btn" class="p-1 rounded-full text-gray-400 hover:bg-gray-700 focus:outline-none"><svg id="toggle-ai-verdict-icon" class="w-5 h-5 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button></div>
                </section>
                <section id="trailing-stop-calc-section" class="card p-6">
                    <button id="toggle-ts-calc-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">Kalkulator Eksekusi</h2>
                        <svg id="toggle-ts-calc-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>
                    
                    <div id="ts-calc-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 calc-binance-style">
                            
                            <button id="autofill-ts-btn" class="btn-primary w-full mb-4">
                                ⚡️ Auto-fill dari Setup Scalping
                            </button>

                            <div class="btn-group">
                                <button id="ts-mode-cross" class="active">Cross</button>
                                <input type="number" id="ts-leverage" value="20" class="input-field text-center" style="padding-right: 2.5rem;">
                                <button id="ts-mode-isolated" class="">Isolated</button>
                                <button id="ts-trailing-stop-options">⚙️ TS</button>
                            </div>

                            <div class="grid grid-cols-2 gap-4">
                                <div class="input-group">
                                    <label for="ts-wallet-balance" class="input-label-top">Available Balance ($)</label>
                                    <input type="number" id="ts-wallet-balance" class="input-field" value="1000">
                                </div>
                                <div class="input-group">
                                    <label for="ts-cost" class="input-label-top">Cost / Modal ($)</label>
                                    <input type="number" id="ts-cost" class="input-field" placeholder="0.00">
                                </div>
                            </div>

                            <div>
                                <input type="range" min="0" max="100" value="0" class="margin-slider" id="ts-margin-slider">
                                <div class="slider-ticks">
                                    <span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>
                                </div>
                            </div>

                            <div class="input-group mt-6">
                                <label for="ts-market-price" class="input-label-top">Harga Pasar Saat Ini ($)</label>
                                <input type="number" id="ts-market-price" class="input-field" placeholder="Harga market saat ini...">
                            </div>

                            <div class="tpsl-section">
                                <div class="flex items-center gap-2">
                                    <input type="checkbox" id="ts-tpsl-toggle" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 text-yellow-500">
                                    <label for="ts-tpsl-toggle" class="text-sm">TP/SL</label>
                                </div>
                                <div id="ts-tpsl-inputs" class="hidden mt-4 space-y-4">
                                    <div class="input-group">
                                        <label for="ts-take-profit" class="input-label-top">Take Profit</label>
                                        <input type="number" id="ts-take-profit" class="input-field" placeholder="Mark">
                                    </div>
                                    <div class="input-group">
                                        <label for="ts-stop-loss" class="input-label-top">Stop Loss</label>
                                        <input type="number" id="ts-stop-loss" class="input-field" placeholder="Mark">
                                    </div>
                                </div>
                            </div>

                            <div class="exec-buttons">
                                <button class="btn-buy" id="ts-buy-long-btn">Buy/Long</button>
                                <button class="btn-sell" id="ts-sell-short-btn">Sell/Short</button>
                            </div>

                            <div class="calc-result-grid">
                                <span>Cost</span><span id="ts-result-cost">--</span>
                                <span>Max</span><span id="ts-result-max">--</span>
                                <span>Position Size</span><span id="ts-result-position-size">--</span>
                                <span>Liq. Price</span><span id="ts-result-liq-price">--</span>
                                <span class="pt-2 border-t border-dashed border-gray-700">Status TS</span><span id="ts-result-status" class="pt-2 border-t border-dashed border-gray-700">--</span>
                                <span>Harga Stop Loss TS</span><span id="ts-result-sl-price">--</span>
                                <span>Potensi ROE</span><span id="ts-result-roe">--</span>
                            </div>
                        </div>
                    </div>

                    <div id="ts-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
                        <div id="ts-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-lg font-bold">Pengaturan Trailing Stop</h3>
                                <button id="ts-modal-close-btn" class="text-gray-400 hover:text-white">&times;</button>
                            </div>
                            <div class="space-y-4">
                                <div class="form-group">
                                    <label for="ts-modal-callback-rate">Callback Rate (%)</label>
                                    <input type="number" id="ts-modal-callback-rate" class="input-field" placeholder="cth: 0.5">
                                </div>
                                <div class="form-group">
                                    <label for="ts-modal-activation-price">Harga Aktivasi ($)</label>
                                    <input type="number" id="ts-modal-activation-price" class="input-field" placeholder="cth: 65000">
                                </div>
                            </div>
                            <div class="mt-6 text-right">
                                <button id="ts-modal-save-btn" class="btn-primary">Simpan Pengaturan</button>
                            </div>
                        </div>
                    </div>
                </section>
                <section id="paper-trading-section" class="card p-6">
                    <button id="toggle-paper-trading-btn" class="w-full flex justify-between items-center text-left mb-4">
                        <h2 class="text-xl font-bold">Trading Simulation</h2>
                        <svg id="toggle-paper-trading-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                    </button>

                    <div id="paper-trading-content-wrapper" class="collapsible-content">
                        <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                                <div>
                                    <p class="text-xs text-gray-500">Equity</p>
                                    <p id="sim-equity" class="font-mono font-bold text-lg text-blue-400">$1,000.00</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Unrealized PNL</p>
                                    <p id="sim-unrealized-pnl" class="font-mono font-bold text-lg text-gray-400">$0.00</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Available Margin</p>
                                    <p id="sim-available-margin" class="font-mono font-bold text-lg text-gray-400">$1,000.00</p>
                                </div>
                                <div class="flex items-center justify-center">
                                    <button id="sim-reset-account-btn" class="btn-secondary !text-xs !py-1 !px-2">Reset Account</button>
                                </div>
                            </div>

                            <div id="sim-active-position-container" class="hidden">
                                <h3 class="font-semibold text-yellow-400 mb-2">Active Position</h3>
                                <div class="p-3 rounded-md bg-gray-800/50 text-sm space-y-2">
                                    <div class="flex justify-between items-center">
                                        <span id="sim-position-header" class="font-bold text-lg">LONG / 20x</span>
                                        <button id="sim-close-position-btn" class="btn-primary !bg-red-600 !text-xs !py-1 !px-3">Close Position</button>
                                    </div>
                                    <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                        <div><span class="text-gray-400">Size:</span> <span id="sim-position-size" class="font-mono"></span></div>
                                        <div><span class="text-gray-400">Entry:</span> <span id="sim-position-entry" class="font-mono"></span></div>
                                        <div><span class="text-gray-400">Mark:</span> <span id="sim-position-mark" class="font-mono"></span></div>
                                        <div><span class="text-gray-400">Liq:</span> <span id="sim-position-liq" class="font-mono"></span></div>
                                    </div>
                                    <div class="pt-2 border-t border-dashed border-gray-700">
                                        <span class="text-gray-400">PNL (ROE %):</span>
                                        <span id="sim-position-pnl" class="font-mono font-bold text-lg ml-2"></span>
                                    </div>
                                </div>
                            </div>

                            <div>
                                <h3 class="font-semibold text-gray-400 mb-2">Trade History</h3>
                                <div id="sim-trade-history-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                                    <p class="text-center text-gray-600">No trade history yet.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                </div>
            </div>
        </div>
    </main>
<script>
// =====================================================================================================================================================================
// BAGIAN 1: DEKLARASI SEMUA ELEMEN DOM
// =====================================================================================================================================================================
    const gainersList = document.getElementById('gainers-list');
    const losersList = document.getElementById('losers-list');
    const navWrapper = document.getElementById('sticky-nav-wrapper');
    const mainContent = document.getElementById('main-content-container');
    const toggleAiVerdictBtn = document.getElementById('toggle-ai-verdict-btn');
    const toggleAiVerdictIcon = document.getElementById('toggle-ai-verdict-icon');
    const aiVerdictContentWrapper = document.getElementById('ai-verdict-content-wrapper');
    const assetInput = document.getElementById('asset-input');
    const apiKeyInput = document.getElementById('gemini-api-key');
    const timeframeSelect = document.getElementById('timeframe-select');
    const marketTypeSelect = document.getElementById('market-type-select');
    const analyzeBtn = document.getElementById('analyze-asset-btn');
    const buttonText = document.getElementById('button-text');
    const buttonLoader = document.getElementById('button-loader');
    const assetError = document.getElementById('asset-error');
    const dashboardContent = document.getElementById('dashboard-content');
    const initialPlaceholder = document.getElementById('initial-placeholder');
    const loaderOverlay = document.getElementById('loader-overlay');
    const loaderText = document.getElementById('loader-text');
    const themeToggleBtn = document.getElementById('theme-toggle');
    const darkIcon = document.getElementById('theme-toggle-dark-icon');
    const lightIcon = document.getElementById('theme-toggle-light-icon');
    const projectionResultsContainer = document.getElementById('projection-results-container');
    const specificTokenTitle = document.getElementById('specific-token-title');
    const specificTokenContent = document.getElementById('specific-token-content');
    const trendingPoolsContent = document.getElementById('trending-pools-content');
    const fullOrderBookContainer = document.getElementById('full-order-book-container');
    const tradeLink = document.getElementById('trade-link');
    const navVolume24h = document.getElementById('nav-volume-24h');
    const navAth = document.getElementById('nav-ath');
    const navAtl = document.getElementById('nav-atl');
    const resetBtn = document.getElementById('reset-btn');


// =====================================================================================================================================================================
// BAGIAN 2: KONSTANTA KONFIGURASI
// =====================================================================================================================================================================
    const UI_UPDATE_INTERVAL = 500;
    const KLINE_CACHE_DURATION = 5 * 60 * 1000; // Cache berlaku 5 menit
    const CVD_DIP_DEBOUNCE_MS = 5000; // <-- TAMBAHKAN BARIS INI

// =====================================================================================================================================================================
// BAGIAN 3: DEKLARASI STATE & VARIABEL GLOBAL
// =====================================================================================================================================================================
    const realtimeCache = {
        main: {
            symbol: null,
            tickerData: {},
            klines: [],
            calculatedData: {},
            liveScores: { pumpStrength: 0, dumpRisk: 0 }
        },
        
        movers: {}
    };
    let userSettings = {
        active: {
            weights: {}, 
            indicatorParams: {} 
        },
        presets: {
            'default': {
                weights: { ma: 2, pivot: 2, vwap: 2, ichimoku: 3, rsi: 1.5, stoch: 1, macd: 2, candlePattern: 1.5, psar: 1, linreg: 1, roc: 1, bollingerBands: 1, rsiDivergence: 2.5, obvDivergence: 3.0, openInterest: 1, funding: 1, lsr: 1, orderBookBias: 1, bbSqueeze: 1 },
                
                indicatorParams: { 
                    rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9,
                    stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 
                }
            },
            
        }
    };
    const timeframeParameterMap = {
        // Kategori Scalping (Timeframe <= 15m) -> Stoch RSI lebih sensitif
        '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        // Kategori Day Trading (Timeframe > 15m dan <= 4h) -> Stoch RSI standar
        '30m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '2h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        // Kategori Swing Trading (Timeframe > 4h) -> Stoch RSI lebih stabil
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1w': { rsi_period: 25, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 25, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };

    let candleCountdownInterval = null;
    let newCandleJustStarted = false;
    let klineCache = {};
    let latestBids = [];
    let latestAsks = [];
    let liveAnalysisScores = {};
    let coinListCache = null;
    let exchangeInfoCache = { spot: null, futures: null }; 
    let cvdChartInstance = null;
    let liveCvdValue = 0;
    let liveCvdData = [];
    let liveCvdValueUsdt = 0;
    let periodicUpdateInterval = null;
    let latestCalculatedData = {};
    let lastUiUpdateTime = 0;
    let tradeQueue = [];
    let depthQueue = [];
    let klineQueue = [];
    let processingInterval = null;
    let fundingRateTimer = null;
    let orderBookDOMElements = null;
    let orderBookHistory = {
        avgVolumes: [], 
        maxSize: 50     
    };
    let topMoversInterval = null;
    let topMoversCountdown = null;
    let currentTimeframe = "1h";
    let currentInterval = 60000; // default 10 detik
    let remainingTime = currentInterval / 1000;
    let isTooltipActive = false;
    let lastCvdDipCalculationTime = 0;
    let lastCvdDipResult = { triggered: false, points: 0 }; 
    const CVD_AGGREGATION_INTERVAL_MS = 10000; // Agregasi data setiap 5 detik
    const CVD_HISTORY_LENGTH = 50; // Menyimpan histori 50 keranjang data (50 * 5 detik = 250 detik)

    // Objek untuk menangani agregasi data CVD secara real-time
    let cvdAggregator = {
        currentBucketTimestamp: 0,
        currentBucketDelta: 0,
        history: [], // Akan berisi [timestamp, totalDelta]
        lastTriggerResult: { triggered: false, points: 0 }
    };

// =====================================================================================================================================================================
// OBJEK WEBSOCKET MANAGER HARUS DIDEKLARASIKAN DI AWAL
// =====================================================================================================================================================================
    const WebSocketManager = {
        ws: null,
        mainSubscriptions: new Set(),
        moverSubscriptions: new Set(),
        messageHandlers: {},
        reconnectBaseDelay: 5000, 
        reconnectAttempts: 0,
        maxReconnectDelay: 60000,
        isConnecting: false,
        
        handleOpen() {
            this.isConnecting = false;
            this.reconnectAttempts = 0; 
        },

        handleMessage(event) {
            const message = JSON.parse(event.data);
            if (message.result !== undefined) return;

            if (message.stream && message.data) {
                const streamName = message.stream;
                const payload = message.data;
                const symbol = streamName.split('@')[0].toUpperCase();


                if (this.moverSubscriptions.has(symbol)) {
                    onNewMoverData(symbol, streamName, payload);
                }
                
                if (realtimeCache.main.symbol && realtimeCache.main.symbol === symbol) {
                    if (streamName.includes('@kline')) {
                        if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                    } else if (streamName.includes('@aggTrade')) {
                        if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                    } else if (streamName.includes('@depth')) {
                        if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                    } else if (streamName.includes('@bookTicker')) {
                        if (this.messageHandlers['bookTicker']) this.messageHandlers['bookTicker'](payload);
                    }
                }
            }
        },

        handleClose() {
            this.isConnecting = false;
            if (this.mainSubscriptions.size > 0 || this.moverSubscriptions.size > 0) {
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectBaseDelay * (2 ** this.reconnectAttempts), this.maxReconnectDelay);
                setTimeout(() => this.connect(), delay);
            }
        },

        handleError(error) {
            console.error("Kesalahan WebSocket:", error);
            this.isConnecting = false;
            if (this.ws) this.ws.close();
        },

        connect() {
            if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) return;
            this.isConnecting = true;
            
            const moverStreams = Array.from(this.moverSubscriptions).flatMap(s => [`${s.toLowerCase()}@kline_1h`, `${s.toLowerCase()}@aggTrade`, `${s.toLowerCase()}@depth20`]);
            const mainStreams = Array.from(this.mainSubscriptions);
            const allSubscriptions = new Set([...mainStreams, ...moverStreams]);
            
            const streamNames = Array.from(allSubscriptions).join('/');
            
            if (streamNames.length === 0) {
                this.isConnecting = false;
                return;
            }
            const url = `wss://fstream.binance.com/stream?streams=${streamNames}`;
            this.ws = new WebSocket(url);
            this.ws.onopen = this.handleOpen.bind(this);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);
        },
        
        subscribe(streams) { // Hanya untuk panel utama
            this.mainSubscriptions.clear();
            streams.forEach(stream => this.mainSubscriptions.add(stream));
            this.reconnect();
        },

        // NEW CODE (AFTER PATCH)
        resetSubscriptions() { // Sekarang mereset SEMUA langganan
            this.mainSubscriptions.clear();
            this.moverSubscriptions.clear(); 
            this.reconnect();
        },

        subscribeToMovers(symbols) {
            const newSubs = new Set(symbols);
            if (new Set([...newSubs]).size === this.moverSubscriptions.size && [...newSubs].every(s => this.moverSubscriptions.has(s))) {
                return; // NONE perubahan, tidak perlu reconnect
            }
            this.moverSubscriptions = newSubs;
            this.reconnect();
        },

        reconnect() {
            if (this.ws) {
                this.ws.onclose = null;
                this.ws.close();
            }
            this.connect();
        },

        registerHandler(streamName, handler) {
            this.messageHandlers[streamName] = handler;
        }
    };
// =====================================================================================================================================================================
// BAGIAN 4: DEFINISI FUNGSI-FUNGSI
// =====================================================================================================================================================================
    function setButtonState(button, isLoading, text = null) {
        const btnText = button.querySelector('span');
        const btnLoader = button.querySelector('.loader');
        
        button.disabled = isLoading;
        if (btnText) btnText.classList.toggle('hidden', isLoading);
        if (btnLoader) btnLoader.classList.toggle('hidden', !isLoading);
        
        if (text && btnText && !isLoading) {
            btnText.textContent = text;
        }
    }
// =====================================================================================================================================================================
    function getSignClass(value, positiveClass = 'positive', negativeClass = 'negative') {
        return value >= 0 ? positiveClass : negativeClass;
    } 
// =====================================================================================================================================================================       
    function startCandleCountdown() {
            // Hentikan timer lama jika ada yang berjalan
            if (candleCountdownInterval) clearInterval(candleCountdownInterval);

            const countdownContainer = document.getElementById('candle-countdown-container');
            const countdownBar = document.getElementById('candle-countdown-bar');
            const klines = realtimeCache.main.klines;

            // Pastikan kita punya data candle
            if (!klines || klines.length === 0) {
                countdownContainer.classList.add('hidden');
                return;
            }

            countdownContainer.classList.remove('hidden');

            const lastCandle = klines[klines.length - 1];
            const candleOpenTime = lastCandle[0];
            const candleCloseTime = lastCandle[6];
            const candleDuration = candleCloseTime - candleOpenTime;

            // Set interval untuk update bar setiap detik
            candleCountdownInterval = setInterval(() => {
                const now = Date.now();

                // Jika waktu saat ini sudah melewati waktu tutup candle
                if (now > candleCloseTime) {
                    countdownBar.style.width = '100%';
                    clearInterval(candleCountdownInterval);
                    return;
                }

                const elapsedTime = now - candleOpenTime;
                const percentage = (elapsedTime / candleDuration) * 100;

                countdownBar.style.width = `${Math.min(100, percentage)}%`;

            }, 1000); // Update setiap 1 detik
        }
// =====================================================================================================================================================================
    function adaptIndicatorParamsToTimeframe(timeframe) {
        const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];

        userSettings.active.indicatorParams = { ...userSettings.presets['default'].indicatorParams, ...params };

        document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
        document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
        document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
        document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
        document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;       
    }
// =====================================================================================================================================================================
    function applyPreset(presetName) {
            if (!userSettings.presets[presetName]) return;

            userSettings.active.weights = { ...userSettings.presets['default'].weights, ...userSettings.presets[presetName].weights };

            document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
            document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
            document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;
            
            if (realtimeCache.main.calculatedData) {
                updateQuickConfluenceWidget();
            }
        }
// =====================================================================================================================================================================
    function debounce(func, delay) {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    }
// =====================================================================================================================================================================
    function determineMarketRegime(klines, closes) {
        if (!klines || klines.length < 200) {
            return { regime: 'RANGING', reason: 'Data kurang' };
        }

        const adxData = calculateADX(klines, 14);
        const ema200 = calculateEMA(closes, 200).pop();
        const lastPrice = closes[closes.length - 1];
        
        const isTrending = parseFloat(adxData.adx) > 25;

        if (isTrending) {
            if (lastPrice > ema200) {
                return { regime: 'TRENDING_UP', reason: `ADX (${adxData.adx}) > 25 & Harga > EMA 200` };
            } else {
                return { regime: 'TRENDING_DOWN', reason: `ADX (${adxData.adx}) > 25 & Harga < EMA 200` };
            }
        } else {
            return { regime: 'RANGING', reason: `ADX (${adxData.adx}) < 25` };
        }
    }
// =====================================================================================================================================================================
   function displaySentimentDataInDashboard(data) {
        const container = document.getElementById('sentiment-display-container');

        const netflowClass = data.netflow < 0 ? 'positive' : 'negative';
        const netflowText = data.netflow < 0 ? `Outflow (Bullish)` : `Inflow (Bearish)`;

        const oiClass = data.oiChange > 0 ? 'positive' : 'negative';
        const oiText = data.oiChange > 0 ? `Naik` : `Turun`;

        const fundingClass = Math.abs(data.fundingRate) > 0.02 ? 'negative' : 'text-gray-400';
        const fundingText = Math.abs(data.fundingRate) > 0.02 ? `Ekstrem` : `Sehat`;

        const lsParts = data.lsRatio24h.split('/');
        const longRatio = parseFloat(lsParts[0]);
        const shortRatio = parseFloat(lsParts[1]);
        const lsClass = longRatio > shortRatio ? 'positive' : (shortRatio > longRatio ? 'negative' : 'text-gray-400');
        const lsText = longRatio > shortRatio ? `Dominan Long` : (shortRatio > longRatio ? `Dominan Short` : `Seimbang`);

        container.innerHTML = `
            <h3 class="text-lg font-bold mb-4 text-center">🌡️ Sentimen Pasar (via AI)</h3>
            <div class="space-y-2 text-sm">
                <div class="flex justify-between items-center"><span class="text-gray-400">Aliran Bursa (Netflow BTC)</span><span class="font-bold ${netflowClass}">${data.netflow.toFixed(2)} BTC (${netflowText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Perubahan Open Interest</span><span class="font-bold ${oiClass}">${data.oiChange.toFixed(2)}% (${oiText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rata-rata Funding Rate</span><span class="font-bold ${fundingClass}">${(data.fundingRate * 100).toFixed(4)}% (${fundingText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Rasio Long/Short (24j)</span><span class="font-bold ${lsClass}">${data.lsRatio24h} (${lsText})</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">Likuidasi (Long vs Short)</span><span class="font-bold text-gray-200">${data.liquidations}</span></div>
                <div class="flex justify-between items-center"><span class="text-gray-400">MVRV Z-Score</span><span class="font-bold text-yellow-400">${data.mvrv_z_score.toFixed(2)}</span></div>
                <p class="text-center text-xs text-gray-500 pt-2">Data diambil oleh AI pada: ${new Date().toLocaleTimeString('id-ID')}</p>
            </div>
        `;
    }
// =====================================================================================================================================================================
    function saveSettings() {
        userSettings.active.indicatorParams.rsi_period = parseInt(document.getElementById('setting-rsi-period').value);
        userSettings.active.indicatorParams.macd_fast = parseInt(document.getElementById('setting-macd-fast').value);
        userSettings.active.indicatorParams.macd_slow = parseInt(document.getElementById('setting-macd-slow').value);
        userSettings.active.indicatorParams.macd_signal = parseInt(document.getElementById('setting-macd-signal').value);
        
        userSettings.active.weights.rsiDivergence = parseFloat(document.getElementById('setting-weight-divergence').value);
        userSettings.active.weights.macd = parseFloat(document.getElementById('setting-weight-macd').value);
        userSettings.active.weights.obvDivergence = parseFloat(document.getElementById('setting-weight-obv-divergence').value);

        localStorage.setItem('ultimateAppSettings', JSON.stringify(userSettings.active)); 
        const msgEl = document.getElementById('settings-saved-msg');
        msgEl.classList.remove('hidden');
        setTimeout(() => msgEl.classList.add('hidden'), 2000);
    }

// =====================================================================================================================================================================
    function loadSettings() {
        const savedActiveSettings = localStorage.getItem('ultimateAppSettings');
        
        applyPreset('default'); 
        
        if (savedActiveSettings) {
            try {
                const parsed = JSON.parse(savedActiveSettings);
                if (parsed.weights) userSettings.active.weights = { ...userSettings.active.weights, ...parsed.weights };
                if (parsed.indicatorParams && Object.keys(parsed.indicatorParams).length > 0) {
                    userSettings.active.indicatorParams = { ...userSettings.active.indicatorParams, ...parsed.indicatorParams };
                }
            } catch (e) {
                console.error("Gagal parse pengaturan.", e);
            }
        }

        if (Object.keys(userSettings.active.indicatorParams).length === 0) {
            adaptIndicatorParamsToTimeframe(timeframeSelect.value);
        }

        document.getElementById('setting-rsi-period').value = userSettings.active.indicatorParams.rsi_period;
        document.getElementById('setting-macd-fast').value = userSettings.active.indicatorParams.macd_fast;
        document.getElementById('setting-macd-slow').value = userSettings.active.indicatorParams.macd_slow;
        document.getElementById('setting-macd-signal').value = userSettings.active.indicatorParams.macd_signal;
        document.getElementById('setting-stoch-rsi-period').value = userSettings.active.indicatorParams.stoch_rsi_period;
        document.getElementById('setting-stoch-stoch-period').value = userSettings.active.indicatorParams.stoch_stoch_period;
        document.getElementById('setting-stoch-k-smooth').value = userSettings.active.indicatorParams.stoch_k_smooth;
        document.getElementById('setting-stoch-d-smooth').value = userSettings.active.indicatorParams.stoch_d_smooth;
        document.getElementById('setting-weight-divergence').value = userSettings.active.weights.rsiDivergence;
        document.getElementById('setting-weight-macd').value = userSettings.active.weights.macd;
        document.getElementById('setting-weight-obv-divergence').value = userSettings.active.weights.obvDivergence;
    }

// =====================================================================================================================================================================
    function showError(message) {
        assetError.textContent = message;
        assetError.classList.remove('hidden');
    }
// =====================================================================================================================================================================
    function hideError() {
        assetError.classList.add('hidden');
    }
// =====================================================================================================================================================================
    function showLoader(show, text = '') {
        if (show) {
            loaderText.textContent = text;
            loaderOverlay.classList.remove('hidden');
            loaderOverlay.classList.add('flex');
        } else {
            loaderOverlay.classList.add('hidden');
            loaderOverlay.classList.remove('flex');
        }
        setButtonState(analyzeBtn, show);
    }
// =====================================================================================================================================================================
    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) {
            console.error('Elemen toggle tidak ditemukan untuk:', buttonId);
            return;
        }
        contentWrapper.classList.add('collapsible-content');
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };
        let isVisible = startVisible;
        applyState(isVisible);
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }
// =====================================================================================================================================================================
    function adjustContentPadding() {
        if (navWrapper && mainContent) {
            const navHeight = navWrapper.offsetHeight;
            mainContent.style.paddingTop = `${navHeight}px`;
        }
    }
// =====================================================================================================================================================================
    // GANTI SELURUH FUNGSI formatPrice ANDA DENGAN INI
const formatPrice = (price) => {
    // PERBAIKAN: Cek jika input bukan angka (termasuk string '--' atau 'N/A')
    if (typeof price !== 'number' || isNaN(price)) {
        return price; // Kembalikan input aslinya (misalnya, '--') tanpa error
    }

    // Sisa dari logika format harga tetap sama
    if (price >= 1) {
        return `$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    }
    const priceString = price.toString();
    const decimalPart = priceString.includes('.') ? priceString.split('.')[1] : '';
    if (decimalPart.length === 0) return `$${price.toFixed(2)}`;
    
    let nonZeroIndex = -1;
    for (let i = 0; i < decimalPart.length; i++) {
        if (decimalPart[i] !== '0') {
            nonZeroIndex = i;
            break;
        }
    }
    if (nonZeroIndex !== -1) {
        const significantDigits = 4;
        return `$${price.toFixed(nonZeroIndex + significantDigits)}`;
    }
    return `$${price.toFixed(8)}`;
};
// =====================================================================================================================================================================
    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 7;
        return 8;
    }
// ===================================================================================================================================================================================================================================================================================
    function getUltimateSignalScore(indicator, signalData) {
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const mapRange = (x, inMin, inMax, outMin, outMax) => {
            const t = (x - inMin) / (inMax - inMin);
            return outMin + clamp(t, 0, 1) * (outMax - outMin);
        };       
        const confidence = (typeof signalData?.confidence === 'number')
            ? clamp(signalData.confidence, 0, 1)
            : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const biasSigned = (typeof signalData?.biasSigned === 'number')
            ? Math.sign(signalData.biasSigned)
            : null;
        // Normalisasi indikator by name
        if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }

        // Divergence
        if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }

        // Open Interest
        if (indicator === 'openInterest') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('UP')) return +1 * confidence;
            if (text.includes('DOWN')) return -1 * confidence;
            return 0;
        }

        // Funding / fundingRate
        if (indicator === 'funding' || indicator === 'fundingRate') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 0; // ex: 0.0005 = 0.05%
            const s = Math.max(-1, Math.min(1, v / 0.0025));
            return s * confidence;
            }

        // Long/Short Ratio (lsr / lsRatio)
        if (indicator === 'lsr' || indicator === 'lsRatio') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 1;
            // map 0.7..1.3 ke -1..+1, clamp
            const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
            return s * confidence;
            }

        // Order Book Bias
        if (indicator === 'orderBookBias') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BID')) return +1 * confidence;
            if (text.includes('ASK')) return -1 * confidence;
            return 0;
        }

        // BB Squeeze
        if (indicator === 'bbSqueeze') {
            const st = (signalData?.status || '').toString().toUpperCase();
            if (st.includes('RELEASE')) return +1 * confidence; // siap bergerak
            if (st.includes('ON')) return 0; // kompresi
            if (st.includes('OFF')) return 0.3 * confidence; // keluar channel
            return 0;
        }

        // fallback
        return 0;
    }
// ===================================================================================================================================================================================================================================================================================
    async function updateQuickConfluenceWidget() {
        const data = realtimeCache.main.calculatedData;
            if (!data) return;

        const mtfAlignmentScore = realtimeCache.main.tfAlignmentSummary?.score || 0;
        const mtfMultiplier = 1 + (Math.abs(mtfAlignmentScore) / 4) * 0.25;

        let totalBullScore = 0;
        let totalBearScore = 0;
        let maxPossibleScore = 0;

        const marketType = marketTypeSelect.value;
        const marketRegime = realtimeCache.main.marketRegime?.regime || 'RANGING';
        const trendIndicators = ['ma', 'ichimoku', 'psar', 'adx'];
        const rangeIndicators = ['rsi', 'stoch', 'rsiDivergence', 'bollingerBands'];

        for (const indicator in userSettings.active.weights) {
            if (['funding', 'lsr', 'openInterest'].includes(indicator)) {
                if (marketType !== 'futures') {
                    continue;
                }
            }
            
            let weight = userSettings.active.weights[indicator] || 0;

            if (marketRegime.includes('TRENDING') && rangeIndicators.includes(indicator)) {
                weight *= 0.5;
            }
            if (marketRegime === 'RANGING' && trendIndicators.includes(indicator)) {
                weight *= 0.5;
            }
            
            if (data[indicator]) {
                const rawScore = getUltimateSignalScore(indicator, data[indicator]);
                let finalWeight = weight;

                if (rawScore > 0 && mtfAlignmentScore > 0) {
                    finalWeight *= mtfMultiplier;
                } else if (rawScore < 0 && mtfAlignmentScore < 0) {
                    finalWeight *= mtfMultiplier;
                } else if ((rawScore > 0 && mtfAlignmentScore < 0) || (rawScore < 0 && mtfAlignmentScore > 0)) {
                    finalWeight *= 0.75; 
                }

                const weightedScore = rawScore * finalWeight;
                
                if (weightedScore > 0) totalBullScore += weightedScore;
                if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
            }
            maxPossibleScore += Math.abs(weight);
        }

        const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
        const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;
        
        realtimeCache.main.quickConfluenceScore = { 
            score: bullPercentage - bearPercentage,
            bull: bullPercentage,
            bear: bearPercentage
        };
        
        const { text: verdict, class: verdictClass } = generateShortVerdict(bullPercentage, bearPercentage);
        const mtfScoreText = mtfAlignmentScore > 0 ? `+${mtfAlignmentScore}` : mtfAlignmentScore;
        const mtfHtml = `<div class="text-xs text-center text-gray-400 mt-2">Multi-Timeframe Trend Confirmation: <span class="font-bold ${mtfAlignmentScore > 0 ? 'positive' : (mtfAlignmentScore < 0 ? 'negative' : '')}">${mtfScoreText}</span></div>`;

        document.getElementById('quick-confluence-timeframe').textContent = timeframeSelect.value;
        document.getElementById('quick-finalBullishScore').textContent = `${bullPercentage.toFixed(0)}% 🐂`;
        document.getElementById('quick-finalBearishScore').textContent = `🐻 ${bearPercentage.toFixed(0)}%`;
        const totalStrength = bullPercentage + bearPercentage;
        const bullWidthPercentage = totalStrength > 0 ? (bullPercentage / totalStrength) * 100 : 50;
        document.getElementById('quick-confluenceBarBullish').style.width = `${bullWidthPercentage}%`;
        document.getElementById('quick-confluenceBarBearish').style.width = `${100 - bullWidthPercentage}%`;
        // --- AWAL BLOK PERUBAHAN ---

        // 1. Hitung Skor Tensi
        const tensionScore = Math.min(100, bullPercentage + bearPercentage);
        let tensionText = "Low";
        if (tensionScore > 50) tensionText = "Medium";
        if (tensionScore > 75) tensionText = "High";
        if (tensionScore > 90) tensionText = "Extreme";

        // 2. Tampilkan Verdict Utama
        const verdictEl = document.getElementById('quick-finalVerdict');
        verdictEl.innerHTML = `${verdict} <span class="text-sm font-mono ${verdictClass}">(${(bullPercentage - bearPercentage).toFixed(0)})</span> ${mtfHtml}`;
        verdictEl.className = `font-semibold`;

        // 3. Tampilkan Skor Tensi
        const tensionContainer = document.getElementById('tension-score-container');
        tensionContainer.innerHTML = `
            <span class="text-gray-400">Market Tension: <strong>${tensionText}</strong> (${tensionScore.toFixed(0)}/100)</span>
            <div class="tension-bar-bg">
                <div class="tension-bar-fill" style="width: ${tensionScore}%;"></div>
            </div>
        `;

        analyzeAndDisplayConfluenceContributors();
        
        
        const verdictSpan = verdictEl.querySelector(`.${verdictClass.split(' ')[0]}`);
        if (verdictSpan) {
            verdictSpan.className = verdictClass;
        } else {
            // Fallback jika struktur HTML berubah
            const textNode = verdictEl.childNodes[0];
            const newSpan = document.createElement('span');
            newSpan.className = verdictClass;
            newSpan.textContent = textNode.textContent;
            verdictEl.replaceChild(newSpan, textNode);
        }
        
        analyzeAndDisplayConfluenceContributors();
    }
// ===================================================================================================================================================================================================================================================================================
    function updateCvdTableLive() {
        const tableBody = document.getElementById('cvd-table-body');
        if (!tableBody || liveCvdData.length === 0) return;

        const lastDataPoint = liveCvdData[liveCvdData.length - 1];
        const newRow = tableBody.insertRow(0);       
        const date = new Date(lastDataPoint.x);
        const formattedTime = date.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        const prevUsdt = liveCvdData.length > 1 ? liveCvdData[liveCvdData.length - 2].y_usdt : 0;
        const colorClass = lastDataPoint.y_usdt > prevUsdt ? 'positive' : 'negative';

        newRow.innerHTML = `
            <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">${formattedTime}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">${lastDataPoint.y_coin.toFixed(4)}</td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${colorClass}">$${lastDataPoint.y_usdt.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
        `;

        while (tableBody.rows.length > 5) {
            tableBody.deleteRow(tableBody.rows.length - 1);
        }
    }
// ===================================================================================================================================================================================================================================================================================
    function updateRealTimeIndicators(klines) {
        if (!klines || klines.length < 50) return;

        realtimeCache.main.calculatedData = recalculateAllIndicators(
            klines,
            realtimeCache.main.tickerData,
            null, 
            marketTypeSelect.value,
            realtimeCache.main.cvdData,
            realtimeCache.main.orderBookData,
            realtimeCache.main.fundingRateData,
            realtimeCache.main.lsRatioUmumData,
            realtimeCache.main.openInterestData
        );

        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// ===================================================================================================================================================================================================================================================================================
    async function updatePeriodicData() {
        try {
            const binanceSymbol = realtimeCache.main.binanceSymbol;
            if (!binanceSymbol || marketTypeSelect.value !== 'futures') return;

            const [lsRatioUmumData, lsRatioTopData] = await Promise.all([
                 fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                 fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
            ]);

            realtimeCache.main.lsRatioUmumData = lsRatioUmumData;
            realtimeCache.main.lsRatioTopData = lsRatioTopData;

            if (lsRatioUmumData?.[0]) {
                document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            }
            if (lsRatioTopData?.[0]) {
                document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
            }

        } catch(error) {
            console.error("Gagal memperbarui data periodik:", error);
        }
    }
// ===================================================================================================================================================================================================================================================================================
    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
        const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Binance API error (${marketType}): ${errorData.msg || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from Binance ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari Binance ${marketType.toUpperCase()}.`);
        }
    }
// ===================================================================================================================================================================================================================================================================================
    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }
// ===================================================================================================================================================================================================================================================================================
    async function fetchCoinGeckoData(coinId) {
        if (!coinId) return null;
        const url = `https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false`;
        try {
            const response = await fetch(url);
            if (!response.ok) return null;
            return response.json();
        } catch (error) { return null; }
    }
// ===================================================================================================================================================================================================================================================================================
   
// ===================================================================================================================================================================================================================================================================================
    async function getCoinGeckoId(baseAssetSymbol) {
        if (!coinListCache) {
            const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
            if (!response.ok) throw new Error('Gagal unduh daftar koin CoinGecko.');
            coinListCache = await response.json();
        }
        const assetSymbolLower = baseAssetSymbol.toLowerCase();
        const priorityMap = {
            'btc': 'bitcoin', 'eth': 'ethereum', 'bnb': 'binancecoin', 'weth': 'wrapped-ether',
            'sol': 'solana', 'wbtc': 'wrapped-bitcoin', 'uni': 'uniswap', 'shib': 'shiba-inu',
            'pepe': 'pepe', 'cross': 'cross-2', 'ada': 'cardano', 'xrp': 'ripple', 'ava': 'avant-usd', 'ethw': 'ethereum-pow-iou',
            'avax': 'avalanche-2'
        };
        if (priorityMap[assetSymbolLower]) return priorityMap[assetSymbolLower];

        let match = coinListCache.find(coin => coin.symbol === assetSymbolLower);
        if (match) return match.id;

        try {
            const searchResult = await fetchGeckoTerminal(`search/pools?query=${baseAssetSymbol}`);
            if (searchResult.data && searchResult.data.length > 0) {
                const topResult = searchResult.data[0];
                if (topResult.relationships.base_token.data.id) {
                    const coinId = topResult.relationships.base_token.data.id.split('_')[1];
                    if (coinId) return coinId;
                }
            }
        } catch (e) { console.error("Pencarian cerdas gagal:", e); }

        throw new Error(`Simbol "${baseAssetSymbol}" tidak ditemukan di CoinGecko.`);
    }
// ===================================================================================================================================================================================================================================================================================
    async function initializeExchangeInfo(marketType) {
        if (exchangeInfoCache[marketType]) return;
        const url = marketType === 'spot' ? 'https://api.binance.com/api/v3/exchangeInfo' : 'https://fapi.binance.com/fapi/v1/exchangeInfo';
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
        const data = await response.json();
        exchangeInfoCache[marketType] = data.symbols;
        if (document.getElementById('market-type-select').value === marketType) {
            populateAssetDatalist(data.symbols, marketType);
        }
    }
// ===================================================================================================================================================================================================================================================================================
    function populateAssetDatalist(symbols, marketType) {
        const dataList = document.getElementById('asset-list');
        if (!dataList) return;
        dataList.innerHTML = '';
        const filterFn = s => s.quoteAsset === 'USDT' && s.status === 'TRADING' && (marketType === 'spot' || s.contractType === 'PERPETUAL');
        symbols.filter(filterFn).sort((a, b) => a.symbol.localeCompare(b.symbol)).forEach(s => {
            const option = document.createElement('option');
            option.value = s.symbol;
            dataList.appendChild(option);
        });
    }
// ===================================================================================================================================================================================================================================================================================
    async function validateBinanceSymbol(symbol, marketType) {
        if (!exchangeInfoCache[marketType]) {
            await initializeExchangeInfo(marketType);
        }
        
        const symbolData = exchangeInfoCache[marketType].find(s => s.symbol === symbol);
        if (!symbolData || symbolData.status !== 'TRADING') {
            throw new Error(`Simbol "${symbol}" tidak valid atau tidak aktif di Binance ${marketType}.`);
        }
    }
// ===================================================================================================================================================================================================================================================================================
    async function callGemini(parts, isJsonOutput = true) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) throw new Error("PASTE API Key!!!!!!!");
        const model = 'gemini-2.5-flash-preview-05-20';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
        const payload = { contents: [{ role: "user", parts }] };
        if (isJsonOutput) {
            payload.generationConfig = {
                "response_mime_type": "application/json",
                "max_output_tokens": 8192
            };
        }
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(`Google AI API error: ${errorBody?.error?.message || response.statusText}`);
        }
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) return result.candidates[0].content.parts[0].text;
        throw new Error("Respons dari AI tidak valid atau kosong.");
    }

// ===================================================================================================================================================================================================================================================================================
    // == BLOK FUNGSI KALKULASI INDIKATOR BARU (MULAI) ==
// ===================================================================================================================================================================================================================================================================================
    function calculatePivotPoints(prevDayKline) {
    // Pengecekan awal, jika tidak ada data sama sekali, langsung hentikan.
    if (!prevDayKline || prevDayKline.length < 5) return null;

    // Ambil nilai dan pastikan dikonversi menjadi angka.
    const high = parseFloat(prevDayKline[2]);
    const low = parseFloat(prevDayKline[3]);
    const close = parseFloat(prevDayKline[4]);

    // ---> INI BAGIAN PENTING <---
    // Pengecekan kedua, jika salah satu data gagal di-parse menjadi angka, hentikan.
    if (isNaN(high) || isNaN(low) || isNaN(close)) {
        console.error("Gagal menghitung Pivot: Salah satu data (H, L, C) bukan angka yang valid.", {high, low, close});
        return null;
    }

    // Jika semua data valid, lanjutkan perhitungan seperti biasa.
    const P = (high + low + close) / 3;
    const R1 = (2 * P) - low;
    const S1 = (2 * P) - high;
    const R2 = P + (high - low);
    const S2 = P - (high - low);
    const R3 = high + 2 * (P - low);
    const S3 = low - 2 * (high - P);

    return { P, R1, S1, R2, S2, R3, S3 };
}
// ===================================================================================================================================================================================================================================================================================
    function calculateKeltnerChannels(klines, period = 20, multiplier = 2, atrPeriod = 10) {
        if (!klines || klines.length < period) return { upper: [], middle: [], lower: [], width: [] };
        const closes = klines.map(k => parseFloat(k[4]));
        const emaMiddle = calculateEMA(closes, period);
        const atr = calculateATR(klines, atrPeriod).value; 

        const upper = emaMiddle.map(val => val !== undefined ? val + (atr * multiplier) : undefined);
        const lower = emaMiddle.map(val => val !== undefined ? val - (atr * multiplier) : undefined);
        const width = upper.map((u, i) => (u !== undefined && lower[i] !== undefined) ? u - lower[i] : undefined);
        
        return { upper, middle: emaMiddle, lower, width };
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateIchimokuCloud(klines, tenkanP = 9, kijunP = 26, senkouP = 52) {
        if (klines.length < senkouP) return null;
        
        const result = { tenkan: [], kijun: [], senkouA: [], senkouB: [], chikou: [], status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= tenkanP - 1 ? getHighLow(klines.slice(i - tenkanP + 1, i + 1)) : { high: 0, low: 0 };
            result.tenkan.push(i >= tenkanP - 1 ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= kijunP - 1 ? getHighLow(klines.slice(i - kijunP + 1, i + 1)) : { high: 0, low: 0 };
            result.kijun.push(i >= kijunP - 1 ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
            result.chikou.push(parseFloat(klines[i][4]));
        }
        for (let i = 0; i < klines.length; i++) {
            const senkouA_val = (result.tenkan[i] !== undefined && result.kijun[i] !== undefined) ? (result.tenkan[i] + result.kijun[i]) / 2 : undefined;
            result.senkouA.push(senkouA_val);
            const senkouB_HighLow = i >= senkouP - 1 ? getHighLow(klines.slice(i - senkouP + 1, i + 1)) : { high: 0, low: 0 };
            result.senkouB.push(i >= senkouP - 1 ? (senkouB_HighLow.high + senkouB_HighLow.low) / 2 : undefined);
        }

        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = result.tenkan[result.tenkan.length - 1];
        const lastKijun = result.kijun[result.kijun.length - 1];
        
        const currentSenkouA = result.senkouA[klines.length - 1 - kijunP];
        const currentSenkouB = result.senkouB[klines.length - 1 - kijunP];
        
        const pastPriceForChikou = parseFloat(klines[klines.length - 1 - kijunP][4]);

        const isBullish = lastPrice > currentSenkouA && lastPrice > currentSenkouB &&
                        lastTenkan > lastKijun &&
                        lastPrice > pastPriceForChikou;

        const isBearish = lastPrice < currentSenkouA && lastPrice < currentSenkouB &&
                        lastTenkan < lastKijun &&
                        lastPrice < pastPriceForChikou;

        if (isBullish) {
            result.status = "Bullish";
        } else if (isBearish) {
            result.status = "Bearish";
        }
        
        return result;
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A' };
        }

        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
            trs.push(tr);
        }

        const atrValues = [];
        let sum = 0;
        for (let i = 0; i < trs.length; i++) {
            sum += trs[i];
            if (i >= period - 1) {
                if (i > period - 1) {
                    sum = sum - trs[i - period];
                }
                atrValues.push(sum / period);
            } else {
                atrValues.push(undefined);
            }
        }
        
        const atr = atrValues[atrValues.length - 1] || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;

        let status;
        if (atrPercent > 5) {
            status = 'Very High';
        } else if (atrPercent > 2.5) {
            status = 'High';
        } else if (atrPercent < 1) {
            status = 'Low';
        } else {
            status = 'Normal';
        }
        return { value: atr, status: status }; 
    }
// ===================================================================================================================================================================================================================================================================================
    const calculateEMA = (data, period) => {
        if (!data || data.length < period) return [];
        const k = 2 / (period + 1);
        let emaArray = Array(period - 1).fill(undefined);
        let sum = 0;
        for (let i = 0; i < period; i++) sum += data[i];
        let currentEma = sum / period;
        emaArray.push(currentEma);
        for (let i = period; i < data.length; i++) {
            currentEma = (data[i] * k) + (currentEma * (1 - k));
            emaArray.push(currentEma);
        }
        return emaArray;
    };
// ===================================================================================================================================================================================================================================================================================
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) return [];
        let sma = Array(period - 1).fill(undefined);
        for (let i = period - 1; i < data.length; i++) {
            const slice = data.slice(i - period + 1, i + 1);
            sma.push(slice.reduce((a, b) => a + b, 0) / period);
        }
        return sma;
    };
// ===================================================================================================================================================================================================================================================================================
    const calculateRSI = (closes, period = userSettings.active.indicatorParams.rsi_period) => {
        if (!closes || closes.length <= period) return Array(closes?.length || 0).fill(undefined);
        let gains = [], losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        if (avgLoss === 0) return Array(closes.length).fill(100);
        let rsi = [100 - (100 / (1 + (avgGain / avgLoss)))];
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            if (avgLoss === 0) { rsi.push(100); } 
            else { rsi.push(100 - (100 / (1 + (avgGain / avgLoss)))); }
        }
        return Array(period).fill(undefined).concat(rsi);
    };
// =====================================================================================================================================================================
    const calculateMACD = (closes, fast = userSettings.active.indicatorParams.macd_fast, slow = userSettings.active.indicatorParams.macd_slow, signal = userSettings.active.indicatorParams.macd_signal) => {
        if (closes.length < slow + signal) {
            return { status: 'Netral', hist: 'Netral', class: 'text-gray-500', macdLine: [], signalLine: [], histogram: [] };
        }
// =====================================================================================================================================================================       
    const emaFast = calculateEMA(closes, fast);
    const emaSlow = calculateEMA(closes, slow);
        
// =====================================================================================================================================================================    
    const macdLine = emaSlow.map((slowVal, i) => {
        if (slowVal !== undefined && emaFast[i] !== undefined) {
            return emaFast[i] - slowVal;
        }
            return undefined;
        });

        const signalLine = calculateEMA(macdLine.filter(v => v !== undefined), signal);
        const histogram = macdLine.map((macdVal, i) => {
            const signalIndex = i - (slow - 1); 
            if (macdVal !== undefined && signalLine[signalIndex] !== undefined) {
                const histValue = macdVal - signalLine[signalIndex];
                const prevHistValue = (i > 0 && macdLine[i-1] !== undefined && signalLine[signalIndex-1] !== undefined) 
                                    ? (macdLine[i-1] - signalLine[signalIndex-1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        });

        const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
        const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
        const lastHist = histogram.filter(v => v !== undefined).pop()?.value || 0;
        const prevMacdLine = macdLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        const prevSignalLine = signalLine.filter(v => v !== undefined).slice(-2, -1)[0] || 0;
        
        let status = 'Netral', macdClass = 'text-gray-500';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) { 
            status = 'Bullish Cross'; 
            macdClass = 'positive'; 
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) { 
            status = 'Bearish Cross'; 
            macdClass = 'negative'; 
        }
        
        return { 
            status, 
            hist: lastHist > 0 ? '(Naik)' : '(Turun)', 
            class: macdClass, 
            macdLine, 
            signalLine, 
            histogram 
        };
    };
// =====================================================================================================================================================================
    const calculateStochasticRSI = (closes, 
        rsiPeriod = userSettings.active.indicatorParams.stoch_rsi_period, 
        stochPeriod = userSettings.active.indicatorParams.stoch_stoch_period, 
        kSmooth = userSettings.active.indicatorParams.stoch_k_smooth, 
        dSmooth = userSettings.active.indicatorParams.stoch_d_smooth
    ) => {
        const rsiValues = calculateRSI(closes, rsiPeriod).filter(v => v !== undefined);
        if (rsiValues.length < stochPeriod) {
            return { k: 50, d: 50, status: 'Netral', class: 'tag-gray', kLine: [], dLine: [], kOffset: 0, dOffset: 0 };
        }
        const stochArr = [];
        for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
            const window = rsiValues.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((rsiValues[i] - minR) / denom) * 100);
        }
        const kLine = calculateSMA(stochArr, kSmooth);
        const dLine = calculateSMA(kLine.filter(v => v !== undefined), dSmooth);
        const lastK = kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = dLine.filter(v => v !== undefined).pop() || 50;
        let status = 'Netral', stochClass = 'tag-yellow';
        if (lastK > 80 && lastD > 80) { status = 'Overbought'; stochClass = 'tag-red'; }
        else if (lastK < 20 && lastD < 20) { status = 'Oversold'; stochClass = 'tag-green'; }
        const kOffset = closes.length - kLine.length;
        const dOffset = closes.length - dLine.length;
        return {
            k: lastK.toFixed(2), d: lastD.toFixed(2), status, class: stochClass,
            kLine, dLine, kOffset, dOffset
        };
    };
// =====================================================================================================================================================================
    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) return { upper: [], middle: [], lower: [], width: [], status: 'N/A' };
        const middle = calculateSMA(closes, period);
        let upper = Array(period - 1).fill(undefined);
        let lower = Array(period - 1).fill(undefined);
        let width = Array(period - 1).fill(undefined);

        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                width.push(undefined);
                continue;
            };
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            upper.push(middle[i] + (stdev * stdDev));
            lower.push(middle[i] - (stdev * stdDev));
            width.push((middle[i] + (stdev * stdDev)) - (middle[i] - (stdev * stdDev))); 
        }

        const lastClose = closes[closes.length - 1];
        const lastUpper = upper.filter(v => v !== undefined).pop();
        const lastLower = lower.filter(v => v !== undefined).pop();
        const lastWidth = width.filter(v => v !== undefined).pop();

        let status = 'INSIDE';
        if (lastClose > lastUpper) status = 'Above';
        if (lastClose < lastLower) status = 'Below';

        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            const recentWidths = width.slice(-50);
            const minWidth = Math.min(...recentWidths);
            const avgWidth = recentWidths.reduce((a, b) => a + b, 0) / recentWidths.length;
            if (lastWidth < avgWidth * 0.7) { 
                squeezeStatus = 'Squeeze!';
            }
        }

        return { upper, middle, lower, width, status, squeezeStatus }; 
    };
// =====================================================================================================================================================================
    const calculateVPVR = (klines, numRows = 70, valueAreaPercent = 0.70) => {
        if (!klines || klines.length === 0) return { poc: 0, vah: 0, val: 0 };
        let overallLow = Infinity, overallHigh = -Infinity;
        const candles = klines.map(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]);
            if (high > overallHigh) overallHigh = high;
            if (low < overallLow) overallLow = low;
            return { high, low, volume: parseFloat(k[5]) };
        });
        const rowSize = (overallHigh - overallLow) / numRows;
        let profile = Array.from({ length: numRows }, (_, i) => ({ price: overallLow + (i * rowSize), volume: 0 }));
        let totalVolume = 0;
        candles.forEach(c => {
            totalVolume += c.volume;
            const startIdx = Math.max(0, Math.floor((c.low - overallLow) / rowSize));
            const endIdx = Math.min(numRows - 1, Math.floor((c.high - overallLow) / rowSize));
            const volPerRow = c.volume / (endIdx - startIdx + 1);
            for (let i = startIdx; i <= endIdx; i++) profile[i].volume += volPerRow;
        });
        if (totalVolume === 0) return { poc: 0, vah: 0, val: 0 };
        let pocIndex = profile.reduce((maxIdx, row, idx, arr) => row.volume > arr[maxIdx].volume ? idx : maxIdx, 0);
        const poc = profile[pocIndex].price + (rowSize / 2);
        const targetVolume = totalVolume * valueAreaPercent;
        let vaVolume = profile[pocIndex].volume;
        let upperIdx = pocIndex, lowerIdx = pocIndex;
        while (vaVolume < targetVolume) {
            const volAbove = (upperIdx + 1 < numRows) ? profile[upperIdx + 1].volume : -1;
            const volBelow = (lowerIdx - 1 >= 0) ? profile[lowerIdx - 1].volume : -1;
            if (volAbove === -1 && volBelow === -1) break;
            if (volAbove > volBelow) {
                upperIdx++;
                vaVolume += profile[upperIdx].volume;
            } else {
                lowerIdx--;
                vaVolume += profile[lowerIdx].volume;
            }
        }
        return { poc, vah: profile[upperIdx].price + rowSize, val: profile[lowerIdx].price };
    };
// =====================================================================================================================================================================
    function CVDanalyze(klines, cvdData) {
        if (!klines || klines.length < 2 || !cvdData || cvdData.length < 2) {
        return { trend: 'N/A', divergence: 'N/A', summary: 'Data tidak cukup untuk analisa CVD.' };
        }

        const firstPrice = parseFloat(klines[0][4]);
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const priceTrend = lastPrice > firstPrice ? 'Naik' : (lastPrice < firstPrice ? 'Turun' : 'Datar');

        const firstCvd = cvdData[0].cvd;
        const lastCvd = cvdData[cvdData.length - 1].cvd;
        const cvdTrend = lastCvd > firstCvd ? 'Naik' : (lastCvd < firstCvd ? 'Turun' : 'Datar');

        let divergence = 'NONE';
        let summary = `Tren harga dan CVD bergerak selaras (${priceTrend}).`;

            if (priceTrend === 'Naik' && cvdTrend === 'Turun') {
                divergence = 'Bearish 👎';
                summary = 'Harga naik tetapi tekanan beli melemah. Hati-hati, ini adalah sinyal divergensi bearish.';
            } else if (priceTrend === 'Turun' && cvdTrend === 'Naik') {
                divergence = 'Bullish 👍';
                summary = 'Harga turun tetapi tekanan beli menguat. Ini adalah sinyal divergensi bullish yang potensial.';
            }

            return {
                trend: cvdTrend,
                divergence: divergence,
                summary: summary
            };
    }
    // ==============================================
    const calculateCVD = (trades) => {
        let cumulativeDeltaCoin = 0;
        let cumulativeDeltaUsdt = 0;
        return trades.map(t => {
            const quantity = parseFloat(t.q);
            const price = parseFloat(t.p);
            const sign = t.m ? -1 : 1; 
            
            cumulativeDeltaCoin += quantity * sign;
            cumulativeDeltaUsdt += (quantity * price) * sign;

            return { 
                time: t.T / 1000, 
                cvd_coin: cumulativeDeltaCoin,
                cvd_usdt: cumulativeDeltaUsdt 
            };
        });
    };
// =====================================================================================================================================================================
    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { adx: 'N/A', plusDI: 'N/A', minusDI: 'N/A' };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
    // =============================================
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { adx: adxValues.filter(v=>v!==undefined).pop()?.toFixed(2) || 'N/A', plusDI: plusDIs.pop()?.toFixed(2) || 'N/A', minusDI: minusDIs.pop()?.toFixed(2) || 'N/A' };
    };
// =====================================================================================================================================================================
    const findCandlestickPatterns = (klines) => {        
        if (!klines || klines.length < 3) {            
            return { pattern: 'NONE', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: null };
        }
               
        const lastCandleTimestamp = klines[klines.length - 1][0];
        const getCandleDetails = (k) => {
            const [open, high, low, close] = k.slice(1, 5).map(parseFloat);
            return { open, high, low, close, body: Math.abs(close - open), isGreen: close > open, isRed: close < open };
        };

        const c1 = getCandleDetails(klines[klines.length - 1]); 
        const c2 = getCandleDetails(klines[klines.length - 2]);
        const c3 = getCandleDetails(klines[klines.length - 3]);

        
        let result = { pattern: 'NONE', class: 'text-gray-500', bias: 'NETRAL', svg: '', timestamp: lastCandleTimestamp };

        // Cek Pola 3-Candle
        if (c3.isGreen && c2.isGreen && c1.isGreen && c1.close > c2.close && c2.close > c3.close) {
            result = { pattern: 'THREE WHITE SOLDIERS', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('THREE_WHITE_SOLDIERS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.isRed && c1.isRed && c1.close < c2.close && c2.close < c3.close) {
            result = { pattern: 'THREE BLACK CROWS', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('THREE_BLACK_CROWS'), timestamp: lastCandleTimestamp };
        } else if (c3.isRed && c2.body < c3.body * 0.3 && c1.isGreen && c1.close > c3.open) {
            result = { pattern: 'MORNING STAR', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('MORNING_STAR'), timestamp: lastCandleTimestamp };
        } else if (c3.isGreen && c2.body < c3.body * 0.3 && c1.isRed && c1.close < c3.open) {
            result = { pattern: 'EVENING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('EVENING_STAR'), timestamp: lastCandleTimestamp };
        }

        // Jika belum ketemu, cek Pola 2-Candle
        if (result.pattern === 'NONE') {
            if (c2.isRed && c1.isGreen && c1.close > c2.open && c1.open < c2.close) {
                result = { pattern: 'BULLISH ENGULFING', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.close < c2.open && c1.open > c2.close) {
                result = { pattern: 'BEARISH ENGULFING', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_ENGULFING'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.close && c1.close < c2.open && c1.close > (c2.open + c2.body/2)) {
                result = { pattern: 'DARK CLOUD COVER', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('DARK_CLOUD_COVER'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.close && c1.close > c2.open && c1.close < (c2.open - c2.body/2)) {
                result = { pattern: 'PIERCING LINE', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('PIERCING_LINE'), timestamp: lastCandleTimestamp };
            } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close) {
                result = { pattern: 'BEARISH HARAMI', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('BEARISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close) {
                result = { pattern: 'BULLISH HARAMI', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('BULLISH_HARAMI'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.high - c2.high) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER TOP', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('TWEEZER_TOP'), timestamp: lastCandleTimestamp };
            } else if (Math.abs(c1.low - c2.low) < (c1.range * 0.05)) {
                result = { pattern: 'TWEEZER BOTTOM', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('TWEEZER_BOTTOM'), timestamp: lastCandleTimestamp };
            }
        }

        // Jika masih belum ketemu, cek Pola 1-Candle
        if (result.pattern === 'NONE') {
            const lowerWick = Math.min(c1.open, c1.close) - c1.low;
            const upperWick = c1.high - Math.max(c1.open, c1.close);
            if (lowerWick > c1.body * 2 && upperWick < c1.body * 0.5) {
                result = { pattern: 'HAMMER', class: 'positive', bias: 'BULLISH', svg: getPatternSVG('HAMMER'), timestamp: lastCandleTimestamp };
            } else if (upperWick > c1.body * 2 && lowerWick < c1.body * 0.5) {
                result = { pattern: 'SHOOTING STAR', class: 'negative', bias: 'BEARISH', svg: getPatternSVG('SHOOTING_STAR'), timestamp: lastCandleTimestamp };
            }
        }
        
        return result;
    };
// =====================================================================================================================================================================
    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE', class: 'text-gray-500' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPeaks = (data, isHigh) => {
            let peaks = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    peaks.push({ index: i, value: data[i] });
                }
            }
            return peaks;
        };
        const priceLows = findPeaks(recentCloses, false), priceHighs = findPeaks(recentCloses, true);
        const rsiLows = findPeaks(recentRSI, false), rsiHighs = findPeaks(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };
// =====================================================================================================================================================================
    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };
// ===================================================================================================================================================================================================================================================================================  
    function getPatternSVG(patternName) {
        const svgHeader = `<svg viewBox="0 0 110 60" class="w-24 h-auto mx-auto my-2">`;
        const svgFooter = `</svg>`;
        const green = '#26a69a', red = '#ef5350', gray = '#2A1E27';

        let content = '';

        const createCandle = (x, open, high, low, close, color) => {
            const bodyY = Math.min(open, close);
            const bodyHeight = Math.abs(open - close);
            return `
                <line x1="${x+10}" y1="${high}" x2="${x+10}" y2="${low}" stroke="${color}" stroke-width="1"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" fill="${color}"/>
            `;
        };
    // ======================================
        switch(patternName) {
            // --- POLA BULLISH ---
            case 'BULLISH_ENGULFING':
                content = createCandle(20, 40, 45, 25, 30, red) + createCandle(50, 28, 55, 10, 50, green);
                break;
            case 'HAMMER':
                content = createCandle(40, 50, 52, 10, 48, red);
                break;
            case 'MORNING_STAR':
                content = createCandle(10, 50, 55, 15, 20, red) + createCandle(40, 15, 20, 5, 12, gray) + createCandle(70, 18, 50, 15, 45, green);
                break;
            case 'THREE_WHITE_SOLDIERS':
                content = createCandle(10, 25, 35, 10, 30, green) + createCandle(40, 32, 45, 28, 40, green) + createCandle(70, 42, 55, 38, 50, green);
                break;
            case 'BULLISH_HARAMI':
                content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                break;
            case 'TWEEZER_BOTTOM':
                content = createCandle(20, 40, 45, 10, 20, red) + createCandle(50, 22, 48, 10, 35, green);
                break;
            // --- POLA BEARISH ---
            case 'BEARISH_ENGULFING':
                content = createCandle(20, 20, 45, 15, 40, green) + createCandle(50, 42, 55, 10, 15, red);
                break;
            case 'SHOOTING_STAR':
                content = createCandle(40, 12, 50, 10, 15, green);
                break;
            case 'EVENING_STAR':
                content = createCandle(10, 15, 50, 10, 45, green) + createCandle(40, 52, 58, 48, 50, gray) + createCandle(70, 48, 50, 15, 20, red);
                break;
            case 'THREE_BLACK_CROWS':
                content = createCandle(10, 50, 55, 30, 45, red) + createCandle(40, 42, 48, 20, 25, red) + createCandle(70, 22, 28, 5, 10, red);
                break;
            case 'BEARISH_HARAMI':
                content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                break;
            case 'TWEEZER_TOP':
                content = createCandle(20, 20, 55, 15, 40, green) + createCandle(50, 38, 55, 18, 25, red);
                break;
            default:
                return ''; 
        }

        return svgHeader + content + svgFooter;
    }
// =====================================================================================================================================================================
    function getTimeAgo(date) {
        if (!(date instanceof Date) || isNaN(date)) {
            return 'beberapa saat lalu'; 
        }
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 0) return 'baru saja'; 
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + " tahun lalu";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + " bulan lalu";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + " hari lalu";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + " jam lalu";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + " menit lalu";
        return Math.floor(seconds) + " detik lalu";
    }

// =====================================================================================================================================================================
    function getExplorerUrl(networkName) {
        const explorerMap = {
            'eth': 'https://etherscan.io', 
            'ethereum': 'https://etherscan.io',
            'solana': 'https://solscan.io',
            'bsc': 'https://bscscan.com',
            'arbitrum': 'https://arbiscan.io',
            'base': 'https://basescan.org'
        };
        const baseUrl = explorerMap[networkName] || `https://${networkName}.info`;
        // Kembalikan URL terpisah untuk dompet dan transaksi
        return {
            address: `${baseUrl}/address/`,
            tx: `${baseUrl}/tx/`
        };
    }
// =====================================================================================================================================================================
    function getHolderCategory(usdValue) {
        if (usdValue >= 500000) return { name: 'Humpback', class: 'text-purple-400' };
        if (usdValue >= 100000) return { name: 'Whale', class: 'text-blue-400' };
        if (usdValue >= 50000) return { name: 'Tuna', class: 'text-teal-400' };
        if (usdValue >= 10000) return { name: 'Dolphin', class: 'text-cyan-400' };
        if (usdValue >= 1000) return { name: 'Crab', class: 'text-yellow-400' };
        return { name: 'Shrimp', class: 'text-gray-400' };
    }
// =====================================================================================================================================================================
     function findPivots(klines, lookback = 10) {
        const pivots = [];
        if (klines.length < lookback * 2 + 1) return [];

        for (let i = lookback; i < klines.length - lookback; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            let isHigh = true, isLow = true;

            for (let j = 1; j <= lookback; j++) {
                if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
            }
            if (isHigh) pivots.push({ type: 'high', price: high, index: i });
            else if (isLow) pivots.push({ type: 'low', price: low, index: i });
        }
        return pivots;
    }
// =====================================================================================================================================================================
    function calculateSlope(p1, p2) {
        if (p2.index === p1.index) return Infinity;
        return (p2.price - p1.price) / (p2.index - p1.index);
    }
    
// =====================================================================================================================================================================
    function detectHeadAndShoulders(pivots) {
        for (let i = 4; i < pivots.length; i++) {
            const p1 = pivots[i-4], p2 = pivots[i-3], p3 = pivots[i-2], p4 = pivots[i-1], p5 = pivots[i];
            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high' && p4.type === 'low' && p5.type === 'high') {
                if (p3.price > p1.price && p3.price > p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'HEAD & SHOULDERS', class: 'negative blinking-text-animation' };
                }
            }
           
            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low' && p4.type === 'high' && p5.type === 'low') {
                 if (p3.price < p1.price && p3.price < p5.price && Math.abs(p1.price - p5.price) / p5.price < 0.15) {
                    return { pattern: 'INVERSE H&S', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

// =====================================================================================================================================================================
    function detectDoubles(pivots) {
        for (let i = 2; i < pivots.length; i++) {
            // Cek Double Top: H, L, H
            const p1_dt = pivots[i-2], p2_dt = pivots[i-1], p3_dt = pivots[i];
            if (p1_dt.type === 'high' && p2_dt.type === 'low' && p3_dt.type === 'high') {
                if (Math.abs(p1_dt.price - p3_dt.price) / p3_dt.price < 0.03 && p2_dt.price < p1_dt.price) {
                    return { pattern: 'DOUBLE TOP', class: 'negative blinking-text-animation' };
                }
            }
            // Cek Double Bottom: L, H, L
            const p1_db = pivots[i-2], p2_db = pivots[i-1], p3_db = pivots[i];
            if (p1_db.type === 'low' && p2_db.type === 'high' && p3_db.type === 'low') {
                if (Math.abs(p1_db.price - p3_db.price) / p3_db.price < 0.03 && p2_db.price > p1_db.price) {
                    return { pattern: 'DOUBLE BOTTOM', class: 'positive blinking-text-animation' };
                }
            }
        }
        return null;
    }

// =====================================================================================================================================================================
    function detectTriangles(pivots) {
        const recentPivots = pivots.slice(-7); // Fokus pada 7 pivot terakhir
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lastLow = lows[lows.length - 1], prevLow = lows[lows.length - 2];
            const lastHigh = highs[highs.length - 1], prevHigh = highs[highs.length - 2];

            const isLowsAscending = lastLow.price > prevLow.price;
            const isHighsFlat = Math.abs(lastHigh.price - prevHigh.price) / prevHigh.price < 0.015; // Toleransi 1.5%
            if (isLowsAscending && isHighsFlat) return { pattern: 'ASCENDING TRIANGLE', class: 'positive' };

            const isHighsDescending = lastHigh.price < prevHigh.price;
            const isLowsFlat = Math.abs(lastLow.price - prevLow.price) / prevLow.price < 0.015; // Toleransi 1.5%
            if (isHighsDescending && isLowsFlat) return { pattern: 'DESCENDING TRIANGLE', class: 'negative' };

            if (isLowsAscending && isHighsDescending) return { pattern: 'SYMMETRICAL TRIANGLE', class: 'text-yellow-400' };
        }
        return null;
    }
// =====================================================================================================================================================================
    function detectWedges(pivots) {
        const recentPivots = pivots.slice(-7);
        const highs = recentPivots.filter(p => p.type === 'high');
        const lows = recentPivots.filter(p => p.type === 'low');

        if (lows.length >= 2 && highs.length >= 2) {
            const lowSlope = calculateSlope(lows[lows.length - 2], lows[lows.length - 1]);
            const highSlope = calculateSlope(highs[highs.length - 2], highs[highs.length - 1]);

            
            if (lowSlope > 0 && highSlope > 0 && lowSlope > highSlope) {
                 return { pattern: 'RISING WEDGE', class: 'negative blinking-text-animation' };
            }
            
            if (lowSlope < 0 && highSlope < 0 && Math.abs(highSlope) > Math.abs(lowSlope)) {
                return { pattern: 'FALLING WEDGE', class: 'positive blinking-text-animation' };
            }
        }
        return null;
    }

// =====================================================================================================================================================================
    function detectFlags(klines) {
        const lookback = 30; 
        const flagLength = 10;
        if (klines.length < lookback + flagLength) return null;
        
        const closes = klines.map(k => parseFloat(k[4]));
        const poleStartPrice = closes[closes.length - flagLength - lookback];
        const poleEndPrice = closes[closes.length - flagLength];
        const priceChange = (poleEndPrice - poleStartPrice) / poleStartPrice;
        
        
        if (priceChange > 0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);
            
            if (flagLow > poleStartPrice + (poleEndPrice - poleStartPrice) * 0.5) {
                return { pattern: 'BULL FLAG', class: 'positive' };
            }
        }
        
        if (priceChange < -0.05) {
            const flagCloses = closes.slice(-flagLength);
            const flagHigh = Math.max(...flagCloses);
            const flagLow = Math.min(...flagCloses);

            if (flagHigh < poleStartPrice - (poleStartPrice - poleEndPrice) * 0.5) {
                return { pattern: 'BEAR FLAG', class: 'negative' };
            }
        }
        return null;
    }
// =====================================================================================================================================================================
    function findChartPatterns(klines) {
        if (!klines || klines.length < 50) {
            return { pattern: 'Data Kurang', class: 'text-gray-500' };
        }
        
        const pivots = findPivots(klines, 10);
        let pattern;
            
        pattern = detectHeadAndShoulders(pivots);
        if (pattern) return pattern;

        pattern = detectDoubles(pivots);
        if (pattern) return pattern;
        
        pattern = detectWedges(pivots);
        if (pattern) return pattern;

        pattern = detectTriangles(pivots);
        if (pattern) return pattern;

        pattern = detectFlags(klines);
        if (pattern) return pattern;

        return { pattern: 'Tidak Terdeteksi', class: 'text-gray-500' };
    }
// =====================================================================================================================================================================
// == BLOK FUNGSI BARU UNTUK DETEKSI POLA CHART (SELESAI) ==
// =====================================================================================================================================================================
    function findLastSignificantSwing(klines) {
        const pivots = findPivots(klines.slice(-300), 5); 
        if (pivots.length < 3) return null;

        const lastPivot = pivots[pivots.length - 1];
        const prevPivot = pivots[pivots.length - 2];
        const prevPrevPivot = pivots[pivots.length - 3];

        // Swing untuk potensi LONG (kita mencari titik A, B, C: Low -> High -> Low)
        if (lastPivot.type === 'low' && prevPivot.type === 'high' && prevPrevPivot.type === 'low') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'UP' };
        }
        // Swing untuk potensi SHORT (kita mencari titik A, B, C: High -> Low -> High)
        if (lastPivot.type === 'high' && prevPivot.type === 'low' && prevPrevPivot.type === 'high') {
            return { A: prevPrevPivot, B: prevPivot, C: lastPivot, type: 'DOWN' };
        }
        return null;
    }

// =====================================================================================================================================================================
    function calculateFibonacciExtension(swing) {
        if (!swing) return null;
        const impulseMove = Math.abs(swing.B.price - swing.A.price);
        if (swing.type === 'UP') {
            return swing.C.price + (impulseMove * 1.618);
        } else { 
            return swing.C.price - (impulseMove * 1.618);
        }
    } 
// ===================================================================================================================================================================================================================================================================================
    function calculateATRPercentage(klines, period = 14) {
        if (!klines || klines.length === 0) {
            return 0; 
        }
        
        const atrResult = calculateATR(klines, period);
        const atrValue = atrResult.value;
        const lastClose = parseFloat(klines[klines.length - 1][4]);

        if (lastClose === 0) {
            return 0; 
        }
        const atrPercent = (atrValue / lastClose) * 100;
        
        return atrPercent;
    }
// ===================================================================================================================================================================================================================================================================================
    async function fetchGeckoTerminal(endpoint) {
        const baseUrl = 'https://api.geckoterminal.com/api/v2';
        const url = `${baseUrl}/${endpoint}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GeckoTerminal API error: ${errorData.errors?.[0]?.title || response.statusText}`);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from GeckoTerminal ${endpoint}: ${error.message}`);
            throw new Error(`Gagal mengambil data dari GeckoTerminal.`);
        }
    }
// ===================================================================================================================================================================================================================================================================================
    function renderTrendingPools(poolsData) {
        let html = '';
        const topPools = poolsData.slice(0, 5); 

        topPools.forEach(pool => {
            const attributes = pool.attributes;
            const priceChange = parseFloat(attributes.price_change_percentage.h24);
            const colorClass = priceChange >= 0 ? 'positive' : 'negative';
            const volume = parseFloat(attributes.volume_usd.h24);

            html += `
                <div class="p-2 rounded-md bg-gray-100 dark:bg-gray-800/50">
                    <div class="flex justify-between items-center font-semibold">
                        <span>${attributes.name}</span>
                        <span class="${colorClass}">${priceChange.toFixed(2)}%</span>
                    </div>
                    <div class="text-xs text-gray-400 flex justify-between mt-1">
                        <span>Vol 24j: $${(volume / 1_000_000).toFixed(2)}jt</span>
                        <span>Jaringan: ${pool.relationships.network.data.id}</span>
                    </div>
                </div>
            `;
        });
        trendingPoolsContent.innerHTML = html;
    }
// ===================================================================================================================================================================================================================================================================================
// runFullAnalysis 
// ===================================================================================================================================================================================================================================================================================
    async function runFullAnalysis(symbol = null) {
        if (candleCountdownInterval) clearInterval(candleCountdownInterval);
        adaptIndicatorParamsToTimeframe(timeframeSelect.value);
        WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
        WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
        WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));
        orderBookDOMElements = null;
        hideError();
        showLoader(true, 'Please Wait! Analyzing.............');

        specificTokenTitle.innerHTML = 'Analisis Token Spesifik';
        specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Mencari data on-chain...</p>`;
        trendingPoolsContent.innerHTML = `<div class="text-center py-2"><div class="loader mx-auto h-6 w-6"></div></div>`;
    // =======================     
        try {
            const aiContentContainer = document.getElementById('ai-content-container');
            if (aiContentContainer) aiContentContainer.classList.add('hidden');
            const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
            if (comprehensiveBtn) {
                const btnText = comprehensiveBtn.querySelector('span');
                const btnLoader = comprehensiveBtn.querySelector('.loader');
                btnText.classList.remove('hidden');
                btnLoader.classList.add('hidden');
                comprehensiveBtn.disabled = false;
            }

            const binanceSymbol = (symbol || assetInput.value.trim() || 'BTCUSDT').toUpperCase();

            if (symbol) { 
                assetInput.value = symbol;
            }
            
            const correlationAsset = document.getElementById('correlation-asset-input').value.trim().toUpperCase() || 'BTCUSDT';
            const marketType = marketTypeSelect.value;
            const selectedTimeframe = timeframeSelect.value;
            
            // Validasi Simbol
            await validateBinanceSymbol(binanceSymbol, marketType);

            showLoader(true, 'Fetching Market Data...');
            const baseAsset = binanceSymbol.replace(/USDT$|^\d+/g, '');
    // =======================         
            let promisesToRun = [
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: selectedTimeframe, limit: 500 }, marketType), 
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1h', limit: 200 }, marketType), 
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '15m', limit: 200 }, marketType), 
                fetchBinanceAPIData('ticker/24hr', { symbol: binanceSymbol }, marketType),
                fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 30 }, marketType),
                fetchBinanceAPIData('klines', { symbol: correlationAsset, interval: '1d', limit: 30 }, 'spot'),
                fetchBinanceAPIData('depth', { symbol: binanceSymbol, limit: 100 }, marketType),
                fetch('https://api.coingecko.com/api/v3/global').then(res => res.json()),
                
                (async () => {
                    try {
                        const coinGeckoId = await getCoinGeckoId(baseAsset);
                        return await fetchCoinGeckoData(coinGeckoId);
                    } catch (e) {
                        console.warn(`Gagal mengambil data CoinGecko: ${e.message}`);
                        return null; 
                    }
                })(),
            ];

            if (marketType === 'futures') {
                promisesToRun.push(
                    fetchBinanceAPIData('openInterest', { symbol: binanceSymbol }, 'futures'),
                    fetchBinanceAPIData('premiumIndex', { symbol: binanceSymbol }, 'futures'),
                    fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json()),
                    fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${binanceSymbol}&period=5m&limit=1`).then(res => res.json())
                );
            }

        const results = await Promise.allSettled(promisesToRun);
    // ======================= 
        const klines = results[0].status === 'fulfilled' ? results[0].value : null;
        const klines1h = results[1].status === 'fulfilled' ? results[1].value : null;
        const klines15m = results[2].status === 'fulfilled' ? results[2].value : null;
        const tickerData = results[3].status === 'fulfilled' ? results[3].value : null;
        const assetDailyKlines = results[4].status === 'fulfilled' ? results[4].value : null;
        // ---> TAMBAHKAN KODE DI BAWAH INI <---
        //console.warn("--- DEBUGGING DATA PIVOT ---");
        if (assetDailyKlines && assetDailyKlines.length >= 2) {
            //console.log("Status: BERHASIL. Data harian cukup.", assetDailyKlines);
            //console.log("Data 'prevDayKline' yang akan digunakan:", assetDailyKlines[assetDailyKlines.length - 2]);
        } else {
            //console.error("Status: GAGAL. Data harian tidak cukup atau gagal diambil.", assetDailyKlines);
        }
        //console.warn("------------------------------");
// ---> BATAS AKHIR KODE TAMBAHAN <---
        const btcDailyKlines = results[5].status === 'fulfilled' ? results[5].value : null;
        const orderBookData = results[6].status === 'fulfilled' ? results[6].value : null;
        // Indeks setelah ini disesuaikan karena fetchUsdToIdrRate (bekas indeks 7) telah dihapus
        const globalData = results[7].status === 'fulfilled' ? results[7].value : null;      // <-- DIUBAH ke 7
        const coinGeckoData = results[8].status === 'fulfilled' ? results[8].value : null;   // <-- DIUBAH ke 8
    // ======================= 
        let openInterestData = null, fundingRateData = null, lsRatioUmumData = null, lsRatioTopData = null;
      if (marketType === 'futures' && results.length > 9) { // <-- Ubah 10 menjadi 9
            openInterestData = results[9].status === 'fulfilled' ? results[9].value : null;   // <-- Ubah 10 menjadi 9
            fundingRateData = results[10].status === 'fulfilled' ? results[10].value : null;  // <-- Ubah 11 menjadi 10
            lsRatioUmumData = results[11].status === 'fulfilled' ? results[11].value : null;  // <-- Ubah 12 menjadi 11
            lsRatioTopData = results[12].status === 'fulfilled' ? results[12].value : null;   // <-- Ubah 13 menjadi 12
        }

    // ======================= AWAL BLOK PERBAIKAN =======================
        realtimeCache.main.multiTfKlines = {};
        const defaultDumpTf = document.getElementById('dump-trigger-timeframe-select').value;
        if (selectedTimeframe !== defaultDumpTf) {
            console.log(`Pre-fetching data untuk default dump TF: ${defaultDumpTf}`);
            try {
                const dumpTfKlines = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: defaultDumpTf, limit: 200 }, marketType);
                // Simpan data ini ke dalam "wadah" multi-timeframe
                realtimeCache.main.multiTfKlines[defaultDumpTf] = dumpTfKlines;
            } catch (e) {
                console.warn(`Gagal pre-fetch data untuk ${defaultDumpTf}:`, e);
            }
        }
    // ======================= AKHIR BLOK PERBAIKAN =======================
        if (!klines || !tickerData) {
            throw new Error("Gagal memuat data esensial (Kline & Ticker) dari Binance. Coba lagi.");
        }

            klineCache[binanceSymbol + selectedTimeframe] = { data: klines, timestamp: Date.now() };

            let correlationValue = null;
            if (binanceSymbol !== 'BTCUSDT' && assetDailyKlines && btcDailyKlines && assetDailyKlines.length === btcDailyKlines.length) {
                correlationValue = calculateCorrelation(assetDailyKlines.map(k=>parseFloat(k[4])), btcDailyKlines.map(k=>parseFloat(k[4])));
            }

            realtimeCache.main = { 
                symbol: binanceSymbol,
                tickerData, 
                klines,
                klines1h,
                klines15m, 
                orderBookData, 
                globalData, 
                coinGeckoData, 
                openInterestData, 
                fundingRateData, 
                lsRatioUmumData, 
                lsRatioTopData, 
                binanceSymbol, 
                selectedTimeframe, 
                correlationData: correlationValue,
                multiTfKlines: {
                    [selectedTimeframe]: klines 
                },
                liveScores: { pumpStrength: 0, dumpRisk: 0 }
            };
    // ======================= 
            showLoader(true, 'Calculating Data...');
            
            const allTrades = await fetchBinanceAPIData('aggTrades', { symbol: binanceSymbol, limit: 1000 }, marketType);
            const cvdData = calculateCVD(allTrades);
            realtimeCache.main.cvdData = cvdData;

            realtimeCache.main.calculatedData = recalculateAllIndicators(
                klines,
                tickerData,
                assetDailyKlines[assetDailyKlines.length - 2],
                marketType,
                cvdData,
                orderBookData,
                fundingRateData,
                lsRatioUmumData,
                openInterestData
            );

            const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);
            realtimeCache.main.tfAlignmentSummary = tfAlignmentSummary;
            const marketRegime = determineMarketRegime(klines, klines.map(k => parseFloat(k[4])));
            realtimeCache.main.marketRegime = marketRegime;

            updateDashboardUI();
            startCandleCountdown(); 
            document.getElementById('scalping-setup-section').scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            const navPriceEl = document.getElementById('nav-price');
            if (navPriceEl) {
                navPriceEl.textContent = formatPrice(parseFloat(tickerData.lastPrice));
            }
            
            if (orderBookData) {
                latestBids = orderBookData.bids;
                latestAsks = orderBookData.asks;
                const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
                const precision = getPrecisionForAsset(parseFloat(latestPrice));
                const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
                renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
            }

            const symbolLower = binanceSymbol.toLowerCase();
            const mainTfStream = `${symbolLower}@kline_${selectedTimeframe}`;
            const dumpTf = document.getElementById('dump-trigger-timeframe-select').value;
            const dumpTfStream = `${symbolLower}@kline_${dumpTf}`;

            // Siapkan stream dasar
            const streamsToSub = [
                mainTfStream,
                `${symbolLower}@aggTrade`,
                `${symbolLower}@depth20@100ms`
            ];

            // Tambahkan stream untuk dump TF HANYA JIKA berbeda dari main TF
            if (mainTfStream !== dumpTfStream) {
                streamsToSub.push(dumpTfStream);
            }

            WebSocketManager.subscribe(streamsToSub);
    // ======================= 
            (async () => {
                try {
                    const searchQuery = (await getCoinGeckoId(baseAsset).then(id => fetchCoinGeckoData(id)).catch(() => null))?.platforms?.ethereum || baseAsset;
                    specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span>`;
                    const searchResult = await fetchGeckoTerminal(`search/pools?query=${searchQuery}`);
                    if (searchResult.data && searchResult.data.length > 0) {
                        searchResult.data.sort((a, b) => parseFloat(b.attributes.reserve_in_usd) - parseFloat(a.attributes.reserve_in_usd));
                        const topPool = searchResult.data[0];
                        const attrs = topPool.attributes;
                        const networkName = topPool.id.split('_')[0];
                        const dexName = topPool.relationships?.dex?.data?.id.split('_').join(' ') || attrs.name.split(' ').pop();
                        if (networkName.includes('sepolia')) {
                            document.getElementById('onchain-card').style.display = 'none';
                            return;
                        } else {
                            document.getElementById('onchain-card').style.display = 'block';
                        }
                        specificTokenTitle.innerHTML = `Analisis Token: <span class="text-white">${baseAsset.toUpperCase()}</span> <span class="text-xs text-gray-400 capitalize">(${networkName} / ${dexName})</span>`;
                        const price = formatPrice(parseFloat(attrs.base_token_price_usd));
                        const volume = (parseFloat(attrs.volume_usd.h24) / 1000000).toFixed(2);
                        const liquidity = attrs.reserve_in_usd ? (parseFloat(attrs.reserve_in_usd) / 1000000).toFixed(2) : 'N/A';
                        let staticContentHtml = `<div class="flex justify-between items-baseline"><span class="text-gray-500 capitalize">Harga DEX (${dexName})</span><span class="font-bold text-lg text-yellow-400">${price}</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Volume 24j DEX</span><span>$${volume}jt</span></div><div class="flex justify-between items-baseline"><span class="text-gray-500">Likuiditas Pool</span><span>$${liquidity}jt</span></div>`;
                        specificTokenContent.innerHTML = staticContentHtml;
    // ======================= // ======================= 
                        try {
                            const poolAddress = attrs.address;
                            const tradesData = await fetchGeckoTerminal(`networks/${networkName}/pools/${poolAddress}/trades`);
                            const tradeEvents = tradesData.data.filter(trade => trade.attributes.kind === 'buy' || trade.attributes.kind === 'sell').map(trade => ({ kind: trade.attributes.kind, usd: parseFloat(trade.attributes.volume_in_usd), price: parseFloat(trade.attributes.price_in_usd || attrs.base_token_price_usd), time: new Date(trade.attributes.block_timestamp), trader: trade.attributes.tx_from_address, network: topPool.id.split('_')[0] })).filter(event => event.usd >= 5000).slice(0, 100);
                            if (tradeEvents.length > 0) {
                                let buyVolume = 0, sellVolume = 0;
                                let buyCount = 0, sellCount = 0;
                                tradeEvents.forEach(event => { if (event.kind === 'buy') { buyVolume += event.usd; buyCount++; } else { sellVolume += event.usd; sellCount++; } });
                                realtimeCache.main.onChainSummary = { totalBuyVolume: buyVolume, totalSellVolume: sellVolume, buyTransactions: buyCount, sellTransactions: sellCount, sentiment: buyVolume > sellVolume ? 'Dominan Beli' : 'Dominan Jual', netVolume: buyVolume - sellVolume };
                                let html = '<hr class="border-slate-700/50 my-3"/><h4 class="text-lg font-semibold mb-2">100 Trans Terbaru di DEX >$5000 </h4>';
                                tradeEvents.forEach(event => {
                                    const category = getHolderCategory(event.usd);
                                    const timeAgo = getTimeAgo(event.time);
                                    const specificTime = event.time.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' });
                                    const walletLink = `https://dexcheck.ai/app/wallet-analyzer/${event.trader}`;
                                    const bgColor = event.kind === 'buy' ? 'bg-green-900/40 dark:bg-green-800/20' : 'bg-red-900/40 dark:bg-red-800/20';
                                    const amountColor = event.kind === 'buy' ? 'text-green-400' : 'text-red-400';
                                    const icon = event.kind === 'buy' ? '🟢' : '🔴';
                                    const actionText = event.kind === 'buy' ? 'BELI' : 'JUAL';
                                    html += `<div class="p-2 rounded-md ${bgColor}"><div class="flex justify-between items-center font-semibold"><span>${icon} ${actionText}</span><span class="${amountColor}">$${event.usd.toLocaleString('en-US', {maximumFractionDigits: 0})}</span></div><div class="text-xs text-gray-400 flex justify-between items-center mt-1"><span class="${category.class} font-bold">[${category.name}]</span><span class="font-mono text-yellow-400">@ ${formatPrice(event.price)}</span><span>${timeAgo} <span class="text-gray-500">(${specificTime})</span></span><a href="${walletLink}" target="_blank" class="underline hover:text-white">Lihat Dompet 🔗</a></div></div>`;
                                });
                                specificTokenContent.innerHTML += html;
                            } else {
                            realtimeCache.main.onChainSummary = null;
                            specificTokenContent.innerHTML += `<p class="text-xs text-gray-500 text-center pt-2">NONE transaksi jual/beli signifikan baru-baru ini.</p>`;
                            }
                        } catch (tradeError) {
                            specificTokenContent.innerHTML += `<p class="text-xs text-red-500 text-center pt-2">Gagal memuat jejak trader: ${tradeError.message}</p>`;
                        }
                    } else {
                        specificTokenContent.innerHTML = `<p class="text-xs text-gray-500 text-center">Tidak ditemukan pool on-chain untuk ${baseAsset.toUpperCase()}.</p>`;
                    }
                } catch (dexError) {
                    specificTokenContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data token spesifik: ${dexError.message}</p>`;
                }
            })();
        // ======================= 
            (async () => {
                try {
                    const trendingData = await fetchGeckoTerminal('networks/trending_pools');
                    renderTrendingPools(trendingData.data);
                } catch (trendingError) {
                    trendingPoolsContent.innerHTML = `<p class="text-xs text-red-500 text-center">Gagal memuat data trending: ${trendingError.message}</p>`;
                }
            })();
        // ======================= 
        } catch (error) {
            console.error("Analisis Gagal:", error);
            showError(error.message);
        } finally {
            showLoader(false);
            if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
            if (processingInterval) clearInterval(processingInterval);
            periodicUpdateInterval = setInterval(updatePeriodicData, 300000);
            processingInterval = setInterval(processQueues, 500);
        }
    }
// ===========end of async function runFullAnalysis(symbol = null) {====================================================================================================
// ===================================================================================================================================================================================================================================================================================
    async function getConfluenceScoreForSymbol(symbol) {
        try {
            // Sekarang hanya mengambil data ticker 24 jam yang ringan
            const tickerData = await fetchBinanceAPIData('ticker/24hr', { symbol }, 'spot');
            
            return {
                symbol,
                price: parseFloat(tickerData.lastPrice),
                change24h: parseFloat(tickerData.priceChangePercent),
            };
        } catch (error) {
            console.error(`Gagal memindai ${symbol}:`, error);
            return { symbol, error: error.message };
        }
    }
// ===================================================================================================================================================================================================================================================================================
// ===BLOK KODE UPGRADE FINAL V2 UNTUK ANALISIS AI (TERMASUK KORELASI & RISIKO) ==masihh ada cache==
// ===================================================================================================================================================================================================================================================================================
    async function runComprehensiveAIAnalysis() {
        if (!realtimeCache.main.tickerData) {
            showError("Jalankan 'GET DATA' terlebih dahulu untuk memuat data.");
            return;
        }

        const comprehensiveBtn = document.getElementById('run-comprehensive-ai-btn');
        const btnText = comprehensiveBtn.querySelector('span');
        const btnLoader = comprehensiveBtn.querySelector('.loader');
        const aiContentContainer = document.getElementById('ai-content-container');
        const aiNarrativeEl = document.getElementById('ai-narrative-content');

        btnText.classList.add('hidden');
        btnLoader.classList.remove('hidden');
        comprehensiveBtn.disabled = true;
        document.getElementById('projection-results-container').innerHTML = '';
        document.getElementById('saran-buyer').textContent = '-';
        document.getElementById('alasan-buyer').textContent = '';
        document.getElementById('saran-holder').textContent = '-';
        document.getElementById('alasan-holder').textContent = '';

        aiNarrativeEl.innerHTML = '';
        aiContentContainer.classList.remove('hidden');

        try {
            const { 
                binanceSymbol, 
                calculatedData, 
                tickerData, 
                correlationData,
                onChainSummary
            } = realtimeCache.main;
            
            const marketType = marketTypeSelect.value;

            const tfAlignmentSummary = await createTFAlignmentSummary(binanceSymbol, marketType);

            const klines1d = await fetchBinanceAPIData('klines', { symbol: binanceSymbol, interval: '1d', limit: 200 }, marketType);
            const vwap20d = calculateVWAP(klines1d, 'rolling', 20);
            const obvValues = calculateOBV(klines1d);
            const obvTrend = obvValues.length > 1 && obvValues[obvValues.length - 1] > obvValues[obvValues.length - 2] ? 'Naik (Akumulasi)' : 'Turun (Distribusi)';
            const vwapStatus = parseFloat(tickerData.lastPrice) > vwap20d ? 'Di Atas VWAP (Bullish)' : 'Di Bawah VWAP (Bearish)';
            
            const volumeAnalysisData = {
                vwap_20d: vwapStatus,
                obv_trend: obvTrend
            };
           
            const prompt = constructHybridAIPrompt(
                binanceSymbol, 
                calculatedData, 
                tfAlignmentSummary, 
                volumeAnalysisData, 
                onChainSummary, 
                correlationData
            );
            
            const aiResponseText = await callGemini([{ text: prompt }], false);
            const parsedData = parseAIResponseWithTags(aiResponseText);
            displayComprehensiveResults(parsedData);

        } catch (error) {
            aiNarrativeEl.innerHTML = `<p class="text-red-500">Gagal mendapatkan analisa AI: ${error.message}</p>`;

        } finally {
            const btnText = comprehensiveBtn.querySelector('span');
            const btnLoader = comprehensiveBtn.querySelector('.loader');

            btnText.classList.remove('hidden');
            btnLoader.classList.add('hidden');
            comprehensiveBtn.disabled = false;
        }
    }
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
    function constructHybridAIPrompt(symbol, singleTfData, multiTfData, volumeData, onChainSummary, correlationData) {
        const mainPriceContext = {
            current_price: formatPrice(parseFloat(realtimeCache.main.tickerData.lastPrice))
        };
        const cleanSingleTfData = {
            timeframe: timeframeSelect.value,
            candlestick_pattern: singleTfData.candlePattern,
            chart_pattern: singleTfData.chartPattern,
            rsi_divergence: singleTfData.rsiDivergence,
            obv_divergence: singleTfData.obvDivergence.status,
            volatilitas_atr: singleTfData.atr,
            order_book_bias: realtimeCache.main.orderBookBias,
            bollinger_squeeze: singleTfData.bollingerBands.squeezeStatus,
            pivot_harian_bias: singleTfData.pivot.status + (singleTfData.pivot.data?.P ? ` (Pivot @ ${formatPrice(singleTfData.pivot.data.P)})` : ' (Data N/A)'),
            vwap_20d_bias: singleTfData.vwap.status,
            ichimoku_bias: singleTfData.ichimoku.status,
            squeeze_pro_bb_kc: (singleTfData.bollingerBands.width.slice(-1)[0] < singleTfData.keltnerChannels.width.slice(-1)[0]) ? 'Terdeteksi!' : 'Tidak Aktif'
        };
        const fundamentalData = {
            market_cap: realtimeCache.main.coinGeckoData?.market_data?.market_cap?.usd?.toLocaleString() || 'N/A'
        };
        const correlationText = correlationData !== null ? correlationData.toFixed(2) : 'N/A (Aset adalah BTC atau data tidak cukup)';
        const mvrvPromptData = realtimeCache.main.mvrvData 
            ? {
                status: "Data MVRV disediakan pengguna",
                nilai_z_score: realtimeCache.main.mvrvData.value,
                tanggal_data: realtimeCache.main.mvrvData.date
            }
            : "Data MVRV tidak disediakan pengguna.";

        const ema9 = calculateEMA(realtimeCache.main.klines.map(k=>parseFloat(k[4])), 9).pop();
        const ema21 = calculateEMA(realtimeCache.main.klines.map(k=>parseFloat(k[4])), 21).pop();
        const scalpingBias = ema9 > ema21 ? 'LONG' : 'SHORT';
        const scalpingSetupData = {
            bias_sesaat: scalpingBias,
            timeframe: timeframeSelect.value
        };

        return `Sebagai seorang analis kuantitatif (Quant Analyst) senior, berikan analisis pasar yang komprehensif untuk ${symbol}.

        TUGAS UTAMA:
        1.  **CARI DATA EKSTERNAL TERBARU:** Sebelum melakukan analisis, cari data sentimen pasar TERBARU (tidak lebih dari 24 jam terakhir) untuk BITCOIN dari sumber on-chain (Glassnode, CryptoQuant, Coinglass). Sertakan data-data berikut:
            a.  **MVRV Z-Score:** Cari nilai Z-Score terbaru.
            b.  **Data Sentimen Coinglass:** Cari data Netflow, Perubahan OI, Funding Rate, Rasio L/S 24 jam, dan Likuidasi.
            c.  **Format hasilnya HANYA dalam bentuk JSON** di dalam tag [SENTIMEN_DATA_JSON_START]. Strukturnya harus: {\"mvrv_z_score\":1.23, \"netflow\":-57.82, \"oiChange\":-0.89, \"fundingRate\":0.0050, \"lsRatio24h\":\"50.9% / 49.1%\", \"liquidations\":\"215.30M vs 89.10M\"}
        2.  **ANALISIS SEMUA DATA:** Lanjutkan dengan menganalisis SEMUA data yang diberikan di bawah ini untuk mengisi sisa tag output.
        3.  **GUNAKAN JANGKAR HARGA:** Gunakan 'current_price' dari DATA #0 sebagai satu-satunya titik acuan untuk SEMUA PROYEKSI HARGA.
        4.  **GAYA PENULISAN:** Gunakan bahasa yang padat, fokus pada data kunci, dan hindari kalimat berlebihan. Buat dalam bentuk poin-poin.

        **DATA #0: KONTEKS HARGA UTAMA (JANGKAR)**
        ${JSON.stringify(mainPriceContext, null, 2)}

        **DATA #1: Analisis Detail Timeframe Utama (${cleanSingleTfData.timeframe})**
        ${JSON.stringify(cleanSingleTfData, null, 2)}

        **DATA #2: Ringkasan Keselarasan Tren Multi-Timeframe (EMA 21/50)**
        ${JSON.stringify(multiTfData, null, 2)}

        **DATA #3: Analisis Berbasis Volume (CEX - Harian)**
        ${JSON.stringify(volumeData, null, 2)}

        **DATA #4: Data Fundamental Dasar**
        ${JSON.stringify(fundamentalData, null, 2)}

        **DATA #5: Ringkasan Aktivitas On-Chain (DEX - Transaksi >$5000)**
        ${onChainSummary ? JSON.stringify(onChainSummary, null, 2) : '"Data on-chain tidak tersedia untuk aset ini."'}

        **DATA #6: Korelasi Pasar (vs. BTCUSDT 30 Hari)**
        ${JSON.stringify({ correlation_coefficient: correlationText }, null, 2)}

        **DATA #7: Metrik Makro On-Chain (MVRV Z-Score)**
        ${JSON.stringify(mvrvPromptData, null, 2)}

        INSTRUKSI OUTPUT (WAJIB IKUTI FORMAT TAG DAN STRUKTUR MARKDOWN DI BAWAH INI):

        [SENTIMEN_DATA_JSON_START]
        (Letakkan hasil pencarian data sentimen Coinglass dalam format JSON murni di sini)
        [SENTIMEN_DATA_JSON_END]
        
        [NARASI_PASAR_START]
        (Berikan analisis narasi pasar. WAJIB GUNAKAN FORMAT MARKDOWN BERIKUT. Setiap poin harus berupa kalimat singkat dan padat berisi data.
        ### 🟥 Argumen Bearish (Jangka Pendek)
        * ### 🟩 Argumen Bullish (Tersembunyi)
        * ### ⚖️ Kesimpulan Narasi
        * )
        [NARASI_PASAR_END]

        [ANALISIS_RISIKO_START]
        (Berikan analisis risiko dalam 1-2 kalimat singkat.)
        [ANALISIS_RISIKO_END]

        [SMC_NARRATIVE_START]
        (Berikan analisis struktur pasar (SMC) dalam poin-poin singkat.
        ### 🟥 Sinyal Bearish (Distribusi)
        * ### 🟩 Sinyal Bullish (Akumulasi)
        * ### 🎯 Target & Konfirmasi Berikutnya
        * )
        [SMC_NARRATIVE_END]

        [SMC_POI_BULLISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bullish terdekat. Contoh: 'Order Block H4 di $50000 - $51000')
        [SMC_POI_BULLISH_END]

        [SMC_POI_BEARISH_START]
        (Sebutkan TIPE dan rentang harga zona POI bearish terdekat. Contoh: 'Supply zone H1 di $60000 - $61000')
        [SMC_POI_BEARISH_END]

        [PROYEKSI_LENGKAP_JSON_START]
        [
            { "periode": "Micro Scalp (1-4 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Sangat Pendek (24-48 jam)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Pendek (1-7 hari)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Menengah (1-4 minggu)", "target_harga": "...", "alasan": "..." },
            { "periode": "Jangka Panjang (6-12 bulan)", "target_harga": "...", "alasan": "..." },
            { "periode": "Siklus Makro (1-3 tahun)", "target_harga": "...", "alasan": "..." }
        ]
        [PROYEKSI_LENGKAP_JSON_END]

        [SARAN_HOLDER_START]
        (Pilih salah satu: TAHAN, JUAL, TAMBAH, KURANGI SEBAGIAN)
        [SARAN_HOLDER_END]

        [ALASAN_HOLDER_START]
        (Berikan 2-3 poin alasan teknikal singkat.)
        [ALASAN_HOLDER_END]

        [SARAN_BUYER_START]
        (Pilih salah satu: BELI SEKARANG, TUNGGU DI AREA, JANGAN MASUK)
        [SARAN_BUYER_END]

        [ALASAN_BUYER_START]
        (Berikan 2-3 poin alasan teknikal singkat. Jika TUNGGU, berikan rentang harga ideal.)
        [ALASAN_BUYER_END]
        `;
    }
// ===================================================================================================================================================================================================================================================================================
    function parseAIResponseWithTags(rawText) {
        const result = {};
        const tags = [
            "SENTIMEN_DATA_JSON",
            "PUTUSAN_FINAL", "TINGKAT_KEYAKINAN", "NARASI_PASAR", "ANALISIS_SCALPING", "ANALISIS_RISIKO",
            "SMC_NARRATIVE", "SMC_POI_BULLISH", "SMC_POI_BEARISH",
            "PROYEKSI_LENGKAP_JSON", "SARAN_HOLDER", "ALASAN_HOLDER",
            "SARAN_BUYER", "ALASAN_BUYER"
        ];

        tags.forEach(tag => {
            const regex = new RegExp(`\\[${tag}_START\\]([\\s\\S]*?)\\[${tag}_END\\]`, 'i');
            const match = rawText.match(regex);
            const content = match ? match[1].trim() : null;
            
            const key = tag.toLowerCase();
            if (key === "proyeksi_lengkap_json" && content) {
                try {
                    result[key] = JSON.parse(content);
                } catch (e) {
                    console.error(`Gagal parse JSON untuk tag ${tag}:`, e);
                    result[key] = [];
                }
            } else {
                result[key] = content;
            }
        });
        return result;
    }
// ===================================================================================================================================================================================================================================================================================
    function displayComprehensiveResults(data) {    
        const aiNarrativeEl = document.getElementById('ai-narrative-content');
        const projectionContainer = document.getElementById('projection-results-container');
        const buyerSaranEl = document.getElementById('saran-buyer');
        const buyerAlasanEl = document.getElementById('alasan-buyer');
        const holderSaranEl = document.getElementById('saran-holder');
        const holderAlasanEl = document.getElementById('alasan-holder');
        
        aiNarrativeEl.innerHTML = '';
        projectionContainer.innerHTML = '';
        buyerSaranEl.textContent = '-';
        buyerAlasanEl.textContent = '';
        holderSaranEl.textContent = '-';
        holderAlasanEl.textContent = '';

        if (!data || Object.keys(data).length === 0) {
            aiNarrativeEl.innerHTML = '<p class="text-red-500 text-center">AI gagal memberikan analisis yang bisa diproses. Coba lagi.</p>';
            return;
        }

        if (data.sentimen_data_json) {
            try {
                const sentimentData = { ...JSON.parse(data.sentimen_data_json), lastUpdated: new Date() };
                realtimeCache.main.shortTermSentiment = sentimentData;
                displaySentimentDataInDashboard(sentimentData);
            } catch (e) {
                console.error("Gagal parse JSON sentimen dari AI:", e);
                const sentimentContainer = document.getElementById('sentiment-display-container');
                if(sentimentContainer) {
                    sentimentContainer.innerHTML = `<p class="text-xs text-center text-red-500">AI gagal memberikan data sentimen dalam format JSON yang benar.</p>`;
                }
            }
        }
        
        let shortVerdictHtml = '';
        if (realtimeCache.main.quickConfluenceScore) {
            const { bull, bear } = realtimeCache.main.quickConfluenceScore;
            const { text, class: verdictClass } = generateShortVerdict(bull, bear);
            shortVerdictHtml = `<p class="text-center font-bold text-2xl mb-4 ${verdictClass}">${text}</p>`;
        }

        const narrativeHtml = data.narasi_pasar ? marked.parse(data.narasi_pasar) : '';
        const smcHtml = data.smc_narrative ? marked.parse(data.smc_narrative) : '';

        let detailsHtml = `
            <div class="space-y-4 text-sm">
                ${narrativeHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md">${narrativeHtml}</div>` : ''}
                ${data.analisis_risiko ? `<div class="p-3 bg-yellow-50 dark:bg-yellow-900/20 rounded-md border border-dashed border-yellow-500/50"><strong>Analisis Risiko:</strong> ${data.analisis_risiko}</div>` : ''}
                ${smcHtml ? `<div class="p-3 bg-gray-50 dark:bg-gray-800/20 rounded-md mt-3">${smcHtml}</div>` : ''}
            </div>
        `;

        aiNarrativeEl.innerHTML = shortVerdictHtml + detailsHtml;

        if (data.proyeksi_lengkap_json && data.proyeksi_lengkap_json.length > 0) {
            data.proyeksi_lengkap_json.forEach(p => {
                projectionContainer.innerHTML += `
                    <div class="card p-3 bg-gray-50 dark:bg-gray-800/50">
                        <h4 class="font-semibold text-blue-400 text-sm">${p.periode}</h4>
                        <p class="font-bold text-base text-gray-800 dark:text-white">${p.target_harga}</p>
                        <p class="text-xs text-gray-500 mt-1">${p.alasan}</p>
                    </div>`;
            });
            projectionContainer.className = `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`;
        } else {
            projectionContainer.innerHTML = '<p class="text-xs text-gray-500 col-span-full">Proyeksi harga tidak tersedia.</p>';
        }

        buyerSaranEl.textContent = data.saran_buyer || 'N/A';
        buyerAlasanEl.innerHTML = (data.alasan_buyer || 'NONE alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
        holderSaranEl.textContent = data.saran_holder || 'N/A';
        holderAlasanEl.innerHTML = (data.alasan_holder || 'NONE alasan spesifik.').replace(/\$([\d,.-]+)/g, '<span class="font-bold text-yellow-400">\$&</span>');
    }
// ===================================================================================================================================================================================================================================================================================
    function generateShortVerdict(bullPercentage, bearPercentage) {
        let verdict = "NETRAL / CONSOLIDATION";
        let verdictClass = "text-yellow-400";
        
        if (bullPercentage > bearPercentage * 1.8 && bullPercentage > 40) {
            verdict = "STRONG BULLISH";
            verdictClass = "positive";
        } else if (bearPercentage > bullPercentage * 1.8 && bearPercentage > 40) {
            verdict = "STRONG BEARISH";
            verdictClass = "negative";
        } else if (bullPercentage > bearPercentage) {
            verdict = "SLIGHTLY BULLISH";
            verdictClass = "positive";
        } else if (bearPercentage > bullPercentage) {
            verdict = "SLIGHTLY BEARISH";
            verdictClass = "negative";
        }
        return { text: verdict, class: verdictClass };
    }
// ===================================================================================================================================================================================================================================================================================
    function analyzeAndDisplayConfluenceContributors() {
        const data = realtimeCache.main.calculatedData;
        if (!data) return;

        let contributors = [];
    
        for (const indicator in userSettings.active.weights) {
            if (data[indicator]) {
                const score = getUltimateSignalScore(indicator, data[indicator]);
                if (score !== 0) {
                    contributors.push({ 
                        name: indicator.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()), 
                        score: score 
                    });
                }
            }
        }

        contributors.sort((a, b) => Math.abs(b.score) - Math.abs(a.score));

        const topBullish = contributors.filter(c => c.score > 0).slice(0, 3);
        const topBearish = contributors.filter(c => c.score < 0).slice(0, 3);

        // Bagian untuk menampilkan kontributor Bullish
        let bullishHtml = '<h4 class="font-bold positive mb-1">👍 Pro Bullish</h4><ul class="space-y-1 text-gray-400">';
        if (topBullish.length > 0) {
            topBullish.forEach(item => {
                bullishHtml += `<li class="flex justify-between"><span>• ${item.name}</span> <span class="font-mono text-xs positive">+${item.score.toFixed(2)}</span></li>`;
            });
        } else {
            bullishHtml += '<li class="text-xs italic text-gray-600">NONE.</li>';
        }
        bullishHtml += '</ul>';
        document.getElementById('top-bullish-contributors').innerHTML = bullishHtml;

        let bearishHtml = '<h4 class="font-bold negative mb-1">👎 Pro Bearish</h4><ul class="space-y-1 text-gray-400">';
        if (topBearish.length > 0) {
            topBearish.forEach(item => {
                // [PERBAIKAN] Tampilkan nama DAN skornya
                bearishHtml += `<li class="flex justify-between"><span>• ${item.name}</span> <span class="font-mono text-xs negative">${item.score.toFixed(2)}</span></li>`;
            });
        } else {
            bearishHtml += '<li class="text-xs italic text-gray-600">NONE.</li>';
        }
        bearishHtml += '</ul>';
        document.getElementById('top-bearish-contributors').innerHTML = bearishHtml;
        
        document.getElementById('confluence-breakdown-container').classList.remove('hidden');
    }

// ===================================================================================================================================================================================================================================================================================
    // GANTI SELURUH FUNGSI LAMA ANDA DENGAN VERSI FINAL INI
async function createTFAlignmentSummary(symbol, marketType) {
    const timeframes = ['5m', '15m', '1h', '4h', '1d'];
    const summary = {};
    
    let score = 0; 
    
    const klinesPromises = timeframes.map(tf => 
        fetchBinanceAPIData('klines', { symbol, interval: tf, limit: 51 }, marketType)
    );
    const klinesResults = await Promise.all(klinesPromises);

    klinesResults.forEach((klines, index) => {
        const tf = timeframes[index];
        if (klines && klines.length >= 50) {
            const closes = klines.map(k => parseFloat(k[4]));
            const ema21 = calculateEMA(closes, 21).pop();
            const ema50 = calculateEMA(closes, 50).pop();
            // Logika ini tetap menghasilkan 'UPTREND'/'DOWNTREND' untuk dependensi ke Bias Kontekstual
            summary[tf] = ema21 > ema50 ? 'UPTREND' : 'DOWNTREND';
        } else {
            summary[tf] = 'N/A';
        }
        
        // Kalkulasi skor (tidak diubah)
        if (summary[tf] === 'UPTREND') {
            score++;
        } else if (summary[tf] === 'DOWNTREND') {
            score--;
        }
    });

    realtimeCache.main.tfAlignmentSummary = { summary, score };

    // Tampilkan di UI
    const alignmentContainer = document.getElementById('tf-alignment-summary');
    let alignmentHtml = '<h4 class="font-semibold text-gray-300 mt-2 mb-1">Multi TF Alignment (EMA 21/50)</h4><div class="flex justify-center gap-1">';
    
    for(const tf in summary){
        const trend = summary[tf];
        const colorClass = trend === 'UPTREND' ? 'positive' : (trend === 'DOWNTREND' ? 'negative' : 'text-gray-500');
        
        // --- PERUBAHAN 1: Definisikan ikon berdasarkan teks tren ---
        const trendIcon = trend === 'UPTREND' ? '▲' : (trend === 'DOWNTREND' ? '▼' : '—');
        
        // --- PERUBAHAN 2: Gunakan variabel ikon, bukan teks, dan perbesar ukurannya ---
        alignmentHtml += `
            <div class="text-center p-1 rounded-md bg-gray-800/50 flex-1 mtf-clickable-box" data-timeframe="${tf}">
                <span class="font-semibold">${tf}</span><br>
                <span class="text-xl ${colorClass}">${trendIcon}</span>
            </div>`;
    }
    
    alignmentHtml += '</div>';
    if(alignmentContainer) alignmentContainer.innerHTML = alignmentHtml;

    return { summary, score };
}
// ===================================================================================================================================================================================================================================================================================
    function updateDashboardUI() {
        if (!realtimeCache.main.tickerData) return;
        const navInfoContainer = document.getElementById('nav-info-container');
        const navStatsContainer = document.getElementById('nav-stats-container');
        const tradeLinkContainer = document.getElementById('trade-link');

        if (navInfoContainer) {
            navInfoContainer.classList.remove('hidden');
            navInfoContainer.classList.add('md:flex');
        }
        if (navStatsContainer) {
            navStatsContainer.classList.remove('hidden');
            navStatsContainer.classList.add('md:flex');
        }
        if (tradeLinkContainer) {
            tradeLinkContainer.classList.remove('hidden');
        }
        initialPlaceholder.classList.add('hidden');
        dashboardContent.classList.remove('hidden');
        const navHeight = document.getElementById('sticky-nav-wrapper').offsetHeight;
        
        populateCurrentStateWidget();
        populateConfluenceDetailsWidget();
        populateCorrelationWidget(); 
        
        
        renderCvdChart();
        updateQuickConfluenceWidget();
        calculateAndDisplayScalpingSetup();
    }
// ===================================================================================================================================================================================================================================================================================
    
    
// ===================================================================================================================================================================================================================================================================================
    
// ===================================================================================================================================================================================================================================================================================
    function startFundingRateTimer(nextFundingTime) {
        if (fundingRateTimer) clearInterval(fundingRateTimer);

        const updateTimer = () => {
            const timeRemaining = formatTimeRemaining(nextFundingTime);
            document.getElementById('funding-rate-interval').textContent = timeRemaining;

            // Jika waktu sudah habis, hentikan timer
            if (timeRemaining === '00:00:00') {
                clearInterval(fundingRateTimer);
            }
        };

        updateTimer(); 
        fundingRateTimer = setInterval(updateTimer, 1000);
    }
// ===================================================================================================================================================================================================================================================================================
    function formatTimeRemaining(timestamp) {
        const now = new Date().getTime();
        const nextFunding = new Date(timestamp);
        const diff = nextFunding - now;

        if (diff <= 0) return '00:00:00';

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        const pad = (num) => num.toString().padStart(2, '0');

        return `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
    }
// ===================================================================================================================================================================================================================================================================================
    function populateConfluenceDetailsWidget() {  
        const { calculatedData, tickerData, orderBookData, lsRatioUmumData, lsRatioTopData } = realtimeCache.main;
        //if (calculatedData.pivot?.data) {
            //document.getElementById('pivot-p').textContent = formatPrice(calculatedData.pivot.data.P);
        //}
    // Temukan elemen-elemen yang relevan
const pivotContainer = document.getElementById('pivot-levels-container');
const pivotPEl = document.getElementById('pivot-p');
const pivotData = calculatedData.pivot?.data;

// HANYA perbarui elemen jika ada data baru yang valid.
// JANGAN timpa nilai yang sudah ada dengan placeholder '-'.
if (pivotData && pivotData.P) {
    pivotPEl.textContent = formatPrice(pivotData.P);
    
    document.getElementById('pivot-r1s1').textContent = `${formatPrice(pivotData.R1)} / ${formatPrice(pivotData.S1)}`;
    document.getElementById('pivot-r2s2').textContent = `${formatPrice(pivotData.R2)} / ${formatPrice(pivotData.S2)}`;
    document.getElementById('pivot-r3s3').textContent = `${formatPrice(pivotData.R3)} / ${formatPrice(pivotData.S3)}`;
    
    pivotContainer.classList.remove('hidden');
}
//} else {
    // Jika objek pivotData tidak ada sama sekali, pastikan kontainer tetap tersembunyi
    //pivotContainer.classList.add('hidden');
//}
        if (calculatedData.vwap) {
            document.getElementById('vwap-20d').textContent = formatPrice(calculatedData.vwap.value);
        }
        if (calculatedData.ichimoku) {
            const ichiBiasEl = document.getElementById('ichimoku-bias');
            ichiBiasEl.textContent = calculatedData.ichimoku.status;
            ichiBiasEl.className = `font-mono font-semibold ${calculatedData.ichimoku.status === 'Bullish' ? 'positive' : (calculatedData.ichimoku.status === 'Bearish' ? 'negative' : 'text-gray-500')}`;
        }
        
        if (calculatedData.obv?.value !== undefined) {
            const obv = calculatedData.obv;
            const obvEl = document.getElementById('obv-value');
            const formattedObv = (obv.value / 1_000_000).toFixed(2) + 'M'; // Format ke jutaan
            obvEl.textContent = `${formattedObv} (${obv.trend})`;
            obvEl.className = `font-mono font-semibold ${obv.trend === 'Naik' ? 'positive' : 'negative'}`;
        }

        document.getElementById('confluence-timeframe-display').textContent = timeframeSelect.value;
        document.getElementById('vpvr-vah').textContent = formatPrice(calculatedData.vpvr.vah);
        document.getElementById('vpvr-poc').textContent = formatPrice(calculatedData.vpvr.poc);
        document.getElementById('vpvr-val').textContent = formatPrice(calculatedData.vpvr.val);
        
        const maStatusEl = document.getElementById('ma-status');
        maStatusEl.textContent = calculatedData.ma.status;
        maStatusEl.className = `font-mono font-semibold ${calculatedData.ma.class}`;
        
        document.getElementById('ema-21-value').textContent = `EMA21: ${formatPrice(calculatedData.ma.value21)}`;
        document.getElementById('ema-50-value').textContent = `EMA50: ${formatPrice(calculatedData.ma.value50)}`;
        document.getElementById('rsi-value').textContent = calculatedData.rsi.last;
        
        const rsiStatusEl = document.getElementById('rsi-status');
        rsiStatusEl.textContent = calculatedData.rsi.status;
        rsiStatusEl.className = `tag ${calculatedData.rsi.class}`;
        const rsiDivergenceEl = document.getElementById('rsi-divergence');
        rsiDivergenceEl.textContent = calculatedData.rsiDivergence.status;
        rsiDivergenceEl.className = `font-mono font-semibold ${calculatedData.rsiDivergence.class}`;
        
        document.getElementById('stoch-value').textContent = `${calculatedData.stoch.k}/${calculatedData.stoch.d}`;
        
        const stochStatusEl = document.getElementById('stoch-status');
        stochStatusEl.textContent = calculatedData.stoch.status;
        stochStatusEl.className = `tag ${calculatedData.stoch.class}`;
        
        document.getElementById('macd-status').textContent = calculatedData.macd.status;
        document.getElementById('macd-status').className = `font-mono font-semibold ${calculatedData.macd.class}`;
        document.getElementById('macd-hist').textContent = calculatedData.macd.hist;
        document.getElementById('bollinger-bands-status').textContent = calculatedData.bollingerBands.status;
        
        const bbData = calculatedData.bollingerBands;
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop();
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop();
        const lastLower = bbData.lower.filter(v => v !== undefined).pop();
        
        document.getElementById('bb-upper-value').textContent = `U: ${formatPrice(lastUpper)}`;
        document.getElementById('bb-middle-value').textContent = `M: ${formatPrice(lastMiddle)}`;
        document.getElementById('bb-lower-value').textContent = `L: ${formatPrice(lastLower)}`;
        
        const { atr, atrPercent } = calculatedData;
        const atrStatusBadge = document.getElementById('atr-status-badge');
        const statusClassMap = { 'Low': 'tag-green', 'Normal': 'tag-yellow', 'High': 'tag-red', 'Very High': 'tag-red' };
        atrStatusBadge.textContent = atr.status;
        atrStatusBadge.className = `tag ${statusClassMap[atr.status] || 'tag-gray'} ml-2`;
        
        document.getElementById('atr-percent-value').textContent = `${atrPercent.toFixed(2)}%`;
        document.getElementById('atr-absolute-value').textContent = atr.value.toFixed(6);
        
        const candlePatternContainer = document.getElementById('candlestick-pattern').parentElement;
        const candleResult = calculatedData.candlePattern;
        let biasClass = '';
        if (candleResult.bias === 'BULLISH') biasClass = 'positive';
        if (candleResult.bias === 'BEARISH') biasClass = 'negative';
        const formattedTime = candleResult.timestamp ? new Date(candleResult.timestamp).toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }) : '';
        candlePatternContainer.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <p class="text-xs text-gray-500">Candlestick Pattern</p>
                <p class="text-xs text-gray-400 font-mono">${formattedTime}</p>
            </div>
            
            <div class="h-16 flex items-center justify-center my-2">
                ${candleResult.svg || ''}
            </div>
            
            <p id="candlestick-pattern" class="font-semibold ${candleResult.class}">${candleResult.pattern}</p>
            ${candleResult.bias !== 'NETRAL' ? `<p class="text-xs font-bold ${biasClass}">${candleResult.bias}</p>` : ''}
        `;
        const chartPatternEl = document.getElementById('chart-pattern');
        chartPatternEl.textContent = calculatedData.chartPattern.pattern;
        chartPatternEl.className = `font-semibold ${calculatedData.chartPattern.class}`;
        const psarStatusEl = document.getElementById('psar-status');
        
        psarStatusEl.textContent = calculatedData.psar.status;
        psarStatusEl.className = `font-mono font-semibold ${calculatedData.psar.status === 'Bullish' ? 'positive' : 'negative'}`;
        
        const rocStatusEl = document.getElementById('roc-status');
        rocStatusEl.textContent = `${calculatedData.roc.value.toFixed(2)}% (${calculatedData.roc.status})`;
        rocStatusEl.className = `font-mono font-semibold ${calculatedData.roc.status === 'Positif' ? 'positive' : 'negative'}`;
        
        document.getElementById('linreg-status').textContent = calculatedData.linreg.status;
        const bbWidth = calculatedData.bollingerBands.width.slice(-1)[0];
        const kcWidth = calculatedData.keltnerChannels.width.slice(-1)[0];
        const bbSqueezeEl = document.getElementById('bollinger-squeeze-status');
        if (bbWidth < kcWidth) {
            bbSqueezeEl.textContent = 'SQUEEZE PRO!';
            bbSqueezeEl.className = 'font-mono font-bold negative blinking-text-animation';
        } else if (calculatedData.bollingerBands.squeezeStatus === 'Squeeze!') {
            bbSqueezeEl.textContent = 'Squeeze!';
            bbSqueezeEl.className = 'font-mono font-bold text-yellow-500 blinking-text-animation';
        } else {
            bbSqueezeEl.textContent = 'Normal';
            bbSqueezeEl.className = 'font-mono text-gray-500';
        }
        
        document.getElementById('bollinger-rejection-status').textContent = calculatedData.bollingerBands.rejection;
        document.getElementById('bollinger-walk-status').textContent = calculatedData.bollingerBands.walkTheBands;
        if (calculatedData.adx) {
            document.getElementById('adx-value').textContent = calculatedData.adx.adx;
            document.getElementById('plus-di-value').textContent = calculatedData.adx.plusDI;
            document.getElementById('minus-di-value').textContent = calculatedData.adx.minusDI;
        }
        const lsUmumContainer = document.getElementById('ls-umum-container'), lsTopContainer = document.getElementById('ls-top-container');
        if (marketTypeSelect.value === 'futures' && lsRatioUmumData?.[0] && lsRatioTopData?.[0]) {
            lsUmumContainer.classList.remove('hidden');
            lsTopContainer.classList.remove('hidden');
            document.getElementById('ls-ratio-umum').textContent = lsRatioUmumData[0].longShortRatio;
            document.getElementById('ls-ratio-top').textContent = lsRatioTopData[0].longShortRatio;
        } else {
            lsUmumContainer.classList.add('hidden');
            lsTopContainer.classList.add('hidden');
        }
        if (orderBookData?.bids && orderBookData?.asks) {
            const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
            const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
            let biasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (BUYER LIMIT)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (SELLER LIMIT)' : 'Netral');
            document.getElementById('order-book-bias').textContent = biasText;
            realtimeCache.main.orderBookBias = biasText;
        } else {
            document.getElementById('order-book-bias').textContent = 'N/A';
            realtimeCache.main.orderBookBias = 'N/A';
        }
        //baru simulasi
        tsCalc.elements.marketPrice.value = parseFloat(realtimeCache.main.tickerData.lastPrice).toFixed(getPrecisionForAsset(parseFloat(realtimeCache.main.tickerData.lastPrice)));

        const resistanceContainer = document.getElementById('scalping-resistance-info');
        if (resistanceContainer && tickerData) {
            const currentPrice = parseFloat(tickerData.lastPrice);
            const pivots = calculatedData.pivot.data; // Simpan data pivot di variabel agar lebih rapi

            const potentialResistances = [
                { name: 'VAH', value: calculatedData.vpvr.vah },
                { name: '24H High', value: parseFloat(tickerData.highPrice) },
                // Menambahkan SEMUA level resistance pivot (P, R1, R2, R3) sebagai kandidat
                { name: 'Pivot', value: pivots?.P },
                { name: 'R1', value: pivots?.R1 },
                { name: 'R2', value: pivots?.R2 },
                { name: 'R3', value: pivots?.R3 }
            ].filter(r => r.value && r.value > currentPrice); // Filter hanya yang di atas harga saat ini
            if (potentialResistances.length > 0) {
                const nearestResistance = potentialResistances.reduce((prev, curr) => 
                    (Math.abs(curr.value - currentPrice) < Math.abs(prev.value - currentPrice) ? curr : prev)
                );
                resistanceContainer.querySelector('span:last-child').innerHTML = `${formatPrice(nearestResistance.value)} <span class="text-gray-500 text-xs">(${nearestResistance.name})</span>`;
            } else {
                resistanceContainer.querySelector('span:last-child').textContent = 'N/A';
            }
        }
    }
// ===================================================================================================================================================================================================================================================================================
    function detectAndDisplayWall(bids, asks) {
        const symbolInfo = exchangeInfoCache[marketTypeSelect.value]?.find(s => s.symbol === realtimeCache.main.binanceSymbol);
        const priceFilter = symbolInfo?.filters.find(f => f.filterType === 'PRICE_FILTER');
        const lotSizeFilter = symbolInfo?.filters.find(f => f.filterType === 'LOT_SIZE');       
        const tickSize = priceFilter ? parseFloat(priceFilter.tickSize) : 0.01;
        const stepSize = lotSizeFilter ? parseFloat(lotSizeFilter.stepSize) : 0.001;

        let smoothedAvgVolume = 0;
        if (orderBookHistory.avgVolumes.length > 0) {
            smoothedAvgVolume = orderBookHistory.avgVolumes.reduce((sum, vol) => sum + vol, 0) / orderBookHistory.avgVolumes.length;
        } else {
            const initialLevels = [...bids.slice(0,15), ...asks.slice(0,15)];
            if(initialLevels.length > 0) {
            smoothedAvgVolume = initialLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / initialLevels.length;
            }
        }

        const classifyWall = (volume, mediumThreshold, thickThreshold) => {
            if (volume >= thickThreshold) return 'Thick';
            if (volume >= mediumThreshold) return 'Medium';
            return 'Thin';
        };

        const findWallCluster = (levels) => {
            if (!levels || levels.length < 5 || smoothedAvgVolume === 0) return null;
            
            const topLevels = levels.slice(0, 15).map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...topLevels);
            const thinThreshold   = Math.max(smoothedAvgVolume * 3, maxVolume * 0.2);
            const mediumThreshold = Math.max(smoothedAvgVolume * 7, maxVolume * 0.5);
            const thickThreshold  = Math.max(smoothedAvgVolume * 15, maxVolume * 0.7);

            let currentWall = null;
            let walls = [];

            for (let i = 0; i < levels.length; i++) {
                const price = parseFloat(levels[i][0]);
                const volume = parseFloat(levels[i][1]);

                if (volume >= thinThreshold) {
                    if (!currentWall) {
                        currentWall = {
                            priceStart: price,
                            priceEnd: price,
                            totalVolume: volume,
                            levels: 1,
                            levelPrices: [price]
                        };
                    } else {
                        if (Math.abs(price - currentWall.priceEnd) <= (tickSize * 2)) {
                            currentWall.priceEnd = price;
                            currentWall.totalVolume += volume;
                            currentWall.levels++;
                            currentWall.levelPrices.push(price);
                        } else {
                            if (currentWall.levels >= 2) walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                            currentWall = { priceStart: price, priceEnd: price, totalVolume: volume, levels: 1, levelPrices: [price] };
                        }
                    }
                } else {
                    if (currentWall && currentWall.levels >= 2) {
                        walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
                    }
                    currentWall = null;
                }
            }
            
            if (currentWall && currentWall.levels >= 2) {
                walls.push({ ...currentWall, wallType: classifyWall(currentWall.totalVolume, mediumThreshold, thickThreshold) });
            }

            if (walls.length > 0) {
                return walls.reduce((max, w) => (w.totalVolume > max.totalVolume ? w : max), walls[0]);
            }
            return null;
        };
        
        
        const findSingleWall = (levels) => {
            if (!levels || levels.length === 0 || smoothedAvgVolume === 0) return null;
            
            const volumes = levels.slice(0, 20).map(l => parseFloat(l[1]));
            const maxVolume = Math.max(...volumes);

            if (maxVolume > smoothedAvgVolume * 20) { 
                const idx = volumes.findIndex(v => v === maxVolume);
                return {
                    priceStart: parseFloat(levels[idx][0]),
                    priceEnd: parseFloat(levels[idx][0]),
                    totalVolume: maxVolume,
                    levels: 1,
                    wallType: 'Thick'
                };
            }
            return null;
        };

        const buyWallCluster = findWallCluster(bids);
        const sellWallCluster = findWallCluster(asks);
        const buyWallSingle  = findSingleWall(bids);
        const sellWallSingle = findSingleWall(asks);

        return {
            buyWall: buyWallCluster || buyWallSingle,
            sellWall: sellWallCluster || sellWallSingle
        };
    }
// ===================================================================================================================================================================================================================================================================================
    function renderFullOrderBook(bids, asks, wallInfo, precision) {
        const numLevels = 10;
        if (!orderBookDOMElements) {
            let asksHtml = Array.from({ length: numLevels }).map(() => `
                <div class="flex items-center text-xs mt-1 relative z-0">
                    <div class="ask-bar absolute inset-0 bg-red-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                    <span class="ask-price w-1/2 text-left font-mono"></span>
                    <span class="ask-qty w-1/2 text-right font-mono"></span>
                </div>
            `).join('');

            let bidsHtml = Array.from({ length: numLevels }).map(() => `
                <div class="flex items-center text-xs mt-1 relative z-0">
                    <div class="bid-bar absolute inset-0 bg-green-500/10 z-[-1] transition-all duration-300" style="width: 0%;"></div>
                    <span class="bid-qty w-1/2 text-left font-mono"></span>
                    <span class="bid-price w-1/2 text-right font-mono"></span>
                </div>
            `).join('');

            // ==========================================================
            // === PERBAIKAN 1: UBAH STRUKTUR HTML YANG DIBUAT DI SINI ===
            // ==========================================================
            fullOrderBookContainer.innerHTML = `
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <h4 class="text-red-500 font-bold">ASKs (Jual)</h4>
                        <div id="asks-container">${asksHtml}</div>
                    </div>
                    <div>
                        <h4 class="text-green-500 font-bold">BIDs (Beli)</h4>
                        <div id="bids-container">${bidsHtml}</div>
                    </div>
                </div>
                <div id="main-ob-wall-container" class="text-center text-xs mt-4 space-y-1">
                    <div id="main-ob-buy-wall" class="h-4 flex items-center justify-center"></div>
                    <div id="main-ob-sell-wall" class="h-4 flex items-center justify-center"></div>
                </div>
            `;
            
            orderBookDOMElements = {
                asks: Array.from(document.querySelectorAll('#asks-container > div')).map(row => ({
                    row, bar: row.querySelector('.ask-bar'), price: row.querySelector('.ask-price'), qty: row.querySelector('.ask-qty')
                })).reverse(), 
                bids: Array.from(document.querySelectorAll('#bids-container > div')).map(row => ({
                    row, bar: row.querySelector('.bid-bar'), price: row.querySelector('.bid-price'), qty: row.querySelector('.bid-qty')
                })),
                // PERBAIKAN: Tambahkan elemen baru untuk ditarget
                mainObBuyWall: document.getElementById('main-ob-buy-wall'),
                mainObSellWall: document.getElementById('main-ob-sell-wall')
            };
        }

        const topLevels = [...bids.slice(0, 15), ...asks.slice(0, 15)];
        if (topLevels.length > 0) {
            const currentAvgVolume = topLevels.reduce((sum, level) => sum + parseFloat(level[1]), 0) / topLevels.length;
        
        
        orderBookHistory.avgVolumes.push(currentAvgVolume);
        
        while (orderBookHistory.avgVolumes.length > orderBookHistory.maxSize) {
            orderBookHistory.avgVolumes.shift();
        }
    }
        
        const totalMaxVolume = Math.max(
            ...bids.slice(0, numLevels).map(b => parseFloat(b[1])), 
            ...asks.slice(0, numLevels).map(a => parseFloat(a[1]))
        );

        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.asks[i];
            const data = asks[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.sellWall && price >= wallInfo.sellWall.priceStart && price <= wallInfo.sellWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `ask-price w-1/2 text-left font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-red-500' : 'text-red-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        for (let i = 0; i < numLevels; i++) {
            const el = orderBookDOMElements.bids[i];
            const data = bids[i];
            if (el && data) {
                const price = parseFloat(data[0]);
                const quantity = parseFloat(data[1]);
                const percentage = (quantity / totalMaxVolume) * 100;
                const isWall = wallInfo.buyWall && price >= wallInfo.buyWall.priceStart && price <= wallInfo.buyWall.priceEnd;

                el.price.textContent = price.toFixed(precision);
                el.qty.textContent = quantity.toFixed(2);
                el.bar.style.width = `${percentage}%`;
                el.price.className = `bid-price w-1/2 text-right font-mono ${isWall ? 'font-bold text-white px-1 rounded bg-green-500' : 'text-green-400'}`;
            } else if (el) {
                el.price.textContent = '';
                el.qty.textContent = '';
                el.bar.style.width = '0%';
            }
        }

        const buyWallDisplay = document.getElementById('buy-wall-display');
        const sellWallDisplay = document.getElementById('sell-wall-display');
        const fullOrderBookWallInfo = orderBookDOMElements.wallInfo;

        let buyWallText = '<span class="text-gray-600 font-normal">— No Buy Wall Detected —</span>';
        if (wallInfo.buyWall) {
            buyWallText = `<span class="font-normal ">BUY WALL ${wallInfo.buyWall.wallType.toUpperCase()}</span> DETECTED ${formatPrice(wallInfo.buyWall.priceStart)} TO ${formatPrice(wallInfo.buyWall.priceEnd)} (Vol: $${(wallInfo.buyWall.totalVolume * parseFloat(bids[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        buyWallDisplay.innerHTML = buyWallText;

        let sellWallText = '<span class="text-gray-600 font-normal">— No Sell Wall Detected —</span>';
        if (wallInfo.sellWall) {
            sellWallText = `<span class="font-normal">SELL WALL ${wallInfo.sellWall.wallType.toUpperCase()}</span> DETECTED ${formatPrice(wallInfo.sellWall.priceStart)} TO ${formatPrice(wallInfo.sellWall.priceEnd)} (Vol: $${(wallInfo.sellWall.totalVolume * parseFloat(asks[0][0])).toLocaleString('en-US', {notation: 'compact'})})`;
        }
        sellWallDisplay.innerHTML = sellWallText;

        // (Opsional) Update juga info di panel Order Book besar
        if (fullOrderBookWallInfo) {
            let combinedText = '';
            if (wallInfo.buyWall) combinedText += buyWallDisplay.innerHTML + '<br>';
            if (wallInfo.sellWall) combinedText += sellWallDisplay.innerHTML;
            fullOrderBookWallInfo.innerHTML = combinedText;
        }
    }
// ===================================================================================================================================================================================================================================================================================
    
// ===================================================================================================================================================================================================================================================================================
    function calculateBollingerBands_forPlot(closes, period = 20, stdDev = 2, klines) {
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const middle = calculateSMA(closes, period);
        const upper = [], middleData = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                continue;
            }
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            const time = klines[i][0] / 1000;
            upper.push({ time, value: middle[i] + (stdev * stdDev) });
            lower.push({ time, value: middle[i] - (stdev * stdDev) });
            middleData.push({ time, value: middle[i] });
        }
        return { upper: upper.filter(d => d), middle: middleData.filter(d => d.value !== undefined), lower: lower.filter(d => d) };
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateROC_forPlot(closes, period = 12) {
        if (closes.length < period + 1) return [];
        const rocData = [];
        for (let i = period; i < closes.length; i++) {
            const currentClose = closes[i];
            const pastClose = closes[i - period];
            if (pastClose !== 0) {
                const roc = ((currentClose - pastClose) / pastClose) * 100;
                rocData.push({ time: realtimeCache.main.klines[i][0] / 1000, value: roc });
            }
        }
        return rocData;
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateLinearRegressionChannel_forPlot(klines, period = 14, stdDev = 2) {
        const closes = klines.map(k => parseFloat(k[4]));
        if (closes.length < period) return { upper: [], middle: [], lower: [] };
        const upper = [], middle = [], lower = [];
        for (let i = period - 1; i < closes.length; i++) {
            const y = closes.slice(i - period + 1, i + 1);
            const n = period; 
            const sumX = (n * (n - 1)) / 2;
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = y.reduce((acc, val, j) => acc + val * j, 0);
            const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate Standard Deviation from regression error
            let sumErrSq = 0;
            for (let j = 0; j < n; j++) {
                const predictedY = intercept + slope * j;
                sumErrSq += Math.pow(y[j] - predictedY, 2);
            }
            const stdErr = Math.sqrt(sumErrSq / (n - 2));

            const middleValue = intercept + slope * (n - 1);
            middle.push({ time: klines[i][0] / 1000, value: middleValue });
            upper.push({ time: klines[i][0] / 1000, value: middleValue + (stdDev * stdErr) });
            lower.push({ time: klines[i][0] / 1000, value: middleValue - (stdDev * stdErr) }); 
        }
        return { upper, middle, lower };
    }

// ===================================================================================================================================================================================================================================================================================
    function analyzeBollingerBandsPriceAction(klines, bbData) {
        if (!klines || klines.length < 2 || !bbData || bbData.upper.length < 2) {
            return { rejection: 'NONE', walkTheBands: 'NONE' };
        }

        const lastKline = klines[klines.length - 1];
        const prevKline = klines[klines.length - 2];
        const lastUpper = bbData.upper.pop()?.value;
        const lastLower = bbData.lower.pop()?.value;
        const prevUpper = bbData.upper.pop()?.value;
        const prevLower = bbData.lower.pop()?.value;
        const lastClose = parseFloat(lastKline[4]);
        const prevClose = parseFloat(prevKline[4]);

        let rejection = 'NONE';
        // Logika Rejection Bullish
        if (prevClose < prevLower && lastClose > lastLower && lastClose > prevClose) {
            rejection = 'Bullish Rejection (Lower BB)';
        }
        // Logika Rejection Bearish
        if (prevClose > prevUpper && lastClose < lastUpper && lastClose < prevClose) {
            rejection = 'Bearish Rejection (Upper BB)';
        }

        let walkTheBands = 'NONE';
        // Logika Walk the Bands Bullish
        if (lastClose >= lastUpper && prevClose >= prevUpper) {
            walkTheBands = 'Bullish (Upper BB)';
        }
        // Logika Walk the Bands Bearish
        if (lastClose <= lastLower && prevClose <= prevLower) {
            walkTheBands = 'Bearish (Lower BB)';
        }
        
        return { rejection, walkTheBands };
    }
// ===================================================================================================================================================================================================================================================================================
    
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
    const processQueues = () => {
        let shouldUpdateMainUI = false;
        let shouldUpdateScalpingUI = false;

        // 1. Proses antrean KLINE (Logika Baru)
        if (klineQueue.length > 0) {
            const klinesToProcess = klineQueue.splice(0, klineQueue.length);

            klinesToProcess.forEach(message => {
                const candle = message.k;
                const timeframe = candle.i; // Timeframe dari pesan (cth: '5m', '1h')
                const mainTimeframe = timeframeSelect.value;
                const dumpTimeframe = document.getElementById('dump-trigger-timeframe-select').value;

                const formattedCandle = [
                    candle.t, candle.o, candle.h, candle.l, candle.c, candle.v,
                    candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B
                ];

                // Cek apakah ini untuk timeframe utama
                if (timeframe === mainTimeframe && realtimeCache.main.klines) {
                    const klinesCache = realtimeCache.main.klines;
                    if (candle.x) { // Jika candle final (candle LAMA baru saja selesai)
                        klinesCache.shift();
                        klinesCache.push(formattedCandle);
                        newCandleJustStarted = true; // <-- Set penanda bahwa candle BARU akan segera dimulai
                    } else { // Jika candle live (ini adalah tick pertama atau selanjutnya dari candle BARU)
                        klinesCache[klinesCache.length - 1] = formattedCandle;
                        // Cek apakah ini tick pertama dari candle baru
                        if (newCandleJustStarted) {
                            startCandleCountdown(); // <-- Panggil countdown di sini, di waktu yang TEPAT!
                            newCandleJustStarted = false; // <-- Reset penanda agar tidak dipanggil terus
                        }
                    }
                    shouldUpdateMainUI = true;
                }
                // Cek apakah ini untuk timeframe scalping
                else if (timeframe === dumpTimeframe && realtimeCache.main.multiTfKlines[dumpTimeframe]) {
                    const klinesCache = realtimeCache.main.multiTfKlines[dumpTimeframe];
                    if (candle.x) { // Jika candle final
                        klinesCache.shift();
                        klinesCache.push(formattedCandle);
                    } else { // Jika candle live
                        klinesCache[klinesCache.length - 1] = formattedCandle;
                    }
                    shouldUpdateScalpingUI = true;
                }
            });
        }

        // 2. Proses antrean TRADE (Logika Lama yang Dikembalikan)
        if (tradeQueue.length > 0) {
            try {
                const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
                tradesToProcess.forEach(trade => {
                    const quantity = parseFloat(trade.q);
                    // Di dalam loop forEach di processQueues
                    const price = parseFloat(trade.p);

                    // === AWAL PERBAIKAN PENTING ===

                    // 1. Perbarui harga di cache utama agar simulasi bisa membacanya
                    if (realtimeCache.main.tickerData) {
                        realtimeCache.main.tickerData.lastPrice = price;
                    }

                    // 2. Perbarui harga di input kalkulator secara real-time
                    const marketPriceInput = tsCalc.elements.marketPrice;
                    // Hanya update jika pengguna tidak sedang mengetik di dalamnya
                    if (document.activeElement !== marketPriceInput) {
                        marketPriceInput.value = price.toFixed(getPrecisionForAsset(price));
                    }

                    // 3. Perbarui harga di header navigasi (kode lama yang dipertahankan)
                    const navPriceEl = document.getElementById('nav-price');
                    if (navPriceEl) {
                        navPriceEl.textContent = formatPrice(price);
                    }

                    // === AKHIR PERBAIKAN PENTING ===

                    const now = trade.T;
                    const bucketTimestamp = Math.floor(now / CVD_AGGREGATION_INTERVAL_MS) * CVD_AGGREGATION_INTERVAL_MS;
                    if (bucketTimestamp > cvdAggregator.currentBucketTimestamp) {
                        if (cvdAggregator.currentBucketTimestamp > 0) {
                            cvdAggregator.history.push({ 
                                time: cvdAggregator.currentBucketTimestamp, 
                                delta: cvdAggregator.currentBucketDelta 
                            });
                            if (cvdAggregator.history.length > CVD_HISTORY_LENGTH) {
                                cvdAggregator.history.shift();
                            }
                        }
                        cvdAggregator.currentBucketTimestamp = bucketTimestamp;
                        cvdAggregator.currentBucketDelta = 0;
                    }
                    const sign = trade.m ? -1 : 1;
                    cvdAggregator.currentBucketDelta += (quantity * price * sign);
                    
                    if (cvdChartInstance) {
                        if (isNaN(quantity) || quantity === 0) return;
                        liveCvdValue += quantity * sign;
                        liveCvdValueUsdt += (quantity * price) * sign;
                        const newPoint = { x: trade.T, y_coin: liveCvdValue, y_usdt: liveCvdValueUsdt };
                        cvdChartInstance.data.datasets[0].data.push(newPoint);
                        liveCvdData.push(newPoint);
                        while (cvdChartInstance.data.datasets[0].data.length > 300) {
                            cvdChartInstance.data.datasets[0].data.shift();
                            liveCvdData.shift();
                        }
                        cvdChartInstance.update('none');
                        updateCvdTableLive();
                    }
                });
            } catch (error) {
                console.error("Error saat memproses trade:", error);
            }
        }

        // 3. Proses antrean DEPTH/Order Book (Logika Lama yang Dikembalikan)
        if (depthQueue.length > 0) {
            try {
                const updatesToProcess = depthQueue.splice(0, depthQueue.length);
                updatesToProcess.forEach(update => {
                    if (update.b) {
                        update.b.forEach(([price, qty]) => {
                            const existingIndex = latestBids.findIndex(bid => bid[0] === price);
                            if (parseFloat(qty) === 0) {
                                if (existingIndex !== -1) latestBids.splice(existingIndex, 1);
                            } else {
                                if (existingIndex !== -1) latestBids[existingIndex] = [price, qty];
                                else latestBids.push([price, qty]);
                            }
                        });
                    }
                    if (update.a) {
                        update.a.forEach(([price, qty]) => {
                            const existingIndex = latestAsks.findIndex(ask => ask[0] === price);
                            if (parseFloat(qty) === 0) {
                                if (existingIndex !== -1) latestAsks.splice(existingIndex, 1);
                            } else {
                                if (existingIndex !== -1) latestAsks[existingIndex] = [price, qty];
                                else latestAsks.push([price, qty]);
                            }
                        });
                    }
                });
                latestBids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
                latestAsks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
                const latestPrice = latestBids?.[0]?.[0] || latestAsks?.[0]?.[0] || 0;
                const precision = getPrecisionForAsset(parseFloat(latestPrice));
                const wallInfo = detectAndDisplayWall(latestBids, latestAsks);
                renderFullOrderBook(latestBids, latestAsks, wallInfo, precision);
            } catch (error) {
                console.error("Error saat memproses depth:", error);
            }
        }

        // 4. Panggil fungsi update UI berdasarkan data mana yang baru (Logika Baru)
        if (shouldUpdateMainUI) {
            // Jika data utama berubah, hitung ulang & update semua panel terkait
            updateRealTimeIndicators(realtimeCache.main.klines);
        } else if (shouldUpdateScalpingUI) {
            // Jika hanya data scalping yang berubah, cukup update panel scalping
            calculateAndDisplayScalpingSetup();
        }
    };
// ===================================================================================================================================================================================================================================================================================
    function populateCurrentStateWidget() {
        const { tickerData, coinGeckoData, globalData, openInterestData, fundingRateData, binanceSymbol } = realtimeCache.main;
        
        document.getElementById('nav-symbol').textContent = binanceSymbol;
        const navChange24hEl = document.getElementById('nav-change-24h');
        const navChange1hEl = document.getElementById('nav-change-1h');
        
        const change24h = parseFloat(tickerData.priceChangePercent);
        if (navChange24hEl) {
            navChange24hEl.textContent = `${change24h.toFixed(2)}%`;
            navChange24hEl.className = `font-semibold ${getSignClass(change24h)}`;
        }
        
        if (navChange1hEl && coinGeckoData?.market_data) {
            const change1h = coinGeckoData.market_data.price_change_percentage_1h_in_currency.usd || 0;
            navChange1hEl.textContent = `${change1h.toFixed(2)}%`;
            navChange1hEl.className = `font-semibold ${getSignClass(change1h)}`;
        }
        navVolume24h.textContent = `$${parseFloat(tickerData.quoteVolume).toLocaleString('en-US', { notation: 'compact' })}`;
        if (coinGeckoData?.market_data) {
            navAth.textContent = formatPrice(coinGeckoData.market_data.ath.usd);
            navAtl.textContent = formatPrice(coinGeckoData.market_data.atl.usd);
        }

        if (coinGeckoData?.market_data) {
            document.getElementById('market-cap').textContent = formatPrice(coinGeckoData.market_data.market_cap.usd);
        }
        if (globalData?.data) {
            document.getElementById('btc-dominance').textContent = `${globalData.data.market_cap_percentage.btc.toFixed(2)}%`;
        }

        document.getElementById('current-state-title').innerHTML = `Current Market Condition <span class="text-yellow-500 font-semibold ml-2">💲 ${binanceSymbol}</span>`;
        document.getElementById('range-24h').textContent = `${formatPrice(parseFloat(tickerData.lowPrice)).replace('$', '')} - ${formatPrice(parseFloat(tickerData.highPrice)).replace('$', '')}`;
        
        const futuresContainer = document.getElementById('futures-data-container');
        const price = parseFloat(tickerData.lastPrice);
        if (marketTypeSelect.value === 'futures' && openInterestData && fundingRateData) {
            futuresContainer.classList.remove('hidden');
            if (openInterestData && parseFloat(openInterestData.openInterest) > 0) {
                const oiValue = parseFloat(openInterestData.openInterest) * price;
                document.getElementById('open-interest').textContent = `$${oiValue.toLocaleString('en-US', { notation: 'compact' })}`;
            } else {
                document.getElementById('open-interest').textContent = '-';
            }
            document.getElementById('funding-rate').textContent = `${(parseFloat(fundingRateData.lastFundingRate) * 100).toFixed(4)}%`;
            if (fundingRateData.nextFundingTime) {
                startFundingRateTimer(fundingRateData.nextFundingTime);
            } else {
                document.getElementById('funding-rate-interval').textContent = '-';
            }
        } else {
            futuresContainer.classList.add('hidden');
        }
    }
// ===================================================================================================================================================================================================================================================================================
    function renderCvdChart() {
        const { cvdData } = realtimeCache.main;
        if (!cvdData || cvdData.length === 0) return;

        // Inisialisasi data live dengan format baru yang lengkap
        liveCvdData = cvdData.map(d => ({ 
            x: d.time * 1000, 
            y_coin: d.cvd_coin,
            y_usdt: d.cvd_usdt 
        }));
        
        // Inisialisasi nilai kumulatif terakhir
        if (liveCvdData.length > 0) {
            const lastPoint = liveCvdData[liveCvdData.length - 1];
            liveCvdValue = lastPoint.y_coin;
            liveCvdValueUsdt = lastPoint.y_usdt;
        }

        const ctx = document.getElementById('cvdChart').getContext('2d');
        if (cvdChartInstance) cvdChartInstance.destroy();
        
        const isDarkMode = document.documentElement.classList.contains('dark');
        const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
        const negativeColor = isDarkMode ? '#f87171' : '#dc2626';

        cvdChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'CVD (USDT)',
                    data: liveCvdData,
                    parsing: {
                        yAxisKey: 'y_usdt' // <-- PENTING: Memberitahu chart untuk menggunakan nilai USDT
                    },
                    fill: false, tension: 0.1, pointRadius: 0, borderWidth: 2,
                    segment: {
                        borderColor: ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor,
                    }
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, animation: false,
                scales: {
                    x: { type: 'time', time: { tooltipFormat: 'MMM dd, HH:mm:ss', unit: 'second' }, grid: { display: false }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563', source: 'auto', maxRotation: 0, autoSkip: true } },
                    y: { grid: { color: isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)' }, ticks: { color: isDarkMode ? '#9ca3af' : '#4b5563' } }
                },
                plugins: { legend: { display: false } },
                interaction: { mode: 'index', intersect: false }
            }
        });

    
        updateCvdTableLive(liveCvdData);
    }   
    const reconnectDelay = 5000; // Coba sambung kembali setiap 5 detik
// ===================================================================================================================================================================================================================================================================================
    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { value: 0, status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { value: 0, status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { value: roc, status: roc > 0 ? 'Positif' : 'Negatif' };
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { value: 0, status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { value: sar, status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateLinearRegressionChannel(closes, period = 14, stdDev = 2) {
        if (closes.length < period) return { upper: 0, middle: 0, lower: 0, status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        
        let sumErrSq = 0;
        for (let i = 0; i < n; i++) {
            const predictedY = intercept + slope * i;
            sumErrSq += Math.pow(y[i] - predictedY, 2);
        }
        const stdErr = Math.sqrt(sumErrSq / (n - 2));

        const middle = intercept + slope * (n - 1);
        const upper = middle + (stdDev * stdErr);
        const lower = middle - (stdDev * stdErr);
        
        const lastClose = closes[closes.length - 1];
        let status = "In Channel";
        if(lastClose > upper) status = "Upper Line Channel";
        if(lastClose < lower) status = "Lower Line Channel";

        return { upper, middle, lower, status };
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateParabolicSAR_forPlot(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return [];
        let sar = parseFloat(klines[0][3]);
        let ep = parseFloat(klines[0][2]);
        let af = step;
        let isUptrend = true;
        const sarData = [];

        for (let i = 1; i < klines.length; i++) {
            const time = klines[i][0] / 1000;
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevSar = sar;

            if (isUptrend) {
                sar = prevSar + af * (ep - prevSar);
                if (low < sar) {
                    isUptrend = false;
                    sar = ep;
                    ep = low;
                    af = step;
                } else {
                    if (high > ep) {
                        ep = high;
                        af = Math.min(max, af + step);
                    }
                }
            } else { // Downtrend
                sar = prevSar - af * (prevSar - ep);
                if (high > sar) {
                    isUptrend = true;
                    sar = ep;
                    ep = high;
                    af = step;
                } else {
                    if (low < ep) {
                        ep = low;
                        af = Math.min(max, af + step);
                    }
                }
            }
            sarData.push({ time, value: sar });
        }
        return sarData;
    }
// =====================================================================================================================================================================
    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i - 1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) {
                obv.push(obv[i - 1] + volume);
            } else if (close < prevClose) {
                obv.push(obv[i - 1] - volume);
            } else {
                obv.push(obv[i - 1]);
            }
        }
        return obv;
    };
// ===================================================================================================================================================================================================================================================================================
    function calculateVWAP(klines, mode = 'rolling', period = 20) {
        if (!klines || klines.length === 0) return 0;

        let sumPV = 0; // sum(Price * Volume)
        let sumV = 0;  // sum(Volume)
        let vwapValues = [];

        if (mode === 'rolling') {
            const recentKlines = klines.slice(-period);
            recentKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;

        } else if (mode === 'session') {
            const todayUTC = new Date().toISOString().slice(0, 10);
            const sessionKlines = klines.filter(k => new Date(k[0]).toISOString().slice(0, 10) === todayUTC);
            if (sessionKlines.length === 0) return 0; // NONE data untuk sesi hari ini
            
            sessionKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;

        } else if (mode === 'anchored') {
            const anchorLookback = 200; // Mencari titik terendah dalam 200 candle terakhir
            const recentSlice = klines.slice(-anchorLookback);
            if (recentSlice.length === 0) return 0;

            let lowestLow = Infinity;
            let anchorIndex = -1;
            
            recentSlice.forEach((k, index) => {
                const low = parseFloat(k[3]);
                if (low < lowestLow) {
                    lowestLow = low;
                    anchorIndex = klines.length - anchorLookback + index;
                }
            });

            const anchoredKlines = klines.slice(anchorIndex);
            anchoredKlines.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;
        }
        return 0; // Fallback
    }
// ===================================================================================================================================================================================================================================================================================
    function calculateCorrelation(dataX, dataY) {
        if (dataX.length !== dataY.length || dataX.length === 0) {
            return null;
        }
        const n = dataX.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += dataX[i];
            sumY += dataY[i];
            sumXY += dataX[i] * dataY[i];
            sumX2 += dataX[i] * dataX[i];
            sumY2 += dataY[i] * dataY[i];
        }

        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

        if (denominator === 0) {
            return 0; 
        }
        
        return numerator / denominator;
    }
// ===================================================================================================================================================================================================================================================================================
    function recalculateAllIndicators(klines, tickerData, prevDayKline, marketType, cvdData, orderBookData, fundingRateData, lsRatioUmumData, openInterestData) {
        if (!klines || klines.length < 50) return {};

        const closes = klines.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        const rsiValues = calculateRSI(closes);
        const ema21Values = calculateEMA(closes, 21);
        const ema50Values = calculateEMA(closes, 50);
        const lastEma21 = ema21Values.filter(v => v !== undefined).pop();
        const lastEma50 = ema50Values.filter(v => v !== undefined).pop();
        const pivotPoints = calculatePivotPoints(prevDayKline);
        const ichimoku = calculateIchimokuCloud(klines);
        const keltnerChannels = calculateKeltnerChannels(klines);
        const activeMode = document.querySelector('.vwap-mode-btn.active')?.dataset.mode || 'rolling';
        const vwapValue = calculateVWAP(klines, activeMode);

        let trendStatus = 'Netral';
        let trendClass = 'text-yellow-400';
        if (lastEma21 > lastEma50) {
            trendStatus = (lastPrice > lastEma21) ? 'Strong Uptrend' : 'Correction in Uptrend';
            trendClass = (lastPrice > lastEma21) ? 'positive' : 'text-yellow-400';
        } else if (lastEma50 > lastEma21) {
            trendStatus = (lastPrice < lastEma21) ? 'Strong Downtrend' : 'Downtrend Rally';
            trendClass = (lastPrice < lastEma21) ? 'negative' : 'text-yellow-400';
        }

        let orderBookBiasText = 'N/A';
        if (orderBookData?.bids && orderBookData?.asks) {
            const totalBidQty = orderBookData.bids.reduce((s, b) => s + parseFloat(b[1]), 0);
            const totalAskQty = orderBookData.asks.reduce((s, a) => s + parseFloat(a[1]), 0);
            orderBookBiasText = totalBidQty > totalAskQty * 1.2 ? 'Bullish (Buyer Limit)' : (totalAskQty > totalBidQty * 1.2 ? 'Bearish (Seller Limit)' : 'Netral');
        }

        const openInterestStatus = (marketType === 'futures' && openInterestData?.openInterest > 0 && tickerData?.priceChangePercent)
            ? (parseFloat(tickerData.priceChangePercent) > 0 ? 'Bullish' : 'Bearish')
            : 'Netral';

        const bb = calculateBollingerBands(closes);
        const bbPriceAction = analyzeBollingerBandsPriceAction(klines, bb);
        const obvValues = calculateOBV(klines);
        const lastObv = obvValues.length > 0 ? obvValues[obvValues.length - 1] : 0;

        return {
            adx: calculateADX(klines),
            cvd: CVDanalyze(klines, cvdData),
            vpvr: calculateVPVR(klines),
            ma: { status: trendStatus, class: trendClass, value21: lastEma21, value50: lastEma50 },
            rsi: {
                values: rsiValues,
                last: rsiValues.filter(v => v !== undefined).pop()?.toFixed(2) || 50,
                status: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'Overbought' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'Oversold' : 'Netral'),
                class: (rsiValues.filter(v => v !== undefined).pop() || 50) > 70 ? 'tag-red' : ((rsiValues.filter(v => v !== undefined).pop() || 50) < 30 ? 'tag-green' : 'tag-yellow')
            },
            rsiDivergence: detectRSIDivergence(closes, rsiValues),
            obvDivergence: detectOBVDivergence(closes, klines),
            stoch: calculateStochasticRSI(closes),
            macd: calculateMACD(closes),
            bollingerBands: { ...bb, rejection: bbPriceAction.rejection, walkTheBands: bbPriceAction.walkTheBands },
            obv: { value: lastObv, trend: lastObv > obvValues[obvValues.length - 2] ? 'Naik' : 'Turun' },
            pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
            atr: calculateATR(klines),
            atrPercent: calculateATRPercentage(klines),
            candlePattern: findCandlestickPatterns(klines),
            chartPattern: findChartPatterns(klines),
            roc: calculateROC(closes),
            psar: calculateParabolicSAR(klines),
            linreg: calculateLinearRegressionChannel(closes),
            vwap: { status: lastPrice > vwapValue ? 'Bullish' : 'Bearish', value: vwapValue },
            obv: { value: lastObv, trend: lastObv > obvValues[obvValues.length - 2] ? 'Naik' : 'Turun' },
            pivot: { status: (lastPrice > pivotPoints?.P) ? 'Bullish' : 'Bearish', data: pivotPoints },
            ichimoku: { status: ichimoku?.status || 'Netral', data: ichimoku },
            keltnerChannels: keltnerChannels,
            fundingRate: fundingRateData,
            lsRatio: lsRatioUmumData?.[0],
            openInterest: { status: openInterestStatus },
            orderBookBias: orderBookBiasText
        };
    }
// ===================================================================================================================================================================================================================================================================================
    function populateCorrelationWidget() {
        const valueEl = document.getElementById('correlation-value');
        const textEl = document.getElementById('correlation-text');        
        const correlationData = realtimeCache.main.correlationData;

        if (correlationData === null || correlationData === undefined) {
            valueEl.textContent = '-';
            textEl.textContent = 'NOT ENOUGH DATA TO CALCULATE.';
            valueEl.className = 'text-base font-sbold text-gray-400 dark:text-gray-500';
            return;
        }

        const value = correlationData;
        valueEl.textContent = value.toFixed(2);

        let text = 'NONE';
        let colorClass = 'text-gray-400 dark:text-gray-500';

        if (value >= 0.7) { text = 'Positif Strong'; colorClass = 'positive'; } 
        else if (value >= 0.4) { text = 'Positive Medium'; colorClass = 'positive'; } 
        else if (value >= 0.1) { text = 'Positive Weak'; colorClass = 'text-yellow-400'; } 
        else if (value <= -0.7) { text = 'Negative Strong'; colorClass = 'negative'; } 
        else if (value <= -0.4) { text = 'Negative Medium'; colorClass = 'negative'; } 
        else if (value <= -0.1) { text = 'Negative Weak'; colorClass = 'text-yellow-400'; }
        
        textEl.textContent = text;
        valueEl.className = `text-lg font-semibold ${colorClass}`;
    }
// ===================================================================================================================================================================================================================================================================================
    function resetDashboard() {
         if (candleCountdownInterval) clearInterval(candleCountdownInterval);
        WebSocketManager.resetSubscriptions();
        if (periodicUpdateInterval) clearInterval(periodicUpdateInterval);
        if (fundingRateTimer) clearInterval(fundingRateTimer);
        
        dashboardContent.classList.add('hidden');
        initialPlaceholder.classList.remove('hidden');

        realtimeCache.main = {};
        realtimeCache.movers = {}; // <-- ADD THIS LINE
        klineCache = {}; 
        orderBookHistory = { avgVolumes: [], maxSize: 30 };
    }
// ===================================================================================================================================================================================================================================================================================
    function updateVwapDisplay(mode) {
        if (!realtimeCache.main.klines) return;
        
        // Gunakan klines yang sesuai dengan timeframe
        const vwapValue = calculateVWAP(realtimeCache.main.klines, mode);
        const lastPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
        
        // Simpan ke cache untuk digunakan oleh skor konfluensi dan AI
        realtimeCache.main.calculatedData.vwap = {
            status: lastPrice > vwapValue ? 'Bullish' : 'Bearish',
            value: vwapValue
        };
        
        // Perbarui tampilan di panel Data Timeframe
        document.getElementById('vwap-20d').textContent = formatPrice(vwapValue);

        // Panggil ulang update skor konfluensi agar ikut berubah
        updateQuickConfluenceWidget();
    }
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
    function renderTriggerBreakdown(breakdown) {
        const container = document.getElementById('trigger-breakdown-list');
        if (!container) return;

        const renderTrigger = (name, triggerData, valueText, conditionText = '') => {
            const safeTriggerData = triggerData || { triggered: false, points: 0 };
            const isTriggered = safeTriggerData.triggered;
            const points = safeTriggerData.points;
            const icon = isTriggered ? '✅' : '▫️';
            const pointsText = isTriggered ? `+${points.toFixed(1).replace('.0', '')} Poin` : `0 Poin`;
            const mainColor = isTriggered ? 'text-green-400' : 'text-gray-500';
            const pointColor = isTriggered ? 'text-green-400' : 'text-gray-500';
            
            return `
                <li class="flex justify-between items-center py-2 border-b border-gray-700/50 ${mainColor}">
                    <span>${icon} ${name}</span>
                    <div class="text-right text-xs">
                        <span class="font-semibold">${valueText}</span>
                        <span class="text-gray-600 ml-1">${conditionText}</span>
                        <br>
                        <span class="font-mono font-bold ${pointColor}">${pointsText}</span>
                    </div>
                </li>
            `;
        };

        let html = '<ul class="list-none">';
        
        html += renderTrigger('Red Candle after HH', breakdown.candleRed, breakdown.candleRed?.triggered ? 'Detected' : 'NONE');
        html += renderTrigger('Bearish Candle', breakdown.doji, breakdown.candlePattern, '(ex: Shooting Star)');
        html += renderTrigger('Volume Exhaustion', breakdown.volumeExhaustion, breakdown.volumeExhaustion?.triggered ? 'DETECTED!' : 'Normal', '(Vol Top < 60% Avg)');
        html += renderTrigger('CVD Nose Dive', breakdown.cvdDip, breakdown.cvdDip?.triggered ? 'Yes' : 'No');
        html += renderTrigger('CVD Divergence', breakdown.cvdDivergence, breakdown.cvdStatus, '');
        // Ganti baris lama dengan ini untuk menampilkan nilai U/M/L
        html += renderTrigger(
            'Rejection Bollinger Band', 
            breakdown.bbRejection, 
            `<span class="text-red-400">U: ${breakdown.bbUpper}</span> / <span class="text-blue-400">M: ${breakdown.bbMiddle}</span> / <span class="text-green-400">L: ${breakdown.bbLower}</span>`,
            breakdown.bbStatus
        );
        html += renderTrigger('MACD Bearish Cross', breakdown.macdCross, `Status: ${breakdown.macdStatus}`);
        html += renderTrigger('RSI Overbought', breakdown.rsiOverbought, `Value: ${breakdown.rsiValue}`, '');

        html += '</ul>';
        container.innerHTML = html;
    }
// ===================================================================================================================================================================================================================================================================================
    function detectSignificantSellWall(asks) {
        if (!asks || asks.length === 0) return null;
        
        let totalVolume = asks.reduce((sum, ask) => sum + parseFloat(ask[1]), 0);
        let avgVolume = totalVolume / asks.length;
        let sellWallVolume = 0;
        const wallThreshold = avgVolume * 5; 
        
        for (const ask of asks) {
            if (parseFloat(ask[1]) > wallThreshold) {
                sellWallVolume += parseFloat(ask[1]);
            }
        }
        
        if (sellWallVolume > totalVolume * 0.2) {
            return { volume: sellWallVolume, type: 'significant' };
        }
        
        return null;
    }
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
    async function updateTopMovers(timeframe = "1h") {
        try {
            const topGainersList = document.getElementById('gainers-list');
            
            if (topGainersList && !topGainersList.hasChildNodes()) {
                const loaderHtml = `<div class="p-4 flex justify-center items-center"><div class="loader"></div></div>`;
                topGainersList.innerHTML = loaderHtml;
                if (losersList) losersList.innerHTML = loaderHtml;
            }

            if (!exchangeInfoCache.futures) await initializeExchangeInfo('futures');
            
            const tradingSymbols = new Set(exchangeInfoCache.futures
                .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
                .map(s => s.symbol)
            );
            
            const ticker24hData = await fetchBinanceAPIData('ticker/24hr', {}, 'futures');
            let usdtPairs = ticker24hData.filter(d => d.symbol.endsWith('USDT') && tradingSymbols.has(d.symbol));

            usdtPairs.forEach(d => {
                const priceChange24h = parseFloat(d.priceChangePercent);
                const volume24h = parseFloat(d.quoteVolume);
                d.strengthScore24h = priceChange24h * Math.log10(volume24h + 1);
            });
            usdtPairs.sort((a, b) => b.strengthScore24h - a.strengthScore24h);
            const candidates = usdtPairs.slice(0, 30);

            let finalSortedGainers;

            if (timeframe !== '24h') {
                const klinesPromises = candidates.map(d => 
                    fetchBinanceAPIData('klines', { symbol: d.symbol, interval: timeframe, limit: 100 }, 'futures').catch(() => null)
                );
                const klinesResults = await Promise.all(klinesPromises);

                candidates.forEach((pair, index) => {
                    const klines = klinesResults[index];
                    if (klines && klines.length > 1) {
                        const firstClose = parseFloat(klines[0][4]);
                        const lastClose = parseFloat(klines[klines.length - 1][4]);
                        const quoteVolume = klines.reduce((sum, k) => sum + (parseFloat(k[5]) * parseFloat(k[4])), 0);
                        const priceChange = firstClose > 0 ? ((lastClose - firstClose) / firstClose) * 100 : 0;
                        pair.strengthScore = priceChange * Math.log10(quoteVolume + 1);
                        pair.dynamicPriceChange = priceChange;
                    } else {
                        pair.strengthScore = -Infinity;
                        pair.dynamicPriceChange = 0;
                    }
                });
                
                candidates.sort((a, b) => b.strengthScore - a.strengthScore);
                finalSortedGainers = candidates.slice(0, 10);

            } else {
                finalSortedGainers = candidates.slice(0, 10);
                finalSortedGainers.forEach(d => d.dynamicPriceChange = parseFloat(d.priceChangePercent));
            }

            // FUNGSI HELPER DIPINDAHKAN KE LUAR LOOP UNTUK EFISIENSI
            const calculateChange = (kData) => {
                if (!kData || kData.length < 2) return 'N/A';
                const prevClose = parseFloat(kData[0][4]);
                const currentClose = parseFloat(kData[1][4]);
                return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
            };

            const gainersWithDetails = await Promise.all(finalSortedGainers.map(async (mover) => {
                const [klines1h, klines15m, klines5m, aggTrades] = await Promise.all([
                    fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                    fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 2 }, 'futures').catch(() => null),
                    fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '5m', limit: 200 }, 'futures').catch(() => []),
                    fetchBinanceAPIData('aggTrades', { symbol: mover.symbol, limit: 1000 }, 'futures').catch(() => [])
                ]);

                realtimeCache.movers[mover.symbol] = { 
                    klines_1h: klines1h,
                    klines_5m: klines5m,
                    aggTrades: aggTrades,
                };

                return { 
                    ...mover, 
                    change1h: calculateChange(klines1h.slice(-2)), 
                    change15m: calculateChange(klines15m) 
                };
            }));

            // >>> AWAL BLOK PENAMBAHAN ASET PIN <<<
    const pinnedAssets = ['BTCUSDT', 'ETHUSDT', 'XRPUSDT', 'SOLUSDT'];
    
    // Filter aset pin yang belum ada di daftar top movers untuk menghindari duplikat
    const existingSymbols = new Set(gainersWithDetails.map(m => m.symbol));
    const assetsToFetch = pinnedAssets.filter(symbol => !existingSymbols.has(symbol));

    if (assetsToFetch.length > 0) {
        // Ambil data ticker untuk aset yang di-pin dari data yang sudah di-fetch
        const pinnedTickers = usdtPairs.filter(d => assetsToFetch.includes(d.symbol));

        // Ambil detail klines untuk aset yang di-pin (logika sama seperti top movers)
        const pinnedAssetsWithDetails = await Promise.all(pinnedTickers.map(async (mover) => {
            const [klines1h, klines15m, klines5m, aggTrades] = await Promise.all([
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '1h', limit: 200 }, 'futures').catch(() => []),
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '15m', limit: 2 }, 'futures').catch(() => null),
                fetchBinanceAPIData('klines', { symbol: mover.symbol, interval: '5m', limit: 200 }, 'futures').catch(() => []),
                fetchBinanceAPIData('aggTrades', { symbol: mover.symbol, limit: 1000 }, 'futures').catch(() => [])
            ]);

            realtimeCache.movers[mover.symbol] = { 
                klines_1h: klines1h,
                klines_5m: klines5m,
                aggTrades: aggTrades,
            };

            // Dapatkan kembali fungsi helper 'calculateChange' jika tidak tersedia secara global
            const calculateChange = (kData) => {
                if (!kData || kData.length < 2) return 'N/A';
                const prevClose = parseFloat(kData[0][4]);
                const currentClose = parseFloat(kData[1][4]);
                return prevClose > 0 ? (((currentClose - prevClose) / prevClose) * 100).toFixed(2) : '0.00';
            };

            return { 
                ...mover, 
                change1h: calculateChange(klines1h.slice(-2)), 
                change15m: calculateChange(klines15m),
                dynamicPriceChange: parseFloat(mover.priceChangePercent)
            };
        }));
        
        // Gabungkan daftar top movers dengan daftar aset yang di-pin
        gainersWithDetails.push(...pinnedAssetsWithDetails);
    }
    // >>> AKHIR BLOK PENAMBAHAN ASET PIN <<<

    
            renderMoversList('gainers-list', gainersWithDetails, true, timeframe);
            
            if (losersList) {
                // Logika untuk losers tetap di sini jika elemennya ada
            }

            attachTopMoversListeners();
            WebSocketManager.subscribeToMovers(gainersWithDetails.map(m => m.symbol));
            
        } catch (error) {
            console.error("Failed Getting Top Movers Data:", error);
            document.getElementById('gainers-list').innerHTML = `<div class="text-red-500 text-xs p-2">Error: ${error.message}. Try Again Later...</div>`;
            const losersList = document.getElementById('losers-list');
            if (losersList) losersList.innerHTML = '';
        }
    }
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
    function renderMoversList(containerId, moversData, isGainer, timeframe) {
        const container = document.getElementById(containerId);
        if (!container) return; // Pengaman jika kontainer NONE

        let html = ""; 
        const maxStrengthScore = isGainer && moversData.length > 0 && moversData[0].strengthScore ? moversData[0].strengthScore : 1;

        moversData.forEach(item => {
            const priceChange24h = parseFloat(item.priceChangePercent);
            // Ganti text-white menjadi text-gray-800 dark:text-white
            let headerHtml = `<div class="flex justify-between items-center text-sm font-semibold"><span class="font-bold text-gray-800 dark:text-white cursor-pointer" onclick="runFullAnalysis('${item.symbol}')">${item.symbol}</span><span class="font-mono text-gray-800 dark:text-white" id="price-${item.symbol}">${formatPrice(parseFloat(item.lastPrice))}</span></div>`;
            let detailsHtml = '';

            if (isGainer) {
                const pumpStrengthPercentage = Math.max(0, item.dynamicPriceChange > 0 ? Math.min(100, item.dynamicPriceChange * 2) : 0);
                
                const formatChange = (val, lbl) => {
                    if (val === 'N/A' || isNaN(parseFloat(val))) return `<span class="text-gray-500">${lbl}: --</span>`;
                    const value = parseFloat(val);
                    const color = value >= 0 ? 'positive' : 'negative';
                    // Logika untuk menyorot timeframe aktif
                    const isPrimary = timeframe && timeframe.toUpperCase() === lbl;
                    return `<span class="${color} ${isPrimary ? 'font-bold underline' : ''}">${lbl}: ${value.toFixed(2)}%</span>`;
                };

                detailsHtml = `<div class="flex justify-between items-center">
                    <div class="flex items-center gap-2 text-xs font-mono">
                        ${formatChange(priceChange24h, '24H')} 
                        ${formatChange(item.change1h, '1H')} 
                        ${formatChange(item.change15m, '15M')}
                    </div>
                    <div class="hybrid-bar" id="hybrid-bar-${item.symbol}">
                        <div class="pump-strength" style="width: ${pumpStrengthPercentage}%"></div>
                        <div class="dump-risk" style="width:0%;"></div>
                    </div>
                </div>`;
            } else {
            }
            
            html += `<div class="flex flex-col bg-gray-100 dark:bg-gray-800 p-2 rounded gap-2 mover-item" data-symbol="${item.symbol}">${headerHtml}${detailsHtml}</div>`;
            });

        container.innerHTML = html || `<div class="text-xs text-gray-500 p-2">NONE data.</div>`;
    }
// ===================================================================================================================================================================================================================================================================================
// =================================================POSSIBLE DUPILICATE==============DUPLICATE REMOVED!!!====================================================================================================================================================================================================================
    function calculateShortConfluenceScore(symbol, timeframe) {
        if (!symbol) return { score: 0, breakdown: {} };

        // ================== LOGIKA PEMILIHAN DATA (TETAP SAMA) ==================
        let klines;
        let aggTrades;

        if (symbol === realtimeCache.main.symbol) {
            klines = realtimeCache.main.multiTfKlines[timeframe];
            aggTrades = realtimeCache.main.cvdData ? null : realtimeCache.main.aggTrades;
        } else if (realtimeCache.movers[symbol]) {
            if (timeframe === '5m') {
                klines = realtimeCache.movers[symbol].klines_5m;
            } else {
                klines = realtimeCache.movers[symbol].klines_1h;
            }
            aggTrades = realtimeCache.movers[symbol].aggTrades;
        } else {
            console.error(`NONE data cache yang ditemukan untuk simbol ${symbol}`);
            return { score: 0, breakdown: {} };
        }
        
        if (!klines || klines.length < 50) {
            return { score: 0, breakdown: {} };
        }

        const closes = klines.map(k => parseFloat(k[4]));
        const cvdDataForAnalysis = (symbol === realtimeCache.main.symbol && realtimeCache.main.cvdData) 
            ? realtimeCache.main.cvdData 
            : calculateCVD(aggTrades || []);

        // ==========================================================
        // === AWAL BLOK PERUBAHAN & TAMBAHAN UNTUK BOLLINGER BANDS ===
        // ==========================================================
        
        // 1. Hitung data BB lengkap sekali saja untuk efisiensi
        const bbData = calculateBollingerBands(closes);
        
        // 2. Ekstrak nilai terakhir dari Upper, Middle, dan Lower band
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop() || 0;
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop() || 0;
        const lastLower = bbData.lower.filter(v => v !== undefined).pop() || 0;

        const indicators = {
            candlePattern: findCandlestickPatterns(klines),
            macd: calculateMACD(closes),
            rsi: calculateRSI(closes),
            // 3. Gunakan bbData yang sudah dihitung untuk analisis rejection
            bollingerBands: analyzeBollingerBandsPriceAction(klines, bbData), 
            cvd: CVDanalyze(klines, cvdDataForAnalysis),
            atr: calculateATR(klines)
        };
        
        const atrStatus = indicators.atr.status;
        let volatilityMultiplier = 1.0; 

        if (atrStatus === 'High') {
            volatilityMultiplier = 0.75;
        } else if (atrStatus === 'Very High') {
            volatilityMultiplier = 0.5;
        }

        const lastRsiValue = indicators.rsi.filter(v => v !== undefined).pop() || 50;
        let score = 0;
        
        let breakdown = {
            rsiValue: lastRsiValue.toFixed(2),
            macdStatus: indicators.macd.status,
            bbStatus: indicators.bollingerBands.rejection,
            // 4. Tambahkan nilai U/M/L yang sudah diformat ke objek breakdown
            bbUpper: formatPrice(lastUpper),
            bbMiddle: formatPrice(lastMiddle),
            bbLower: formatPrice(lastLower),
            cvdStatus: indicators.cvd.divergence,
            candlePattern: indicators.candlePattern.pattern,
            candleRed: { triggered: false, points: 0 },
            doji: { triggered: false, points: 0 },
            cvdDip: { triggered: false, points: 0 },
            cvdDivergence: { triggered: false, points: 0 },
            rsiOverbought: { triggered: false, points: 0 },
            bbRejection: { triggered: false, points: 0 },
            macdCross: { triggered: false, points: 0 },
            volumeExhaustion: { triggered: false, points: 0 }
        };

        // ========================================================
        // === AKHIR BLOK PERUBAHAN & TAMBAHAN ===
        // ========================================================

        const lookbackPeriod = 15;
        const recentKlines = klines.slice(-lookbackPeriod);
        
        if (recentKlines.length >= 3) {
            let peakIndex = 0;
            for (let i = 1; i < recentKlines.length; i++) {
                if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
            }

            if (peakIndex < lookbackPeriod - 2) {
                const triggerCandleArr = recentKlines[peakIndex + 1];
                if (triggerCandleArr) {
                    const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                    if (triggerCandle.Close < triggerCandle.Open) {
                        const points = 3 * volatilityMultiplier;
                        score += points;
                        breakdown.candleRed = { triggered: true, points: points };
                    }
                }
            }
            
            if (peakIndex > 4 && peakIndex < recentKlines.length - 1) {
                const pumpVolumeLookback = 5;
                const pumpCandles = recentKlines.slice(peakIndex - pumpVolumeLookback, peakIndex);
                
                if (pumpCandles.length > 0) {
                    const avgPumpVolume = pumpCandles.reduce((sum, k) => sum + parseFloat(k[5]), 0) / pumpCandles.length;
                    const peakVolume = parseFloat(recentKlines[peakIndex][5]);

                    if (peakVolume < (avgPumpVolume * 0.6)) {
                        const points = 2;
                        score += points;
                        breakdown.volumeExhaustion = { triggered: true, points: points };
                    }
                }
            }
        }
        
        if (indicators.candlePattern.bias === 'BEARISH') {
            const points = 1 * volatilityMultiplier;
            score += points;
            breakdown.doji = { triggered: true, points: points };
        }

        const now = Date.now();
        if (now - lastCvdDipCalculationTime > CVD_DIP_DEBOUNCE_MS) {
            lastCvdDipCalculationTime = now; 
            const cvdValues = cvdDataForAnalysis.map(d => d.cvd_usdt);
            const changeLookback = 50;
            const stdDevMultiplier = 1.3;

            if (cvdValues.length > changeLookback) {
                let cvdChanges = [];
                for (let i = cvdValues.length - changeLookback; i < cvdValues.length; i++) {
                    cvdChanges.push(cvdValues[i] - cvdValues[i - 1]);
                }
                const avgChange = cvdChanges.reduce((sum, val) => sum + val, 0) / changeLookback;
                const variance = cvdChanges.reduce((sum, val) => sum + Math.pow(val - avgChange, 2), 0) / changeLookback;
                const stdDev = Math.sqrt(variance);
                const lastChange = cvdChanges[cvdChanges.length - 1];
                if (lastChange < (avgChange - (stdDevMultiplier * stdDev))) {
                    const points = 0.09 * volatilityMultiplier;
                    lastCvdDipResult = { triggered: true, points: points }; 
                } else {
                    lastCvdDipResult = { triggered: false, points: 0 };
                }
            } else {
                lastCvdDipResult = { triggered: false, points: 0 };
            }
        }
        
        if(lastCvdDipResult.triggered) {
            score += lastCvdDipResult.points;
        }
        breakdown.cvdDip = lastCvdDipResult;

        if (indicators.cvd.divergence.includes('Bearish')) {
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.cvdDivergence = { triggered: true, points: points };
        }
        
        if (lastRsiValue > 70) {
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.rsiOverbought = { triggered: true, points: points };
        }

        if (indicators.bollingerBands.rejection === 'Bearish Rejection (Upper BB)') {
            score += 3;
            breakdown.bbRejection = { triggered: true, points: 3 };
        }
        if (indicators.macd.status === 'Bearish Cross') {
            score += 2;
            breakdown.macdCross = { triggered: true, points: 2 };
        }   
        return { score: Math.min(score, 10), breakdown };
    }
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
    function getConfluenceAnalysis(klines) {
        if (!klines || klines.length < 50) {
            return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
        }

        let skorBullish = 0;
        let skorBearish = 0;
        const closes = klines.map(k => parseFloat(k[4]));

        // --- Kalkulasi Indikator Penting ---
        const rsiValues = calculateRSI(closes);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const macd = calculateMACD(closes);
        const candlePattern = findCandlestickPatterns(klines);
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);

        // --- Logika Penilaian Bearish ---
        if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
        if (macd.status === 'Bearish Cross') skorBearish += 2.0;
        if (lastRsi > 70) skorBearish += 1.5; // Overbought
        if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

        // --- Logika Penilaian Bullish ---
        if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
        if (macd.status === 'Bullish Cross') skorBullish += 2.0;
        if (lastRsi < 30) skorBullish += 1.5; // Oversold
        if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
        
        // Total skor maksimal adalah 8
        const totalPossibleScore = 8.0;

        return { 
            skorBullish: (skorBullish / totalPossibleScore) * 10,
            skorBearish: (skorBearish / totalPossibleScore) * 10,
            detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
        };
    }
// ===================================================================================================================================================================================================================================================================================
    function onNewMoverData(symbol, streamName, payload) {
        if (!realtimeCache.movers[symbol]) {
            realtimeCache.movers[symbol] = { klines_1h: [], aggTrades: [], orderBook: { bids: [], asks: [] } };
        }
        const moverData = realtimeCache.movers[symbol];

        // Blok untuk memproses update kline 1 jam
        if (streamName.includes('@kline_1h')) {
            const k = payload.k;
            // Format kline baru sebagai ARRAY agar konsisten dengan data awal
            const newKlineArray = [
                k.t, k.o, k.h, k.l, k.c, k.v, k.T, 
                k.q, k.n, k.V, k.Q, k.B
            ];

            // Cek kline terakhir berdasarkan timestamp di indeks [0]
            if (moverData.klines_1h && moverData.klines_1h.length > 0 && moverData.klines_1h[moverData.klines_1h.length - 1][0] === k.t) {
                // Update kline terakhir jika timestamp sama
                moverData.klines_1h[moverData.klines_1h.length - 1] = newKlineArray;
            } else {
                // Tambahkan kline baru jika ini candle baru
                moverData.klines_1h.push(newKlineArray);
            }
            
            // Jaga agar panjang array tidak melebihi batas
            if (moverData.klines_1h.length > 200) {
                moverData.klines_1h.shift();
            }
        } 
        // Blok untuk memproses update trade
        else if (streamName.includes('@aggTrade')) {
            moverData.aggTrades.push(payload);
            if (moverData.aggTrades.length > 1000) moverData.aggTrades.shift();
        } 
        // Blok untuk memproses update order book
        else if (streamName.includes('@depth20')) {
            moverData.orderBook = { bids: payload.bids, asks: payload.asks };
        }
        
        // ================== AWAL BLOK PERBAIKAN FINAL ==================
        // Menghitung dan memperbarui "Bullish Momentum" bar secara real-time untuk setiap mover
        let pumpStrengthPercentage = 0;
        const klines1h = moverData.klines_1h;
        if (klines1h && klines1h.length >= 2) {
            const prevClose = parseFloat(klines1h[klines1h.length - 2][4]);
            const lastClose = parseFloat(klines1h[klines1h.length - 1][4]);
            const change1h = prevClose > 0 ? ((lastClose - prevClose) / prevClose) * 100 : 0;
            // Kalkulasi sederhana: persentase kenaikan dikali 2, maks 100%
            pumpStrengthPercentage = Math.max(0, change1h > 0 ? Math.min(100, change1h * 2) : 0);
        }
        
        // Update langsung elemen UI (bar) untuk mover yang bersangkutan
        const pumpBarElement = document.querySelector(`#hybrid-bar-${symbol} .pump-strength`);
        if (pumpBarElement) {
            pumpBarElement.style.width = `${pumpStrengthPercentage}%`;
        }
        // =================== AKHIR BLOK PERBAIKAN FINAL ===================

        // Menghitung skor Dump Potention
        const scoreData = calculateShortConfluenceScore(symbol, '5m');

        if (scoreData !== null) {
            // Memperbarui UI skor Dump Potention
            updateShortScoreUI(symbol, scoreData.score, scoreData.breakdown);

            // Sinkronisasi dengan panel utama jika mover yang diupdate adalah aset yang sedang dianalisis
            if (realtimeCache.main.symbol === symbol) {
                const klines1h_sync = moverData.klines_1h;
                
                // Perbarui skor pump/dump di cache utama
                if (klines1h_sync.length >= 2) {
                    // Anda bisa menambahkan logika skor pump yang lebih kompleks di sini jika perlu
                    // Untuk sekarang, kita akan sinkronkan skor pump & dump
                }
                realtimeCache.main.liveScores.pumpStrength = pumpStrengthPercentage;
                realtimeCache.main.liveScores.dumpRisk = scoreData.score;
                
                // Sinkronkan data kline 1 jam terbaru ke cache utama SEBELUM render ulang
                realtimeCache.main.klines1h = klines1h_sync;

                // Panggil ulang render panel scalping dengan data terbaru
                calculateAndDisplayScalpingSetup();
            }
        }
    }
// ===================================================================================================================================================================================================================================================================================
// GANTI SELURUH FUNGSI LAMA ANDA DENGAN VERSI FINAL INI
    function calculateAndDisplayScalpingSetup() {
        const selectedDumpTf = document.getElementById('dump-trigger-timeframe-select').value;
        const { klines, calculatedData, symbol, selectedTimeframe, tfAlignmentSummary } = realtimeCache.main;
        if (!klines || klines.length < 50 || !calculatedData) {
            document.getElementById('scalping-setup-content').innerHTML = '<p class="text-sm text-gray-500">Not Enough Data</p>';
            return;
        }
        document.getElementById('scalping-timeframe-display').textContent = `💲${symbol} at TF ${selectedTimeframe}`;
        const scoreData = calculateShortConfluenceScore(symbol, selectedDumpTf) || { score: 0, breakdown: {} };
        const dumpRiskScore = scoreData.score;
        const triggerBreakdown = scoreData.breakdown;
        const pumpStrength = realtimeCache.main.liveScores.pumpStrength || 0;
        document.getElementById('main-pump-bar').style.width = `${pumpStrength}%`;
        document.getElementById('main-dump-bar').style.width = `${dumpRiskScore * 10}%`;
        document.getElementById('main-pump-score').textContent = `${pumpStrength.toFixed(0)}%`;
        document.getElementById('main-dump-score').textContent = `${dumpRiskScore}/10`;
        renderTriggerBreakdown(triggerBreakdown);

        const container = document.getElementById('scalping-setup-content');
        const closes = klines.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        
        // --- Langkah 1: Tentukan sinyal dan tren (logika tetap sama) ---
        let biasKontekstual = "NETRAL / CHOP";
        let biasClass = "status-chop";
        let biasDetail = "Waiting Signal...";
        let trenUtama = "CHOP";
        let trenUtamaClass = "status-chop";

        if (tfAlignmentSummary && tfAlignmentSummary.summary['1h']) {
            const trend1h = tfAlignmentSummary.summary['1h'];
            if (trend1h === 'UPTREND') { trenUtama = "UPTREND"; trenUtamaClass = "status-uptrend"; } 
            else if (trend1h === 'DOWNTREND') { trenUtama = "DOWNTREND"; trenUtamaClass = "status-downtrend"; }
        }

        const analisisTrigger = getConfluenceAnalysis(klines); 
        const { skorBullish, skorBearish, detail } = analisisTrigger;
        biasDetail = detail;

        if (skorBullish > skorBearish + 1.5) {
            if (trenUtama === 'UPTREND') { biasKontekstual = 'LONG (Follow Trend)'; biasClass = 'status-uptrend'; } 
            else if (trenUtama === 'DOWNTREND') { biasKontekstual = 'LONG (Counter Trend)'; biasClass = 'status-uptrend'; } 
            else { biasKontekstual = 'LONG (Range Trading)'; biasClass = 'status-uptrend'; }
        } else if (skorBearish > skorBullish + 1.5) {
            if (trenUtama === 'DOWNTREND') { biasKontekstual = 'SHORT (Follow Trend)'; biasClass = 'status-downtrend'; } 
            else if (trenUtama === 'UPTREND') { biasKontekstual = 'SHORT (Counter Trend)'; biasClass = 'status-downtrend'; } 
            else { biasKontekstual = 'SHORT (Range Trading)'; biasClass = 'status-downtrend'; }
        }

        // --- Langkah 2: Inisialisasi semua variabel dengan nilai placeholder ---
        let entryPrice = '--', stopLoss = '--', takeProfit1 = '--', takeProfit2 = '--', takeProfit3 = 'N/A';
        let entryPercent = '', slPercent = '', tp1Percent = '', tp2Percent = '', tp3Percent = '';
        let slColorClass = 'text-gray-500', tpColorClass = 'text-gray-500';
        let finalVerdictHtml = '';

        // --- Langkah 3: Isi variabel dengan data nyata HANYA JIKA ada sinyal ---
        if (biasKontekstual !== "NETRAL / CHOP") {
            const biasKalkulator = biasKontekstual.startsWith('LONG') ? 'LONG' : 'SHORT';
            const ema9 = calculateEMA(closes, 9).pop();
            const recentKlines = klines.slice(-15);
            const recentSwingHigh = Math.max(...recentKlines.map(k => parseFloat(k[2])));
            const recentSwingLow = Math.min(...recentKlines.map(k => parseFloat(k[3])));

            if (biasKalkulator === 'LONG') {
                entryPrice = ema9;
                stopLoss = recentSwingLow * 0.999;
                takeProfit1 = recentSwingHigh;
                takeProfit2 = entryPrice + (Math.abs(entryPrice - stopLoss) * 1.5);
            } else { // SHORT
                entryPrice = ema9;
                stopLoss = recentSwingHigh * 1.001;
                takeProfit1 = recentSwingLow;
                takeProfit2 = entryPrice - (Math.abs(stopLoss - entryPrice) * 1.5);
            }
            
            const calculatePercentage = (target, entry) => (typeof target !== 'number' || entry === 0) ? '' : `(${( (target - entry) / entry * 100).toFixed(2)}%)`;
            entryPercent = `(Pullback to ${calculatePercentage(entryPrice, lastPrice)})`;
            slPercent = calculatePercentage(stopLoss, entryPrice);
            tp1Percent = calculatePercentage(takeProfit1, entryPrice);
            tp2Percent = calculatePercentage(takeProfit2, entryPrice);
            slColorClass = 'negative';
            tpColorClass = 'positive';
            realtimeCache.main.latestScalpingSetup = { entry: entryPrice, sl: stopLoss, tp1: takeProfit1 };
        } else {
            finalVerdictHtml = `
                <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-center p-4 rounded-lg bg-gray-100 dark:bg-gray-800/50">
                    <p class="font-semibold text-yellow-400">SIDEWAYS</p>
                    <p class="text-sm text-gray-400 mt-1">No Feasible Long/Short Setup. Do Not Trade.</p>
                </div>
            `;
            realtimeCache.main.latestScalpingSetup = null;
        }
        
        const tp3Display = takeProfit3 !== 'N/A' ? `${formatPrice(takeProfit3)}<br><span class="text-xs font-mono ${tpColorClass}">${tp3Percent}</span>` : '<span class="text-gray-400 dark:text-gray-600">N/A</span>';
        
        // --- Langkah 4: BLOK RENDER TUNGGAL (STATIS) ---
        // Struktur HTML ini akan selalu sama, hanya isinya yang berubah.
        container.innerHTML = `
            <div class="grid grid-cols-3 gap-4 text-center items-start">
                <div class="col-span-1">
                    <p class="text-xs text-gray-500">Contextual Bias (TF: 1H)</p>
                    <p class="text-[10px] font-mono ${trenUtamaClass}">1H Trend: ${trenUtama}</p> 
                    <p class="text-sm font-semiboldblinking-text-animation ${biasClass}">${biasKontekstual}</p>
                    <p class="text-xs text-gray-400 font-mono">${biasDetail}</p>
                </div>
                <div class="col-span-2 grid grid-cols-2 gap-4">
                    <div>
                        <p class="text-xs text-gray-500">Entry</p>
                        <p class="font-normal text-sm text-yellow-400">${formatPrice(entryPrice)}</p>
                        <p class="text-xs font-mono text-yellow-500">${entryPercent}</p>
                    </div>
                    <div>
                        <p class="text-sm text-gray-500">SL (Structural)</p>
                        <p class="font-normal text-sm ${slColorClass}">${formatPrice(stopLoss)}</p>
                        <p class="text-xs font-mono ${slColorClass}">${slPercent}</p>
                    </div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 grid grid-cols-3 gap-4 text-center items-start">
                <div>
                    <p class="text-xs text-gray-500">TP 1 (Structural)</p>
                    <p class="font-normal ${tpColorClass}">${formatPrice(takeProfit1)}</p>
                    <p class="text-xs font-mono ${tpColorClass}">${tp1Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 2 (R:R 1:1.5)</p>
                    <p class="font-normal ${tpColorClass}">${formatPrice(takeProfit2)}</p>
                    <p class="text-xs font-mono ${tpColorClass}">${tp2Percent}</p>
                </div>
                <div>
                    <p class="text-xs text-gray-500">TP 3 (Key Level)</p>
                    <p class="font-semibold text-sm">${tp3Display}</p>
                </div>
            </div>
            <div class="min-h-[90px] flex flex-col justify-center">
                ${finalVerdictHtml}
            </div>
        `;
    }
// ===================================================================================================================================================================================================================================================================================
    function updateShortScoreUI(symbol, score, breakdown) {
        const dumpRiskElement = document.querySelector(`#hybrid-bar-${symbol} .dump-risk`);
        if (dumpRiskElement) dumpRiskElement.style.width = `${score * 10}%`;
        const moverItem = document.querySelector(`.mover-item[data-symbol="${symbol}"]`);
        if (moverItem) {
            moverItem.dataset.dumpRiskScore = score;
            moverItem.dataset.breakdown = JSON.stringify(breakdown || {});
        }
    }
// ===================================================================================================================================================================================================================================================================================
    function attachTopMoversListeners() {
        document.querySelectorAll("#gainers-list .mover-item").forEach(el => {
            el.addEventListener("mouseenter", e => { showCustomTooltip(e.currentTarget); });
            el.addEventListener("mouseleave", () => { hideCustomTooltip(); });
            el.addEventListener("click", e => {
                if (!el.classList.contains("tooltip-active")) {
                    document.querySelectorAll('.mover-item.tooltip-active').forEach(activeEl => activeEl.classList.remove('tooltip-active'));
                    el.classList.add("tooltip-active");
                    showCustomTooltip(e.currentTarget);
                    e.stopPropagation();
                } else {
                    el.classList.remove("tooltip-active");
                    hideCustomTooltip();
                    runFullAnalysis(el.dataset.symbol);
                }
            });
        });
    }
// ===================================================================================================================================================================================================================================================================================
    function showCustomTooltip(target) {
        isTooltipActive = true;
        const tooltip = document.getElementById("custom-tooltip");
        const symbol = target.dataset.symbol;
        const score = target.dataset.dumpRiskScore || '0';
        const breakdown = JSON.parse(target.dataset.breakdown || '{}');

        tooltip.innerHTML = `
            <strong>${symbol} - Analisis Short</strong>
            <p>Skor Potensi Dump: ${score}/10</p>
            <ul class="list-none text-xs mt-2 space-y-1">
                <li>Candle Merah: ${breakdown.candleRed ? "✅" : "▫️"}</li>
                <li>CVD Menukik: ${breakdown.cvd ? "✅" : "▫️"}</li>
                <li>Shooting Star/Doji: ${breakdown.doji ? "✅" : "▫️"}</li>
                <li class="italic text-gray-500">Resistance & Sell Wall (di panel utama)</li>
            </ul>`;
        tooltip.style.opacity = 1;
        tooltip.style.visibility = "visible";
        const rect = target.getBoundingClientRect();
        tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
        tooltip.style.left = `${rect.left + window.scrollX}px`;
    }
// ===================================================================================================================================================================================================================================================================================
    function hideCustomTooltip() {
        isTooltipActive = false;
        const tooltip = document.getElementById("custom-tooltip");
        if(tooltip) {
            tooltip.style.opacity = 0;
            tooltip.style.visibility = "hidden";
        }
        document.querySelectorAll('.mover-item.tooltip-active').forEach(el => el.classList.remove('tooltip-active'));
    }
// ===================================================================================================================================================================================================================================================================================
    function initTopMoversTimeframeSelector() {
        document.querySelectorAll(".top-movers-tf-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                document.querySelectorAll(".top-movers-tf-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                const timeframe = btn.dataset.timeframe;
                startTopMoversAutoRefresh(timeframe, currentInterval);
            });
        });
    }
// ===================================================================================================================================================================================================================================================================================
    function initRefreshIntervalSelector() {
        const select = document.getElementById("refresh-interval-select");
        select.addEventListener("change", () => {
            const interval = parseInt(select.value, 10);
            startTopMoversAutoRefresh(currentTimeframe, interval);
        });
    }

    function startTopMoversAutoRefresh(timeframe = "1h", interval = 10000) {
        currentTimeframe = timeframe;
        currentInterval = interval;
        remainingTime = interval / 1000;
        if (topMoversInterval) clearInterval(topMoversInterval);
        if (topMoversCountdown) clearInterval(topMoversCountdown);
        
        updateTopMovers(timeframe);
        
        topMoversInterval = setInterval(() => {
            if (!isTooltipActive) {
                updateTopMovers(timeframe);
                remainingTime = interval / 1000;
            }
        }, interval);
        
        topMoversCountdown = setInterval(() => {
            if (!isTooltipActive) {
                remainingTime--;
                if (remainingTime < 0) remainingTime = interval / 1000;
            }
            const countdownEl = document.getElementById("refresh-countdown");
            if (countdownEl) {
                countdownEl.textContent = isTooltipActive ? "⏸ Paused" : `⏱️ ${remainingTime}s`;
            }
        }, 1000);
    }
// ================================================================

    // =====================================================================================================================================================================
// ================================================================
// === GANTI SELURUH BLOK tsCalc DAN initializeNewCalculator ANDA DENGAN INI ===
// ================================================================
// ================================================================
// === GANTI SELURUH BLOK tsCalc DAN initializeNewCalculator ANDA DENGAN INI ===
// ================================================================
const tsCalc = {
    elements: {
        leverage: document.getElementById('ts-leverage'),
        cost: document.getElementById('ts-cost'),
        slider: document.getElementById('ts-margin-slider'),
        walletBalance: document.getElementById('ts-wallet-balance'),
        marketPrice: document.getElementById('ts-market-price'),
        tpslToggle: document.getElementById('ts-tpsl-toggle'),
        tpslInputs: document.getElementById('ts-tpsl-inputs'),
        takeProfit: document.getElementById('ts-take-profit'),
        stopLoss: document.getElementById('ts-stop-loss'),
        resultCost: document.getElementById('ts-result-cost'),
        resultMax: document.getElementById('ts-result-max'),
        resultPosSize: document.getElementById('ts-result-position-size'),
        resultLiqPrice: document.getElementById('ts-result-liq-price'),
        resultStatus: document.getElementById('ts-result-status'),
        resultSlPrice: document.getElementById('ts-result-sl-price'),
        resultRoe: document.getElementById('ts-result-roe'),
        crossBtn: document.getElementById('ts-mode-cross'),
        isolatedBtn: document.getElementById('ts-mode-isolated'),
        buyBtn: document.getElementById('ts-buy-long-btn'),
        sellBtn: document.getElementById('ts-sell-short-btn'),
        autofillBtn: document.getElementById('autofill-ts-btn'),
        tsOptionsBtn: document.getElementById('ts-trailing-stop-options'),
        // Elemen Modal
        modalContainer: document.getElementById('ts-modal-container'),
        modalCallbackRate: document.getElementById('ts-modal-callback-rate'),
        modalActivationPrice: document.getElementById('ts-modal-activation-price'),
        modalSaveBtn: document.getElementById('ts-modal-save-btn'),
        modalCloseBtn: document.getElementById('ts-modal-close-btn')
    },
    state: {
        marginMode: 'cross',
        leverage: 20,
        cost: 0,
        entryPrice: 0,
        walletBalance: 1000,
        tp: null,
        sl: null,
        callbackRate: null,
        activationPrice: null,
        positionType: 'long'
    },
    
    recalculate: function() {
        this.state.walletBalance = parseFloat(this.elements.walletBalance.value) || 0;
        this.state.leverage = parseFloat(this.elements.leverage.value) || 20;
        this.state.cost = parseFloat(this.elements.cost.value) || 0;
        const marketPrice = parseFloat(this.elements.marketPrice.value);

        const lastPrice = realtimeCache.main.tickerData?.lastPrice ? parseFloat(realtimeCache.main.tickerData.lastPrice) : this.state.entryPrice;
        if (lastPrice === 0 && !marketPrice) return;
        const entry = this.state.entryPrice || lastPrice;

        const positionSize = this.state.cost * this.state.leverage;
        const quantity = entry > 0 ? positionSize / entry : 0;
        
        this.elements.resultCost.textContent = `${this.state.cost.toFixed(2)} USDT`;
        this.elements.resultMax.textContent = `${this.state.walletBalance.toFixed(2)} USDT`;
        this.elements.resultPosSize.textContent = `${positionSize.toFixed(2)} USDT`;
        
        let liqPrice = 0;
        const maintenanceMarginRate = 0.004;
        if (positionSize > 0) {
            if (this.state.marginMode === 'isolated') {
                const priceChange = (this.state.cost / positionSize) * (1 - maintenanceMarginRate);
                liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
            } else { // Cross
                const priceChange = ((this.state.walletBalance) / positionSize) * (1 - maintenanceMarginRate);
                liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
            }
        }
        this.elements.resultLiqPrice.textContent = liqPrice > 0 ? `${liqPrice.toFixed(4)} USDT` : 'N/A';
        
        if (this.state.callbackRate && this.state.activationPrice && !isNaN(marketPrice)) {
            let isActive = false;
            let stopLossPrice = 0;

            if (this.state.positionType === 'long' ? marketPrice >= this.state.activationPrice : marketPrice <= this.state.activationPrice) {
                isActive = true;
                const rate = this.state.callbackRate / 100;
                stopLossPrice = this.state.positionType === 'long' ? marketPrice * (1 - rate) : marketPrice * (1 + rate);
                
                this.elements.resultStatus.textContent = 'Aktif ✅';
                this.elements.resultStatus.className = 'positive';
                this.elements.resultSlPrice.textContent = `${stopLossPrice.toFixed(4)} USDT`;

                const pnl = (this.state.positionType === 'long') ? (stopLossPrice - entry) * quantity : (entry - stopLossPrice) * quantity;
                const roe = this.state.cost > 0 ? (pnl / this.state.cost) * 100 : 0;
                this.elements.resultRoe.textContent = `${roe.toFixed(2)}%`;
                this.elements.resultRoe.className = pnl >= 0 ? 'profit positive' : 'loss negative';
            } else {
                this.elements.resultStatus.textContent = 'Belum Aktif';
                this.elements.resultStatus.className = 'text-yellow-400';
                this.elements.resultSlPrice.textContent = '--';
                this.elements.resultRoe.textContent = '--';
                this.elements.resultRoe.className = '';
            }
        } else {
            this.elements.resultStatus.textContent = 'Belum Diatur';
            this.elements.resultStatus.className = 'text-gray-500';
            this.elements.resultSlPrice.textContent = '--';
            this.elements.resultRoe.textContent = '--';
            this.elements.resultRoe.className = '';
        }
    },

    // Di dalam objek tsCalc
    autofill: function() {
        // Ambil setup terbaru dari cache
        // Di dalam tsCalc.autofill
        const setup = realtimeCache.main.latestScalpingSetup; // Benar 'i'
        
        if (!setup || !setup.entry) { // Pengecekan lebih kuat
            alert("Setup scalping belum siap atau pasar sedang sideways. Tidak bisa auto-fill.");
            return;
        }
        
        // Tentukan tipe posisi dari setup
        const isLong = setup.tp1 > setup.entry;
        this.state.positionType = isLong ? 'long' : 'short';
        
        // Perbarui UI tombol Buy/Sell
        if(isLong) {
            this.elements.buyBtn.classList.remove('opacity-50');
            this.elements.sellBtn.classList.add('opacity-50');
        } else {
            this.elements.sellBtn.classList.remove('opacity-50');
            this.elements.buyBtn.classList.add('opacity-50');
        }
        
        // Dapatkan harga pasar saat ini dari cache
        const currentMarketPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
        const precision = getPrecisionForAsset(currentMarketPrice);

        // Isi semua field di kalkulator
        this.elements.marketPrice.value = currentMarketPrice.toFixed(precision); // Harga saat ini
        this.elements.takeProfit.value = setup.tp1.toFixed(precision); // TP dari scalping setup
        this.elements.stopLoss.value = setup.sl.toFixed(precision);   // SL dari scalping setup

        // Aktifkan toggle TP/SL
        this.elements.tpslToggle.checked = true;
        this.elements.tpslInputs.classList.remove('hidden');

        // Beri fokus ke input modal agar pengguna bisa langsung mengisi
        this.elements.cost.focus();
        this.recalculate(); // Hitung ulang semua nilai di kalkulator
        
        // Scroll ke kalkulator agar terlihat
        this.elements.leverage.scrollIntoView({ behavior: 'smooth', block: 'center' });
    },
};

function initializeNewCalculator() {
    const { elements, state } = tsCalc;
    
    elements.sellBtn.classList.add('opacity-50');
    state.positionType = 'long';

    elements.crossBtn.addEventListener('click', () => {
        state.marginMode = 'cross';
        elements.crossBtn.classList.add('active');
        elements.isolatedBtn.classList.remove('active');
        tsCalc.recalculate();
    });
    elements.isolatedBtn.addEventListener('click', () => {
        state.marginMode = 'isolated';
        elements.isolatedBtn.classList.add('active');
        elements.crossBtn.classList.remove('active');
        tsCalc.recalculate();
    });
    elements.buyBtn.addEventListener('click', () => {
        state.positionType = 'long';
        elements.buyBtn.classList.remove('opacity-50');
        elements.sellBtn.classList.add('opacity-50');
        
        // --- TAMBAHAN BARU ---
        if (confirm(`Buka posisi LONG simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
            paperTrade.openPosition('long', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
        }
        // --- AKHIR TAMBAHAN ---
        
        tsCalc.recalculate();
    });
    elements.sellBtn.addEventListener('click', () => {
        state.positionType = 'short';
        elements.sellBtn.classList.remove('opacity-50');
        elements.buyBtn.classList.add('opacity-50');
        
        // --- TAMBAHAN BARU ---
        if (confirm(`Buka posisi SHORT simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
            paperTrade.openPosition('short', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
        }
        // --- AKHIR TAMBAHAN ---
        
        tsCalc.recalculate();
    });
    elements.tpslToggle.addEventListener('change', () => {
        elements.tpslInputs.classList.toggle('hidden', !elements.tpslToggle.checked);
    });
    elements.slider.addEventListener('input', () => {
        const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
        const percentage = parseFloat(elements.slider.value);
        const newCost = (currentWalletBalance * (percentage / 100));
        elements.cost.value = newCost.toFixed(2);
        tsCalc.recalculate();
    });
    ['cost', 'leverage', 'walletBalance', 'marketPrice'].forEach(id => {
        elements[id].addEventListener('input', () => tsCalc.recalculate());
    });
    elements.cost.addEventListener('input', () => {
        const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
        const costValue = parseFloat(elements.cost.value) || 0;
        const percentage = currentWalletBalance > 0 ? (costValue / currentWalletBalance) * 100 : 0;
        elements.slider.value = Math.min(100, percentage);
    });
    elements.autofillBtn.addEventListener('click', () => tsCalc.autofill());

    // --- LOGIKA BARU UNTUK MODAL TS ---
    elements.tsOptionsBtn.addEventListener('click', () => tsCalc.toggleModal(true));
    elements.modalCloseBtn.addEventListener('click', () => tsCalc.toggleModal(false));
    elements.modalContainer.addEventListener('click', (e) => {
        if (e.target === elements.modalContainer) tsCalc.toggleModal(false);
    });
    elements.modalSaveBtn.addEventListener('click', () => {
        state.callbackRate = parseFloat(elements.modalCallbackRate.value);
        state.activationPrice = parseFloat(elements.modalActivationPrice.value);
        tsCalc.toggleModal(false);
        tsCalc.recalculate();
    });

    tsCalc.recalculate();
}
// ================================================================
// === BLOK LOGIKA BARU UNTUK KALKULATOR BINANCE STYLE (SELESAI) ===
// ================================================================
// === LOGIKA SIMULASI TRADING (MULAI) ===
const paperTrade = {
    state: {
        balance: 1000,
        position: null, // { type: 'long'/'short', entryPrice: 65000, quantity: 0.1, leverage: 20, cost: 325 }
        history: []
    },
    elements: {
        equity: document.getElementById('sim-equity'),
        unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
        availableMargin: document.getElementById('sim-available-margin'),
        resetBtn: document.getElementById('sim-reset-account-btn'),
        
        positionContainer: document.getElementById('sim-active-position-container'),
        positionHeader: document.getElementById('sim-position-header'),
        closePositionBtn: document.getElementById('sim-close-position-btn'),
        positionSize: document.getElementById('sim-position-size'),
        positionEntry: document.getElementById('sim-position-entry'),
        positionMark: document.getElementById('sim-position-mark'),
        positionLiq: document.getElementById('sim-position-liq'),
        positionPnl: document.getElementById('sim-position-pnl'),
        
        tradeHistoryList: document.getElementById('sim-trade-history-list'),
    },

    init: function() {
        this.loadState();
        this.elements.resetBtn.addEventListener('click', () => this.resetAccount());
        this.elements.closePositionBtn.addEventListener('click', () => this.closePosition());
        setInterval(() => this.update(), 500); // Update PNL setiap 500ms
        this.render();
    },

    openPosition: function(type, leverage, cost, entryPrice) {
        if (this.state.position) {
            alert("Hanya 1 posisi yang bisa dibuka dalam satu waktu.");
            return;
        }
        if (cost > this.state.balance) {
            alert("Modal tidak cukup untuk membuka posisi.");
            return;
        }

        const positionSize = cost * leverage;
        const quantity = entryPrice > 0 ? positionSize / entryPrice : 0;
        
        // Asumsi margin terisolasi untuk perhitungan likuidasi sederhana
        const maintenanceMarginRate = 0.005; 
        const liqPriceChange = (cost / positionSize) * (1 - maintenanceMarginRate);
        const liqPrice = type === 'long' 
            ? entryPrice * (1 - liqPriceChange) 
            : entryPrice * (1 + liqPriceChange);

        this.state.balance -= cost;
        this.state.position = {
            type: type,
            entryPrice: entryPrice,
            quantity: quantity,
            leverage: leverage,
            cost: cost,
            liqPrice: liqPrice
        };
        
        this.saveState();
        this.render();
    },

    closePosition: function() {
        if (!this.state.position) return;

        const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
        if (isNaN(markPrice)) {
            alert("Tidak bisa menutup posisi, harga pasar tidak tersedia.");
            return;
        }
        
        const pos = this.state.position;
        const pnl = (pos.type === 'long') 
            ? (markPrice - pos.entryPrice) * pos.quantity 
            : (pos.entryPrice - markPrice) * pos.quantity;

        this.state.balance += (pos.cost + pnl);
        
        this.state.history.unshift({
            symbol: realtimeCache.main.symbol,
            type: pos.type,
            pnl: pnl,
            roe: (pnl / pos.cost) * 100,
            closedAt: new Date()
        });
        
        if (this.state.history.length > 20) {
            this.state.history.pop();
        }

        this.state.position = null;
        this.saveState();
        this.render();
    },

    update: function() {
        if (!this.state.position) return;
        
        const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
        if (isNaN(markPrice)) return;
        
        const pos = this.state.position;
        const pnl = (pos.type === 'long') 
            ? (markPrice - pos.entryPrice) * pos.quantity 
            : (pos.entryPrice - markPrice) * pos.quantity;
        
        const equity = this.state.balance + pos.cost + pnl;
        
        this.elements.equity.textContent = formatPrice(equity);
        this.elements.unrealizedPnl.textContent = formatPrice(pnl);
        this.elements.unrealizedPnl.className = `font-mono font-bold text-lg ${pnl >= 0 ? 'positive' : 'negative'}`;
        this.elements.positionMark.textContent = formatPrice(markPrice);
        
        const roe = (pnl / pos.cost) * 100;
        this.elements.positionPnl.textContent = `${formatPrice(pnl)} (${roe.toFixed(2)}%)`;
        this.elements.positionPnl.className = `font-mono font-bold text-lg ml-2 ${pnl >= 0 ? 'positive' : 'negative'}`;

        // Cek likuidasi
        if ((pos.type === 'long' && markPrice <= pos.liqPrice) || (pos.type === 'short' && markPrice >= pos.liqPrice)) {
            alert(`Posisi ${pos.type.toUpperCase()} terlikuidasi!`);
            this.state.history.unshift({
                symbol: realtimeCache.main.symbol,
                type: pos.type,
                pnl: -pos.cost, // PNL adalah kehilangan seluruh modal
                roe: -100,
                closedAt: new Date(),
                liquidated: true
            });
            this.state.position = null;
            this.saveState();
            this.render();
        }
    },

    render: function() {
        const pos = this.state.position;
        
        if (pos) {
            const equity = this.state.balance + pos.cost; // PNL belum dihitung saat render awal
            this.elements.equity.textContent = formatPrice(equity);
            this.elements.availableMargin.textContent = formatPrice(this.state.balance);
            
            this.elements.positionContainer.classList.remove('hidden');
            this.elements.positionHeader.textContent = `${pos.type.toUpperCase()} / ${pos.leverage}x`;
            this.elements.positionHeader.className = `font-bold text-lg ${pos.type === 'long' ? 'positive' : 'negative'}`;
            this.elements.positionSize.textContent = formatPrice(pos.cost * pos.leverage);
            this.elements.positionEntry.textContent = formatPrice(pos.entryPrice);
            this.elements.positionLiq.textContent = formatPrice(pos.liqPrice);
            this.elements.unrealizedPnl.textContent = '$0.00';
            this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
        } else {
            this.elements.equity.textContent = formatPrice(this.state.balance);
            this.elements.availableMargin.textContent = formatPrice(this.state.balance);
            this.elements.unrealizedPnl.textContent = '$0.00';
            this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
            this.elements.positionContainer.classList.add('hidden');
        }

        // Render Riwayat
        if (this.state.history.length > 0) {
            this.elements.tradeHistoryList.innerHTML = this.state.history.map(trade => `
                <div class="p-1.5 rounded-md ${trade.pnl >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'} flex justify-between items-center">
                    <div>
                        <span class="font-bold ${trade.type === 'long' ? 'positive' : 'negative'}">${trade.symbol} ${trade.type.toUpperCase()}</span>
                        <span class="text-gray-400 text-[10px] ml-2">${trade.closedAt.toLocaleTimeString()}</span>
                    </div>
                    <div class="font-mono text-right ${trade.pnl >= 0 ? 'positive' : 'negative'}">
                        ${formatPrice(trade.pnl)} (${trade.roe.toFixed(2)}%) ${trade.liquidated ? '🔥' : ''}
                    </div>
                </div>
            `).join('');
        } else {
            this.elements.tradeHistoryList.innerHTML = '<p class="text-center text-gray-600">No trade history yet.</p>';
        }
    },

    resetAccount: function() {
        if (confirm("Apakah Anda yakin ingin mereset akun simulasi? Semua riwayat akan hilang.")) {
            this.state.balance = 1000;
            this.state.position = null;
            this.state.history = [];
            this.saveState();
            this.render();
        }
    },

    saveState: function() {
        localStorage.setItem('paperTradeState', JSON.stringify(this.state));
    },

    loadState: function() {
        const savedState = localStorage.getItem('paperTradeState');
        if (savedState) {
            this.state = JSON.parse(savedState);
            if (this.state.history) {
                 this.state.history.forEach(trade => trade.closedAt = new Date(trade.closedAt));
            }
        }
    }
};
// === LOGIKA SIMULASI TRADING (SELESAI) ===
// =====================================================================================================================================================================
// BAGIAN 5: EVENT LISTENER UTAMA
// =====================================================================================================================================================================
document.addEventListener('DOMContentLoaded', () => {
    loadSettings();
    initTopMoversTimeframeSelector(); 
    initRefreshIntervalSelector();
    startTopMoversAutoRefresh("1h", 60000); // Default: 1H, refresh setiap 60 detik
    adjustContentPadding();
    setupToggle('toggle-scalping-btn', 'scalping-content-wrapper', 'toggle-scalping-icon', true);
    setupToggle('toggle-sentiment-btn', 'sentiment-content-wrapper', 'toggle-sentiment-icon', false);
    setupToggle('toggle-market-state-btn', 'current-state-content-wrapper', 'toggle-market-state-icon', true);
    setupToggle('toggle-confluence-btn', 'confluence-content-wrapper', 'toggle-confluence-icon', true);
    setupToggle('toggle-onchain-btn', 'onchain-content-wrapper', 'toggle-onchain-icon', false);        
    setupToggle('toggle-settings-btn', 'settings-content-wrapper', 'toggle-settings-icon', false);
    setupToggle('toggle-ai-verdict-btn', 'ai-verdict-content-wrapper', 'toggle-ai-verdict-icon', true);
    
    window.addEventListener('resize', adjustContentPadding); 
    document.getElementById('save-settings-btn').addEventListener('click', saveSettings);
    
    timeframeSelect.addEventListener('change', (e) => {
        adaptIndicatorParamsToTimeframe(e.target.value);
    });

    themeToggleBtn.addEventListener('click', () => {
        document.documentElement.classList.toggle('dark');
        darkIcon.classList.toggle('hidden');
        lightIcon.classList.toggle('hidden');
        localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            if (cvdChartInstance) {
                const isDarkMode = document.documentElement.classList.contains('dark');
                const positiveColor = isDarkMode ? '#4ade80' : '#16a34a';
                const negativeColor = isDarkMode ? '#f87171' : '#dc2626';
                cvdChartInstance.data.datasets[0].segment.borderColor = ctx => ctx.p1.parsed.y >= ctx.p0.parsed.y ? positiveColor : negativeColor;
                cvdChartInstance.options.scales.x.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                cvdChartInstance.options.scales.y.ticks.color = isDarkMode ? '#9ca3af' : '#4b5563';
                cvdChartInstance.options.scales.y.grid.color = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
                cvdChartInstance.update();
            }
    });

    if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
        darkIcon.classList.remove('hidden');
    } else {
        lightIcon.classList.remove('hidden');
    }

    apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
    apiKeyInput.addEventListener('change', () => localStorage.setItem('geminiApiKey', apiKeyInput.value));
    assetInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') runFullAnalysis(); });
    const presetSelect = document.getElementById('preset-select');

    presetSelect.addEventListener('change', (e) => {
        applyPreset(e.target.value);
    });

    document.getElementById('vwap-mode-buttons').addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            const mode = e.target.dataset.mode;
            document.querySelectorAll('.vwap-mode-btn').forEach(btn => btn.classList.remove('active'));
            e.target.classList.add('active');
            updateVwapDisplay(mode);
        }
    });

    document.getElementById('run-comprehensive-ai-btn').addEventListener('click', runComprehensiveAIAnalysis);
    
    tradeLink.addEventListener('click', (e) => {
        e.preventDefault();
        const binanceSymbol = realtimeCache.main.binanceSymbol;
        if (!binanceSymbol) return;
        const marketType = marketTypeSelect.value;
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const desktopUrl = marketType === 'futures' ? `https://www.binance.com/en/futures/${binanceSymbol}` : `https://www.binance.com/en/trade/${binanceSymbol}`;
        const mobileUrl = marketType === 'futures' ? `binance://futures/trade?symbol=${binanceSymbol}` : `binance://trade?symbol=${binanceSymbol}`;
        if (isMobile) {
            window.location.href = mobileUrl;
            setTimeout(() => { window.location.href = desktopUrl; }, 1500);
        } else {
            window.open(desktopUrl, '_blank');
        }
    });

    marketTypeSelect.addEventListener('change', () => initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message)));
    initializeExchangeInfo(marketTypeSelect.value).catch(err => showError(err.message));
    resetBtn.addEventListener('click', resetDashboard);
    const tooltipElement = document.createElement('div');
    tooltipElement.id = 'custom-tooltip';
    document.body.appendChild(tooltipElement);

    
    const debouncedRunAnalysis = debounce(runFullAnalysis, 100); 
    analyzeBtn.addEventListener('click', () => {
        analyzeBtn.disabled = true;
        debouncedRunAnalysis();
    });
    assetInput.addEventListener('keypress', (e) => { 
        if (e.key === 'Enter') {
            analyzeBtn.disabled = true; 
            debouncedRunAnalysis();
        } 
    });
    
    const showTooltip = (e) => {
        const target = e.currentTarget;
        const tooltipContent = target.getAttribute('data-tooltip');
        if (!tooltipContent) return;
        
        const [title, ...body] = tooltipContent.split('|');
        const formattedContent = `<strong>${title}</strong><p>${body.join('<br>')}</p>`;
        tooltipElement.innerHTML = formattedContent;

        const targetRect = target.getBoundingClientRect();
        tooltipElement.style.opacity = '1';
        tooltipElement.style.visibility = 'visible';
        
        const tooltipRect = tooltipElement.getBoundingClientRect();
        let top = targetRect.top - tooltipRect.height - 10;
        let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);

        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        if (top < 10) {
            top = targetRect.bottom + 10;
            tooltipElement.style.setProperty('--arrow-top', '-6px');
            tooltipElement.style.setProperty('--arrow-border-color', 'transparent transparent #2d3748 transparent');
        } else {
            tooltipElement.style.setProperty('--arrow-top', '100%');
            tooltipElement.style.setProperty('--arrow-border-color', '#2d3748 transparent transparent transparent');
        }

        tooltipElement.style.left = `${left}px`;
        tooltipElement.style.top = `${top + window.scrollY}px`;
    };

    const hideTooltip = () => {
        tooltipElement.style.opacity = '0';
        tooltipElement.style.visibility = 'hidden';
    };

    const triggers = document.querySelectorAll('[data-tooltip]');
    triggers.forEach(trigger => {
        trigger.classList.add('tooltip-trigger');
        trigger.addEventListener('mouseenter', showTooltip);
        trigger.addEventListener('mouseleave', hideTooltip);
        
        let isTooltipVisible = false;
        trigger.addEventListener('click', (e) => {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                e.preventDefault();
                if (!isTooltipVisible) {
                    showTooltip(e);
                    isTooltipVisible = true;
                } else {
                    hideTooltip();
                    isTooltipVisible = false;
                }
            }
        });
    });
    
    document.body.addEventListener('click', (e) => {
        if (!e.target.hasAttribute('data-tooltip')) {
            hideTooltip();
            triggers.forEach(trigger => trigger.isTooltipVisible = false);
        }
    }, true);

    const dumpTfSelect = document.getElementById('dump-trigger-timeframe-select');
    const triggerListDiv = document.getElementById('trigger-breakdown-list');

    // === LOGIKA BARU UNTUK MEMBUAT KOTAK MTF INTERAKTIF ===
        const mtfAlignmentContainer = document.getElementById('tf-alignment-summary');

        mtfAlignmentContainer.addEventListener('click', (event) => {
            // Cari elemen kotak yang bisa di-klik yang paling dekat dengan target klik
            const clickedBox = event.target.closest('.mtf-clickable-box');

            // Jika yang diklik memang kotaknya (bukan area kosong di sekitarnya)
            if (clickedBox) {
                // Ambil timeframe dari atribut data yang kita buat tadi
                const newTimeframe = clickedBox.dataset.timeframe;
                
                // Temukan dropdown timeframe utama dan tombol "GET DATA"
                const mainTimeframeSelect = document.getElementById('timeframe-select');
                const mainAnalyzeBtn = document.getElementById('analyze-asset-btn');

                // Untuk mencegah klik ganda saat sedang loading
                if (mainAnalyzeBtn.disabled) {
                    console.log("Analisis sedang berjalan, harap tunggu.");
                    return;
                }

                console.log(`Mengganti timeframe utama ke: ${newTimeframe}`);

                // 1. Ubah nilai dropdown utama sesuai dengan kotak yang diklik
                mainTimeframeSelect.value = newTimeframe;

                // 2. Simulasikan klik pada tombol "GET DATA" untuk memuat ulang seluruh data
                mainAnalyzeBtn.click();
            }
        });
// === AKHIR LOGIKA BARU ===
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    dumpTfSelect.addEventListener('change', async () => {
        if (!realtimeCache.main.symbol) return; // Abaikan jika analisis belum berjalan

        const selectedTf = dumpTfSelect.value;
        const symbol = realtimeCache.main.symbol;
        const marketType = marketTypeSelect.value;

        // Jaring Pengaman untuk mencegah fatal error
        try {
            // Tampilkan status loading agar pengguna tahu ada proses berjalan
            dumpTfSelect.disabled = true;
            triggerListDiv.innerHTML = `<p class="text-xs text-center text-yellow-400">Loading data ${selectedTf}...</p>`;

            // Cek apakah data sudah ada di "wadah"
            if (!realtimeCache.main.multiTfKlines[selectedTf]) {
                console.log(`Data ${selectedTf} NONE di cache. Mengambil dari API...`);
                // Jika NONE, ambil data baru dari API
                const newData = await fetchBinanceAPIData('klines', { symbol: symbol, interval: selectedTf, limit: 200 }, marketType);
                // Simpan data baru ke "wadah" agar tidak perlu download lagi
                realtimeCache.main.multiTfKlines[selectedTf] = newData;
                console.log(`Data ${selectedTf} berhasil diambil dan disimpan.`);
            }

            // Panggil fungsi update HANYA SETELAH data dijamin ada
            calculateAndDisplayScalpingSetup();
            console.log(`Mengganti langganan WebSocket ke timeframe: ${selectedTf}`);
            const symbolLower = symbol.toLowerCase();
            const mainTfStream = `${symbolLower}@kline_${realtimeCache.main.selectedTimeframe}`;
            const newDumpTfStream = `${symbolLower}@kline_${selectedTf}`;

            const newStreamsToSub = [
                mainTfStream,
                `${symbolLower}@aggTrade`,
                `${symbolLower}@depth20@100ms`
            ];

            if (mainTfStream !== newDumpTfStream) {
                newStreamsToSub.push(newDumpTfStream);
            }
            WebSocketManager.subscribe(newStreamsToSub);
        } catch (error) {
            // Jika ada error (misal: internet), aplikasi TIDAK AKAN CRASH
            console.error(`Gagal mengambil data untuk ${selectedTf}:`, error);
            triggerListDiv.innerHTML = `<p class="text-xs text-center text-red-500">Failed Data Fetch.. ${selectedTf}.</p>`;
        } finally {
            // Apapun yang terjadi, aktifkan kembali dropdown
            dumpTfSelect.disabled = false;
        }
    });
    // TAMBAHKAN BARIS INI
    setupToggle('toggle-ts-calc-btn', 'ts-calc-content-wrapper', 'toggle-ts-calc-icon', true); // Dibuat default terbuka
    initializeNewCalculator();
    setupToggle('toggle-paper-trading-btn', 'paper-trading-content-wrapper', 'toggle-paper-trading-icon', true);
    paperTrade.init();
});
// ===================================================================================================================================================================================================================================================================================
// ===================================================================================================================================================================================================================================================================================
</script>
</body>
</html>