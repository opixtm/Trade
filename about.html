<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HFT BOT</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

<style>body{font-family:'Inter',sans-serif;background-color:#000000;color:#E0E0E0;}.card{background-color:#151414;border:1px solid #333;border-radius:.75rem;}.positive{color:#4ade80;}.negative{color:#f87171;}.btn-primary{background-color:#c97c00;color:#1f2937;font-weight:600;padding:.625rem 1.25rem;border-radius:.5rem;transition:background-color .3s;display:flex;align-items:center;justify-content:center;gap:.5rem;}.btn-primary:hover{background-color:#eb9413;}.btn-special{background-color:#8B5CF6;color:white;font-weight:600;padding:.625rem 1.25rem;border-radius:.5rem;transition:background-color .3s;display:flex;align-items:center;justify-content:center;gap:.5rem;}.btn-special:hover{background-color:#7C3AED;}.tab-button.active{border-bottom:2px solid #c97c00;font-weight:600;}.toggle-btn{transition:background-color .3s;}.toggle-btn.active{background-color:#c97c00;}.toggle-icon{transition:transform .3s ease-in-out;}.toggle-icon.rotate-180{transform:rotate(180deg);}.indicator-label{min-width:100px;}.hidden-panel{display:none;}.input-primary{background-color:#2c2c2c;border:1px solid #444;border-radius:.5rem;padding:.625rem 1rem;width:100%;color:#E0E0E0;}.loader{display:flex;justify-content:center;align-items:center;gap:4px;}.dot{width:8px;height:8px;background-color:#e1e1e1;border-radius:50%;animation:bounce 1.4s infinite ease-in-out both;}.dot:nth-child(1){animation-delay:-.32s;}.dot:nth-child(2){animation-delay:-.16s;}@keyframes bounce{0%,80%,100%{transform:scale(0);}40%{transform:scale(1.0);}}.collapsible-content{display:grid;grid-template-rows:0fr;transition:grid-template-rows .4s ease-in-out;}.collapsible-content.expanded{grid-template-rows:1fr;}.collapsible-content>div{overflow:hidden;}.btn-secondary{background-color:#374151;color:#E0E0E0;font-weight:600;transition:background-color .3s;}.btn-secondary:hover{background-color:#4b5563;}.chart-tf-btn.active{background-color:#c97c00;color:#1f2937;}.calc-binance-style .btn-group{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-bottom:1.5rem;}.calc-binance-style .btn-group button{padding:10px;border-radius:6px;cursor:pointer;background-color:#2c2f36;border:1px solid #3a3f4a;color:#e0e0e0;font-weight:500;transition:background-color .2s;}.calc-binance-style .btn-group button:hover{background-color:#3a3f4a;}.calc-binance-style .btn-group button.active{background-color:#f0b90b;color:#14151a;border-color:#f0b90b;}.calc-binance-style .input-group{position:relative;margin-bottom:1rem;}.calc-binance-style .input-field{width:100%;padding:12px;background-color:#2c2f36;border:1px solid #3a3f4a;border-radius:8px;color:#e0e0e0;font-size:1.1em;}.calc-binance-style .input-label-top{font-size:.8em;color:#848e9c;margin-bottom:8px;}.calc-binance-style .margin-slider{width:100%;-webkit-appearance:none;appearance:none;height:4px;background:#3a3f4a;outline:none;border-radius:2px;margin:1.5rem 0;}.calc-binance-style .margin-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#f0b90b;cursor:pointer;border-radius:50%;}.calc-binance-style .slider-ticks{display:flex;justify-content:space-between;font-size:.75rem;color:#848e9c;}.calc-binance-style .exec-buttons{display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:1.5rem;}.calc-binance-style .exec-buttons button{padding:14px;font-size:1.1em;font-weight:600;border:none;border-radius:8px;cursor:pointer;}.calc-binance-style .btn-buy{background-color:#2ebd85;color:white;}.calc-binance-style .btn-sell{background-color:#f6465d;color:white;}.calc-binance-style .calc-result-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:1rem;font-size:.85em;color:#848e9c;}.calc-binance-style .calc-result-grid span:nth-child(even){text-align:right;font-weight:600;color:#e0e0e0;}#ts-modal-content .input-field{background-color:#2c2f36;border:1px solid #3a3f4a;}#ts-modal-close-btn{font-size:2rem;line-height:1;}
        .top-bar-sticky{position:-webkit-sticky;position:sticky;top:0;z-index:50;background-color:#0c031a;border-bottom:1px solid #333;padding-top:1rem;padding-bottom:1rem}@keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}.blinking-status{animation:blink 1.5s infinite}.svg-green{fill:#26a69a;stroke:#26a69a}.svg-red{fill:#ef5350;stroke:#ef5350}.svg-gray{fill:#2c2c2c;stroke:#4b5563}.svg-body{stroke-width:0}.svg-wick{stroke-width:1}.slider-wrapper{width:400px;padding:20px;background-color:#222;color:#fff;border-radius:5px}#percentageSlider{width:100%;margin:10px 0}.display-area{text-align:center;font-size:1.5em;margin-bottom:10px;font-weight:700}.percentage-labels{display:flex;justify-content:space-between;font-size:12px}
    /* CSS BARU UNTUK S.O.P. "THE REALM" */
    .glow-support {
        /* Border hijau tebal untuk Tembok Support yang terkonvergensi */
        box-shadow: inset 0 0 0 2px #2ebd85;
        background-color: rgba(46, 189, 133, 0.1);
    }
    .glow-resistance {
        /* Border merah tebal untuk Tembok Resistance yang terkonvergensi */
        box-shadow: inset 0 0 0 2px #f6465d;
        background-color: rgba(246, 70, 93, 0.1);
    }
</style>
</head>
<body class="p-8">

<header class="text-center mb-8"><h1 class="text-lg"></h1><p class="text-gray-400">BOT ON BINANCE PERPETUAL</p></header>

    <main class="max-w-7xl mx-auto space-y-8">
 <section id="api-connection-section" class="card top-bar-sticky">
    <div class="flex justify-between items-center gap-2 text-sm">
        <div>
            <button id="connect-api-btn" class="btn-primary">
                <span id="connect-api-status-text">üîå BINANCE</span>
            </button>
        </div>

        <div id="api-status-display" class="flex items-center gap-4 text-sm font-mono">
            
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500"></span>
                <span id="sticky-equity-display" class="text-sm font-mono text-blue-400">$----.--</span>
            </div>

            <div class="flex items-center gap-2 border-l border-gray-600 pl-4">
                <span id="asset-symbol-display" class="text-sm text-white">--</span>
                <span><span id="live-price-display" class="text-sm font-mono text-yellow-400">$0.00</span></span>
                <div id="api-status-dot" class="w-3 h-3 rounded-full bg-gray-500"></div>
                <span id="api-status-text" class="text-xs text-gray-400">View Only</span>
            </div>
            
            <div class="border-l border-gray-600 pl-4">
                <span id="ping-latency-display" class="text-sm text-gray-400"> -- ms</span>
            </div>
        </div>

    </div>
</section>

        <section id="imported-strategy-section" class="card p-4">
            <button id="toggle-import-btn" class="w-full flex justify-between items-center text-left">
                <h2 class="text-lg font-semibold">DNA STRATEGI</h2>
                <svg id="toggle-import-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <div id="import-content-wrapper" class="collapsible-content">
                    <div class="pt-4 mt-4 border-t border-gray-700">
                        <div class="flex items-center space-x-4">
                            <label for="import-file" class="btn-special cursor-pointer flex-grow text-center">
                                Import DNA (.json)
                            </label>
                            <input type="file" id="import-file" class="hidden" accept=".json" />
                        </div>
                        
                        <div class="mt-2 text-center">
                            <span id="dna-status-display" class="text-sm font-mono text-gray-500">
                                Status: Belum ada DNA dimuat.
                            </span>
                        </div>
                        <div id="imported-sinyal-panel" class="mt-4 pt-4 border-t border-gray-700">
                            <p class="text-center text-sm text-gray-400"></p>
                        </div>
                    </div>
                </div>
        </section>

        <section id="live-data-input-section" class="card p-3">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                <input type="text" id="live-symbol-input" list="future-symbols" placeholder="BTCUSDT" value="BTCUSDT" class="input-primary flex-grow text-center uppercase">
                <datalist id="future-symbols">
                    </datalist>
                <select id="live-timeframe-select" class="input-primary">
                    <option value="1m" selected>1m</option>
                    <option value="5m">5m</option>
                    <option value="15m">15m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                </select>
                <button id="start-live-btn" class="btn-primary">
                    <span>‚ñ∂Ô∏è START LIVE</span>
                    <div class="loader w-5 h-5 hidden">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </button>
            </div>

            <section id="charts-wrapper" class="card p-4 my-4" style="display: none;">
                <h2 class="text-xl font-semibold mb-4">Live Chart</h2>
                <div id="chart-timeframe-selector" class="flex flex-wrap gap-2 mb-4 border-b border-gray-700 pb-4">
                    <button data-timeframe="1m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3 active">1m</button>
                    <button data-timeframe="3m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">3m</button>
                    <button data-timeframe="5m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">5m</button>
                    <button data-timeframe="15m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                    <button data-timeframe="1h" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1h</button>
                </div>
                <div class="chart-container relative">
                    <div class="pane-title">Price</div>
                    <div id="main-chart-container" style="height: 450px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Volume</div>
                    <div id="volume-chart-container" style="height: 100px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">RSI (14)</div>
                    <div id="rsi-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Stochastic RSI</div>
                    <div id="stoch-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">MACD</div>
                    <div id="macd-chart-container" style="height: 120px;"></div>
                </div>
            </section>
            <button id="toggle-charts-btn" class="btn-primary w-full mt-4">SHOW CHART</button>



            <div id="live-signal-panel" class="card p-3 mt-6">
                <h2 class="text-xl font-semibold mb-4 text-orange-500 flex items-center justify-between">
                    <span></span>
                    <span id="dump-score-display" class="font-mono text-base text-white ml-auto"></span>
                </h2>
                <div class="mb-4">
                    <details>
                        <summary class="cursor-pointer text-xs text-gray-400 hover:text-white transition-colors flex justify-between items-center border-b border-gray-500">
                            <span>Dump Risk Score Trigger Timeframe ‚ñæ</span>
                            <select id="dump-trigger-timeframe-select" class="input-primary !text-xs !w-auto !p-1 bg-gray-900/50 border-gray-600" onclick="event.stopPropagation()">
                                <option value="1m" selected>1m</option>
                                <option value="5m">5m</option>
                                <option value="15m">15m</option>
                                <option value="1h">1h</option>
                                <option value="4h">4h</option>
                            </select>
                        </summary>
                        <div id="dump-risk-visual-bar" class="pt-4 mt-4 border-t border-gray-700">
                             <div class="flex justify-between items-center text-xs font-mono mb-1">
                                 <span class="text-gray-400">Momentum Bullish</span>
                                 <span class="text-gray-400">Bearish Pressure Score</span>
                             </div>
                             <div class="w-full bg-gray-800 rounded-lg h-6 flex overflow-hidden border border-gray-700">
                                 <div id="bull-bar-dump" class="h-full flex items-center justify-start px-2" style="width: 50%;">
                                     <span id="bull-percent-dump" class="font-bold text-sm"></span>
                                 </div>
                                 <div id="bear-bar-dump" class="h-full flex items-center justify-end px-2" style="width: 50%;">
                                     <span id="bear-score-dump" class="font-bold text-sm"></span>
                                 </div>
                             </div>
                        </div>
                        
                        <details class="mt-4">
                            <summary class="cursor-pointer text-xs text-gray-400 hover:text-white">Breakdown Details ‚ñæ</summary>
                            <div id="trigger-breakdown-list" class="mt-2 pt-2 text-sm space-y-1">
                                <p class="text-xs text-center text-gray-600">Memuat rincian skor...</p>
                            </div>
                        </details>
                    </details>
                </div>
                <div id="htf-compass-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-normal text-gray-400">HTF Compass</span>
                        <div id="htf-compass-selector" class="flex flex-wrap gap-2">
                            <button data-timeframe="5m" class="htf-btn btn-secondary !text-xs !py-1 !px-3 active">5m</button>
                            <button data-timeframe="15m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                            <button data-timeframe="1h" class="htf-btn btn-secondary !text-xs !py-1 !px-3">1H</button>
                            <button data-timeframe="4h" class="htf-btn btn-secondary !text-xs !py-1 !px-3">4H</button>
                        </div>
                    </div>
                    <div id="htf-compass-result" class="text-center mt-2 text-sm">
                        -- Pilih Timeframe --
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-3 text-center">
                        <div>
                            <p id="htf-resistance-price" class="font-mono text-lg negative">--</p>
                            <p class="text-xs text-gray-500">HTF Resistance</p>
                        </div>
                        <div>
                            <p id="htf-support-price" class="font-mono text-lg positive">--</p>
                            <p class="text-xs text-gray-500">HTF Support</p>
                        </div>
                        <div id="fib-targets-display" class="mt-3 flex justify-center col-span-2">
                            </div>
                    </div>
                    <div class="mt-4">
                        <details>
                            <summary class="cursor-pointer text-xs text-gray-400 hover:text-white">Sentiment & Volatility Indicators</summary>
                            <div id="sentiment-indicators-content" class="pt-2 mt-2 border-t border-gray-700 text-xs space-y-1 font-mono">
                                <div class="flex justify-between"><span>Parabolic SAR</span><span id="sentiment-psar">--</span></div>
                                <div class="flex justify-between"><span>Rate of Change (12)</span><span id="sentiment-roc">--</span></div>
                                <div class="flex justify-between"><span>ADX (14)</span><span id="sentiment-adx">--</span></div>
                                <div class="flex justify-between"><span>ATR (% of Price)</span><span id="sentiment-atr">--</span></div>
                                <hr class="border-gray-700/50 my-1"/>
                                <div class="flex justify-between"><span>L/S Ratio (Global)</span><span id="sentiment-ls-global">--</span></div>
                                <div class="flex justify-between"><span>L/S Ratio (Top)</span><span id="sentiment-ls-top">--</span></div>
                                <div class="flex justify-between"><span>Funding Interval</span><span id="sentiment-funding-interval">--:--:--</span></div>
                                <div class="flex justify-between"><span>Funding Rate</span><span id="sentiment-funding">--</span></div>
                                <div class="flex justify-between"><span>Open Interest</span><span id="sentiment-oi">--</span></div>
                            </div>
                        </details>
                    </div>
                </div>
                <div id="ema-ribbon-multi-tf-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
    <span class="text-sm font-normal text-gray-400 flex justify-between items-center">
        EMA Ribbon Dynamic S/R 
        <span id="price-change-alert" class="text-xs text-gray-500"></span>
    </span>
    <div class="mt-3 overflow-x-auto">
        <table class="min-w-full text-xs text-left">
            <thead class="text-gray-400 uppercase bg-gray-700/50">
                <tr>
                    <th scope="col" class="px-2 py-1">TF</th>
                    <th scope="col" class="px-2 py-1 text-center">E13</th>
                    <th scope="col" class="px-2 py-1 text-center">E21</th>
                    <th scope="col" class="px-2 py-1 text-center">E34</th>
                    <th scope="col" class="px-2 py-1 text-center">E55</th>
                    <th scope="col" class="px-2 py-1 text-center">E89</th>
                    <th scope="col" class="px-2 py-1 text-center">E144</th>
                </tr>
            </thead>
            <tbody id="ema-ribbon-table-body">
                </tbody>
        </table>
    </div>
</div>
                <div id="order-flow-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <span class="text-sm font-normal text-gray-400">Order Flow Imbalance</span>
                    <div class="mt-2 w-full bg-gray-700 rounded-full h-4 relative">
                        <div id="order-flow-bar" class="bg-gradient-to-r from-green-500 to-red-500 h-4 rounded-full" style="width: 50%;"></div>
                        <div id="order-flow-text" class="absolute inset-0 flex items-center justify-center text-xs font-bold text-white">
                            50% | 50%
                        </div>
                    </div>
                    <div class="flex justify-between text-xs mt-1">
                        <span class="text-green-400">BIDS</span>
                        <span class="text-red-400">ASKS</span>
                    </div>
                </div>

                <div id="ema-and-candle-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <div class="grid grid-cols-2 gap-3">
                        <div class="text-center pt-2">
                            <span class="text-xs text-gray-500">EMA 21/89 Status</span>
                            <p id="ema-status-display" class="font-mono text-sm font-semibold text-gray-400">--</p>
                            <p id="ema-values-display" class="text-xs text-gray-500">21:-- / 89:--</p>
                        </div>
                        <div class="text-center border-l border-gray-700/50 pt-2">
                            <span class="text-xs text-gray-500">Candle Pattern</span>
                            <div id="candlestick-svg-container" class="h-8 flex items-center justify-center my-1">
                                </div>
                            <p id="candlestick-pattern-display" class="text-xs font-semibold text-gray-400">NONE</p>
                        </div>

                    </div>
                </div>
                </div>
        </section>

        <div id="current-regime-status-container" class="card p-3 mt-6">
            <div class="space-y-1 text-sm text-center">
                <span id="ai-status" class="font-medium text-gray-400">LOADING...</span>
                <div class="flex justify-center">
                    <span id="regime-confidence-score" class="font-medium text-gray-400">0.0%</span>
                </div>
                <p class="flex justify-center !mt-2 border-t border-gray-700 pt-2">
                    <span id="active-regime-display" class="text-base text-gray-400">LOADING...</span>
                </p>
            </div>
        </div>
        
        <div id="live-signal-content">
            <p class="text-center text-sm text-gray-400"></p>
        </div>

        <section id="paper-trading-section" class="card p-3">
            <button id="toggle-paper-trading-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-lg font-semibold">Auto/Manual Trade
                    <button id="sim-reset-account-btn" class="btn-secondary !text-xs !py-1 !px-3 !bg-red-700 hover:!bg-red-600">FULL RESET</button>
                    <button id="open-aft-filter-btn" class="btn-secondary !text-xs !py-1 !px-3">Strategy Filter</button>
                    <button id="enable-auto-trade-btn" class="btn-secondary !text-xs !py-1 !px-3 !bg-gray-600 hover:!bg-gray-500">‚ñ∂Ô∏è ENABLE AUTO-TRADE</button>
                    <div id="sizing-injection-area" class="mt-4 pt-4 border-t border-gray-700">
                        <h3 class="text-sm text-gray-400 mb-2">Cost/Margin Alokasi (Fixed Margin)</h3>
                        <div class="grid grid-cols-2 gap-3 mb-2">
                            <div class="input-group">
                                <label for="aft-wallet-balance" class="input-label-top text-xs text-gray-500">Available Balance ($)</label>
                                <input type="number" id="aft-wallet-balance" class="input-primary small-input !py-2" value="250" disabled>
                            </div>
                            <div class="input-group">
                                <label for="aft-cost-input" class="input-label-top text-xs text-gray-500">Cost / Modal ($)</label>
                                <input type="number" id="aft-cost-input" class="input-primary small-input !py-2" value="12.50">
                            </div>
                        </div>
                        
                        <div class="mt-4">
                            <div class="flex justify-center text-lg font-bold mb-2">
                                <span id="aft-margin-display" class="text-yellow-400">5%</span>
                            </div>
                            <input type="range" min="0" max="100" step="1" value="5" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer" id="aft-margin-slider">

                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>0%</span>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                </h2>
                <svg id="toggle-paper-trading-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
                    <div id="sim-active-position-container" class="hidden">
                        <h3 class="text-yellow-400 mb-2">Active Position</h3>
                        
                        <div class="p-3 rounded-md bg-gray-800/50 text-sm space-y-2">
                            
                            <div class="flex justify-between items-center pb-2 border-b border-gray-700/50">
                                <div class="flex flex-col text-left">
                                    <span class="text-gray-400 text-xs"> 
                                        <span id="sim-position-symbol" class="text-white mr-2">--</span>
                                        <span id="sim-position-header">LONG / 30x</span>
                                    </span>
                                    
                                    <span id="sim-position-pnl-top" class="font-mono text-xs ml-2 text-gray-400"></span> 
                                </div>
                                <div class="flex flex-col text-right">
                                    <button id="sim-close-position-btn" class="btn-primary !bg-red-600 !text-xs !py-1 !px-3">Close Position</button>
                                    <span id="sim-position-margin" class="font-mono text-xs mt-1"></span>
                                </div>
                            </div>

                            <div class="grid grid-cols-3 gap-2 text-xs text-center pt-2 border-b border-gray-700/50 pb-2">
                                <div>
                                    <span class="text-gray-400">Size (Notional)</span>
                                    <span id="sim-position-size" class="font-mono block"></span>
                                </div>
                                <div>
                                    <span class="text-gray-400">Entry Price</span>
                                    <span id="sim-position-entry" class="font-mono block"></span>
                                </div>
                                <div>
                                    <span class="text-gray-400">Mark Price</span>
                                    <span id="sim-position-mark" class="font-mono block"></span>
                                </div>
                            </div>

                            <div class="grid grid-cols-3 gap-2 text-xs text-center pt-2">
                                <div>
                                    <span class="text-gray-400">B.E.P</span>
                                    <span id="sim-position-bep" class="font-mono block">--</span>
                                </div>
                                <div>
                                    <span class="text-gray-400">üî• SL AKTIF</span>
                                    <span id="sim-position-sl-active" class="font-mono block negative">--</span>
                                </div>
                                <div>
                                    <span class="text-gray-400">üéØ NEXT TP</span>
                                    <span id="sim-position-tp-final" class="font-mono block positive">--</span>
                                </div>
                            </div>
                            
                            </div> 
                    </div>
                    <p class="flex justify-center !mt-2 border-t border-gray-700 pt-2"></p>

                    <div class="flex justify-between items-center gap-2">
                        <div class="grid grid-cols-3 gap-3 text-center flex-grow">
                        <div>
                            <p class="text-xs text-gray-500">Equity</p>
                            <p id="sim-equity" class="font-mono text-xs text-blue-400">$250.00</p>
                        </div>
                        <div>
                            <p class="text-xs text-gray-500">Unrealized PNL</p>
                            <p id="sim-unrealized-pnl" class="font-mono text-xs text-gray-400">$0.00</p>
                        </div>
                        <div>
                            <p class="text-xs text-gray-500">Available Margin</p>
                            <p id="sim-available-margin" class="font-mono text-xs text-gray-400">$250.00</p>
                        </div> 
                    </div>
                        <div class="flex flex-col gap-2">
                            
                            
                        </div>
                    </div>
                    </div>

            <div id="paper-trading-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-700 space-y-4">
                    <div id="sim-metrics-dashboard" class="card p-4 mt-4 bg-gray-900/50">
                            <div class="grid grid-cols-2 gap-4 border-b border-gray-700/50 pb-2 mb-2">
                                
                            </div>
                            <h3 class="text-sm font-normal mb-3 text-yellow-400 border-b border-gray-700 pb-1">
                                Performance Metrics
                            </h3>
                            <div class="grid grid-cols-3 md:grid-cols-7 gap-2 text-center">
                                <div>
                                    <p class="text-xs text-gray-500">üí∞ Total P/L</p>
                                    <p id="sim-result-pnl" class="font-mono text-xs negative">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">üéØ Win Rate</p>
                                    <p id="sim-result-winrate" class="font-mono text-xs">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">üìà Profit Factor</p>
                                    <p id="sim-result-profit-factor" class="font-mono text-xs">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Trades</p>
                                    <p id="sim-result-total-trades" class="font-mono text-xs">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">üìâ Max Drawdown</p>
                                    <p id="sim-result-max-drawdown" class="font-mono text-xs negative">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">üé≤ Expectancy</p>
                                    <p id="sim-result-expectancy" class="font-mono text-xs">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">üî• Max Lose Streak</p>
                                    <p id="sim-result-losing-streak" class="font-mono text-xs">--</p>
                                </div>
                            </div>
                                <div id="strategy-performance-panel" class="mt-4 pt-3 border-t border-gray-700">
                                    <h4 class="text-xs text-gray-500 mb-2 text-center">Strategy Performance</h4>
                                    <div class="overflow-x-auto">
                                        <table class="min-w-full text-xs text-left">
                                            <thead class="text-gray-400">
                                                <tr>
                                                    <th class="py-1 px-2">Strategy</th>
                                                    <th class="py-1 px-2 text-center">Trades</th>
                                                    <th class="py-1 px-2 text-center">Wins</th>
                                                    <th class="py-1 px-2 text-center">Losses</th>
                                                    <th class="py-1 px-2 text-center">Win Rate</th>
                                                    <th class="py-1 px-2 text-right">Total P/L</th>
                                                </tr>
                                            </thead>
                                            <tbody id="strategy-performance-body">
                                                <tr><td colspan="4" class="py-2 text-center text-gray-600">-- Data akan muncul setelah ada riwayat trade --</td></tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                    


                        
                    <div> 
                        <h3 class="text-gray-400 mb-2">Trade History</h3> 
                        <div id="sim-trade-history-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                            <p class="text-center text-gray-600">No trade history yet.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="custom-console-section" class="card p-3 mt-8" hidden>
            <h2 class="text-sm font-semibold text-blue-400 mb-4">üñ•Ô∏è Console Log</h2>
            <div id="live-console-output" class="bg-black p-2 rounded-md max-h-64 overflow-y-auto text-xs font-mono border border-gray-700">
                <p class="text-gray-500">Console Log siap...</p>
            </div>
        </section>

        <section id="trailing-stop-calc-section" class="card p-3">
            <button id="toggle-ts-calc-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-sm font-semibold">Manual Trade Calculator</h2>
                <svg id="toggle-ts-calc-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>

            <div id="ts-calc-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 calc-binance-style">
                    <button id="autofill-ts-btn" class="btn-primary w-full mb-4">
                        ‚ö°Ô∏è Auto-fill 
                    </button>
                    <div class="btn-group">
                        <button id="ts-mode-cross" class="active">Cross</button>
                        <input type="number" id="ts-leverage" value="30" class="input-field text-center" style="padding-right: 2.5rem;">
                        <button id="ts-mode-isolated" class="">Isolated</button>
                        <button id="ts-trailing-stop-options">‚öôÔ∏è TS</button>
                    </div>

                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label for="ts-wallet-balance" class="input-label-top">Available Balance ($)</label>
                            <input type="number" id="ts-wallet-balance" class="input-field" value="250">
                        </div>
                        <div class="input-group">
                            <label for="ts-cost" class="input-label-top">Cost / Modal ($)</label>
                            <input type="number" id="ts-cost" class="input-field" placeholder="0.00">
                        </div>
                    </div>

                    <div>
                        <input type="range" min="0" max="100" value="0" class="margin-slider" id="ts-margin-slider">
                        <div class="slider-ticks">
                            <span>0%</span>
                            <span>25%</span>
                            <span>50%</span>
                            <span>75%</span>
                            <span>100%</span>
                        </div>
                    </div>

                    <div class="input-group mt-6">
                        <label for="ts-market-price" class="input-label-top">Market Price ($)</label>
                        <input type="number" id="ts-market-price" class="input-field" placeholder="Harga market saat ini...">
                    </div>

                    <div class="tpsl-section">
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="ts-tpsl-toggle" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 text-yellow-500">
                            <label for="ts-tpsl-toggle" class="text-sm">TP/SL</label>
                        </div>
                        <div id="ts-tpsl-inputs" class="hidden mt-4 space-y-4">
                            <div class="input-group">
                                <label for="ts-take-profit" class="input-label-top">Take Profit</label>
                                <input type="number" id="ts-take-profit" class="input-field" placeholder="Mark">
                            </div>
                            <div class="input-group">
                                <label for="ts-stop-loss" class="input-label-top">Stop Loss</label>
                                <input type="number" id="ts-stop-loss" class="input-field" placeholder="Mark">
                            </div>
                        </div>
                    </div>

                    <div class="exec-buttons">
                        <button class="btn-buy" id="ts-buy-long-btn">Buy/Long</button>
                        <button class="btn-sell" id="ts-sell-short-btn">Sell/Short</button>
                    </div>

                    <div class="calc-result-grid">
                        <span>Cost</span>
                        <span id="ts-result-cost">--</span>
                        <span>Max</span>
                        <span id="ts-result-max">--</span>
                        <span>Position Size</span>
                        <span id="ts-result-position-size">--</span>
                        <span>Liq. Price</span>
                        <span id="ts-result-liq-price">--</span>
                        <span class="pt-2 border-t border-dashed border-gray-700">Status TS</span>
                        <span id="ts-result-status" class="pt-2 border-t border-dashed border-gray-700">--</span>
                        <span>Harga Stop Loss TS</span>
                        <span id="ts-result-sl-price">--</span>
                        <span>Potensi ROE</span>
                        <span id="ts-result-roe">--</span>
                    </div>
                </div>
            </div>

            <div id="ts-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
                <div id="ts-modal-content" class="bg-gray-800 p-3 rounded-xl shadow-2xl w-full max-w-md">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Trailing Stop Setup</h3>
                        <button id="ts-modal-close-btn" class="text-gray-400 hover:text-white">&times;</button>
                    </div>
                    <div class="space-y-4">
                        <div class="form-group">
                            <label for="ts-modal-callback-rate">Callback Rate (%)</label>
                            <input type="number" id="ts-modal-callback-rate" class="input-field" placeholder="cth: 0.5">
                        </div>
                        <div class="form-group">
                            <label for="ts-modal-activation-price">Activation Price ($)</label>
                            <input type="number" id="ts-modal-activation-price" class="input-field" placeholder="cth: 65000">
                        </div>
                    </div>
                    <div class="mt-6 text-right">
                        <button id="ts-modal-save-btn" class="btn-primary">üíæSAVE</button>
                    </div>
                </div>
            </div>
        </section>

        <section id="signal-log-analysis-section" class="card p-3" hidden>
            <button id="toggle-signal-log-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-sm font-semibold text-purple-400">üî¨ Signal Log</h2>
                <svg id="toggle-signal-log-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>

            <p id="signal-log-asset-title" class="text-xs font-mono text-gray-400 mb-4 ml-1">
                -- [File: --]
            </p>

            <div id="signal-log-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-700 space-y-4">
                    <div class="flex justify-end mb-4">
                        <button id="clear-signal-log-btn" class="btn-secondary !text-xs !py-1 !px-3 !bg-red-600 hover:!bg-red-500">
                            Hapus Riwayat Log (AFT)
                        </button>
                    </div>

                    <div id="signal-summary-grid" class="grid grid-cols-2 md:grid-cols-4 gap-2 text-center">
                        <div><p class="text-xs text-gray-500">Total Sinyal (Long/Short)</p><p id="stat-total-count" class="font-mono font-semibold text-lg text-white">0 (0/0)</p></div>
                        <div><p class="text-xs text-gray-500">Durasi Rata-rata</p><p id="stat-mean-duration" class="font-mono font-semibold text-lg text-yellow-400">00m 00s</p></div>
                        <div><p class="text-xs text-gray-500">Durasi Terlama</p><p id="stat-longest-duration" class="font-mono font-semibold text-lg positive">00m 00s</p></div>
                        <div><p class="text-xs text-gray-500">Rasio Stabilitas (Std. Dev)</p><p id="stat-std-dev" class="font-mono font-semibold text-lg text-blue-400">0.00s</p></div>
                    </div>

                    <div id="signal-log-history-container" class="mt-4">
                        <h3 class="text-sm font-semibold text-gray-400 mb-2">Log Siklus Sinyal (Durasi > 1s)</h3>
                        <div class="overflow-x-auto p-2 bg-gray-900/50 rounded-md">
                            <table class="min-w-full text-xs text-left text-gray-400">
                                <thead class="text-gray-400 uppercase bg-gray-700/50">
                                    <tr>
                                        <th scope="col" class="px-3 py-1">TIPE</th><th scope="col" class="px-3 py-1">DURASI</th>
                                        <th scope="col" class="px-3 py-1">SKOR AKHIR</th><th scope="col" class="px-3 py-1">BERAKHIR KARENA</th>
                                    </tr>
                                </thead>
                                <tbody id="signal-log-history-body">
                                    <tr class="text-center"><td colspan="4" class="py-2 text-gray-600">Tidak ada siklus sinyal tercatat.</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="weather-forecast-section" class="card p-3 hidden">
            <button id="toggle-forecast-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-xl font-semibold">Monte Carlo Simulation</h2>
                <svg id="toggle-forecast-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <div id="forecast-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                    <div class="flex items-center space-x-4">
                        <label for="forecast-trade-count" class="text-gray-400">Proyeksikan untuk</label>
                        <input type="number" id="forecast-trade-count" value="50" class="input-primary w-24 text-center">
                        <span class="text-gray-400">trade ke depan</span>
                        <button id="run-live-projection-btn" class="btn-primary flex-grow">Jalankan Proyeksi</button>
                    </div>
                    <div id="forecast-chart-container" class="mt-4">
                        <canvas id="forecast-chart"></canvas>
                    </div>
                    <div id="forecast-results" class="calc-result-grid mt-4">
                        <span>Modal Awal Proyeksi</span><span id="forecast-start-equity" class="text-right font-semibold">--</span>
                        <span>Potensi PNL Rata-rata</span><span id="forecast-avg-pnl" class="text-right font-semibold">--</span>
                        <span>Probabilitas Loss</span><span id="forecast-loss-prob" class="text-right font-semibold">--</span>
                        <span>Worst Case (5%)</span><span id="forecast-worst-case" class="text-right font-semibold">--</span>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <div id="aft-filter-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 p-3 rounded-xl shadow-2xl w-full max-w-2xl relative max-h-[95vh] m-auto">

            <div class="flex justify-between items-center mb-4 pr-8">
                <h3 class="text-normal text-blue-400">‚öôÔ∏è</h3>
                <button id="close-aft-filter-btn" class="text-gray-400 hover:text-white text-3xl absolute top-2 right-2 p-2 leading-none">&times;</button>
            </div>

            <div class="overflow-y-auto max-h-[85vh] pr-3">
                <section class="mb-6 pb-4 border-b border-gray-700">
                    <h4 class="font-semibold text-base mb-3">Mode Sizing (Perhitungan Modal)</h4>
                    <div class="flex gap-2">
                        <label class="flex-1 p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                            <input type="radio" name="sizing-mode" value="FIXED_MARGIN" class="form-radio"> <span class="ml-2 font-semibold">Fixed Margin (%)</span>
                            <p class="text-xs text-gray-400 mt-1">Menggunakan persentase tetap dari saldo yang tersedia (Slider di panel utama).</p>
                        </label>
                        <label class="flex-1 p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                            <input type="radio" name="sizing-mode" value="RISK_BASED" class="form-radio" checked>
                            <span class="ml-2 font-semibold">Risk-Based (Max Loss ROE)</span>
                            <p class="text-xs text-gray-400 mt-1">Menghitung modal berdasarkan risiko per trade (Max ROE Loss 5%).</p>
                        </label>
                    </div>
                </section>

                <section class="mb-6 pb-4 border-b border-gray-700">
                    <h4 class="font-semibold text-base mb-3">Trailing Stop (TS) Mode</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                            <input type="radio" name="ts-mode" value="PERCENTAGE" class="form-radio">
                            <span class="ml-2 font-semibold">Persentase</span>
                            <p class="text-xs text-gray-400 mt-1">TS mengikuti harga puncak/lembah dengan jarak persentase tetap (Callback Rate).</p>
                        </label>
                        <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                            <input type="radio" name="ts-mode" value="ATR" class="form-radio" checked>
                            <span class="ml-2 font-semibold text-blue-400">ATR</span>
                            <p class="text-xs text-gray-400 mt-1">TS menjaga jarak berdasarkan 1.5x nilai volatilitas (ATR) terakhir. Adaptif terhadap pasar.</p>
                        </label>
                        <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                            <input type="radio" name="ts-mode" value="PSAR" class="form-radio">
                            <span class="ml-2 font-semibold text-purple-400">PSAR</span>
                            <p class="text-xs text-gray-400 mt-1">TS menggunakan titik Parabolic SAR sebagai level stop. Efektif untuk mengikuti momentum.</p>
                        </label>
                    </div>
                </section>

                <section>
                    <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                        <h4 class="text-base">Active Strategy Filter</h4>
                        <button id="force-reactivate-btn" class="btn-primary !text-xs !py-1 !px-2 !bg-blue-600 hover:!bg-blue-500">
                            ‚úÖ Force Re-Activate All
                        </button>
                    </div>

                    <div class="grid grid-cols-2 gap-x-8 gap-y-2 text-sm">
                        <div class="space-y-2">
                            <h4 class="font-semibold border-b border-gray-600 pb-1">LONG</h4>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG FOLLOW TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Follow Trend</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG COUNTER TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Counter Trend</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG REVERSION" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Mean Reversion</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG BREAKOUT SETUP" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Breakout</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG BIAS (STATIC)" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Static Bias</span></label>
                        </div>
                        <div class="space-y-2">
                            <h4 class="font-semibold border-b border-gray-600 pb-1">SHORT</h4>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT FOLLOW TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Follow Trend</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT COUNTER TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Counter Trend</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT REVERSION" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Mean Reversion</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT BREAKOUT SETUP" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Breakout</span></label>
                            <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT BIAS (STATIC)" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Static Bias</span></label>
                        </div>
                    </div>
                </section>

            </div>
        </div>
    </div>
<script>
// ===================================================================
// BAGIAN 1: DEKLARASI VARIABEL GLOBAL & STATE APLIKASI
// ===================================================================
    const strategyLossStreaks = {};
    const LSTM_NORMALIZATION_PARAMS = {
        min: [0, -1, -0.1, -0.01, 0.001, 0, -0.005, 0.01, 0, 0, -1, -1],
        max: [100, 1, 0.1, 0.01, 0.03, 1, 0.005, 0.05, 100, 100, 1, 1],
    };
    
    const MODEL_ARTIFACTS_JSON_STRING = '{"format":"layers-model","generatedBy":"TensorFlow.js tfjs-layers v4.2.0","convertedBy":null,"modelTopology":{"class_name":"Sequential","config":{"name":"sequential_1","layers":[{"class_name":"LSTM","config":{"name":"lstm_LSTM1","trainable":true,"batch_input_shape":[null,10,12],"dtype":"float32","units":64,"activation":"relu","recurrent_activation":"hard_sigmoid","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"recurrent_initializer":{"class_name":"Orthogonal","config":{"gain":1,"seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"unit_forget_bias":null,"kernel_regularizer":null,"recurrent_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"recurrent_constraint":null,"bias_constraint":null,"dropout":0,"recurrent_dropout":0,"implementation":null,"return_sequences":false,"return_state":false,"go_backwards":false,"stateful":false,"unroll":false}},{"class_name":"Dropout","config":{"rate":0.2,"noise_shape":null,"seed":null,"name":"dropout_Dropout1","trainable":true}},{"class_name":"Dense","config":{"units":32,"activation":"relu","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense1","trainable":true}},{"class_name":"Dense","config":{"units":4,"activation":"softmax","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense2","trainable":true}}]},"keras_version":"tfjs-layers 4.2.0","backend":"tensor_flow.js"},"weightsManifest":[{"paths":["weights.bin"],"weights":[{"name":"lstm_LSTM1/kernel","shape":[12,256],"dtype":"float32"},{"name":"lstm_LSTM1/recurrent_kernel","shape":[64,256],"dtype":"float32"},{"name":"lstm_LSTM1/bias","shape":[256],"dtype":"float32"},{"name":"dense_Dense1/kernel","shape":[64,32],"dtype":"float32"},{"name":"dense_Dense1/bias","shape":[32],"dtype":"float32"},{"name":"dense_Dense2/kernel","shape":[32,4],"dtype":"float32"},{"name":"dense_Dense2/bias","shape":[4],"dtype":"float32"}]}]}';
    const WEIGHTS_BASE64_STRING = '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'; // <--- PASTIKAN TANDA INI ADA
    
    const AI_UPDATE_INTERVAL_MS = 15000; // 15 detik
    const MS_UPDATE_INTERVAL_MS = 10000; // 10 detik
    const HTF_UPDATE_INTERVAL_MS = 30000; // 5 menit untuk update tren utama
    const REGIME_MEMORY_SIZE = 4;
    const TAKER_FEE_NOTIONAL = 0.0005; 
    const BEP_PROFIT_BUFFER_PERCENT = 0.50; // Buffer profit minimal 0.50% ROE untuk mengunci BEP
    const MAX_RISK_ROE = 1.0; // Batas Kerugian Keras untuk Sizing
    const SRSI_ENTRY_LEVEL = 25; // Batas SRSI Entry (15 dan 85)
    const SRSI_EXIT_LEVEL = 10; // Batas SRSI Exit (20 dan 80)
    const MIN_HOLD_TIME_CANDLES = 3; // Logika Anti-CP
    const PROFIT_LOCK_STEP_ROE = 1.5; 
    const TRAILING_BUFFER_ROE = 0.5;
    const userSettings = {
            presets: {
                'default': { weights: { 
                    ma: 2.0, 
                    rsiDivergence: 1.0, 
                    macd: 2.0, 
                    pivot: 0.0,           
                    vwap: 1.5, 
                    ichimoku: 5.0,        
                    candlePattern: 1.0, 
                    obvDivergence: 0.0, 
                    bbSqueeze: 0.0, 
                    psar: 0.0,            
                    roc: 0.0, 
                    bollingerBands: 1.0, 
                    rsi: 2.0, 
                    stoch: 4.0,           
                    linreg: 0.0           
                } },
            }
    };
    const CVD_DIP_DEBOUNCE_MS = 5000;
    const DUMP_RISK_THRESHOLD = 4.0;      
    const MAX_EQUITY_LOSS_PERCENT = 10.0; 
    const MAX_GLOBAL_LOSE_STREAK = 5;     
    const TIMEFRAME_MAP_MS = {
        '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
        '1h': 3600000, '4h': 14400000, '1d': 86400000
     };    
    const timeframeParameterMap = {
        '1m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 9, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 9, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };    
    const CVD_AGGREGATION_INTERVAL_MS = 500000; 
    const WebSocketManager = {
        ws: null,
        mainSubscriptions: new Set(),
        moverSubscriptions: new Set(),
        messageHandlers: {},
        reconnectBaseDelay: 5000, 
        reconnectAttempts: 0,
        maxReconnectDelay: 60000,
        isConnecting: false,
        
        handleOpen() {
            this.isConnecting = false;
            this.reconnectAttempts = 0; 
        },

        handleMessage(event) {
            const message = JSON.parse(event.data);
            if (message.result !== undefined) return;

            if (message.stream && message.data) {
                const streamName = message.stream;
                const payload = message.data;
                const symbol = streamName.split('@')[0].toUpperCase();

                if (this.moverSubscriptions.has(symbol)) {
                    onNewMoverData(symbol, streamName, payload);
                }

                if (realtimeCache.main.symbol && realtimeCache.main.symbol === symbol) {
                    if (streamName.includes('@kline')) {
                        if (this.messageHandlers['kline']) this.messageHandlers['kline'](payload);
                    } else if (streamName.includes('@aggTrade')) {
                        if (this.messageHandlers['aggTrade']) this.messageHandlers['aggTrade'](payload);
                    } else if (streamName.includes('@depth')) {
                        if (this.messageHandlers['depthUpdate']) this.messageHandlers['depthUpdate'](payload);
                    }
                }
            }
        },

        handleClose() {
            this.isConnecting = false;
            if (this.mainSubscriptions.size > 0 || this.moverSubscriptions.size > 0) {
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectBaseDelay * (2 ** this.reconnectAttempts), this.maxReconnectDelay);
                setTimeout(() => this.connect(), delay);
            }
        },

        handleError(error) {
            console.error("Kesalahan WebSocket:", error);
            this.isConnecting = false;
            if (this.ws) this.ws.close();
        },

        connect() {
            if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) return;
            this.isConnecting = true;
            
            // MOVER STREAMS: 1h kline dan aggTrade untuk setiap mover
            const moverStreams = Array.from(this.moverSubscriptions).flatMap(s => [`${s.toLowerCase()}@kline_1h`, `${s.toLowerCase()}@aggTrade`]);
            const mainStreams = Array.from(this.mainSubscriptions);
            const allSubscriptions = new Set([...mainStreams, ...moverStreams]);
            
            const streamNames = Array.from(allSubscriptions).join('/');
            
            if (streamNames.length === 0) {
                this.isConnecting = false;
                return;
            }
            const url = `wss://fstream.binance.com/stream?streams=${streamNames}`;
            this.ws = new WebSocket(url);
            this.ws.onopen = this.handleOpen.bind(this);
            this.ws.onmessage = this.handleMessage.bind(this);
            this.ws.onclose = this.handleClose.bind(this);
            this.ws.onerror = this.handleError.bind(this);
        },
        
        subscribe(streams) { 
            this.mainSubscriptions.clear();
            streams.forEach(stream => this.mainSubscriptions.add(stream));
            this.reconnect();
        },

        subscribeToMovers(symbols) {
            const newSubs = new Set(symbols);
            if (new Set([...newSubs]).size === this.moverSubscriptions.size && [...newSubs].every(s => this.moverSubscriptions.has(s))) {
                return; 
            }
            this.moverSubscriptions = newSubs;
            this.reconnect();
        },

        reconnect() {
            if (this.ws) {
                this.ws.onclose = null;
                this.ws.close();
            }
            this.connect();
        },

        registerHandler(streamName, handler) {
            this.messageHandlers[streamName] = handler;
        }
    };
    
    let tsCalc;
    let tsCalcElements;
    
    const processQueues = async () => {
        if (klineQueue.length > 0) {
            const klinesToProcess = klineQueue.splice(0, klineQueue.length);
            klinesToProcess.forEach(message => {
                const candle = message.k;
                const timeframe = candle.i;
                const mainTimeframe = liveTimeframeSelect.value;
                const formattedCandle = [candle.t, candle.o, candle.h, candle.l, candle.c, candle.v, candle.T, candle.q, candle.n, candle.V, candle.Q, candle.B];

                if (timeframe === mainTimeframe && realtimeCache.main.klines) {
                    if (candle.x) { 
                        realtimeCache.main.klines.shift();
                        realtimeCache.main.klines.push(formattedCandle);
                    } else { 
                        realtimeCache.main.klines[realtimeCache.main.klines.length - 1] = formattedCandle;
                    }
                    updateAllCharts(candle);
                }
                if (realtimeCache.main.multiTfKlines && realtimeCache.main.multiTfKlines[timeframe]) {
                    const multiTfCache = realtimeCache.main.multiTfKlines[timeframe];
                    if (candle.x) { 
                        multiTfCache.shift();
                        multiTfCache.push(formattedCandle);
                    } else { 
                        multiTfCache[multiTfCache.length - 1] = formattedCandle;
                    }
                }
            });
        }

        if (tradeQueue.length > 0) {
            const tradesToProcess = tradeQueue.splice(0, tradeQueue.length);
            const lastTrade = tradesToProcess.slice(-1)[0];
            
            if (lastTrade) {
                const price = parseFloat(lastTrade.p);
                if (realtimeCache.main.tickerData) {
                    realtimeCache.main.tickerData.lastPrice = price.toString();
                }
                
                const livePriceDisplay = document.getElementById('live-price-display');
                if (livePriceDisplay) livePriceDisplay.textContent = formatPrice(price, realtimeCache.main.symbol);
                const marketPriceInput = tsCalcElements.marketPrice;
                if (document.activeElement !== marketPriceInput) {
                    marketPriceInput.value = price.toFixed(precisionMap[realtimeCache.main.symbol] || 4);
                }
            }

            tradesToProcess.forEach(trade => {
                const quantity = parseFloat(trade.q);
                const price = parseFloat(trade.p);
                const sign = trade.m ? -1 : 1; 
                const now = trade.T;

                const lastCvd = realtimeCache.main.cvdData.slice(-1)[0];
                if (lastCvd && now > lastCvd.time * 1000 + CVD_AGGREGATION_INTERVAL_MS) {
                    realtimeCache.main.cvdData.push({ time: now / 1000, cvd_coin: lastCvd.cvd_coin, cvd_usdt: lastCvd.cvd_usdt });
                }
                if (lastCvd) {
                    lastCvd.cvd_coin += quantity * sign;
                    lastCvd.cvd_usdt += (quantity * price) * sign;
                }
            });
        }

        if (realtimeCache.main.symbol && realtimeCache.main.multiTfKlines) {
            const dumpTfSelector = document.getElementById('dump-trigger-timeframe-select');
            const selectedDumpTf = dumpTfSelector ? dumpTfSelector.value : '5m';
            const klinesForDump = realtimeCache.main.multiTfKlines[selectedDumpTf];

            if (klinesForDump && klinesForDump.length >= 50 && realtimeCache.main.cvdData.length > 0) {
                 const scoreData = calculateShortConfluenceScore(realtimeCache.main.symbol, selectedDumpTf); 
                 const finalScore = scoreData.score;
                 const mainScores = realtimeCache.main.latestScalpingSetup?.scores;
                 const bullScore = mainScores?.bull || 0; 
                 const bearScoreAFT = mainScores?.bear || 0;
                 const bullBar = document.getElementById('bull-bar-dump');
                 const bearBar = document.getElementById('bear-bar-dump');
                 const bullPercentEl = document.getElementById('bull-percent-dump');
                 const bearScoreEl = document.getElementById('bear-score-dump');

                 if (bullBar && bearBar) {
                     const totalBullScoreForDisplay = bullScore; 
                     const totalBearScoreForDisplay = finalScore * 10; 
                     const totalDisplay = totalBullScoreForDisplay + totalBearScoreForDisplay;
                     let bullWidth = totalDisplay > 0 ? (totalBullScoreForDisplay / totalDisplay) * 100 : 50;
                     let bearWidth = 100 - bullWidth;
                     bullBar.style.width = `${bullWidth.toFixed(0)}%`;
                     bearBar.style.width = `${bearWidth.toFixed(0)}%`;
                     let bullColor = bullScore >= finalScore * 10 ? '#2ebd85' : '#4ade80'; 
                     let bearColor = finalScore * 10 > bullScore ? '#f6465d' : '#e57373';
                     bullBar.style.backgroundColor = bullColor;
                     bearBar.style.backgroundColor = bearColor;
                     bullPercentEl.textContent = `${totalBullScoreForDisplay.toFixed(0)}%`;
                     bearScoreEl.textContent = `${finalScore.toFixed(1)} / 10`; 
                     bullPercentEl.className = bullScore >= finalScore * 10 ? 'text-black' : 'text-gray-900/70';
                     bearScoreEl.className = finalScore * 10 > bullScore ? 'text-white' : 'text-gray-200/70';
                 }
                
                 const header = document.querySelector('#live-signal-panel h2');
                 if (header) {
                    let scoreSpan = header.querySelector('#dump-score-display');
                    if (!scoreSpan) { 
                         scoreSpan = document.createElement('span');
                         scoreSpan.id = 'dump-score-display';
                         scoreSpan.className = 'font-mono text-base text-white ml-auto'; 
                         header.appendChild(scoreSpan);
                    }
                    scoreSpan.textContent = `Dump Risk: ${finalScore.toFixed(1)} / 10`;
                    
                    if (finalScore >= 8) scoreSpan.className = 'font-mono text-base text-red-500 ml-auto blinking-status';
                    else if (finalScore >= 5) scoreSpan.className = 'font-mono text-base text-yellow-500 ml-auto';
                    else scoreSpan.className = 'font-mono text-base text-green-500 ml-auto';
                 }
                 

                 const breakdownList = document.getElementById('trigger-breakdown-list');
                 if (breakdownList) {
                    const breakdown = scoreData.breakdown;  
                    const renderItem = (key, value) => {
                        const displayName = key.replace(/([A-Z])/g, ' $1').trim();

                        if (typeof value === 'object' && value !== null && typeof value.triggered === 'boolean') {
                            const isTriggered = value.triggered && value.points > 0.001;
                            const color = isTriggered ? 'negative font-semibold' : 'text-gray-600';
                            const displayValue = isTriggered ? `+${value.points.toFixed(2)} Poin` : '0 Poin';
                            
                            return `<div class="flex justify-between text-xs"><span>${isTriggered ? '‚úÖ ' : '‚¨ú '}${displayName}</span><span class="${color}">${displayValue}</span></div>`;
                        }
        
                        const safeValue = value !== undefined && value !== null ? value.toString() : 'N/A';
                        if (key === 'rsiValue' || key.includes('Status') || key.includes('bb')) {
                             const statusClass = safeValue.includes('Bearish') ? 'negative' : (safeValue.includes('Bullish') ? 'positive' : 'text-gray-400');
                             return `<div class="flex justify-between text-xs text-gray-500"><span>${displayName}</span><span class="${statusClass}">${safeValue}</span></div>`;
                        }

                        return '';
                    };

                    const triggerItems = Object.entries(breakdown).filter(([key, value]) => typeof value === 'object' && value !== null && typeof value.triggered === 'boolean');
                    const rawValueItems = Object.entries(breakdown).filter(([key, value]) => key !== 'timeframe' && !key.includes('Status') && !key.includes('bb') && typeof value !== 'object');

                     breakdownList.innerHTML = `
                        <p class="text-xs text-gray-400 mb-2">Timeframe: <span class="font-mono text-yellow-400">${breakdown.timeframe || 'N/A'}</span></p>
                        
                        <h4 class="text-sm font-semibold mb-1 text-gray-400 border-b border-gray-700/50 pb-1">Status Indikator Mentah</h4>
                        <div class="p-2 rounded-md bg-gray-900/50 space-y-1">
                            ${Object.entries(breakdown).map(([key, value]) => {
                                if (key === 'rsiValue' || key.includes('Status') || key.includes('bb')) {
                                    return renderItem(key, value);
                                }
                                return '';
                            }).join('')}
                        </div>
                        
                        <h4 class="text-sm font-semibold mt-3 mb-2 text-red-400">Pemicu Dump (Points)</h4>
                        <div class="p-2 rounded-md bg-gray-900/50 space-y-1">
                           ${triggerItems.map(([key, value]) => renderItem(key, value)).join('')}
                        </div>
                        
                        <hr class="border-gray-700/50 my-2"/>
                        <div class="flex justify-between text-sm font-bold"><span>Final Score</span><span class="${finalScore >= 5 ? 'negative' : 'positive'}">${finalScore.toFixed(1)} / 10</span></div>
                     `;
                 }
            }
        }
        if (depthQueue.length > 0) {
            const depthUpdate = depthQueue.pop(); 
            depthQueue.length = 0; 

            if (depthUpdate) {
                updateOrderFlowPanel(depthUpdate); 
        }}}; 
    
    const realtimeCache = {
        main: {
            symbol: null,
            tickerData: {},
            latestScalpingSetup: null
        },
        indicators: {
            bullScore: 0,
            bearScore: 0,
            htfTrend: 'NEUTRAL',
            atr: 0,
            entryPrice: null, 
            stopLoss: null,
            tp1: null,
            tp2: null 
        }
    };
    
    const activeStrategy = {
        dnaType: 'AutoSwitch_v1', 
        weights: userSettings.presets.default.weights, 
        autoWeights: { 
            'bullTrend': { weights: userSettings.presets.default.weights },
            'bearTrend': { weights: userSettings.presets.default.weights },
            'ranging': { weights: userSettings.presets.default.weights },
            'lowVolatility': { weights: userSettings.presets.default.weights }
        }, 
        metadata: {
            dnaType: 'AutoSwitch_v1', 
            sourceAsset: 'BTCUSDT', 
            sourceTimeframe: '5m',       
            filename: 'BRUTAL_BTC_5M_AUTOSWITCH_DEFAULT.json'
        },
        parameters: {
            riskRewardRatio: 1.5,       
            pullbackEmaPeriod: 8,        
            biasThreshold: 15.0,        
            atrFilterThreshold: 0.5,
            swingLookback: 15
        }
    };
    
    let lastHtfUpdate = 0;
    let lastTradeExecutionTime = 0; 
    let nextFundingTimestamp = 0;
    let isFibRetracementVisible = false;
    let lastUsedApiMode = false; // false = Offline, true = Online
    let latencyInterval = null;
    let binanceApiKeys = { key: 'PROXY_KEY_ACTIVE', secret: 'PROXY_SECRET_ACTIVE' };
    let liveData = null; 
    let liveWebSocket = null;
    let orderFlowSocket = null;
    let liveInterval = null;
    let currentChartTimeframe = '5m';
    let macroTrend_1h = 'NEUTRAL';
    let primaryTrend_15m = 'NEUTRAL';
    let lastPrimaryTrendUpdate = 0;
    let latestSignalSetup = null;
    let currentMarketPrice = 0;
    let precisionMap = {};   
    let isChartsVisible = false;
    let charts = [];
    let candlestickSeries = null;
    let volumeSeries = null;
    let rsiSeries = null;
    let stochKSeries = null;
    let stochDSeries = null;
    let macdLineSeries = null;
    let signalLineSeries = null;
    let macdHistSeries = null;
    let ema21Series = null;
    let ema89Series = null;
    let forecastChart;
    let signalStartTime = null; 
    let timeElapsedInterval = null; 
    let lastStableSignal = 'NONE';
    let signalActiveStartTime = null;
    let activeDnaFilename = '--';
    let currentBias = 'NEUTRAL';
    let regimeSensorModel = null;
    let periodicUpdateInterval = null; 
    let processingInterval = null; 
    let exchangeInfoCache = { futures: null }; 
    let klineQueue = [];
    let tradeQueue = [];
    let depthQueue = [];
    let globalLossStreak = 0; 
    let initialEquitySnapshot = 250; 
    let isGlobalStopActive = false;
    let isTooltipActive = false;
    let orderBookHistory = { avgVolumes: [], maxSize: 30 };
    let cvdAggregator = { currentBucketTimestamp: 0, currentBucketDelta: 0, history: [], lastTriggerResult: { triggered: false, points: 0 } };
    let lastCvdDipCalculationTime = 0;
    let lastCvdDipResult = { triggered: false, points: 0 };
    let cvdChartInstance = null; 
    let regimeMemory = Array(REGIME_MEMORY_SIZE).fill('RANGING'); 
    let lastAiUpdate = 0; 
    let lastMarketStructureUpdate = 0; 
    let regimeConfidence = 0.5;
    let manuallyReactivatedStrategies = new Set();
    let isAutoTradeEnabled = false; 
    let tsModeAFT = 'ATR';
    let lastRiskBasedCost = 0; 
    let currentSuperBias = 'NEUTRAL';

    const dnaStatusDisplay = document.getElementById('dna-status-display');
    const aiStatusDisplay = document.getElementById('ai-status');
    const activeRegimeDisplay = document.getElementById('active-regime-display');
    const assetSymbolDisplay = document.getElementById('asset-symbol-display');
    const REGIME_LABELS = ['BULL_TREND', 'BEAR_TREND', 'RANGING', 'LOW_VOLATILITY'];
    const importFile = document.getElementById('import-file');
    const importedStrategySection = document.getElementById('imported-strategy-section');
    const importedSinyalPanel = document.getElementById('imported-sinyal-panel');
    const liveSymbolInput = document.getElementById('live-symbol-input');
    const liveTimeframeSelect = document.getElementById('live-timeframe-select');
    const liveDataInputSection = document.getElementById('live-data-input-section');
    const liveSignalPanel = document.getElementById('live-signal-panel');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');
    
    const paperTrade = {
            state: {
                balance: 250,
                position: null,
                history: [],
                ts: {
                    enabled: true,          
                    callbackRate: 1.5,  
                    activationProfit: 1.0
                },
                peakEquity: 250, 
                equityProtectorFloor: 0 
            },

            calculatePnl: function(pos, markPrice) {
                const isLong = pos.type === 'long';
                return (isLong ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * pos.quantity;
            },

            calculateRoe: function(pnlRaw, cost) {
                return (cost > 0) ? (pnlRaw / cost) * 100 : 0;
            },
            
            calculateBEP: function(pos) {
                const feeRate = TAKER_FEE_NOTIONAL; 
                const bufferPercent = BEP_PROFIT_BUFFER_PERCENT / 100;
                const totalRequiredChangeRate = (2 * feeRate) + (bufferPercent / pos.leverage); 

                if (pos.type === 'long') {

                    return pos.entryPrice * (1 + totalRequiredChangeRate);
                } else {
                    return pos.entryPrice * (1 - totalRequiredChangeRate);
                }
            },

            init: function() {
                this.elements = {
                    equity: document.getElementById('sim-equity'),
                    unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
                    availableMargin: document.getElementById('sim-available-margin'),
                    resetBtn: document.getElementById('sim-reset-account-btn'),
                    tradeHistoryList: document.getElementById('sim-trade-history-list'),
                    positionContainer: document.getElementById('sim-active-position-container'),
                    positionHeader: document.getElementById('sim-position-header'),
                    closePositionBtn: document.getElementById('sim-close-position-btn'),
                    positionSymbol: document.getElementById('sim-position-symbol'), 
                    positionPnlTop: document.getElementById('sim-position-pnl-top'),
                    positionMargin: document.getElementById('sim-position-margin'),
                    positionSize: document.getElementById('sim-position-size'), 
                    positionEntry: document.getElementById('sim-position-entry'),
                    positionMark: document.getElementById('sim-position-mark'),
                    positionLiq: document.getElementById('sim-position-liq'),
                    positionBep: document.getElementById('sim-position-bep'), 
                    positionSlActive: document.getElementById('sim-position-sl-active'), 
                    positionTpFinal: document.getElementById('sim-position-tp-final'), 
                };

                if (!this.elements.tradeHistoryList) {
                     console.error("üö® FATAL: Elemen Trade History (sim-trade-history-list) tidak ditemukan. Cek kembali ID HTML.");
                     return; 
                }

                if (this.elements.closePositionBtn) {
                    this.elements.closePositionBtn.addEventListener('click', () => {
                        const currentPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                        if (!isNaN(currentPrice)) { 
                            this.closePosition(currentPrice);
                        } else {
                            alert("Gagal menutup posisi, harga pasar saat ini tidak tersedia.");
                        }
                    });
                }

                setInterval(() => this.update(), 300);
                this.loadState();
                this.render();
            },

            resetAccount: function(confirmFirst = true) {	
                const doReset = () => {
                    this.state.position = null;
                    this.state.history = [];
                    this.state.balance = 250;	
                    
                    isGlobalStopActive = false;	
                    globalLossStreak = 0;	
                    initialEquitySnapshot = 250;	
                    
                    this.state.peakEquity = 250;
                    this.state.equityProtectorFloor = 0;
                    for (const key in strategyLossStreaks) { delete strategyLossStreaks[key]; }
                    
                    this.saveState();

                    if (!this.elements || !this.elements.equity) {
                        console.warn("‚ö†Ô∏è Reset dipanggil sebelum Init. Melakukan inisialisasi paksa elemen UI.");
                        this.init(); 
                    }
                    
                    this.render();
                    console.log("‚úÖ FULL RESET: Saldo, Riwayat Trade, dan Status Global Stop telah direset.");
                };

                if (confirmFirst) {
                    if (confirm("üö® PERINGATAN: Anda yakin ingin melakukan FULL RESET? Ini akan menghapus riwayat, mereset saldo ke $250, dan menonaktifkan GLOBAL STOP.")) {
                        doReset();
                    }
                } else {
                    doReset();	
                }
            },

            syncAccountState: async function() {
                if (!lastUsedApiMode) return;	

                try {
                    console.log(`‚öôÔ∏è Menggunakan Proxy: Meminta status akun dari http://localhost:3000/sync-futures-account`);
                    const accountData = await syncAccountViaProxy();
                    const usdtBalance = accountData.usdtBalance;

                    if (!usdtBalance || typeof usdtBalance.walletBalance === 'undefined' || isNaN(parseFloat(usdtBalance.walletBalance))) {
                        throw new Error("Proxy response is incomplete or invalid (usdtBalance missing).");
                    }

                    this.equity = parseFloat(usdtBalance.walletBalance);
                    this.availableMargin = parseFloat(usdtBalance.availableBalance);

                    let totalUnrealizedPnl = accountData.positions.reduce((sum, pos) => sum + parseFloat(pos.unrealizedProfit), 0);
                    
                    const minBalanceThreshold = 50.00;	
                    if (this.equity < minBalanceThreshold) {
                        console.warn(`üö® Saldo Kritis Terdeteksi (\$${this.equity.toFixed(2)}). Live Trade OPEN akan diblokir.`);
                    }

                    const currentSymbol = realtimeCache.main.symbol;
                    const activeLivePosition = accountData.positions.find(p => p.symbol === currentSymbol && parseFloat(p.positionAmt) !== 0);

                    if (activeLivePosition) {
                        const entryPrice = parseFloat(activeLivePosition.entryPrice);
                        const quantity = Math.abs(parseFloat(activeLivePosition.positionAmt));
                        const leverage = parseFloat(activeLivePosition.leverage);
                        const liqPrice = parseFloat(activeLivePosition.liquidationPrice);
                        const cost = (entryPrice * quantity) / leverage;
                        
                        const latestLiqPrice = parseFloat(activeLivePosition.liquidationPrice);

                        this.state.position = {
                            type: parseFloat(activeLivePosition.positionAmt) > 0 ? 'long' : 'short',
                            entryPrice: entryPrice,
                            entryTimestamp: Date.now(),
                            quantity: quantity,
                            leverage: leverage,
                            cost: cost,
                            liqPrice: liqPrice,	
                            symbol: activeLivePosition.symbol,
                            sl: 0, tp1: 0, tp2: 0,
                            flag: 'LIVE',
                            isSafe: false,
                            highestMarkPrice: entryPrice,
                            lowestMarkPrice: entryPrice,
                            trailingStopPrice: parseFloat(activeLivePosition.positionAmt) > 0 ? 0 : 99999999
                        };

                        this.state.position.liqPrice = latestLiqPrice;

                    } else {
                        this.state.position = null;
                    }

                    this.render();	

                    document.getElementById('sim-equity').textContent = formatDollar(this.equity);
                    document.getElementById('sticky-equity-display').textContent = formatDollar(this.equity);
                    document.getElementById('sim-unrealized-pnl').textContent = formatDollar(totalUnrealizedPnl);
                    document.getElementById('sim-available-margin').textContent = formatDollar(this.availableMargin);

                    document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-green-500 blinking-status';
                    document.getElementById('api-status-text').textContent = 'üì° LIVE';
                    document.getElementById('connect-api-status-text').textContent = 'üî• PROXY CONNECTED';

                } catch (error) {
                    console.error("Error syncing account state. Falling back to Simulation Mode:", error);
                    alert(`üö® SYNC FAILED! Gagal terhubung ke proxy atau membaca data saldo. Error: ${error.message}. Beralih ke mode SIMULASI.`);
                    if (window.syncInterval) clearInterval(window.syncInterval);
                    if (window.liveInterval) clearInterval(window.liveInterval);
                    document.getElementById('connect-api-status-text').textContent = 'üö® SYNC FAILED';
                    document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-red-600';
                    fallbackToSimulationMode();
                    return;
                }
            },

            executeApiOpen: async function(tradeType, leverage, cost, entryPrice) {
                const symbol = realtimeCache.main.symbol;
                const side = (tradeType === 'long') ? 'BUY' : 'SELL';
                const oppositeSide = (tradeType === 'long') ? 'SELL' : 'BUY';
                const quantity = (cost * leverage) / entryPrice;
                
                const setup = realtimeCache.main.latestScalpingSetup;
                const stopPrice = setup?.sl?.price || 0;
                const tp1Price = setup?.tp1?.price || 0;
                const quantityPrecision = precisionMap[symbol] || 3;
                const fixedQuantity = quantity.toFixed(quantityPrecision);

                if (parseFloat(fixedQuantity) === 0) {
                    console.error("‚ùå GAGAL MEMBUKA POSISI: Quantity yang dihitung SANGAT KECIL atau NOL. Order dihentikan secara lokal.");
                    alert("GAGAL MEMBUKA POSISI: Kuantitas Order Nol. Periksa modal atau leverage Anda.");
                    return;	
                }

                const openParams = {
                    symbol: symbol, side: side, type: 'MARKET',
                    quantity: fixedQuantity,
                };

                try {
                    console.log(`üöÄ MENGIRIM ORDER OPEN ${side} KE BINANCE (MARKET)...`, openParams);
                    await sendBinanceRequest('POST', '/v1/order', openParams);

                    if (stopPrice > 0) {
                        const slParams = {
                            symbol: symbol,	
                            side: oppositeSide,	
                            type: 'STOP_MARKET',
                            quantity: fixedQuantity,
                            stopPrice: stopPrice.toFixed(precisionMap[symbol] || 2),
                            reduceOnly: 'true'
                        };
                        console.log(`üõ°Ô∏è MENGIRIM ORDER STOP LOSS (STOP MARKET) KE BINANCE...`, slParams);
                        await sendBinanceRequest('POST', '/v1/order', slParams);
                    }

                    if (tp1Price > 0) {
                        const tpParams = {
                            symbol: symbol,	
                            side: oppositeSide,	
                            type: 'TAKE_PROFIT_MARKET',
                            quantity: fixedQuantity,
                            stopPrice: tp1Price.toFixed(precisionMap[symbol] || 2),	
                            reduceOnly: 'true'
                        };
                        console.log(`üéØ MENGIRIM ORDER TAKE PROFIT (TAKE PROFIT MARKET) KE BINANCE...`, tpParams);
                        await sendBinanceRequest('POST', '/v1/order', tpParams);
                    }
                    
                    console.log('‚úÖ Order Live Trade (Open + Proteksi SL/TP) berhasil dikirim.');
                    
                } catch (error) {
                    console.error("‚ùå GAGAL MEMBUKA POSISI API:", error);
                    alert(`GAGAL MEMBUKA POSISI API: ${error.message}`);
                }
            },

            executeApiClose: async function() {
                const pos = this.state.position;
                if (!pos) return;

                try {
                    console.log(`üóëÔ∏è MEMBATALKAN SEMUA ORDER TERTUNDA DI BINANCE...`);
                    const cancelParams = { symbol: pos.symbol };	
                    await sendBinanceRequest('DELETE', '/v1/allOpenOrders', cancelParams);
                    console.log('‚úÖ Pembatalan order tertunda berhasil.');
                } catch (error) {
                    console.warn("‚ö†Ô∏è Gagal membatalkan order tertunda (mungkin tidak ada order terbuka).", error);
                }

                const orderParams = {
                    symbol: pos.symbol,
                    side: (pos.type === 'long') ? 'SELL' : 'BUY',
                    type: 'MARKET',
                    quantity: pos.quantity.toFixed(precisionMap[pos.symbol] || 3),
                    reduceOnly: 'true'
                };

                try {
                    console.log(`‚èπÔ∏è MENGIRIM ORDER CLOSE KE BINANCE (MARKET)...`, orderParams);
                    const orderResponse = await sendBinanceRequest('POST', '/v1/order', orderParams);
                    console.log('‚úÖ RESPON BINANCE (CLOSE):', orderResponse);
                } catch (error) {
                    console.error("‚ùå GAGAL MENUTUP POSISI API:", error);
                    alert(`GAGAL MENUTUP POSISI API: ${error.message}`);
                }
            },

            // --- GANTI SELURUH FUNGSI 'openPosition' ANDA DENGAN INI ---
            openPosition: async function(type, leverage, cost, entryPrice, flag = 'Manual', sizingMode = 'FIXED', stopLoss, tp1, tp2, tp3) {
                if (isGlobalStopActive) {
                    console.warn(`üö® GLOBAL STOP ACTIVE: Entry diblokir.`);
                    return;
                }

                const pos = this.state.position; // Cek posisi internal (simulasi/cache)

                // --- LOGIKA "THE WHITE SWAN" V2.1 ---
                
                // SKENARIO 1: "ADD MARGIN" (S.O.P. 4a)
                if (pos && pos.type === type) {
                    
                    // Filter "add margin only one time"
                    if (pos.entryCount && pos.entryCount >= 2) {
                        console.warn(`[AFT BLOCKED] Sinyal Add Margin ke-2 terdeteksi. Ditolak. Sesuai S.O.P. "add margin only one time".`);
                        return;
                    }

                    console.log(`üî• [ADD MARGIN] S.O.P. 4a terdeteksi. Menambahkan 10% margin ke posisi ${type.toUpperCase()}.`);
                    
                    // --- PERBAIKAN BOM WAKTU 'TODO' (LIVE MODE) ---
                    if (lastUsedApiMode) {
                        try {
                            console.warn(`[LIVE: ADD MARGIN] Membatalkan SL/TP lama...`);
                            // 1. Batalkan semua SL/TP lama untuk simbol ini
                            await sendBinanceRequest('DELETE', '/v1/allOpenOrders', true, { symbol: pos.symbol });
                            
                            console.log(`[LIVE: ADD MARGIN] Mengirim order MARKET (10% baru)...`);
                            // 2. Kirim order MARKET baru (Binance akan otomatis averaging)
                            const quantity = (cost * leverage) / entryPrice;
                            const quantityPrecision = precisionMap[pos.symbol] || 3;
                            await sendBinanceRequest('POST', '/v1/order', true, {
                                symbol: pos.symbol, side: (type === 'long' ? 'BUY' : 'SELL'), type: 'MARKET',
                                quantity: quantity.toFixed(quantityPrecision),
                            });

                            console.log(`[LIVE: ADD MARGIN] Mengirim SL/TP BARU (berdasarkan sinyal re-entry)...`);
                            // 3. Kirim SL/TP BARU berdasarkan sinyal RE-ENTRY (S.O.P. 2.1 / SL Black Swan)
                            // Catatan: Kita tidak tahu harga rata-rata baru sampai 'syncAccountState' berikutnya,
                            // jadi kita HARUS MENGGUNAKAN SL/TP DARI SINYAL RE-ENTRY.
                            const stopPrice = stopLoss; // SL dari sinyal re-entry (Tembok ke-2)
                            const tpPrice = tp1;       // TP dari sinyal re-entry
                            const oppositeSide = (type === 'long') ? 'SELL' : 'BUY';

                            // 4. Hitung ulang total kuantitas (estimasi) untuk order SL/TP baru
                            const newTotalQuantity = pos.quantity + quantity;

                            if (stopPrice > 0) {
                                await sendBinanceRequest('POST', '/v1/order', true, {
                                    symbol: pos.symbol, side: oppositeSide, type: 'STOP_MARKET',
                                    quantity: newTotalQuantity.toFixed(quantityPrecision),
                                    stopPrice: stopPrice.toFixed(precisionMap[pos.symbol] || 2), reduceOnly: 'true'
                                });
                            }
                            if (tpPrice > 0) {
                                await sendBinanceRequest('POST', '/v1/order', true, {
                                    symbol: pos.symbol, side: oppositeSide, type: 'TAKE_PROFIT_MARKET',
                                    quantity: newTotalQuantity.toFixed(quantityPrecision),
                                    stopPrice: tpPrice.toFixed(precisionMap[pos.symbol] || 2), reduceOnly: 'true'
                                });
                            }
                            
                            console.log(`‚úÖ [LIVE: ADD MARGIN] Sukses. Bot akan sync di siklus berikutnya.`);
                            // Biarkan syncAccountState() berikutnya (dari interval) memperbaiki data internal
                            return; 

                        } catch (error) {
                            console.error("‚ùå GAGAL FATAL SAAT ADD MARGIN LIVE:", error);
                            alert(`GAGAL ADD MARGIN LIVE: ${error.message}. Cek konsol & posisi Anda di Binance SEKARANG.`);
                            return;
                        }
                    }
                    // --- AKHIR PERBAIKAN 'TODO' ---

                    // (Logika Add Margin SIMULASI - dari kode sebelumnya)
                    const newQuantity = (entryPrice > 0) ? (cost * leverage) / entryPrice : 0;
                    const totalCost = pos.cost + cost;
                    const totalQuantity = pos.quantity + newQuantity;
                    const averageEntryPrice = ((pos.entryPrice * pos.quantity) + (entryPrice * newQuantity)) / totalQuantity;

                    pos.cost = totalCost;
                    pos.quantity = totalQuantity;
                    pos.entryPrice = averageEntryPrice;
                    pos.entryCount = (pos.entryCount || 1) + 1;
                    pos.sl = stopLoss; // Menggunakan SL dari sinyal RE-ENTRY
                    pos.trailingStopPrice = stopLoss;
                    
                    const maintenanceMarginRate = 0.005;
                    const marginUsedForLiq = pos.cost;
                    const priceChangeToLoss = marginUsedForLiq / (pos.entryPrice * pos.quantity);
                    pos.liqPrice = type === 'long' ? pos.entryPrice * (1 - priceChangeToLoss) : pos.entryPrice * (1 + priceChangeToLoss);
                    if (pos.liqPrice < 0) pos.liqPrice = 0;

                    console.log(`‚úÖ [AVERAGING SUKSES] Entry: ${formatPrice(pos.entryPrice)}. SL Baru: ${formatPrice(pos.sl)}. Total Cost: ${pos.cost.toFixed(2)} USDT.`);

                
                // SKENARIO 2: POSISI BERLAWANAN (AUTO-CLOSE LALU BUKA)
                } else if (pos && pos.type !== type) {
                    console.warn(`[AUTO-REVERSE] Sinyal ${type.toUpperCase()} terdeteksi saat ${pos.type.toUpperCase()} aktif. Menutup posisi lama...`);
                    // Untuk Live Mode, syncAccountState() akan menangani penutupan ini
                    if (!lastUsedApiMode) {
                        this.closePosition(entryPrice, `REVERSE SIGNAL (to ${type.toUpperCase()})`);
                    }
                    return; 

                // SKENARIO 3: ENTRY BARU (S.O.P. FASE 3)
                } else if (!pos) {
                    
                    // --- PERBAIKAN BOM WAKTU 'TODO' (LIVE MODE) ---
                    if (lastUsedApiMode) {
                        console.log(`[LIVE: ENTRY 1] Mengirim Sinyal Buka Posisi Baru...`);
                        await this.executeApiOpen(type, leverage, cost, entryPrice, stopLoss, tp1);
                        // Biarkan syncAccountState() berikutnya (dari interval) mengambil posisi baru
                        return;
                    }
                    // --- AKHIR PERBAIKAN 'TODO' ---

                    // (Logika Entry Baru SIMULASI - dari kode sebelumnya)
                    const totalEquity = this.state.balance || 250;
                    if (cost < 1.0 || isNaN(cost) || !isFinite(cost) || cost > totalEquity) {
                        console.warn(`[AFT BLOCKED] Cost (${cost.toFixed(2)} USDT) tidak valid atau melebihi Margin.`);
                        return;
                    }

                    const positionSize = cost * leverage;
                    const quantity = entryPrice > 0 ? positionSize / entryPrice : 0;
                    const MIN_NOTIONAL_LIMIT = 5.0;

                    if (quantity * entryPrice < MIN_NOTIONAL_LIMIT) {
                        console.warn(`üõë ENTRY DIBATALKAN: Notional (${(quantity * entryPrice).toFixed(2)} USD) di bawah batas minimum notional ($${MIN_NOTIONAL_LIMIT}).`);
                        return;
                    }

                    const maintenanceMarginRate = 0.005;
                    const marginUsedForLiq = cost;
                    const priceChangeToLoss = marginUsedForLiq / positionSize;
                    let liqPrice = type === 'long' ? entryPrice * (1 - priceChangeToLoss) : entryPrice * (1 + priceChangeToLoss);
                    if (liqPrice < 0) liqPrice = 0;

                    this.state.position = {
                        type: type, entryPrice: entryPrice, entryTimestamp: Date.now(),
                        quantity: quantity, leverage: leverage, cost: cost,
                        liqPrice: liqPrice,
                        sl: stopLoss, // Ini adalah SL Awal (Pilar IV / "Black Swan" SL pertama)
                        tp1: tp1, tp2: tp2, tp3: tp3,
                        nextTpTarget: tp1,
                        flag: flag,
                        symbol: realtimeCache.main.symbol,
                        biasStatus: realtimeCache.main.latestScalpingSetup?.bias.status || 'N/A',
                        trailingStopPrice: stopLoss,
                        highestMarkPrice: entryPrice,
                        lowestMarkPrice: entryPrice,
                        isSafe: false,
                        lastPartialCloseStep: 0,
                        marginMode: sizingMode,
                        entryCount: 1 // <-- PELACAK BARU UNTUK "ADD MARGIN 1X"
                    };

                    this.state.balance -= cost;
                    console.log(`üöÄ OPEN (ENTRY 1): Posisi ${type.toUpperCase()} ${flag} (${leverage}x) dibuka. Entry: ${formatPrice(entryPrice)}. SL: ${formatPrice(stopLoss)}. Cost: ${cost.toFixed(2)} USDT.`);
                
                } // --- AKHIR LOGIKA "THE WHITE SWAN" ---

                this.saveState();
                this.render();
            },

            closePosition: function(closePrice, closeReason = 'Manual Close') {
                const pos = this.state.position;
                if (!pos) {
                    console.warn("Close diblokir, tidak ada posisi aktif.");
                    return;
                }              
                if (isNaN(closePrice) || closePrice <= 0) {
                    console.error("Close diblokir, harga penutupan tidak valid.");
                    return;
                }

                const isLong = pos.type === 'long';
                const priceDiff = isLong	
                    ? (closePrice - pos.entryPrice)
                    : (pos.entryPrice - closePrice);
                const pnlGross = priceDiff * pos.quantity;	
                const entryNotional = pos.entryPrice * pos.quantity;
                const closeNotional = closePrice * pos.quantity;
                const totalFees = (entryNotional + closeNotional) * TAKER_FEE_NOTIONAL;
                const pnlNet = pnlGross - totalFees;
                const roeNet = (pos.cost > 0) ? (pnlNet / pos.cost) * 100 : 0;
                
                let pnlForBalance = pnlNet;	
                if (pnlNet < 0 && Math.abs(pnlNet) > pos.cost) {
                    pnlForBalance = -pos.cost;	
                    console.warn(`‚ö†Ô∏è SIMULASI FIX: Kerugian (-${Math.abs(pnlNet).toFixed(2)} USD) melebihi margin. Dibatasi pada -${pos.cost.toFixed(2)} USD.`);
                }
                
                if (pnlNet < 0) {
                    globalLossStreak++;
                } else if (pnlNet > 0) {
                    globalLossStreak = 0;	
                }
                
                const strategyName = pos.biasStatus;
                if (strategyName && strategyName !== 'NEUTRAL - NO BIAS') {
                    if (pnlNet < 0) {
                        strategyLossStreaks[strategyName] = (strategyLossStreaks[strategyName] || 0) + 1;
                    console.log(` Streak Kerugian untuk ${strategyName}: ${strategyLossStreaks[strategyName]}x`);
                } else if (pnlNet > 0) {
                        strategyLossStreaks[strategyName] = 0;	
                    }
                }
                
                this.state.balance += pos.cost + pnlForBalance;
                
                const closeTime = new Date();
                const tradeRecord = {
                    time: closeTime.toISOString(),	
                    closedAtString: closeTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }),
                    type: pos.type,
                    symbol: pos.symbol,
                    entry: pos.entryPrice,
                    closePrice: closePrice,
                    pnlGross: pnlGross,
                    pnlNet: pnlNet,	
                    roeNet: roeNet,	
                    fees: totalFees,
                    reason: closeReason,
                    flag: pos.flag,
                    biasStatus: pos.biasStatus,
                    cost: pos.cost,
                    leverage: pos.leverage,
                };

                this.state.history.unshift(tradeRecord);
                
                const logMessage = `‚èπÔ∏è CLOSED: Posisi ${pos.type.toUpperCase()} ditutup di ${formatPrice(closePrice)}. PNL Net: ${formatPrice(pnlNet)} (${roeNet.toFixed(2)}%). Alasan: ${closeReason}`;
                console.log(logMessage);

                lastTradeExecutionTime = Date.now();
                this.state.position = null;	

                this.saveState();
                this.render();
                
                if(isGlobalStopActive) {
                    alert(`üö® GLOBAL STOP ACTIVE! Total Kerugian Realized melebihi ${MAX_EQUITY_LOSS_PERCENT}% atau Global Streak mencapai ${MAX_GLOBAL_LOSE_STREAK}x. Semua entry diblokir.`);
                }
            },

            update: function() {
                const pos = this.state.position;
                if (!pos) return;

                const lastPriceString = realtimeCache.main.tickerData?.lastPrice;
                const markPrice = parseFloat(lastPriceString) || pos.entryPrice; 
                
                if (markPrice <= 0 || isNaN(markPrice)) { 
                    this.render(); 
                    return; 
                }

                const tradeStatus = checkPositionLogic(pos, markPrice, realtimeCache.main.latestScalpingSetup);
                if (tradeStatus.action === 'CLOSE') {
                    this.closePosition(markPrice, tradeStatus.reason);
                    return; 
                } 
                
                this.executeTrailingStopLogic(pos, markPrice, realtimeCache.main.allIndicators);

                const isLong = pos.type === 'long';
                let nextTpTarget = pos.tp3;

                if (pos.tp1 > 0 && ((isLong && markPrice < pos.tp1) || (!isLong && markPrice > pos.tp1))) {
                    nextTpTarget = pos.tp1;
                } else if (pos.tp2 > 0 && ((isLong && markPrice < pos.tp2) || (!isLong && markPrice > pos.tp2))) {
                    nextTpTarget = pos.tp2;
                }
                
                pos.nextTpTarget = nextTpTarget; 

                const pnlRaw = (isLong ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * pos.quantity;
                const TAKER_FEE_NOTIONAL = 0.0005;
                const feeOpen = pos.cost * TAKER_FEE_NOTIONAL;
                const feeCloseEstimate = (pos.cost * pos.leverage) * TAKER_FEE_NOTIONAL; 
                const totalFeesUnrealized = feeOpen + feeCloseEstimate; 
                const pnlNetForDisplay = pnlRaw - totalFeesUnrealized;
                const roeNetForDisplay = (pos.cost > 0) ? (pnlNetForDisplay / pos.cost) * 100 : 0;
                
                if (document.getElementById('sim-unrealized-pnl')) {
                    document.getElementById('sim-unrealized-pnl').textContent = '$' + pnlNetForDisplay.toFixed(2);
                    document.getElementById('sim-unrealized-pnl').className = pnlNetForDisplay >= 0 ? 'positive font-mono text-xs' : 'negative font-mono text-xs';
                }
                
                if (this.elements.positionPnlTop) {
                    this.elements.positionPnlTop.textContent = `$${pnlNetForDisplay.toFixed(2)} (${roeNetForDisplay.toFixed(2)}%)`;
                    this.elements.positionPnlTop.className = pnlNetForDisplay >= 0 
                        ? 'positive font-mono ml-2 text-xs' 
                        : 'negative font-mono ml-2 text-xs';
                }
                
                if (document.getElementById('sim-position-mark')) {
                    document.getElementById('sim-position-mark').textContent = formatPrice(markPrice, pos.symbol);
                }
                
                this.saveState();
                this.render(); 
            },
    
            executeTrailingStopLogic: function(pos, markPrice, allIndicators) {
                if (!pos || !pos.isSafe) return; 

                const isLong = pos.type === 'long';
                const currentTsMode = document.querySelector('input[name="ts-mode"]:checked')?.value || 'ATR';
                
                let newTrailingStopPrice;
                let multiplier = 1.0; 
                const currentRegime = regimeMemory.slice(-1)[0] || 'RANGING'; 
                if (currentRegime === 'BULL_TREND' || currentRegime === 'BEAR_TREND') {
                    multiplier = 2.0; 
                    console.log(`[RISK GOVERNOR] Pasar TREND. TS diatur LEBAR (Multiplier: ${multiplier}x).`);
                } else if (currentRegime === 'LOW_VOLATILITY') {
                    multiplier = 2.5; 
                    console.log(`[RISK GOVERNOR] Pasar LOW VOLATILITY. TS diatur LEBIH SABAR (Multiplier: ${multiplier}x).`);
                } else { 
                    multiplier = 2.0; 
                    console.log(`[RISK GOVERNOR] Pasar RANGING (NOISE). TS diatur KONSISTEN (Multiplier: ${multiplier}x).`);
                }
                
                if (currentTsMode === 'ATR' && allIndicators?.atr?.value > 0) {
                    const atrValue = allIndicators.atr.value;
                    newTrailingStopPrice = isLong 
                        ? markPrice - (atrValue * multiplier) 
                        : markPrice + (atrValue * multiplier);
                } else if (currentTsMode === 'PSAR' && allIndicators?.psar?.value > 0) {
                    newTrailingStopPrice = allIndicators.psar.value;
                } else { 
                    newTrailingStopPrice = pos.sl;
                }

                if (isLong && newTrailingStopPrice > pos.trailingStopPrice) {
                    pos.trailingStopPrice = newTrailingStopPrice;
                    pos.sl = newTrailingStopPrice;
                    console.log(`üìà [TS LONG] Trailing Stop (${currentTsMode}) diupdate ke: ${formatPrice(newTrailingStopPrice, pos.symbol)}`);
                    this.saveState();
                } else if (!isLong && newTrailingStopPrice < pos.trailingStopPrice) {
                    pos.trailingStopPrice = newTrailingStopPrice;
                    pos.sl = newTrailingStopPrice;
                    console.log(`üìâ [TS SHORT] Trailing Stop (${currentTsMode}) diupdate ke: ${formatPrice(newTrailingStopPrice, pos.symbol)}`);
                    this.saveState();
                }
            },

            moveStopLossToBreakEven: function() {
                const pos = this.state.position;
                    if (!pos) return;

                    const feeRate = TAKER_FEE_NOTIONAL;
                    const bufferPercent = BEP_PROFIT_BUFFER_PERCENT / 100; 
                    const totalRequiredChangeRate = (2 * feeRate) + (bufferPercent / pos.leverage); 
                    
                    let bepSlPrice;
                    if (pos.type === 'long') {
                        bepSlPrice = pos.entryPrice * (1 + totalRequiredChangeRate);
                    } else {
                        bepSlPrice = pos.entryPrice * (1 - totalRequiredChangeRate); 
                    }

                    if ((pos.type === 'long' && bepSlPrice > pos.sl) || (pos.type === 'short' && bepSlPrice < pos.sl)) {
                        pos.sl = bepSlPrice; 
                        pos.trailingStopPrice = bepSlPrice;
                        console.log(`üîí RISK-FREE: Stop Loss dipindahkan ke Break-Even + Buffer (${(totalRequiredChangeRate*100).toFixed(4)}% Price Change, ${formatPrice(bepSlPrice)})`);
                        this.saveState();
                    }
                },
           
            executeApiUpdateProtection: async function(pos, markPrice, tradeStatus) {
                const isLong = pos.type === 'long';
                const pnlRaw = (isLong ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * pos.quantity;
                const currentROE = (pos.cost > 0) ? (pnlRaw / pos.cost) * 100 : 0;
                
                if (currentROE >= 1.0 && !pos.isSafe) { 
                    console.warn(`[LIVE MODE: TO-DO] Profit 1% ROE tercapai. API perlu memindahkan SL ke BEP + Buffer.`);
                    pos.isSafe = true; 
                }

                const entryNotional = pos.entryPrice * pos.quantity;
                const markNotional = markPrice * pos.quantity;
                const totalFees = (entryNotional + markNotional) * TAKER_FEE_NOTIONAL;
                const pnlNetForDisplay = pnlRaw - totalFees;
                const roeNet = (pos.cost > 0) ? (pnlNetForDisplay / pos.cost) * 100 : 0;
                
                document.getElementById('sim-unrealized-pnl').textContent = formatPrice(pnlNetForDisplay, pos.symbol);
                document.getElementById('sim-unrealized-pnl').className = pnlNetForDisplay >= 0 ? 'positive font-mono text-xs' : 'negative font-mono text-xs';
                document.getElementById('sim-position-pnl').textContent = `${formatPrice(pnlNetForDisplay, pos.symbol)} (${roeNet.toFixed(2)}%)`;
                document.getElementById('sim-position-pnl').className = pnlNetForDisplay >= 0 ? 'positive font-mono text-xs ml-2' : 'negative font-mono text-xs ml-2';
                document.getElementById('sim-position-mark').textContent = formatPrice(markPrice, pos.symbol);
                
                this.saveState();
            },

            render: function() {
                const pos = this.state.position;

                if (this.elements.equity) this.elements.equity.textContent = formatDollar(this.state.balance);
                if (this.elements.availableMargin) this.elements.availableMargin.textContent = formatDollar(this.state.balance);
                if (document.getElementById('sticky-equity-display')) document.getElementById('sticky-equity-display').textContent = formatDollar(this.state.balance);

                if (pos) {
                    const equity = this.state.balance + pos.cost;
                    if (this.elements.equity) this.elements.equity.textContent = formatDollar(equity);
                    if (this.elements.availableMargin) this.elements.availableMargin.textContent = formatDollar(this.state.balance);
                    if (document.getElementById('sticky-equity-display')) document.getElementById('sticky-equity-display').textContent = formatDollar(equity);
                    if (this.elements.positionContainer) this.elements.positionContainer.classList.remove('hidden');
                    if (this.elements.positionSymbol) this.elements.positionSymbol.textContent = pos.symbol || realtimeCache.main.symbol || '--';
                    if (this.elements.positionHeader) {
                        this.elements.positionHeader.textContent = `${pos.type.toUpperCase()} / ${pos.leverage}x`;
                        this.elements.positionHeader.className = `text-xs ${pos.type === 'long' ? 'positive' : 'negative'}`;
                    }
                    if (this.elements.positionSize) this.elements.positionSize.textContent = formatPrice(pos.cost * pos.leverage, pos.symbol);
                    if (this.elements.positionEntry) this.elements.positionEntry.textContent = formatPrice(pos.entryPrice, pos.symbol);
                    if (this.elements.positionMark) {
                        this.elements.positionMark.textContent = formatPrice(parseFloat(realtimeCache.main.tickerData?.lastPrice) || pos.entryPrice, pos.symbol);
                    }
                    if (this.elements.positionLiq) this.elements.positionLiq.textContent = formatPrice(pos.liqPrice, pos.symbol);
                    
                    const bepPrice = this.calculateBEP(pos); 
                    if (this.elements.positionBep) document.getElementById('sim-position-bep').textContent = formatPrice(bepPrice, pos.symbol);

                    const slActiveEl = document.getElementById('sim-position-sl-active');
                    if (slActiveEl) {
                        slActiveEl.textContent = formatPrice(pos.sl, pos.symbol);
                        slActiveEl.className = `${pos.type === 'long' ? 'negative' : 'positive'} font-mono block`;
                    }
                    const tpActiveEl = document.getElementById('sim-position-tp-final');
                    const tpActiveLabel = document.querySelector('#sim-active-position-container .grid:last-child > div:last-child span.text-gray-400');
                    
                    if (tpActiveEl && pos.nextTpTarget) {
                        tpActiveEl.textContent = formatPrice(pos.nextTpTarget, pos.symbol);
                        tpActiveEl.className = `${pos.type === 'long' ? 'positive' : 'negative'} font-mono block`;
                    } else if (tpActiveEl && pos.tp3) {

                         tpActiveEl.textContent = formatPrice(pos.tp3, pos.symbol); 
                         tpActiveEl.className = `${pos.type === 'long' ? 'positive' : 'negative'} font-mono block`;
                    }
                    if (tpActiveLabel) {
                        tpActiveLabel.textContent = "üéØ TP AKTIF"; 
                    }  
                    if (this.elements.positionMargin) this.elements.positionMargin.textContent = `${pos.cost.toFixed(2)} USDT (${pos.marginMode || 'Cross'})`;
                    if (this.elements.positionPnlTop && this.elements.positionPnlTop.textContent === '') {
                        this.elements.positionPnlTop.textContent = '$0.00 (0.00%)';
                    }
                    
                } else {
                    if (this.elements.positionContainer) this.elements.positionContainer.classList.add('hidden');
                    if (this.elements.unrealizedPnl) {
                        this.elements.unrealizedPnl.textContent = '$0.00';
                        this.elements.unrealizedPnl.className = 'font-mono text-xs text-gray-400';
                    }
                }
                if (this.elements.tradeHistoryList) {
                    if (this.state.history && this.state.history.length > 0) {
                        this.elements.tradeHistoryList.innerHTML = this.state.history.map(trade => {
                            const timeString = trade.closedAtString || (trade.closedAt instanceof Date ? trade.closedAt.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }) : 'N/A');
                            const pnlNetForDisplay = trade.pnlNet || trade.pnlGross || 0; 
                            const roeNetForDisplay = trade.roeNet || 0;
                            const pnlClass = pnlNetForDisplay >= 0 ? 'positive' : 'negative';
                            const pnlGrossValue = trade.pnlGross || trade.pnlNet || 0;
                            const feesValue = trade.fees || 0; 
    
                            return `
                            <div class="p-1.5 rounded-md ${pnlNetForDisplay >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'}">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <span class="${trade.type === 'long' ? 'positive' : 'negative'}">${trade.symbol} ${trade.type.toUpperCase()}</span>
                                        <span class="text-gray-400 text-xs ml-2">${timeString}</span>
                                    </div>
                                    
                                    <div class="font-mono text-right ${pnlClass}">
                                        <span title="PNL Net setelah biaya">$${pnlNetForDisplay.toFixed(2)} (${roeNetForDisplay.toFixed(2)}%)</span> ${trade.liquidated ? 'üî•' : ''}
                                    </div>
                                </div>
                                <div class="text-gray-400 text-xs font-mono flex justify-between mt-1 pt-1 border-t border-gray-700/50">
                                    <span>Entry: ${formatPrice(trade.entry)}</span>
                                    <span>Close: ${formatPrice(trade.closePrice)}</span>
    
                                    <span title="PNL Gross dari pergerakan harga">
                                        Gross PNL: <span class="${pnlGrossValue >= 0 ? 'positive' : 'negative'}">$${pnlGrossValue.toFixed(2)}</span>
                                    </span>
    
                                    <span title="Total Biaya Transaksi (Open + Close)">
                                        Fee: <span class="negative">$-${feesValue.toFixed(2)}</span> </span>
                                </div>
                            </div>
                        `}).join('');
                    } else {
                        this.elements.tradeHistoryList.innerHTML = '<p class="text-center text-gray-600">No trade history yet.</p>';
                    }
                }
                const metrics = this.calculateMetrics();
                const hasTrades = metrics.totalTrades > 0;             
                const pnlEl = document.getElementById('sim-result-pnl');

                if (hasTrades && pnlEl) {
                    pnlEl.textContent = `${formatDollar(metrics.totalPnl)} (${metrics.pnlPercent.toFixed(2)}%)`;
                    pnlEl.className = `font-mono text-sm ${metrics.totalPnl >= 0 ? 'positive' : 'negative'}`;
                    
                    document.getElementById('sim-result-winrate').textContent = `${(metrics.winRate || 0).toFixed(2)}%`;
                    document.getElementById('sim-result-profit-factor').textContent = metrics.profitFactor === Infinity ? '‚àû' : (metrics.profitFactor || 0).toFixed(2);
                    document.getElementById('sim-result-total-trades').textContent = `${metrics.totalTrades}`;
                    document.getElementById('sim-result-max-drawdown').textContent = `${(metrics.maxDrawdown || 0).toFixed(2)}%`;
                    
                    const expectancyEl = document.getElementById('sim-result-expectancy');
                    expectancyEl.textContent = `${(metrics.expectancy || 0).toFixed(2)} USD`;
                    expectancyEl.className = `${(metrics.expectancy || 0) >= 0 ? 'positive' : 'negative'} font-mono text-sm`;
                    
                    document.getElementById('sim-result-losing-streak').textContent = `${metrics.maxLosingStreak}`;
                } else if (pnlEl) {
                    pnlEl.textContent = '--';
                    pnlEl.className = 'font-mono text-sm negative'; 
                    document.getElementById('sim-result-winrate').textContent = '--';
                    document.getElementById('sim-result-profit-factor').textContent = '--';
                    document.getElementById('sim-result-total-trades').textContent = '--';
                    document.getElementById('sim-result-max-drawdown').textContent = '--';
                    document.getElementById('sim-result-expectancy').textContent = '--';
                    document.getElementById('sim-result-losing-streak').textContent = '--';
                }

                const strategyPerformanceData = analyzeStrategyPerformance(this.state.history);
                const performanceBody = document.getElementById('strategy-performance-body');

                if (performanceBody) {
                    performanceBody.innerHTML = ''; 

                    if (Object.keys(strategyPerformanceData).length > 0) {
                        const sortedStrategies = Object.entries(strategyPerformanceData)
                            .sort(([, a], [, b]) => b.trades - a.trades);

                        sortedStrategies.forEach(([strategyName, stats]) => {
                        const totalPnlNetForStrategy = stats.totalPnl; 
                        
                        const pnlClass = totalPnlNetForStrategy > 0 ? 'positive' : (totalPnlNetForStrategy < 0 ? 'negative' : 'text-gray-400');
                        const row = document.createElement('tr');
                        row.className = 'border-b border-gray-800/50';
                        row.innerHTML = `
                            <td class="py-1 px-2 text-gray-300">${strategyName.replace(/LONG |SHORT /g, '')} <span class="${strategyName.includes('LONG') ? 'positive' : 'negative'}">(${strategyName.includes('LONG') ? 'L' : 'S'})</span></td>
                            <td class="py-1 px-2 text-center">${stats.trades}</td>
                            <td class="py-1 px-2 text-center positive">${stats.wins}</td>
                            <td class="py-1 px-2 text-center negative">${stats.losses}</td>
                            <td class="py-1 px-2 text-center">${stats.winRate.toFixed(1)}%</td>
                            <td class="py-1 px-2 text-right font-mono ${pnlClass}">${totalPnlNetForStrategy.toFixed(2)}</td>
                        `;
                        performanceBody.appendChild(row);
                    });
                    } else {
                        performanceBody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-600">-- Data akan muncul setelah ada riwayat trade AFT --</td></tr>';
                    }
                }
            },

            calculateMetrics: function() {  
                const history = this.state.history;
                if (history.length === 0) {
                    return { totalPnl: 0, pnlPercent: 0, winRate: 0, profitFactor: 0, totalTrades: 0, maxDrawdown: 0, expectancy: 0, maxLosingStreak: 0 };
                }
                const initialBalance = 250; 
                const feeRate = 0; 
                const maxEquityLossPercent = MAX_EQUITY_LOSS_PERCENT; 
                const maxGlobalLoseStreak = MAX_GLOBAL_LOSE_STREAK; 
                
                let totalPnlNet = 0; 
                let grossProfit = 0; 
                let grossLoss = 0;
                let maxLosingStreak = 0;
                let currentGlobalLossStreak = 0;

                history.forEach(trade => {
                    const pnlNet = trade.pnlNet; 
                    totalPnlNet += pnlNet; 
                    
                    if (pnlNet > 0) {
                        grossProfit += pnlNet;
                        currentGlobalLossStreak = 0; 
                    } else {
                        grossLoss += Math.abs(pnlNet);
                        currentGlobalLossStreak++; 
                    }
                    maxLosingStreak = Math.max(maxLosingStreak, currentGlobalLossStreak);
                });

                const fullTrades = history.filter(t => t.flag !== 'AFT_PARTIAL');
                const totalTrades = fullTrades.length;
                let wins = 0;
                
                fullTrades.forEach(trade => {
                     if ((trade.pnlNet || 0) > 0) { 
                        wins++;
                    }
                });

                let equity = initialBalance;
                let peakEquity = initialBalance; 
                let maxDrawdown = 0;
                const reversedHistory = [...history].reverse(); 
                reversedHistory.forEach(transaction => {
                    equity += transaction.pnlNet; 
                    peakEquity = Math.max(peakEquity, equity);
                    const drawdown = peakEquity > 0 ? ((peakEquity - equity) / peakEquity) * 100 : 0;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                });

                const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;
                const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : Infinity; 
                const pnlPercent = (totalPnlNet / initialBalance) * 100; 
                const expectancy = totalTrades > 0 ? totalPnlNet / totalTrades : 0; 
                const maxAllowedLoss = initialBalance * (maxEquityLossPercent / 100); 
                
                if (grossLoss >= maxAllowedLoss || maxLosingStreak >= maxGlobalLoseStreak) {
                    isGlobalStopActive = true;
                }

                const finalPnlPercent = isNaN(pnlPercent) ? 0 : pnlPercent;

                return {
                    totalPnl: totalPnlNet, 
                    pnlPercent: finalPnlPercent, 
                    winRate, profitFactor, totalTrades,
                    maxDrawdown, expectancy, maxLosingStreak
                };
            },

            saveState: function() {
                localStorage.setItem('paperTradeState', JSON.stringify(this.state));
            },

            loadState: function() {
                const defaultState = {
                    balance: 250,
                    position: null,
                    history: [],
                    ts: {
                        enabled: true,
                        callbackRate: 0.8,
                        activationProfit: 1.0
                    }
                };

                const savedState = localStorage.getItem('paperTradeState');
                if (savedState) {
                    try {
                        const parsedState = JSON.parse(savedState);
                        this.state = { ...defaultState, ...parsedState };
                        if (this.state.history && Array.isArray(this.state.history)) {
                            this.state.history = this.state.history.map(trade => ({
                                ...trade,

                                closedAt: new Date(trade.closedAt) 
                            }));
                        } else {
                            this.state.history = [];
                        }
                    } catch (e) {
                        console.error("Gagal mem-parsing state tersimpan, kembali ke default.", e);
                        this.state = defaultState;
                    }
                } else {
                    this.state = defaultState;
                }
            },
    };

    const marginSlider = document.getElementById('aft-margin-slider');
    const marginDisplay = document.getElementById('aft-margin-display');
    if (marginSlider && marginDisplay) {
        marginDisplay.textContent = marginSlider.value + '%';
        marginSlider.addEventListener('input', () => {
        marginDisplay.textContent = marginSlider.value + '%';
        });
    }

    (function() {
        const originalConsoleLog = console.log;
        const logPanel = document.getElementById('live-console-output');

        function formatTime() {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
            return `${timeString}.${now.getMilliseconds().toString().padStart(3, '0')}`;
        }

        console.log = function(...args) {

            originalConsoleLog.apply(console, args);
            if (logPanel) {
                const message = args.map(arg => {
                    if (typeof arg === 'object' && arg !== null) {
                        try {
                            return JSON.stringify(arg);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return String(arg);
                }).join(' ');

                const logEntry = document.createElement('p');
                logEntry.className = 'py-0.5 border-b border-gray-800 text-gray-400';
                logEntry.innerHTML = `<span class="text-blue-400">[${formatTime()}]</span> ${message}`;

                logPanel.prepend(logEntry); 
                while (logPanel.children.length > 20) {
                    logPanel.removeChild(logPanel.lastChild);
                }
            }
        };
    })();
// ==========================================================================
// ==========================================================================
        async function liveLoop() {
                const LEVERAGE = 30;
                if (!liveInterval) { 
                    console.log("Sesi analisis dihentikan.");
                    return;
                }

                const COOLDOWN_MS = 10000;
                const timeSinceLastTrade = Date.now() - lastTradeExecutionTime;
                const isWhipsawFilterActive = document.getElementById('whipsaw-filter-toggle')?.checked || false;

                if (isWhipsawFilterActive && timeSinceLastTrade < COOLDOWN_MS) {
                    const secondsRemaining = Math.ceil((COOLDOWN_MS - timeSinceLastTrade) / 1000);
                    paperTrade.update(); 
                    console.log(`‚è±Ô∏è COOLDOWN AKTIF: Menunggu ${secondsRemaining}s untuk re-entry.`);
                    setTimeout(liveLoop, 2500); 
                    return;
                }

                if (!realtimeCache.main.klines || realtimeCache.main.klines.length < 50 || !activeStrategy || !activeStrategy.metadata) {
                    setTimeout(liveLoop, 2500);
                    return;
                }

                const symbol = realtimeCache.main.symbol;
                
                const PRIMARY_TREND_UPDATE_INTERVAL_MS = 12000;
                if (Date.now() - lastHtfUpdate > HTF_UPDATE_INTERVAL_MS) {
                    macroTrend_1h = await getHtfTrend(symbol, '1h', 89);
                    lastHtfUpdate = Date.now();
                    console.log(`[HTF FILTER] Tren Makro (1h) saat ini: ${macroTrend_1h}`);
                }
                if (Date.now() - lastPrimaryTrendUpdate > PRIMARY_TREND_UPDATE_INTERVAL_MS) {
                    primaryTrend_15m = await getHtfTrend(symbol, '15m', 21); 
                    lastPrimaryTrendUpdate = Date.now();
                    console.log(`[HTF FILTER] Tren Primer (15m) saat ini: ${primaryTrend_15m}`);
                }

                let fundingRateData = { lastFundingRate: 0 };
                let lsRatioData = { longShortRatio: 1.0 };
                let lsTopRatioData = { longShortRatio: 1.0 };
                let openInterestData = [];

                try {
                    let [fundingRes, lsRatioRes, lsTopRatioRes, openInterestRes] = await Promise.all([
                        fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${symbol}`),
                        fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}&period=5m&limit=1`),
                        fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${symbol}&period=5m&limit=1`),
                        fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=5m&limit=2`)
                    ]);
                    if (fundingRes.ok) {
                        fundingRateData = await fundingRes.json();
                        nextFundingTimestamp = fundingRateData.nextFundingTime || 0; 
                    }
                    if (lsRatioRes.ok) {
                        const lsData = await lsRatioRes.json();
                        if (lsData.length > 0) lsRatioData = lsData[0];
                    }
                    if (openInterestRes.ok) openInterestData = await openInterestRes.json();
                    if (lsTopRatioRes.ok) {
                        const lsTopData = await lsTopRatioRes.json();
                        if (lsTopData.length > 0) lsTopRatioData = lsTopData[0];
                    }
                } catch (e) { console.error("Gagal mengambil data sentimen:", e); }

                const klinesSnapshot = realtimeCache.main.klines.slice(-500); 
                const closes = klinesSnapshot.map(k => parseFloat(k[4]));
                const lastClose = closes[closes.length - 1];
                const prevClose = closes[closes.length - 2];
                const currentMarketPrice = lastClose;
                const parameters = activeStrategy.parameters;
                const biasThreshold = parameters.biasThreshold;

                let detectedRegimeLabel = 'RANGING';
                if (Date.now() - lastAiUpdate > AI_UPDATE_INTERVAL_MS) {
                    const newPrediction = await predictMarketRegime(klinesSnapshot);
                    if (newPrediction) {
                        detectedRegimeLabel = newPrediction.label;
                        regimeConfidence = newPrediction.confidence || 0.5;
                    }
                    lastAiUpdate = Date.now();
                } else {
                    detectedRegimeLabel = regimeMemory.slice(-1)[0] || 'RANGING'; 
                }
                
                const currentRegime = detectedRegimeLabel; 
                regimeMemory.push(currentRegime);
                if (regimeMemory.length > REGIME_MEMORY_SIZE) {
                    regimeMemory.shift(); 
                }

                const aiStatusEl = document.getElementById('ai-status');
                const activeRegimeEl = document.getElementById('active-regime-display');
                const confidenceScoreEl = document.getElementById('regime-confidence-score');
                
                if (aiStatusEl) aiStatusEl.textContent = 'AI Ready (LSTM TF.js)';
                if (activeRegimeEl) {
                    activeRegimeEl.textContent = currentRegime.replace('_', ' ');
                    activeRegimeEl.className = getRegimeColorClass(currentRegime);
                }
                if (confidenceScoreEl) {
                    confidenceScoreEl.textContent = `${(regimeConfidence * 100).toFixed(1)}%`;
                }

                // --- AWAL KODE FASE 0: KALKULASI SUPER-BIAS 13/89 ---
                // Kita gunakan 15m sebagai Peta Taktis dan 1h sebagai Peta Strategis
                const klines15m = realtimeCache.main.multiTfKlines['15m'];
                const klines1h = realtimeCache.main.multiTfKlines['1h'];
                let bias15m = 'NEUTRAL';
                let bias1h = 'NEUTRAL';

                // Fungsi internal cepat untuk cek status cross (bukan event cross)
                const getEmaState = (klines, fastP, slowP) => {
                    if (!klines || klines.length < slowP) return 'NEUTRAL'; // Data tidak cukup
                    const closes = klines.map(k => parseFloat(k[4]));
                    const emaFast = calculateEMA(closes, fastP).pop();
                    const emaSlow = calculateEMA(closes, slowP).pop();
                    if (!emaFast || !emaSlow) return 'NEUTRAL';
                    return emaFast > emaSlow ? 'LONG_ONLY' : 'SHORT_ONLY';
                };

                // Cek kedua timeframe
                bias15m = getEmaState(klines15m, 13, 89);
                bias1h = getEmaState(klines1h, 13, 89);

                // Logika "Super-Bias": Keduanya harus setuju
                if (bias15m === 'LONG_ONLY' && bias1h === 'LONG_ONLY') {
                    currentSuperBias = 'LONG_ONLY';
                } else if (bias15m === 'SHORT_ONLY' && bias1h === 'SHORT_ONLY') {
                    currentSuperBias = 'SHORT_ONLY';
                } else {
                    // Jika 15m dan 1h tidak setuju (konflik), kita NETRAL dan hati-hati
                    currentSuperBias = 'NEUTRAL'; 
                }
                console.log(`[FASE 0] Super-Bias: ${currentSuperBias} (15m: ${bias15m} | 1h: ${bias1h})`);
                // --- AKHIR KODE FASE 0 ---

                let currentWeights = activeStrategy.weights;
                if (activeStrategy.dnaType === 'AutoSwitch_v1' && activeStrategy.autoWeights) {
                    const dnaKey = currentRegime.toLowerCase().replace(/_(\w)/g, (match, letter) => letter.toUpperCase());
                    if (activeStrategy.autoWeights[dnaKey]) { 
                        currentWeights = activeStrategy.autoWeights[dnaKey].weights; 
                    }
                }

                const currentTf = liveTimeframeSelect.value;
                const tfSettings = timeframeParameterMap[currentTf] || timeframeParameterMap['1m'];

                const RSI_PERIOD = tfSettings.rsi_period;
                const MACD_FAST = tfSettings.macd_fast;
                const MACD_SLOW = tfSettings.macd_slow;
                const MACD_SIGNAL = tfSettings.macd_signal;

                // --- KALKULASI EMA RIBBON PENUH & MACD 15M (GATEKEEPER DATA) ---
                const TARGET_TFS = ['5m', '15m', '1h', '4h'];
                const RIBBON_EMA = [13, 21, 34, 55, 89, 144];
                let trendScore = 0; 
                
                const macd15mData = realtimeCache.main.multiTfKlines['15m'] && realtimeCache.main.multiTfKlines['15m'].length >= 150 
                    ? calculateMACD(realtimeCache.main.multiTfKlines['15m'].map(k => parseFloat(k[4])), 12, 26, 9)
                    : { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };

                TARGET_TFS.forEach(tf => {
                    const klines = realtimeCache.main.multiTfKlines[tf];
                    if (klines && klines.length >= 150) { 
                        const closes = klines.map(k => parseFloat(k[4]));
                        
                        const emas = RIBBON_EMA.map(p => calculateEMA(closes, p).pop() || 0);
                        
                        const fastEMAs = emas.slice(0, 4);
                        const ema89 = emas[4];
                        const ema144 = emas[5];

                        let bullCount = 0;
                        let bearCount = 0;
                        
                        fastEMAs.forEach(ema => {
                            if (ema > ema89 && ema > ema144) {
                                bullCount++;
                            } else if (ema < ema89 && ema < ema144) {
                                bearCount++;
                            }
                        });

                        if (bullCount >= 3) {
                            trendScore++;
                        } else if (bearCount >= 3) {
                            trendScore--;
                        }
                    }
                });

                const rsiValues = calculateRSI(closes, RSI_PERIOD); 
                const macdData = calculateMACD(closes, MACD_FAST, MACD_SLOW, MACD_SIGNAL); 
                const customSRSI = calculateStochasticRSI(closes, 9, 9, 3, 3); 
                const atrData = calculateATR(klinesSnapshot, 14);
                const htfStatus = calculateEMA(closes, 21).pop() > calculateEMA(closes, 89).pop() ? 'BULLISH' : 'DOWNTREND';
                const allIndicators = {
                            ma: { status: htfStatus },
                            rsi: { status: rsiValues[rsiValues.length - 1] > 70 ? 'Overbought' : (rsiValues[rsiValues.length - 1] < 30 ? 'Oversold' : 'Netral'), last: rsiValues[rsiValues.length - 1] },
                            macd: macdData, 
                            macd_15m: macd15mData, 
                            trendAlignmentScore: trendScore,
                            stoch: customSRSI, 
                            rsiDivergence: detectRSIDivergence(closes, rsiValues),
                            candlePattern: findCandlestickPatterns(klinesSnapshot.slice(-2)),
                            obv: { trend: calculateOBV(klinesSnapshot).pop() > calculateOBV(klinesSnapshot).slice(-2)[0] ? 'Naik' : 'Turun' },
                            bbSqueeze: { status: calculateBollingerBands(closes).squeezeStatus },
                            psar: calculateParabolicSAR(klinesSnapshot),
                            roc: calculateROC(closes),
                            vwap: { status: lastClose > calculateVWAP(klinesSnapshot) ? 'BULLISH' : 'BEARISH' },
                            ichimoku: calculateIchimokuCloud(klinesSnapshot),
                            fundingRate: { lastFundingRate: parseFloat(fundingRateData.lastFundingRate) },
                            lsRatio: { longShortRatio: parseFloat(lsRatioData.longShortRatio) },
                            openInterest: { status: (openInterestData && openInterestData.length === 2) 
                                ? ( (lastClose - prevClose > 0 && parseFloat(openInterestData[1].sumOpenInterestValue) > parseFloat(openInterestData[0].sumOpenInterestValue)) ? 'BULLISH_CONFIRMATION' : ((lastClose - prevClose < 0 && parseFloat(openInterestData[1].sumOpenInterestValue) > parseFloat(openInterestData[0].sumOpenInterestValue)) ? 'BEARISH_CONFIRMATION' : 'NETRAL') )
                                : 'NETRAL' }
                        };

                realtimeCache.main.allIndicators = allIndicators;

                //console.log(`[DEBUG SNAPSHOT] ${symbol} (${currentTf}) @ ${formatPrice(currentMarketPrice)}`);
                //console.log(`SRSI K: ${allIndicators.stoch.kLine.slice(-1)[0]?.toFixed(2)} | Status: ${allIndicators.stoch.momentumStatus}`);
                //console.log(`MACD Hist: ${macdData.histogram.slice(-1)[0]?.value?.toFixed(5)} | Status: ${macdData.status}`);
                //console.log(`MACD 15M Gate: ${macd15mData.status} | Score: ${allIndicators.trendAlignmentScore}`); // üî• BARIS DEBUG BARU üî•
                //console.log(`--- CEK EMA RIBBON DI PANEL MTF UNTUK KONTEKS S/R ---`);


                const confluenceResults = calculateConfluenceScoreForCandle(currentWeights, allIndicators, currentRegime);
                const bullScore = confluenceResults.bull;
                const bearScore = confluenceResults.bear;
                const isLongBias_LTF = bullScore > bearScore && (bullScore - bearScore) > biasThreshold;
                const isShortBias_LTF = bearScore > bullScore && (bearScore - bullScore) > biasThreshold;

                let biasStatus = 'NEUTRAL - NO BIAS';
                if (isLongBias_LTF) {
                    if (currentRegime === 'BULL_TREND') biasStatus = 'LONG FOLLOW TREND';
                    else if (currentRegime === 'BEAR_TREND') biasStatus = 'LONG COUNTER TREND';
                    else if (currentRegime === 'RANGING') biasStatus = 'LONG REVERSION';
                    else if (currentRegime === 'LOW_VOLATILITY') biasStatus = 'LONG BREAKOUT SETUP';
                    } else if (isShortBias_LTF) {
                        if (currentRegime === 'BEAR_TREND') biasStatus = 'SHORT FOLLOW TREND';
                        else if (currentRegime === 'BULL_TREND') biasStatus = 'SHORT COUNTER TREND';
                        else if (currentRegime === 'RANGING') biasStatus = 'SHORT REVERSION';
                        else if (currentRegime === 'LOW_VOLATILITY') biasStatus = 'SHORT BREAKOUT SETUP';
                    }

                // --- KALKULASI HARGA (SL/TP) ---
                const FALLBACK_RR_FINAL = 4.0; 
                const FALLBACK_ATR_MULTIPLIER = 1.5;
                const type = biasStatus.includes('LONG') ? 'long' : 'short';
                
                let entryPrice = calculateEMA(closes, parameters.pullbackEmaPeriod).pop();
                let entryPriceFinal = currentMarketPrice; 
                const swingSlPrice = realtimeCache.main.latestScalpingSetup?.sl?.price || 0; 
                const klinesCloses = closes; 
                const entryMode = document.querySelector('input[name="entry-mode"]:checked')?.value;
                const EMA_PULLBACK_PERIOD = parameters.pullbackEmaPeriod || 8;
                const PULLBACK_TOLERANCE_PCT = 0.0005; 

                if (entryMode === 'PRESISI') {
                    const pullbackEma = calculateEMA(klinesCloses, EMA_PULLBACK_PERIOD).pop() || 0;

                    if (pullbackEma > 0 && isFinite(pullbackEma)) {
                        entryPriceFinal = pullbackEma; 
                        const priceDiffPct = Math.abs(currentMarketPrice - pullbackEma) / pullbackEma;

                        if (priceDiffPct > PULLBACK_TOLERANCE_PCT) {
                            console.log(`üõë ENTRY DIBLOKIR (PRESISI): Menunggu Pullback ke EMA ${EMA_PULLBACK_PERIOD}. Diff: ${(priceDiffPct * 100).toFixed(4)}%`);
                            setTimeout(liveLoop, 2500);
                            return; 
                        }
                    }
                }
                
                const riskRoeUsed = MAX_RISK_ROE || 1.0; 
                const fallbackPriceChange = (riskRoeUsed / LEVERAGE) / 100; 
                const hardLimitSlPrice = type === 'long'
                    ? entryPriceFinal * (1 - fallbackPriceChange)
                    : entryPriceFinal * (1 + fallbackPriceChange);
                const atrResults = calculateATR(klinesSnapshot, 14); 
                const SL_DISTANCE = atrResults.value * FALLBACK_ATR_MULTIPLIER; 
                const atrSl = type === 'long' 
                    ? entryPriceFinal - SL_DISTANCE
                    : entryPriceFinal + SL_DISTANCE;

                let finalStopLoss = hardLimitSlPrice; 

                if (type === 'long') {
                    finalStopLoss = Math.min(hardLimitSlPrice, atrSl); 
                    if (swingSlPrice > 0 && swingSlPrice < finalStopLoss) {
                        finalStopLoss = swingSlPrice; 
                        //console.log(`üõ°Ô∏è SL Long dipilih: SL Struktural (Swing Low) - Paling Jauh.`);
                    } else {
                        //console.log(`üõ°Ô∏è SL Long dipilih: SL ${finalStopLoss === hardLimitSlPrice ? 'Hard Limit ROE' : 'ATR'} - Paling Jauh.`);
                    }
                } else { 
                    finalStopLoss = Math.max(hardLimitSlPrice, atrSl); 
                    if (swingSlPrice > 0 && swingSlPrice > finalStopLoss) {
                        finalStopLoss = swingSlPrice; 
                        //console.log(`üõ°Ô∏è SL Short dipilih: SL Struktural (Swing High) - Paling Jauh.`);
                    } else {
                        //console.log(`üõ°Ô∏è SL Short dipilih: SL ${finalStopLoss === hardLimitSlPrice ? 'Hard Limit ROE' : 'ATR'} - Paling Jauh.`);
                    }
                }
                
                const riskDistance = Math.abs(entryPriceFinal - finalStopLoss);
                const tp1Final = type === 'long' ? entryPriceFinal + (riskDistance * 1.0) : entryPriceFinal - (riskDistance * 1.0);
                const tp2Final = type === 'long' ? entryPriceFinal + (riskDistance * 1.5) : entryPriceFinal - (riskDistance * 1.5); 
                const takeProfitFinal = type === 'long' ? entryPriceFinal + (riskDistance * FALLBACK_RR_FINAL) : entryPriceFinal - (riskDistance * FALLBACK_RR_FINAL);

                //console.log(`üß† SL FINAL: ${formatPrice(finalStopLoss)}. TP Target (R:R ${FALLBACK_RR_FINAL.toFixed(2)}): ${formatPrice(takeProfitFinal)}.`);

                const lastSwing = findLastSignificantSwing(klinesSnapshot);
                const signalData = {
                    bias: { status: biasStatus, detail: `${currentRegime.replace('_', ' ')}` },
                    scores: { bull: bullScore, bear: bearScore },
                    entry: { price: entryPriceFinal, percentage: (entryPriceFinal && lastClose > 0) ? (entryPriceFinal - lastClose) / lastClose * 100 : 0 },
                    sl: { price: finalStopLoss, percentage: (finalStopLoss && entryPriceFinal > 0) ? (Math.abs(finalStopLoss - entryPriceFinal) / entryPriceFinal) * 100 : 0 },
                    tp1: { price: tp1Final, percentage: (tp1Final && entryPriceFinal > 0) ? (Math.abs(tp1Final - entryPriceFinal) / entryPriceFinal) * 100 : 0 },
                    tp2: { price: tp2Final, percentage: (tp2Final && entryPriceFinal > 0) ? (Math.abs(tp2Final - entryPriceFinal) / entryPriceFinal) * 100 : 0 },
                    tp3: { price: takeProfitFinal, percentage: (takeProfitFinal && entryPriceFinal > 0) ? (Math.abs(takeProfitFinal - entryPriceFinal) / entryPriceFinal) * 100 : 0 },
                    fib_levels: { 
                        retracement: lastSwing ? calculateFibonacciRetracement(lastSwing) : null, 
                        extension: lastSwing ? calculateAdvancedFibonacciExtension(lastSwing) : null 
                    }
                };
                        
                displayLiveSignal(signalData);

                // --- LOGIKA FILTER ENTRY (GATEKEEPER) ---
                const isCounterTrendSignal = biasStatus.includes('COUNTER TREND');
                const dumpScoreValue = realtimeCache.indicators.dumpScore || 0;
                const isSafeFromDump = biasStatus.includes('LONG') ? dumpScoreValue < DUMP_RISK_THRESHOLD : true;
                
                let shouldEnter = false;
                let blockedBy = '';
                
                if (!isLongBias_LTF && !isShortBias_LTF) {
                    blockedBy = 'LTF Bias terlalu lemah (Neutral)';
                }

                const macd15mStatus = realtimeCache.main.allIndicators.macd_15m.status;
                
                if (isLongBias_LTF && macd15mStatus.includes('Bearish')) {
                    blockedBy = 'MACD 15m Gatekeeper: Konflik Bearish (BLOCKED)';
                } else if (isShortBias_LTF && macd15mStatus.includes('Bullish')) {
                    blockedBy = 'MACD 15m Gatekeeper: Konflik Bullish (BLOCKED)';
                }

                if (blockedBy === '') {
                    if (isCounterTrendSignal) {
                        const macroAlignmentScore = realtimeCache.main.allIndicators.trendAlignmentScore || 0;
                        
                        if (isLongBias_LTF) {
                            if (macroAlignmentScore > -3) { 
                                blockedBy = `Counter Trend Gagal: Tren Makro (${macroAlignmentScore}) masih terlalu kuat untuk reversal.`;
                            }
                        } else if (isShortBias_LTF) {
                            if (macroAlignmentScore < 3) { 
                                blockedBy = `Counter Trend Gagal: Tren Makro (${macroAlignmentScore}) masih terlalu kuat untuk reversal.`;
                            }
                        }
                    }
                }

                if (blockedBy === '') {
                    const lastSRSI_K = allIndicators.stoch.kLine.slice(-1)[0] || 50;
                    const SRSI_ENTRY_LEVEL = 25;

                    if (isLongBias_LTF) {
                        if (lastSRSI_K <= SRSI_ENTRY_LEVEL) shouldEnter = true;
                        else blockedBy = `SRSI: K:${lastSRSI_K.toFixed(2)} (Bukan di zona Oversold/Buy)`;
                    } else if (isShortBias_LTF) {
                        if (lastSRSI_K >= (100 - SRSI_ENTRY_LEVEL)) shouldEnter = true;
                        else blockedBy = `SRSI: K:${lastSRSI_K.toFixed(2)} (Bukan di zona Overbought/Sell)`;
                    }
                }
                
                // --- REVISI: MENAMBAHKAN FILTER SUPER-BIAS FASE 0 ---
                const isLongSignal = biasStatus.includes('LONG');
                const isShortSignal = biasStatus.includes('SHORT');
                const isBiasAllowed = (currentSuperBias === 'LONG_ONLY' && isLongSignal) ||
                                      (currentSuperBias === 'SHORT_ONLY' && isShortSignal) ||
                                      (currentSuperBias === 'NEUTRAL');
                
                if (shouldEnter && isSafeFromDump && isBiasAllowed) {
                // --- AKHIR REVISI ---
                    const allowedStrategies = getAftAllowedStrategies();
                    const isStrategyAllowed = allowedStrategies.includes(biasStatus);
                    
                    if (!isAutoTradeEnabled) {
                        console.log(`üí° Sinyal ${biasStatus} valid muncul, tetapi Auto-Trade dinonaktifkan.`);
                    } else if (!isStrategyAllowed) {
                        console.warn(`[AFT BLOCKED] Sinyal ${biasStatus} muncul, tetapi strategi ini dinonaktifkan di filter.`);
                    } else if ((strategyLossStreaks[biasStatus] || 0) >= 3) {
                        console.warn(`[AFT BLOCKED] Sinyal ${biasStatus} diblokir sementara karena 3x kerugian beruntun.`);
                    } else {
                        
                        // LOGIC SIZING & OPEN POSITION
                        const currentTotalEquity = paperTrade.state.balance || 250;
                        const type = isLongBias_LTF ? 'long' : 'short';
                        const LEVERAGE = 30;
                        
                        const selectedSizingMode = document.querySelector('input[name="sizing-mode"]:checked')?.value || 'FIXED_MARGIN';
                        let cost = currentTotalEquity * (document.getElementById('aft-margin-slider')?.value / 100 || 0.05);
                        
                        if (selectedSizingMode === 'RISK_BASED') {
                            const entry = entryPriceFinal;
                            const slDistancePercent = entry > 0 ? Math.abs(entry - finalStopLoss) / entry : 0;
                            const ACCOUNT_RISK_PCT = 0.01; 
                            const MAX_ALLOWED_COST = currentTotalEquity * 0.10; 

                            if (slDistancePercent > 0.00001 && isFinite(slDistancePercent)) {
                                const maxLossUsdt = currentTotalEquity * ACCOUNT_RISK_PCT;
                                const maxPosSizeUsdt = maxLossUsdt / slDistancePercent;
                                
                                let calculatedCost = maxPosSizeUsdt / LEVERAGE;
                                let finalCost = Math.min(calculatedCost, MAX_ALLOWED_COST); 

                                if (finalCost > 0 && isFinite(finalCost)) {
                                    cost = finalCost; 
                                    console.log(`üß† SIZING: Risk-Based LULUS. Cost: ${cost.toFixed(2)} USDT (Max Loss: ${maxLossUsdt.toFixed(2)} USD).`);
                                } else {
                                    console.warn(`[SIZING FALLBACK] Calculated Cost tidak valid. Menggunakan Fixed Margin awal.`);
                                }
                            } else {
                                console.warn(`[SIZING FALLBACK] SL Distance terlalu kecil/Nol. Menggunakan Fixed Margin awal.`);
                            }
                        }
                        
                        if (cost > currentTotalEquity || cost <= 0 || !isFinite(cost)) {
                            console.warn(`[AFT BLOCKED] Kalkulasi Modal/Cost (${cost.toFixed(2)} USDT) melebihi Available Margin (${currentTotalEquity.toFixed(2)} USDT).`);
                            setTimeout(liveLoop, 2500);
                            return;
                        }

                        const quantity = (cost * LEVERAGE) / entryPriceFinal;
                        const MIN_NOTIONAL_LIMIT = 5.0;

                        if (quantity * entryPriceFinal < MIN_NOTIONAL_LIMIT) {
                            console.warn(`üõë ENTRY DIBATALKAN: Notional (${(quantity * entryPriceFinal).toFixed(2)} USD) di bawah batas minimum notional ($${MIN_NOTIONAL_LIMIT}).`);
                            setTimeout(liveLoop, 2500);
                            return;
                        }
                        
                        paperTrade.openPosition(
                            type,
                            LEVERAGE,
                            cost,
                            entryPriceFinal,
                            'AFT',
                            selectedSizingMode.replace('_MARGIN', ''),
                            finalStopLoss,
                            tp1Final, 
                            tp2Final,
                            takeProfitFinal 
                        );
                    }
                } else {
                    let reason = blockedBy || 'LTF Bias terlalu lemah (Neutral)';
                    // --- TAMBAHKAN BLOK 'ELSE IF' INI ---
                    if (shouldEnter && isSafeFromDump && !isBiasAllowed) {
                        reason = `[FASE 0 BLOCKED] Sinyal ${isLongSignal ? 'LONG' : 'SHORT'} diblokir oleh SUPER-BIAS: ${currentSuperBias}`;
                    }
                    // --- AKHIR TAMBAHAN ---
                    if (reason) {
                        console.log(`[FILTER BLOCKED] Sinyal ${biasStatus.split(' ')[0]} diblokir. Alasan: ${reason}`);
                        setTimeout(liveLoop, 2500);
                        return;
                    }
                }
                
                const psarData = calculateParabolicSAR(klinesSnapshot);
                const rocValue = closes.length > 12 ? ((closes[closes.length - 1] - closes[closes.length - 1 - 12]) / closes[closes.length - 1 - 12]) * 100 : NaN;
                const adxData = calculateADX(klinesSnapshot);
                const atrDataUi = calculateATR(klinesSnapshot, 14); 
                const oiValue = openInterestData.length > 0 ? parseFloat(openInterestData[1].sumOpenInterestValue) : 0;

                updateSentimentDisplay({ 
                    psar: psarData.status, 
                    roc: rocValue, 
                    adx: adxData.value, 
                    atr: atrDataUi, 
                    lsGlobal: parseFloat(lsRatioData.longShortRatio), 
                    lsTop: parseFloat(lsTopRatioData.longShortRatio), 
                    funding: parseFloat(fundingRateData.lastFundingRate), 
                    oi: oiValue 
                });

                updateStrategyFilterUI();
                setTimeout(liveLoop, 2500);
            }

    function calculateMaxAffordableLossROE(numTrades) {
        return -5.0; 
    }

    function checkPositionLogic(pos, markPrice, signalData) {
        if (!pos) return { action: 'HOLD', reason: 'N/A' };
        const isLong = pos.type === 'long';
        const pnlRaw = (isLong ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * pos.quantity;
        const currentROE = (pos.cost > 0) ? (pnlRaw / pos.cost) * 100 : 0;
        const HARD_MAX_LOSS_ROE = -1.0; 
        const MIN_HOLD_TIME_MS = 180000; 
        const timeInPosition = Date.now() - pos.entryTimestamp;

        // PILAR 1: ANTI-CP MIN HOLD TIME & HARD EXIT
        if (timeInPosition < MIN_HOLD_TIME_MS) {
            if (currentROE <= HARD_MAX_LOSS_ROE) {
                return { action: 'CLOSE', reason: `HARD MAX LOSS LIMIT (${currentROE.toFixed(2)}%)` };
            }
            if ((isLong && markPrice <= pos.liqPrice) || (!isLong && markPrice >= pos.liqPrice)) {
                return { action: 'CLOSE', reason: 'LIQUIDATION' };
            }
            return { action: 'HOLD', reason: `Waiting for min hold time (${Math.ceil((MIN_HOLD_TIME_MS - timeInPosition) / 1000)}s)` };
        }
        
        // PRIORITAS #1: SL & LIQUIDATION CHECKS (SETELAH MIN HOLD TIME)
        if (currentROE <= HARD_MAX_LOSS_ROE) {
            return { action: 'CLOSE', reason: `HARD MAX LOSS LIMIT (${currentROE.toFixed(2)}%)` };
        }
        if ((isLong && markPrice <= pos.sl) || (!isLong && markPrice >= pos.sl)) {
            return { action: 'CLOSE', reason: 'STOP LOSS' };
        }
        if ((isLong && markPrice <= pos.liqPrice) || (!isLong && markPrice >= pos.liqPrice)) {
            return { action: 'CLOSE', reason: 'LIQUIDATION' };
        }

        // PRIORITAS #2: BEP LOCK & PROFIT TRAILING
        if (currentROE >= BEP_PROFIT_BUFFER_PERCENT && !pos.isSafe) { 
            paperTrade.moveStopLossToBreakEven(); 
            pos.isSafe = true;
        }
        if (pos.isSafe && currentROE >= PROFIT_LOCK_STEP_ROE && currentROE > pos.lastPartialCloseStep) {
            const currentProfitLockTier = Math.floor(currentROE / PROFIT_LOCK_STEP_ROE) * PROFIT_LOCK_STEP_ROE;
            if (currentProfitLockTier > pos.lastPartialCloseStep) {
                const TARGET_SL_ROE = currentProfitLockTier - TRAILING_BUFFER_ROE; 
                const priceChangeToLock = (TARGET_SL_ROE / pos.leverage) / 100;
                let newSlPrice = isLong 
                    ? pos.entryPrice * (1 + priceChangeToLock) 
                    : pos.entryPrice * (1 - priceChangeToLock);
                
                if ((isLong && newSlPrice > pos.sl) || (!isLong && newSlPrice < pos.sl)) {
                    pos.sl = newSlPrice;
                    pos.trailingStopPrice = newSlPrice;
                    pos.lastPartialCloseStep = currentProfitLockTier; 
                    console.log(`üîí PROFIT LOCK: ROE ${currentROE.toFixed(2)}%. SL dinaikkan ke ${formatPrice(newSlPrice)}`);
                }
            }
        }
        if (pos.tp3 > 0 && ((isLong && markPrice >= pos.tp3) || (!isLong && markPrice <= pos.tp3))) {
            return { action: 'CLOSE', reason: 'AUTO TAKE PROFIT (TP3)' };
        }

        // PRIORITAS #3: EXIT ANTI-CP MTF (MACD 15m CONFLICT) - PROFIT FACTOR MULTIPLIER
        const MACD_15M_STATUS = realtimeCache.main.allIndicators?.macd_15m?.status || 'Netral';
        const hasPositionSafeExit = pos.isSafe; 

        if (hasPositionSafeExit) {
            if (pos.type === 'long') {
                // Exit Long jika Gatekeeper MTF memberikan sinyal Bearish
                if (MACD_15M_STATUS.includes('Bearish Cross')) {
                    return { action: 'CLOSE', reason: 'ANTI-CP REVERSION (MACD 15m Bearish)' };
                }
            } else if (pos.type === 'short') {
                // Exit Short jika Gatekeeper MTF memberikan sinyal Bullish
                if (MACD_15M_STATUS.includes('Bullish Cross')) {
                    return { action: 'CLOSE', reason: 'ANTI-CP REVERSION (MACD 15m Bullish)' };
                }
            }
        }

        return { action: 'HOLD', reason: 'N/A' };
    }
    
    async function getHtfTrend(symbol, timeframe = '1h', period = 89) {
        try {
            const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: period + 200 }, 'futures');
            if (!klines || klines.length < period) {
                console.warn(`[HTF FILTER] Data tidak cukup untuk timeframe ${timeframe}.`);
                return 'NETRAL'; 
            }
            const closes = klines.map(k => parseFloat(k[4]));
            const lastClose = closes[closes.length - 1];
            const ema89 = calculateEMA(closes, period).pop();
            if (!ema89) return 'NETRAL';
            if (lastClose > ema89) {
                return 'BULLISH';
            } else {
                return 'BEARISH';
            }
        } catch (error) {
            console.error(`[HTF FILTER] Gagal mengambil data tren HTF:`, error);
            return 'NETRAL'; 
        }
    }

    function analyzeStrategyPerformance(history) {
        if (!history || history.length === 0) {
            return {};
        }

        const performance = {};
        history.forEach(trade => {
            const strategyName = trade.biasStatus;
            const isAftTrade = trade.flag && trade.flag.startsWith('AFT');

            if (isAftTrade && strategyName) {
                if (!performance[strategyName]) {
                    performance[strategyName] = { trades: 0, wins: 0, losses: 0, totalPnl: 0, winRate: 0, consecutiveLosses: 0 };
                }

                performance[strategyName].totalPnl += trade.pnlNet;
            }
        });

        const fullTrades = history.filter(t => t.flag !== 'AFT_PARTIAL');
        fullTrades.forEach(trade => {
            const strategyName = trade.biasStatus;
            const isAftTrade = trade.flag && trade.flag.startsWith('AFT');

            if (isAftTrade && performance[strategyName]) {
                const stats = performance[strategyName];
                stats.trades++;
                if (trade.pnlNet > 0) {
                    stats.wins++;
                } else if (trade.pnlNet < 0) {
                    stats.losses++;
                }
            }
        });

        for (const strategyName in performance) {
            const stats = performance[strategyName];
            if (stats.trades > 0) {
                stats.winRate = (stats.wins / stats.trades) * 100;
            } else {
                if (stats.totalPnl === 0) {
                    delete performance[strategyName];
                }
            }
        }

        return performance;
    }

    async function startAnalysisSession(useApi = false) {
        const startBtn = document.getElementById('start-live-btn');
        const startBtnText = startBtn.querySelector('span');

        if (startBtnText.textContent.includes("STOP")) {
            console.log(`‚èπÔ∏è Menerima perintah STOP. Sesi analisis dihentikan...`);

            if (paperTrade.state.position) {
                const currentPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (!isNaN(currentPrice)) {
                    paperTrade.closePosition(currentPrice, 'FORCED CLOSE (SESSION STOP)');
                }
            }

            if (window.syncInterval) clearInterval(window.syncInterval);
            if (window.liveInterval) clearInterval(window.liveInterval);
            if (latencyInterval) clearInterval(latencyInterval);
            if (processingInterval) clearInterval(processingInterval);
            liveInterval = null;
            lastTradeExecutionTime = 0;

            isAutoTradeEnabled = false;
            const autoTradeBtn = document.getElementById('enable-auto-trade-btn');
            if (autoTradeBtn) {
                autoTradeBtn.textContent = '‚ñ∂Ô∏è ENABLE AUTO-TRADE';
                autoTradeBtn.classList.remove('!bg-green-600', 'hover:!bg-green-500');
                autoTradeBtn.classList.add('!bg-gray-600', 'hover:!bg-gray-500');
            }

            document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-gray-500';
            document.getElementById('api-status-text').textContent = 'View Only';
            document.getElementById('connect-api-status-text').textContent = 'üîå BINANCE';

            isGlobalStopActive = false;
            globalLossStreak = 0;

            setButtonState(startBtn, false, `‚ñ∂Ô∏è START ANALYSIS`);
            toggleAssetInputs(true);
            return;
        }

        lastUsedApiMode = useApi;
        setButtonState(startBtn, true, "Menunggu AI Ready...");
        await waitForModel();

        isGlobalStopActive = false;
        globalLossStreak = 0;
        initialEquitySnapshot = paperTrade.state.balance;

        setButtonState(startBtn, true, "Memulai Sesi Analisis...");
        toggleAssetInputs(false);

        try {
            if (useApi) {
                await paperTrade.syncAccountState(); 
                if (window.syncInterval) clearInterval(window.syncInterval);
                window.syncInterval = setInterval(() => paperTrade.syncAccountState(), 2500);
                document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-green-500 blinking-status';
                document.getElementById('api-status-text').textContent = 'üì°LIVE';
                document.getElementById('connect-api-status-text').textContent = '‚ö°Ô∏è PROXY LIVE'; 
            } else {
                paperTrade.loadState(); 
                paperTrade.render(); 
                document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-yellow-500';
                document.getElementById('api-status-text').textContent = 'üßæSIM';
                document.getElementById('connect-api-status-text').textContent = 'üîó SIMULASI'; 
            }

            const symbol = liveSymbolInput.value.toUpperCase();
            realtimeCache.main.symbol = symbol;
            if (assetSymbolDisplay) assetSymbolDisplay.textContent = symbol;
            const timeframe = liveTimeframeSelect.value;

            await fetchInitialData(symbol, timeframe);
            const initialTrades = await fetchBinanceAPIData('aggTrades', { symbol: symbol, limit: 1000 }, 'futures');
            realtimeCache.main.klines = [...liveData]; 
            realtimeCache.main.cvdData = calculateCVD(initialTrades);

            const dumpTfs = ['1m', '5m', '15m', '1h', '4h', '1d', '1w'];
            realtimeCache.main.multiTfKlines = {};
            const multiTfPromises = dumpTfs.map(tf => 
                fetchBinanceAPIData('klines', { symbol: symbol, interval: tf, limit: 200 }, 'futures')
                    .then(klines => ({ tf, klines }))
                    .catch(e => { console.warn(`Gagal memuat klines ${tf}:`, e); return { tf, klines: [] }; })
            );
            const multiTfResults = await Promise.all(multiTfPromises);
            multiTfResults.forEach(res => { realtimeCache.main.multiTfKlines[res.tf] = res.klines; });

            WebSocketManager.registerHandler('kline', (message) => klineQueue.push(message));
            WebSocketManager.registerHandler('aggTrade', (trade) => tradeQueue.push(trade));
            WebSocketManager.registerHandler('depthUpdate', (data) => depthQueue.push(data));

            const symbolLower = symbol.toLowerCase();
            const streamsToSub = [
                `${symbolLower}@kline_${timeframe}`, // (Peta Mini 1m Anda)
                `${symbolLower}@kline_5m`,   // <-- Peta 5m
                `${symbolLower}@kline_15m`,  // Peta 15m
                `${symbolLower}@kline_1h`,   // Peta 1h
                `${symbolLower}@kline_4h`,   // Peta 4h
                `${symbolLower}@kline_1d`,   // <-- PERBAIKAN 1D
                `${symbolLower}@kline_1w`,   // Peta 1W (S.O.P. "Semua Jebol")
                `${symbolLower}@aggTrade`, 
                `${symbolLower}@depth5@100ms`
            ];
            WebSocketManager.subscribe(streamsToSub);

            latencyInterval = setInterval(checkBinanceLatency, 10000);

            setButtonState(startBtn, false, `‚èπÔ∏è STOP ANALYSIS`);
            liveSignalPanel.classList.remove('hidden');
            updateHtfCompass('1h');
            updateMarketStructurePanel(symbol, '4h');

            processingInterval = setInterval(processQueues, 500);
            liveInterval = true;
            liveLoop();

        } catch (error) {
            console.error("Gagal memulai sesi (dari dalam startAnalysisSession):", error);
            fallbackToSimulationMode(); 
            toggleAssetInputs(true);
        }
    }
// ===================================================================
    // --- GANTI FUNGSI V2.1 ANDA DENGAN YANG INI (V3.0) ---
    function updateEmaRibbonTable() {
        const tableBody = document.getElementById('ema-ribbon-table-body');
        const symbol = realtimeCache.main.symbol;
        const multiTfKlines = realtimeCache.main.multiTfKlines;
        const mainTimeframeKlines = realtimeCache.main.klines;
        
        // --- LOGIKA BARU "TIDAK BOLAK-BALIK" (V3.0) ---
        // 1. DAPATKAN SINYAL KONTEKSTUAL (bukan Rezim AI)
        // Kita baca dari variabel global 'lastStableSignal' yang di-update oleh displayLiveSignal
        const currentSignalBias = lastStableSignal.toUpperCase() || 'NEUTRAL - NO BIAS';
        // --- AKHIR PERUBAHAN V3.0 ---

        if (!tableBody || !multiTfKlines || !symbol || !mainTimeframeKlines || mainTimeframeKlines.length < 100) {
            if (tableBody) tableBody.innerHTML = '<tr><td colspan="7" class="text-center p-4 text-gray-600">Memuat data klines utama...</td></tr>';
            return;
        }

        // 2. HITUNG "TEMBOK" HORIZONTAL (BUY/SELL POWER) DARI TF UTAMA
        const { buyPower, sellPower } = calculateBuySellPower(mainTimeframeKlines, 100);

        const TARGET_TFS = ['1m', '5m', '15m', '1h', '4h', '1d', '1w'];
        const EMA_RIBBON = [13, 21, 34, 55, 89, 144];
        
        let tableHtml = '';
        const currentPrice = parseFloat(realtimeCache.main.tickerData?.lastPrice) || 0;
        const PROXIMITY_PERCENT = 0.002; // Toleransi 0.2%

        TARGET_TFS.forEach(tf => {
            const klines = multiTfKlines[tf];
            
            if (!klines || klines.length < 150) { 
                tableHtml += `<tr class="border-b border-gray-800"><td class="px-2 py-1 text-yellow-400 font-semibold">${tf.toUpperCase()}</td><td colspan="6" class="text-center text-gray-600">Data Klines Tidak Cukup</td></tr>`;
                return;
            }

            const closes = klines.map(k => parseFloat(k[4]));
            let emaValues = {};
            EMA_RIBBON.forEach(period => {
                const ema = calculateEMA(closes, period).pop();
                emaValues[period] = ema || NaN;
            });
            
            let rowContent = `<td class="px-2 py-1 text-yellow-400 font-semibold">${tf.toUpperCase()}</td>`;
            
            EMA_RIBBON.forEach(period => {
                const emaPrice = emaValues[period];
                let cellClass = ''; 
                
                // --- LOGIKA BARU V3.0: Baca Sinyal Kontekstual ---
                const isNearBuyPower = buyPower > 0 && Math.abs(emaPrice - buyPower) / buyPower < PROXIMITY_PERCENT;
                const isNearSellPower = sellPower > 0 && Math.abs(emaPrice - sellPower) / sellPower < PROXIMITY_PERCENT;

                // Terapkan "Glow" HANYA jika relevan dengan Sinyal Anda
                if (currentSignalBias.includes('LONG') && isNearBuyPower) {
                    // Jika sinyal LONG, hanya sorot Tembok SUPPORT (Hijau)
                    cellClass = 'glow-support'; 
                } else if (currentSignalBias.includes('SHORT') && isNearSellPower) {
                    // Jika sinyal SHORT, hanya sorot Tembok RESISTANCE (Merah)
                    cellClass = 'glow-resistance';
                } else if (currentSignalBias.includes('NEUTRAL')) {
                    // Jika NETRAL, sorot KEDUANYA
                    if (isNearBuyPower) cellClass = 'glow-support';
                    if (isNearSellPower) cellClass = 'glow-resistance';
                }
                // --- AKHIR LOGIKA BARU ---

                let priceColorClass = 'text-gray-400';
                if (currentPrice > emaPrice) priceColorClass = 'positive';
                else if (currentPrice < emaPrice) priceColorClass = 'negative';
                
                rowContent += `<td class="px-2 py-1 text-center font-mono ${cellClass}">
                                    <span class="${priceColorClass}">
                                        ${formatPrice(emaPrice, symbol)}
                                    </span>
                                </td>`;
            });

            tableHtml += `<tr class="border-b border-gray-800/50">${rowContent}</tr>`;
        });

        tableBody.innerHTML = tableHtml;
    }

    function updateShortScoreUI(symbol, score, breakdown) {
        const item = document.querySelector(`.mover-item[data-symbol="${symbol}"]`);
        if (!item) return;

        item.setAttribute('data-dump-risk-score', score.toFixed(1));
        item.setAttribute('data-breakdown', JSON.stringify(breakdown));

        const hybridBar = item.querySelector(`#hybrid-bar-${symbol}`);
        if (hybridBar) {
            const dumpRiskPercent = Math.min(100, score * 10); 
            const dumpRiskElement = hybridBar.querySelector('.dump-risk');
            
            if (dumpRiskElement) {
                dumpRiskElement.style.width = `${dumpRiskPercent}%`;

                let color;
                if (score > 8) color = '#f6465d'; 
                else if (score > 5) color = '#FFC107'; 
                else color = '#2ebd85';

                dumpRiskElement.style.backgroundColor = color;
            }
        }
    }

    function runFullAnalysis(symbol) {
        document.getElementById('live-symbol-input').value = symbol;
        const startBtn = document.getElementById('start-live-btn');
        if (startBtn) {
            console.log(`Mengalihkan analisis utama ke ${symbol} dan memulai sesi simulasi/live.`);
            startBtn.click(); 
        }
    }

    async function updateRealTimeIndicators(klinesSnapshot) {
        if (!klinesSnapshot || klinesSnapshot.length < 50) return;
        
        const closes = klinesSnapshot.map(k => parseFloat(k[4]));
        const currentPrice = closes[closes.length - 1];
        const timeframe = liveTimeframeSelect.value;
        const symbol = liveSymbolInput.value.toUpperCase();
        const psarData = calculateParabolicSAR(klinesSnapshot);
        const rocValue = closes.length > 12 ? ((closes[closes.length - 1] - closes[closes.length - 1 - 12]) / closes[closes.length - 1 - 12]) * 100 : NaN;
        const adxData = calculateADX(klinesSnapshot);
        const atrData = calculateATR(klinesSnapshot, 14);
        
        let fundingRateData = { lastFundingRate: 0, nextFundingTime: 0 };
        let lsRatioData = { longShortRatio: 1.0 };
        let lsTopRatioData = { longShortRatio: 1.0 };
        let openInterestData = [];

        try {
            let [fundingRes, lsRatioRes, lsTopRatioRes, openInterestRes] = await Promise.all([
                fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${symbol}`),
                fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}&period=${timeframe}&limit=1`),
                fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${symbol}&period=${timeframe}&limit=1`),
                fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=${timeframe}&limit=2`)
            ]);

            if (fundingRes.ok) fundingRateData = await fundingRes.json();
            if (lsRatioRes.ok) { const lsData = await lsRatioRes.json(); if (lsData.length > 0) lsRatioData = lsData[0]; }
            if (lsTopRatioRes.ok) { const lsTopData = await lsTopRatioRes.json(); if (lsTopData.length > 0) lsTopRatioData = lsTopData[0]; }
            if (openInterestRes.ok) openInterestData = await openInterestRes.json();
            
            nextFundingTimestamp = fundingRateData.nextFundingTime || 0; 

        } catch (e) { 
            console.warn("Gagal mengambil data sentimen dari API, menggunakan data default."); 
        }

        const oiValue = openInterestData.length > 0 ? parseFloat(openInterestData.slice(-1)[0].sumOpenInterestValue) : 0;
    
        updateSentimentDisplay({ 
            psar: psarData.status, 
            roc: rocValue, 
            adx: adxData.value, 
            atr: atrData, 
            lsGlobal: parseFloat(lsRatioData.longShortRatio), 
            lsTop: parseFloat(lsTopRatioData.longShortRatio), 
            funding: parseFloat(fundingRateData.lastFundingRate), 
            oi: oiValue 
        });

        

        updateOrderFlowPanel({
            b: [['price1', 50000], ['price2', 30000]], 
            a: [['price1', 50000], ['price2', 30000]]  
        });
    }

    async function initializeExchangeInfo(marketType) {
        if (exchangeInfoCache[marketType]) return;
        const url = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1/exchangeInfo' : 'https://api.binance.com/api/v3/exchangeInfo';
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Gagal unduh info bursa ${marketType}.`);
        const data = await response.json();
        exchangeInfoCache[marketType] = data.symbols;
    }

    function calculateChange(kData) {
        if (!kData || kData.length < 2) return 'N/A';
        const firstClose = parseFloat(kData[0][4]);
        const lastClose = parseFloat(kData[kData.length - 1][4]);
        return firstClose > 0 ? (((lastClose - firstClose) / firstClose) * 100).toFixed(2) : '0.00';
    }

    function calculateKeltnerChannels(klines, period = 20, multiplier = 1.5) {
        if (!klines || klines.length < period) return { upper: [], middle: [], lower: [] };
        
        const closes = klines.map(k => parseFloat(k[4]));
        const middle = calculateEMA(closes, period);
        const atr = calculateATR(klines, period).value;
        
        let upper = [], lower = [];
        for (let i = 0; i < middle.length; i++) {
            if (middle[i] !== undefined) {
                upper.push(middle[i] + (atr * multiplier));
                lower.push(middle[i] - (atr * multiplier));
            } else {
                upper.push(undefined);
                lower.push(undefined);
            }
        }
        return { upper, middle, lower };
    }

    function analyzeBollingerBandsPriceAction(klines, bbData) {
        if (!klines || klines.length < 3 || !bbData.upper || bbData.upper.length < 3) {
            return { rejection: 'Netral', walkTheBands: 'Netral' };
        }

        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const prevClose = parseFloat(klines[klines.length - 2][4]);
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop() || 0;
        const lastLower = bbData.lower.filter(v => v !== undefined).pop() || 0;
        
        let rejection = 'Netral';
        if (lastClose > lastUpper && prevClose < lastUpper) rejection = 'Bearish Rejection (Upper BB)';
        else if (lastClose < lastLower && prevClose > lastLower) rejection = 'Bullish Rejection (Lower BB)';

        let walkTheBands = 'Netral';
        if (lastClose > lastUpper) walkTheBands = 'Bullish (Walking the Bands)';
        else if (lastClose < lastLower) walkTheBands = 'Bearish (Walking the Bands)';

        return { rejection, walkTheBands };
    }

    function CVDanalyze(klines, cvdData) {
        if (!klines || klines.length < 50 || !cvdData || cvdData.length < 2) return { divergence: 'Netral' };
        
        const closes = klines.map(k => parseFloat(k[4]));
        const cvdValues = cvdData.map(d => d.cvd_usdt);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };
        
        const lookback = 50; 
        const recentCloses = closes.slice(-lookback);
        const recentCVD = cvdValues.slice(-lookback);
        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const cvdLows = findPivots(recentCVD, false), cvdHighs = findPivots(recentCVD, true);

        if (priceLows.length >= 2 && cvdLows.length >= 2) {
            const lastPriceLow = priceLows.pop(), prevPriceLow = priceLows.pop();
            const lastCvdLow = cvdLows.pop(), prevCvdLow = cvdLows.pop();
            if (lastPriceLow && prevPriceLow && lastCvdLow && prevCvdLow && lastPriceLow.value < prevPriceLow.value && lastCvdLow.value > prevCvdLow.value) return { divergence: 'Bullish Divergence' };
        }

        if (priceHighs.length >= 2 && cvdHighs.length >= 2) {
            const lastPriceHigh = priceHighs.pop(), prevPriceHigh = priceHighs.pop();
            const lastCvdHigh = cvdHighs.pop(), prevCvdHigh = cvdHighs.pop();
            if (lastPriceHigh && prevPriceHigh && lastCvdHigh && prevCvdHigh && lastPriceHigh.value > prevPriceHigh.value && lastCvdHigh.value < prevCvdHigh.value) return { divergence: 'Bearish Divergence' };
        }

        return { divergence: 'Netral' };
    }

    function calculateShortConfluenceScore(symbol, timeframe, moverCache = null) {
        let klines;
        let aggTrades;
        let cvdDataForAnalysis;

        if (symbol === realtimeCache.main.symbol && realtimeCache.main.multiTfKlines && realtimeCache.main.multiTfKlines[timeframe]) {
            klines = realtimeCache.main.multiTfKlines[timeframe];
            cvdDataForAnalysis = realtimeCache.main.cvdData;
        } else if (moverCache) {
            klines = moverCache.klines_5m; 
            cvdDataForAnalysis = moverCache.cvdData;
        } else {
            return { score: 0, breakdown: {} };
        }
        
        if (!klines || klines.length < 50) return { score: 0, breakdown: {} };

        const closes = klines.map(k => parseFloat(k[4]));
        const bbData = calculateBollingerBands(closes);
        const kcData = calculateKeltnerChannels(klines);

        const indicators = {
            candlePattern: findCandlestickPatterns(klines),
            macd: calculateMACD(closes),
            rsi: calculateRSI(closes),
            bollingerBands: analyzeBollingerBandsPriceAction(klines, bbData), 
            cvd: CVDanalyze(klines, cvdDataForAnalysis),
            atr: calculateATR(klines)
        };
        
        const atrStatus = indicators.atr.status;
        let volatilityMultiplier = 1.0; 

        if (atrStatus === 'High' || atrStatus === 'Very High') {
            volatilityMultiplier = 0.5; // Mengurangi bobot saat volatilitas tinggi (false signals)
        }

        const lastRsiValue = indicators.rsi.filter(v => v !== undefined).pop() || 50;
        let score = 0;
        
        const lastUpper = bbData.upper.filter(v => v !== undefined).pop() || 0;
        const lastMiddle = bbData.middle.filter(v => v !== undefined).pop() || 0;
        const lastLower = bbData.lower.filter(v => v !== undefined).pop() || 0;

        let breakdown = {
            timeframe: timeframe,
            rsiValue: lastRsiValue.toFixed(2),
            macdStatus: indicators.macd.status,
            bbStatus: indicators.bollingerBands.rejection,
            bbUpper: formatPrice(lastUpper),
            bbMiddle: formatPrice(lastMiddle),
            bbLower: formatPrice(lastLower),
            cvdStatus: indicators.cvd.divergence,
            candlePattern: indicators.candlePattern.pattern,
            candleRed: { triggered: false, points: 0 },
            doji: { triggered: false, points: 0 },
            cvdDip: { triggered: false, points: 0 },
            cvdDivergence: { triggered: false, points: 0 },
            rsiOverbought: { triggered: false, points: 0 },
            bbRejection: { triggered: false, points: 0 },
            macdCross: { triggered: false, points: 0 },
            volumeExhaustion: { triggered: false, points: 0 }
        };

        const lookbackPeriod = 15;
        const recentKlines = klines.slice(-lookbackPeriod);
        
        if (recentKlines.length >= 3) {
            let peakIndex = 0;
            for (let i = 1; i < recentKlines.length; i++) {
                if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
            }

            if (peakIndex < lookbackPeriod - 2) {
                const triggerCandleArr = recentKlines[peakIndex + 1];
                if (triggerCandleArr) {
                    const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                    if (triggerCandle.Close < triggerCandle.Open) {
                        const points = 3 * volatilityMultiplier;
                        score += points;
                        breakdown.candleRed = { triggered: true, points: points };
                    }
                }
            }
       
            if (peakIndex > 4 && peakIndex < recentKlines.length - 1) {
                const pumpVolumeLookback = 5;
                const pumpCandles = recentKlines.slice(peakIndex - pumpVolumeLookback, peakIndex);
                
                if (pumpCandles.length > 0) {
                    const avgPumpVolume = pumpCandles.reduce((sum, k) => sum + parseFloat(k[5]), 0) / pumpCandles.length;
                    const peakVolume = parseFloat(recentKlines[peakIndex][5]);

                    if (peakVolume < (avgPumpVolume * 0.6)) { 
                        const points = 2 * volatilityMultiplier;
                        score += points;
                        breakdown.volumeExhaustion = { triggered: true, points: points };
                    }
                }
            }
        }

        if (indicators.candlePattern.bias === 'BEARISH') {
            const points = 1 * volatilityMultiplier;
            score += points;
            breakdown.doji = { triggered: true, points: points };
        }

        if (lastRsiValue > 70) {
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.rsiOverbought = { triggered: true, points: points };
        }

        if (indicators.bollingerBands.rejection === 'Bearish Rejection (Upper BB)') {
            score += 3 * volatilityMultiplier;
            breakdown.bbRejection = { triggered: true, points: 3 * volatilityMultiplier };
        }
        
        if (indicators.macd.status === 'Bearish Cross') {
            score += 2 * volatilityMultiplier;
            breakdown.macdCross = { triggered: true, points: 2 * volatilityMultiplier };
        }   

        if (indicators.cvd.divergence.includes('Bearish')) {
            const points = 2 * volatilityMultiplier;
            score += points;
            breakdown.cvdDivergence = { triggered: true, points: points };
        }

        if (symbol === realtimeCache.main.symbol) {
            const now = Date.now();
            if (now - lastCvdDipCalculationTime > CVD_DIP_DEBOUNCE_MS) {
                lastCvdDipCalculationTime = now; 
                const cvdValues = cvdDataForAnalysis.map(d => d.cvd_usdt);
                const changeLookback = 50;
                const stdDevMultiplier = 1.3;

                if (cvdValues.length > changeLookback) {
                    let cvdChanges = [];
                    for (let i = cvdValues.length - changeLookback; i < cvdValues.length; i++) {
                        cvdChanges.push(cvdValues[i] - cvdValues[i - 1]);
                    }
                    const avgChange = cvdChanges.reduce((sum, val) => sum + val, 0) / changeLookback;
                    const variance = cvdChanges.reduce((sum, val) => sum + Math.pow(val - avgChange, 2), 0) / changeLookback;
                    const stdDev = Math.sqrt(variance);
                    const lastChange = cvdChanges[cvdChanges.length - 1];
                    if (lastChange < (avgChange - (stdDevMultiplier * stdDev))) {
                        const points = 0.09 * volatilityMultiplier;
                        lastCvdDipResult = { triggered: true, points: points }; 
                    } else {
                        lastCvdDipResult = { triggered: false, points: 0 };
                    }
                } else {
                    lastCvdDipResult = { triggered: false, points: 0 };
                }
            }
            
            if(lastCvdDipResult.triggered) {
                score += lastCvdDipResult.points;
            }
            breakdown.cvdDip = lastCvdDipResult;
        }

        return { score: Math.min(score, 10), breakdown };
    }

    function getPatternSVG(patternName, candleColor = 'svg-red') {
        const svgHeader = `<svg viewBox="0 0 110 60" class="w-20 h-auto mx-auto my-0.5">`;
        const svgFooter = `</svg>`;
        const green = 'svg-green', red = 'svg-red', gray = 'svg-gray';
        const createCandle = (x, open, high, low, close, color) => {
            const isGreen = close > open;
            const bodyY = Math.min(open, close);
            const bodyHeight = Math.abs(open - close);
            const bodyColor = color === 'svg-gray' ? color : (isGreen ? green : red);

            return `
                <line x1="${x+10}" y1="${high}" x2="${x+10}" y2="${low}" class="svg-wick ${bodyColor}" vector-effect="non-scaling-stroke"/>
                <rect x="${x}" y="${bodyY}" width="20" height="${bodyHeight > 0 ? bodyHeight : 0.5}" class="svg-body ${bodyColor}"/>
            `;
        };

        switch(patternName) {
            case 'BULLISH HARAMI':
                content = createCandle(20, 50, 55, 10, 15, red) + createCandle(55, 25, 35, 20, 30, green);
                break;
            case 'BEARISH HARAMI':
                content = createCandle(20, 10, 50, 8, 45, green) + createCandle(55, 40, 45, 30, 35, red);
                break;
            case 'HAMMER':
                content = createCandle(40, 50, 52, 10, 48, candleColor);
                break;
            case 'SHOOTING STAR':
                content = createCandle(40, 12, 50, 10, 15, candleColor);
                break;
            default:
                if (!liveData || liveData.length < 2) return '';
                
                const lastData = liveData[liveData.length - 1];
                const lastClose = parseFloat(lastData[4]);
                const lastOpen = parseFloat(lastData[1]);
                const lastHigh = parseFloat(lastData[2]);
                const lastLow = parseFloat(lastData[3]);
                const maxPrice = Math.max(...liveData.map(d=>parseFloat(d[2])));
                const minPrice = Math.min(...liveData.map(d=>parseFloat(d[3])));
                const normalize = (price) => {
                    if (maxPrice === minPrice) return 30; 
                    return 55 - ((price - minPrice) / (maxPrice - minPrice)) * 50; 
                };
                
                content = createCandle(40, normalize(lastOpen), normalize(lastHigh), normalize(lastLow), normalize(lastClose), lastClose > lastOpen ? green : red);
                break;
        }

        return svgHeader + content + svgFooter;
    }

    function findCandlestickPatterns(klines) {
        if (!klines || klines.length < 2) return { pattern: 'NONE', bias: 'NETRAL', svg: '' };
        
        const getCandleDetails = (k) => {
            const [o, h, l, c] = k.slice(1, 5).map(parseFloat);
            return { open: o, high: h, low: l, close: c, body: Math.abs(c - o), isGreen: c > o, isRed: c < o, range: h - l };
        };

        const c1 = getCandleDetails(klines[klines.length - 1]); 
        const c2 = getCandleDetails(klines[klines.length - 2]);

        let result = { pattern: 'NONE', bias: 'NETRAL', svg: getPatternSVG('NORMAL_CANDLE') }; 

        if (c2.isRed && c1.isGreen && c1.open < c2.open && c1.close > c2.close && c1.body < c2.body) {
            result = { pattern: 'BULLISH HARAMI', bias: 'BULLISH', svg: getPatternSVG('BULLISH HARAMI') };
        } else if (c2.isGreen && c1.isRed && c1.open > c2.open && c1.close < c2.close && c1.body < c2.body) {
            result = { pattern: 'BEARISH HARAMI', bias: 'BEARISH', svg: getPatternSVG('BEARISH HARAMI') };
        } else if (c1.body > 0 && Math.min(c1.open, c1.close) - c1.low > c1.body * 2 && c1.high - Math.max(c1.open, c1.close) < c1.body * 0.5) {
            const cColor = c1.isGreen ? 'svg-green' : 'svg-red';
            result = { pattern: 'HAMMER', bias: 'BULLISH', svg: getPatternSVG('HAMMER', cColor) };
        } else if (c1.body > 0 && c1.high - Math.max(c1.open, c1.close) > c1.body * 2 && Math.min(c1.open, c1.close) - c1.low < c1.body * 0.5) {
            const cColor = c1.isGreen ? 'svg-green' : 'svg-red';
            result = { pattern: 'SHOOTING STAR', bias: 'BEARISH', svg: getPatternSVG('SHOOTING STAR', cColor) };
        }

        return result;
    };

    function calculateCVD(trades) {
        let cumulativeDeltaCoin = 0;
        let cumulativeDeltaUsdt = 0;
        return trades.map(t => {
            const quantity = parseFloat(t.q || t.Q);
            const price = parseFloat(t.p || t.P);
            const sign = (t.m !== undefined) ? (t.m ? -1 : 1) : (t.M ? -1 : 1); 
            
            cumulativeDeltaCoin += quantity * sign;
            cumulativeDeltaUsdt += (quantity * price) * sign;

            return { 
                time: t.T / 1000, 
                cvd_coin: cumulativeDeltaCoin,
                cvd_usdt: cumulativeDeltaUsdt 
            };
        });
    }

    function calculateEMA(data, period) {
        if (!data || data.length < period) {
            return [];
        }

        const k = 2 / (period + 1);
        let emaArray = Array(data.length).fill(undefined); 
        let sum = 0;
        for (let i = 0; i < period; i++) {
            sum += data[i] || 0;
        }
        
        emaArray[period - 1] = sum / period;

        for (let i = period; i < data.length; i++) {
            const prevEMA = emaArray[i - 1];
            const currentData = data[i];

            emaArray[i] = (currentData * k) + (prevEMA * (1 - k));
        }

        return emaArray; 
    };
    
    function calculateSMA(data, period) {
        if (!data || data.length < period) {
            return [];
        }
        
        let sma = [];
        let sum = 0;

   
        for (let i = 0; i < period; i++) {
            sum += data[i];
        }
        sma.push(sum / period);

        for (let i = period; i < data.length; i++) {
            sum = sum - data[i - period] + data[i];
            sma.push(sum / period);
        }

        const alignedSma = [...Array(period - 1).fill(undefined), ...sma];
        
        return alignedSma;
    };

    function calculateRSI(closes, period = 14) {
        if (!closes || closes.length <= period) {
            return Array(closes.length).fill(undefined);
        }
        
        let gains = [];
        let losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let rsi = Array(period).fill(undefined);
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        rsi[period - 1] = (avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            rsi.push((avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
        }
        return rsi;
    };
    
    function calculateMACD(closes, fast = 12, slow = 26, signal = 9) {
        if (closes.length < slow) {
            return { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };
        }
        
        const emaFast = calculateEMA(closes, fast);
        const emaSlow = calculateEMA(closes, slow);
        const macdLine = emaSlow.map((slowVal, i) => {
            if (slowVal !== undefined && emaFast[i] !== undefined) {
                return emaFast[i] - slowVal;
            }
            return undefined;
        });
        const macdStartIndex = macdLine.findIndex(v => v !== undefined);
        const signalLineRaw = calculateEMA(macdLine, signal); 
        const signalLine = signalLineRaw;
        const histogram = macdLine.map((macdVal, i) => {
            const sigVal = signalLine[i];
            if (macdVal !== undefined && sigVal !== undefined) {
                const histValue = macdVal - sigVal;
                const prevMacdLine = macdLine[i - 1] !== undefined ? macdLine[i - 1] : macdVal;
                const prevSignalLine = signalLine[i - 1] !== undefined ? signalLine[i - 1] : sigVal;
                const prevHistValue = prevMacdLine - prevSignalLine;
                
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        });
        const lastMacd = macdLine.filter(v => v !== undefined).pop() || 0;
        const lastSig = signalLine.filter(v => v !== undefined).pop() || 0;
        const prevMacdLineVal = macdLine.filter(v => v !== undefined).slice(-2)[0] || 0;
        const prevSignalLineVal = signalLine.filter(v => v !== undefined).slice(-2)[0] || 0;
        
        let status = 'Netral';
        if (prevMacdLineVal <= prevSignalLineVal && lastMacd > lastSig) {
            status = 'Bullish Cross';
        } else if (prevMacdLineVal >= prevSignalLineVal && lastMacd < lastSig) {
            status = 'Bearish Cross';
        }
        const finalMacdLine = macdLine.filter(v => v !== undefined);
        const finalSignalLine = signalLine.filter(v => v !== undefined);
        const finalHistogram = histogram.filter(v => v !== undefined);

        return { status, macdLine: finalMacdLine, signalLine: finalSignalLine, histogram: finalHistogram };
    };

    function calculateStochasticRSI(closes, rsiPeriod = 14, stochPeriod = 14, kSmooth = 3, dSmooth = 3) {
        const rsiValues = calculateRSI(closes, rsiPeriod);
        const validRsi = rsiValues.filter(v => v !== undefined);
        if (validRsi.length < rsiPeriod) {
            return { kLine: [], dLine: [], status: 'Netral', momentumStatus: 'NETRAL' };
        }
        let stochArr = [];
        const rsiStartOffset = rsiValues.findIndex(v => v !== undefined);

        for (let i = rsiStartOffset; i < rsiValues.length; i++) {
            const currentRSI = rsiValues[i];

            if (i >= rsiStartOffset + stochPeriod - 1) {
                const windowRSI = rsiValues.slice(i - stochPeriod + 1, i + 1);
                const window = windowRSI.filter(v => v !== undefined);

                if (window.length !== stochPeriod) { 
                    continue; 
                }
                
                const minR = Math.min(...window);
                const maxR = Math.max(...window);
                const denom = maxR - minR;
                
                stochArr.push(denom === 0 ? 0 : ((currentRSI - minR) / denom) * 100);
            }
        }

        const stochStartPad = rsiStartOffset + stochPeriod - 1;
        const kLinePad = calculateSMA(stochArr, kSmooth);
        const kLineRaw = Array(stochStartPad + kSmooth - 1).fill(undefined).concat(kLinePad.filter(v => v !== undefined));
        const dLinePad = calculateSMA(kLinePad.filter(v => v !== undefined), dSmooth);
        const dLineRaw = Array(stochStartPad + kSmooth - 1 + dSmooth - 1).fill(undefined).concat(dLinePad.filter(v => v !== undefined));
        const minLength = Math.min(kLineRaw.length, dLineRaw.length);
        const kLine = kLineRaw.slice(-minLength);
        const dLine = dLineRaw.slice(-minLength);
        const lastK = kLine[kLine.length - 1] || 50;
        const lastD = dLine[dLine.length - 1] || 50;
        const prevK = kLine[kLine.length - 2] || 50;
        const prevD = dLine[dLine.length - 2] || 50;
        
        let status = 'Netral';
        if (lastK > 90 && lastD > 90) status = 'Overbought';
        else if (lastK < 5 && lastD < 5) status = 'Oversold';

        let momentumStatus = 'NETRAL';

        if (prevK < 50 && lastK > 50 && lastK > lastD) {
            momentumStatus = 'BULLISH_CROSS_50'; 
        } 
        else if (prevK > 50 && lastK < 50 && lastK < lastD) {
            momentumStatus = 'BEARISH_CROSS_50'; 
        }
        else if (lastK > 50 && lastK > prevK && lastK > lastD) {
            momentumStatus = 'BULLISH_MOMENTUM_ABOVE_50';
        }
        else if (lastK > 50 && lastK < prevK && lastK < lastD) {
            momentumStatus = 'BULLISH_PULLBACK_ABOVE_50';
        }
        else if (lastK < 50 && lastK < prevK && lastK < lastD) {
            momentumStatus = 'BEARISH_MOMENTUM_BELOW_50';
        }
        else if (lastK < 50 && lastK > prevK && lastK > lastD) {
            momentumStatus = 'BEARISH_BOUNCE_BELOW_50';
        }
        else if (lastK >= 45 && lastK <= 55) {
            momentumStatus = 'NEUTRAL_ZONE';
        }
        
        return { 
            kLine, 
            dLine, 
            status,
            momentumStatus
        };
    }

    function detectRSIDivergence(closes, rsiValues, lookback = 30) {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };
        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const rsiLows = findPivots(recentRSI, false), rsiHighs = findPivots(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH' };
        }
        return { status: 'NONE' };
    };

    function calculateOBV(klines) {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i-1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) obv.push(obv[i-1] + volume);
            else if (close < prevClose) obv.push(obv[i-1] - volume);
            else obv.push(obv[i-1]);
        }
        return obv;
    };

    function detectOBVDivergence(closes, klines, lookback = 30) {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };

    function calculateBollingerBands(closes, period = 20, stdDev = 2) {
        if (closes.length < period) {
            return { upper: [], middle: [], lower: [], squeezeStatus: 'N/A' };
        }

        const middle = calculateSMA(closes, period);
        const upper = [];
        const lower = [];
        const width = [];

        let sum = 0;
        let sumOfSquares = 0;

        const initialSlice = closes.slice(0, period);
        for (const val of initialSlice) {
            sum += val;
            sumOfSquares += val * val;
        }

        const calculateAndPushBands = (currentSum, currentSumOfSquares) => {
            const mean = currentSum / period;
            const variance = (currentSumOfSquares / period) - (mean * mean);
            const stdev = Math.sqrt(Math.max(0, variance));
            upper.push(mean + (stdev * stdDev));
            lower.push(mean - (stdev * stdDev));
            width.push((stdev * stdDev * 2));
        };

        calculateAndPushBands(sum, sumOfSquares);

        for (let i = period; i < closes.length; i++) {
            const oldVal = closes[i - period];
            const newVal = closes[i];

            sum = sum - oldVal + newVal;
            sumOfSquares = sumOfSquares - (oldVal * oldVal) + (newVal * newVal);
            
            calculateAndPushBands(sum, sumOfSquares);
        }

        const lastWidth = width.filter(v => v !== undefined).pop();
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
        }

        const align = (arr) => [...Array(period - 1).fill(undefined), ...arr];

        return { 
            upper: align(upper), 
            middle: middle, 
            lower: align(lower), 
            squeezeStatus 
        };
    };

    function calculateADX(klines, period = 14) {
        if (!klines || klines.length < period * 2) return { value: 0, plusDI: 0, minusDI: 0 };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { value: adxValues.filter(v=>v!==undefined).pop() || 0, plusDI: plusDIs.pop() || 0, minusDI: minusDIs.pop() || 0 };
    };

    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline || prevDayKline.length < 5) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);
        if (isNaN(high) || isNaN(low) || isNaN(close)) return null;
        return { P: (high + low + close) / 3 };
    }

    function findPivots(klines, lookback = 3) {
        const pivots = [];
        if (klines.length < lookback * 2 + 1) return [];

        for (let i = lookback; i < klines.length - lookback; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            let isHigh = true, isLow = true;

            for (let j = 1; j <= lookback; j++) {
                if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
                if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
            }
            if (isHigh) pivots.push({ type: 'high', price: high, index: i });
            else if (isLow) pivots.push({ type: 'low', price: low, index: i });
        }
        return pivots;
    }

    function calculateSlope(p1, p2) {
        if (p2.index === p1.index) return Infinity;
        return (p2.price - p1.price) / (p2.index - p1.index);
    }

    function findLastSignificantSwing(klines) {
        const pivots = findPivots(klines.slice(-500), 5);
        if (pivots.length < 3) return null;

        for (let i = pivots.length - 1; i >= 2; i--) {
            const p3 = pivots[i];
            const p2 = pivots[i - 1];
            const p1 = pivots[i - 2];

            if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low') {
                if (p3.price > p1.price) {
                    return { A: p1, B: p2, C: p3, type: 'UP' };
                }
            }

            if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high') {
                if (p3.price < p1.price) {
                    return { A: p1, B: p2, C: p3, type: 'DOWN' };
                }
            }
        }
        return null;
    }

    function calculateAdvancedFibonacciExtension(swing) {
        if (!swing || !swing.A?.price || !swing.B?.price || !swing.C?.price || !swing.type) return null;
        const priceA = parseFloat(swing.A.price), priceB = parseFloat(swing.B.price), priceC = parseFloat(swing.C.price);
        if (isNaN(priceA) || isNaN(priceB) || isNaN(priceC)) return null;

        const impulseMove = Math.abs(priceB - priceA);
        const fibLevels = [0, 0.618, 1.0, 1.272, 1.618, 2.618];
        const calculatedLevels = {};

        fibLevels.forEach(level => {
            let targetPrice = (swing.type === 'UP') ? priceC + (impulseMove * level) : priceC - (impulseMove * level);
            calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
        });

        return {
            swingPoints: { A: priceA, B: priceB, C: priceC },
            type: swing.type,
            levels: calculatedLevels
        };
    }

    function calculateFibonacciRetracement(swing) {
        if (!swing || !swing.A?.price || !swing.B?.price) return null;
        const priceA = parseFloat(swing.A.price), priceB = parseFloat(swing.B.price);
        if (isNaN(priceA) || isNaN(priceB)) return null;

        const impulseMove = Math.abs(priceB - priceA);
        const retracementLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
        const calculatedLevels = {};

        retracementLevels.forEach(level => {
            let targetPrice = (swing.type === 'UP') ? priceB - (impulseMove * level) : priceB + (impulseMove * level);
            calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
        });

        return {
            swingPoints: { A: priceA, B: priceB },
            type: swing.type,
            levels: calculatedLevels
        };
    }

    function calculateVWAP(klines, period = 20) {
        if (!klines || klines.length < period) return 0;
        let sumPV = 0, sumV = 0;
        const dataSlice = klines.slice(-period);
        dataSlice.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;
    }

    function calculateIchimokuCloud(klines) {
        if (klines.length < 52) return { status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        let tenkan = [], kijun = [];
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= 8 ? getHighLow(klines.slice(i - 8, i + 1)) : {};
            tenkan.push(tenkanHighLow.high ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= 25 ? getHighLow(klines.slice(i - 25, i + 1)) : {};
            kijun.push(kijunHighLow.high ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
        }
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = tenkan[tenkan.length - 1], lastKijun = kijun[kijun.length - 1];
        if (lastTenkan > lastKijun && lastPrice > lastKijun) return { status: "BULLISH" };
        if (lastTenkan < lastKijun && lastPrice < lastKijun) return { status: "BEARISH" };
        return { status: 'Netral' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { status: lastClose > sar ? 'Bullish' : 'Bearish', value: sar };
    }

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateLinearRegressionChannel(closes, period = 14) {
        if (closes.length < period) return { status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return { status: slope > 0 ? 'BULLISH' : 'BEARISH' };
    }

    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A', atrPercent: 0 };
        }
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        const rma = (data, p) => {
            let smoothed = [];
            let sum = 0;
            for(let i=0; i<data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    if (i === p - 1) smoothed.push(sum/p);
                    else smoothed.push(undefined);
                } else if (smoothed[i-1] !== undefined) {
                    smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return smoothed;
        };
        const atrValues = rma(trs, period);
        const atr = atrValues.pop() || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
        let status;
        if (atrPercent > 5) status = 'Very High';
        else if (atrPercent > 2.5) status = 'High';
        else if (atrPercent < 1) status = 'Low';
        else status = 'Normal';
        return { value: atr, status: status, atrPercent: atrPercent }; 
    }

    // FUNGSI BARU (DITERJEMAHKAN DARI PINE SCRIPT "max_min")
    function calculateBuySellPower(klines, period = 100) {
        if (!klines || klines.length < period) {
            return { buyPower: 0, sellPower: 0 };
        }
        
        // Ambil 'period' candle terakhir
        const recentKlines = klines.slice(-period);
        
        let highestHigh = 0;
        let lowestLow = Infinity;

        recentKlines.forEach(k => {
            const high = parseFloat(k[2]);
            const low = parseFloat(k[3]);
            if (high > highestHigh) highestHigh = high;
            if (low < lowestLow) lowestLow = low;
        });

        // Mengembalikan "Tembok" S/R Horizontal Anda
        return {
            buyPower: lowestLow,  // Support (Nearest Major Strong S/R)
            sellPower: highestHigh // Resistance (Nearest Major Strong S/R)
        };
    }

    function startFundingCountdown() {
        setInterval(() => {
            const el = document.getElementById('sentiment-funding-interval');
            if (!el || nextFundingTimestamp === 0) {
                if (el) el.textContent = '--:--:--';
                return;
            }

            const diff = nextFundingTimestamp - Date.now();

            if (diff <= 0) {
                el.textContent = '00:00:00';
                return;
            }

            const hours = Math.floor(diff / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);

            const pad = (num) => num.toString().padStart(2, '0');
            el.textContent = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }, 1000); 
    }

    function updateSentimentDisplay(data) {
        const sentimentPanel = document.getElementById('sentiment-indicators-content');
        if (!sentimentPanel) return;

        const updateEl = (id, value, colorClass = '') => {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = colorClass;
            }
        };

        const psarColor = data.psar === 'Bullish' ? 'positive' : (data.psar === 'Bearish' ? 'negative' : 'text-gray-400');
        updateEl('sentiment-psar', data.psar || '--', psarColor);

        const rocColor = data.roc > 0 ? 'positive' : (data.roc < 0 ? 'negative' : 'text-gray-400');
        updateEl('sentiment-roc', isNaN(data.roc) ? '--' : `${data.roc.toFixed(2)}%`, rocColor);

        const adxColor = data.adx > 25 ? 'positive' : 'text-gray-400'; 
        updateEl('sentiment-adx', isNaN(data.adx) ? '--' : data.adx.toFixed(2), adxColor);

        const atrStatus = data.atr.status;
        let atrColor = 'text-gray-400';
        if (atrStatus === 'High' || atrStatus === 'Very High') atrColor = 'positive';
        if (atrStatus === 'Low' || atrStatus === 'Very Low') atrColor = 'text-yellow-500'; 
        updateEl('sentiment-atr', `${data.atr.atrPercent.toFixed(2)}% (${atrStatus})`, atrColor);

        updateEl('sentiment-ls-global', isNaN(data.lsGlobal) ? '--' : data.lsGlobal.toFixed(4));
        updateEl('sentiment-ls-top', isNaN(data.lsTop) ? '--' : data.lsTop.toFixed(4));

        const fundingRatePercent = data.funding * 100;
        const fundingColor = fundingRatePercent > 0.01 ? 'negative' : (fundingRatePercent < 0 ? 'positive' : 'text-gray-400'); 
        updateEl('sentiment-funding', `${fundingRatePercent.toFixed(4)}%`, fundingColor);

        let oiFormatted = '--';
        if (data.oi > 0) {
            if (data.oi >= 1e9) {
                oiFormatted = `$${(data.oi / 1e9).toFixed(2)}B`;
            } else if (data.oi >= 1e6) {
                oiFormatted = `$${(data.oi / 1e6).toFixed(2)}M`;
            } else {
                oiFormatted = `$${data.oi.toFixed(0)}`;
            }
        }
        updateEl('sentiment-oi', oiFormatted);
    }

    function toggleAftFilterModal(show) {
        const modal = document.getElementById('aft-filter-modal');
        if (modal) {
            modal.classList.toggle('hidden', !show);
            if (show) {
                document.body.style.overflow = 'hidden';
            } else {
                document.body.style.overflow = ''; 
            }
        }
    }

    function fallbackToSimulationMode() {
        if (window.syncInterval) clearInterval(window.syncInterval);
        if (window.liveInterval) clearInterval(window.liveInterval);
        
        binanceApiKeys.key = '';
        binanceApiKeys.secret = '';
        lastUsedApiMode = false;

        document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-yellow-500';
        document.getElementById('api-status-text').textContent = 'View Only/Sim';
        const connectBtnSpan = document.getElementById('connect-api-status-text');
        if (connectBtnSpan) connectBtnSpan.textContent = 'üîå BINANCE';
        
        const startLiveBtn = document.getElementById('start-live-btn');
        if (startLiveBtn) {
            setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START SIM"); 
        }
        console.log("‚úÖ Fallback selesai. System direset ke START SIM.");
    }

    function getUltimateSignalScore(indicator, signalData, currentRegime, allIndicators) { 
        const regime = currentRegime || 'STATIC'; 
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const confidence = (typeof signalData?.confidence === 'number') ? clamp(signalData.confidence, 0, 1) : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const weight = (activeStrategy.weights?.[indicator] || 0);     
        const isBullRegime = regime.includes('BULL');
        const isBearRegime = regime.includes('BEAR');
        const isRangeRegime = regime.includes('RANGING') || regime.includes('LOW_VOLATILITY');
        
        let score = 0;

        if (indicator === 'vwap') {
            if (text.includes('BULLISH')) score = isBullRegime ? 1.0 : 0.5; 
            else if (text.includes('BEARISH')) score = isBearRegime ? -1.0 : -0.5; 
        }
        
        else if (indicator === 'obv') {
            const obvTrend = signalData?.trend;
            const priceStatus = allIndicators?.vwap?.status; 

            if (obvTrend === 'Naik') {
                if (priceStatus === 'BULLISH') score = 1.0; 
                else if (priceStatus === 'BEARISH') score = 0.8; 
            } else if (obvTrend === 'Turun') {
                if (priceStatus === 'BEARISH') score = -1.0; 
                else if (priceStatus === 'BULLISH') score = -0.8; 
            }
        }

        else if (indicator === 'lsRatio') {
            const ratio = parseFloat(signalData.longShortRatio) || 1.0;
            if (ratio > 1.2) score = -0.7; 
            else if (ratio < 0.8) score = 0.7;  
        }

        else if (indicator === 'fundingRate') {
            const rate = parseFloat(signalData.lastFundingRate) || 0;
            if (rate > 0.0005) score = -0.5; 
            else if (rate < -0.0005) score = 0.5; 
        }

        else if (indicator === 'openInterest') {
            const oiStatus = signalData?.status;
            if (oiStatus === 'BULLISH_CONFIRMATION' && isBullRegime) score = 1.0; 
            else if (oiStatus === 'BEARISH_CONFIRMATION' && isBearRegime) score = -1.0; 
            else if (oiStatus === 'SHORT_SQUEEZE' && isBearRegime) score = 0.5;
            else if (oiStatus === 'LONG_SQUEEZE' && isBullRegime) score = -0.5; 
        }

        else if (indicator === 'rsi') {
            const rsiValue = parseFloat(signalData.last) || 50;
            if (isRangeRegime) {
                if (rsiValue > 70) score = -1; 
                else if (rsiValue < 30) score = 1;  
            } else if (isBullRegime) {
                if (rsiValue < 50) score = 0.5; 
                else if (rsiValue > 80) score = -0.5; 
            } else if (isBearRegime) {
                if (rsiValue > 50) score = -0.5; 
                else if (rsiValue < 20) score = 0.5; 
            }
        } 

        else if (indicator === 'stoch') {
            const lastK = allIndicators?.stoch?.kLine?.slice(-1)[0] || 50;
            const lastD = allIndicators?.stoch?.dLine?.slice(-1)[0] || 50;
            const isOversoldExtrem = lastK <= SRSI_ENTRY_LEVEL && lastD <= SRSI_ENTRY_LEVEL; 
            const isOverboughtExtrem = lastK >= (100 - SRSI_ENTRY_LEVEL) && lastD >= (100 - SRSI_ENTRY_LEVEL); 
            const momentumStatus = signalData.momentumStatus;

            if (isOversoldExtrem) {
                score = 3.0; 
            } else if (isOverboughtExtrem) {
                score = -3.0; 
            } 

            else if (momentumStatus === 'BULLISH_MOMENTUM_ABOVE_50') {
                score = 1.5; 
            } else if (momentumStatus === 'BEARISH_MOMENTUM_BELOW_50') {
                score = -1.5; 
            } 
            
            else if (text.includes('OVERSOLD')) {
                score = 2.0; 
            } else if (text.includes('OVERBOUGHT')) {
                score = -2.0;
            }
        }

        else if (indicator === 'bollingerBands') {
            if (signalData.rejection?.includes('Bullish')) score += 1;
            if (signalData.rejection?.includes('Bearish')) score -= 1;
            if (signalData.walkTheBands?.includes('Bullish')) score += 1;
            if (signalData.walkTheBands?.includes('Bearish')) score -= 1;
            
            if (isRangeRegime && (signalData.squeezeStatus === 'Squeeze!' || text.includes('SQUEEZE PRO'))) {
                score += 1.0; 
            }
        }

        else if (indicator === 'candlePattern') {

            if (text.includes('SHOOTING STAR') || text.includes('BEARISH HARAMI')) {
                score = -1.5;
            } else if (text.includes('HAMMER') || text.includes('BULLISH HARAMI')) {
                score = 1.5; 
            } else {

                if (text.includes('BULLISH') && currentRegime !== 'BEAR_TREND') score = 1;
                else if (text.includes('BEARISH') && currentRegime !== 'BULL_TREND') score = -1;
            }
        }

        else if (indicator === 'macd') {
            if (signalData.status === 'Bullish Cross') score = 1;
            else if (signalData.status === 'Bearish Cross') score = -1;
        }
        else if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) score = 1;
            else if (text.includes('BEAR')) score = -1;
        }
        else if (indicator === 'pivot' || indicator === 'psar' || indicator === 'linreg' || indicator === 'roc') {
            if (text.includes('BULL') || text.includes('UP') || text.includes('POSITIVE')) score = 1;
            else if (text.includes('BEAR') || text.includes('DOWN') || text.includes('NEGATIVE')) score = -1;
        }
        else if (text.includes('BULL') || text.includes('UP') || text.includes('POSITIVE') || text.includes('BID')) score = 1;
        else if (text.includes('BEAR') || text.includes('DOWN') || text.includes('NEGATIVE') || text.includes('ASK')) score = -1;

        return clamp(score, -1, 1) * weight * confidence;
    }

    function createTFAlignmentSummary(klines, timeframes, marketType) {
        const summary = {};
        
        let score = 0;
        timeframes.forEach(tf => {
            if (klines[tf] && klines[tf].length >= 200) {
                const closes = klines[tf].map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21);
                const ema89 = calculateEMA(closes, 89);
                const lastEma21 = ema21[ema21.length - 1];
                const lastema89 = ema89[ema89.length - 1];
                summary[tf] = lastEma21 > lastema89 ? 'UPTREND' : 'DOWNTREND';
            } else {
                summary[tf] = 'N/A';
            }
            if (summary[tf] === 'UPTREND') score++;
            else if (summary[tf] === 'DOWNTREND') score--;
        });
        return { summary, score };
    }

    function calculateConfluenceScoreForCandle(activeWeights, indicators, currentRegime) { 
        let totalBullScore = 0; 
        let totalBearScore = 0; 
        let maxPossibleScore = 0;

        for (const indicator in activeWeights) {
            if (indicators[indicator]) {
                const weight = activeWeights[indicator];
                const rawScore = getUltimateSignalScore(indicator, indicators[indicator], currentRegime, indicators);
                const weightedScore = rawScore * weight;
                if (weightedScore > 0) totalBullScore += weightedScore;
                if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                maxPossibleScore += Math.abs(weight);
            }
        }
        const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
        const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;
        return { 
            bull: bullPercentage, 
            bear: bearPercentage,
            totalBullScore: totalBullScore,
            totalBearScore: totalBearScore,
            maxPossibleScore: maxPossibleScore
        };
    }
// =======================
// --- FUNGSI UTAMA AI ---
// =======================
    async function waitForModel() {
        if (regimeSensorModel) return true;
        let attempts = 0;
        while (!regimeSensorModel && attempts < 200) {
            await new Promise(resolve => setTimeout(resolve, 50));
            attempts++;
        }
        return !!regimeSensorModel;
    } 

    function extractLSTMFeatures(klines) {
        const LSTM_LOOKBACK_WINDOW = 10;
        const NUM_FEATURES = 12;

        if (!klines || klines.length < LSTM_LOOKBACK_WINDOW + 20) { 
            console.warn(`[AI PREP] Data tidak cukup untuk ekstraksi fitur LSTM. Perlu > ${LSTM_LOOKBACK_WINDOW + 20}, tersedia: ${klines.length}`);
            return null;
        }

        const sequenceKlines = klines.slice(-LSTM_LOOKBACK_WINDOW);
        const historicalKlines = klines.slice(-(LSTM_LOOKBACK_WINDOW + 20)); 
        const historicalCloses = historicalKlines.map(k => parseFloat(k[4]));
        const historicalHighs = historicalKlines.map(k => parseFloat(k[2]));
        const historicalLows = historicalKlines.map(k => parseFloat(k[3]));
        const historicalVolumes = historicalKlines.map(k => parseFloat(k[5]));
        const RSI_PERIOD = 14; 
        const MACD_FAST = 12, MACD_SLOW = 26, MACD_SIGNAL = 9;
        const EMA_PERIODS = [13, 21, 34, 55, 89, 144];
        const STOCH_RSI_RSI_PERIOD = 9, STOCH_RSI_STOCH_PERIOD = 9, STOCH_RSI_K_SMOOTH = 3, STOCH_RSI_D_SMOOTH = 3;
        const ATR_PERIOD = 14;
        const VOLUME_SPIKE_PERIOD = 20;
        const calculateMultiEMA = (data, periods) => {
            const emas = {};
            periods.forEach(period => {
                emas[period] = calculateEMA(data, period);
            });
            return emas;
        };
        const multiEMAs = calculateMultiEMA(historicalCloses, EMA_PERIODS);
        const rsiValues = calculateRSI(historicalCloses, RSI_PERIOD);
        const macdData = calculateMACD(historicalCloses, MACD_FAST, MACD_SLOW, MACD_SIGNAL);
        const stochRsiData = calculateStochasticRSI(historicalCloses, STOCH_RSI_RSI_PERIOD, STOCH_RSI_STOCH_PERIOD, STOCH_RSI_K_SMOOTH, STOCH_RSI_D_SMOOTH);
        const calculateVolumeSpike = (volumes, period) => {
            const volumeSMA = calculateSMA(volumes, period);
            return volumes.map((v, i) => (volumeSMA[i] > 0) ? (v - volumeSMA[i]) / volumeSMA[i] : 0);
        };
        const calculatePricePosition = (highs, lows, closes) => {
            return closes.map((c, i) => {
                const range = highs[i] - lows[i];
                return (range > 0) ? (c - lows[i]) / range : 0.5;
            });
        };        
        const calculateATRArray = (klines, period) => {
            let trs = [];
            for (let i = 1; i < klines.length; i++) {
                const high = parseFloat(klines[i][2]);
                const low = parseFloat(klines[i][3]);
                const prevClose = parseFloat(klines[i - 1][4]);
                trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
            }
            const rma = (data, p) => {
                let smoothed = [];
                let sum = 0;
                for(let i=0; i<data.length; i++) {
                    if (i < p) {
                        sum += data[i];
                        if (i === p - 1) smoothed.push(sum/p);
                        else smoothed.push(undefined);
                    } else if (smoothed[i-1] !== undefined) {
                        smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                    }
                }
                return smoothed;
            };
            const atrValues = rma(trs, period);
            const lastCloses = klines.map(k => parseFloat(k[4]));
            return atrValues.map((atr, i) => lastCloses[i] > 0 ? (atr / lastCloses[i]) * 100 : 0); // ATR as % of price
        };
        const volumeSpikeValues = calculateVolumeSpike(historicalVolumes, VOLUME_SPIKE_PERIOD);
        const pricePositionValues = calculatePricePosition(historicalHighs, historicalLows, historicalCloses);
        const atrPercentValues = calculateATRArray(historicalKlines, ATR_PERIOD);
        const last10_ATR_Percent = atrPercentValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_Vol_Spike = volumeSpikeValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_Price_Position = pricePositionValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_RSI = rsiValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Hist = macdData.histogram.slice(-LSTM_LOOKBACK_WINDOW).map(h => h?.value);
        const last10_StochK = stochRsiData.kLine.slice(-LSTM_LOOKBACK_WINDOW);

        let sequenceData = [];

        for (let j = 0; j < LSTM_LOOKBACK_WINDOW; j++) {
            const klineForJ = sequenceKlines[j];
            const closeJ = parseFloat(klineForJ[4]);
            const emaDistances = EMA_PERIODS.map(p => {
                const ema_j = multiEMAs[p].slice(-LSTM_LOOKBACK_WINDOW)[j] || closeJ;
                return (ema_j > 0) ? (closeJ - ema_j) / ema_j : 0;
            });
            const rawFeatureArray = [
                ...emaDistances, 
                last10_RSI[j] || 50, 
                last10_StochK[j] || 50, 
                last10_MACD_Hist[j] || 0, 
                last10_ATR_Percent[j] || 0, 
                last10_Vol_Spike[j] || 0, 
                last10_Price_Position[j] || 0.5,
            ].map(v => isFinite(v) ? v : 0);
            const featureArray = rawFeatureArray.map((value, index) => {
                const min = LSTM_NORMALIZATION_PARAMS.min[index];
                const max = LSTM_NORMALIZATION_PARAMS.max[index];
                return minMaxNormalize(value, min, max);
            });

            if (featureArray.length === NUM_FEATURES) {
                sequenceData.push(featureArray);
            }
        }
        if (sequenceData.length === LSTM_LOOKBACK_WINDOW) {
            return sequenceData;
        }
        return null; 
    }

    function minMaxNormalize(value, min, max) {
        if (min === max) {
            return 0.5; 
        }
        const normalized = (value - min) / (max - min);
        return Math.max(0, Math.min(1, normalized)); 
    }

    async function loadRegimeSensorModel() {
        if (regimeSensorModel || typeof tf === 'undefined') {
            const aiStatusEl = document.getElementById('ai-status');
            if (aiStatusEl) aiStatusEl.textContent = 'Auto Switch (No AI)'; 
            return;
        }

        console.log("üß† Memuat Model Sensor Rezim (Final)...");
        try {
            const base64Handler = {
                load: async () => {
                    const modelArtifacts = JSON.parse(MODEL_ARTIFACTS_JSON_STRING);
                    const binaryString = window.atob(WEIGHTS_BASE64_STRING);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const weightData = bytes.buffer;

                    return {
                        modelTopology: modelArtifacts.modelTopology, 
                        weightSpecs: modelArtifacts.weightsManifest[0].weights, 
                        weightData: weightData
                    };
                }
            };

            regimeSensorModel = await tf.loadLayersModel(base64Handler);
            console.log('‚úÖ Model Sensor Rezim berhasil dimuat dan siap bekerja!');

            const aiStatusEl = document.getElementById('ai-status');
            const activeRegimeEl = document.getElementById('active-regime-display');
            const confidenceScoreEl = document.getElementById('regime-confidence-score');

            if (aiStatusEl) aiStatusEl.textContent = 'AI Ready (LSTM TF.js)';
            if (activeRegimeEl) {
                activeRegimeEl.textContent = 'AI STANDBY'; 
                activeRegimeEl.className = 'text-base text-gray-400';
            }
            if (confidenceScoreEl) confidenceScoreEl.textContent = '100.0%'; 

        } catch (error) {
            console.error("‚ùå GAGAL memuat Model Sensor Rezim:", error);
            
            const aiStatusEl = document.getElementById('ai-status');
            if (aiStatusEl) aiStatusEl.textContent = 'ERROR';
            
            regimeSensorModel = null;
        }
    }

    function calculatePredictionInput(klinesSnapshot) {
        if (klinesSnapshot.length < 50 || typeof tf === 'undefined') return null; 
        const featureSequence = extractLSTMFeatures(klinesSnapshot);
        if (!featureSequence) return null;
        return featureSequence; 
    }

    async function predictMarketRegime(klinesSnapshot) {
        const featureSequence = calculatePredictionInput(klinesSnapshot);
        const LSTM_LOOKBACK_WINDOW = 10;
        const NUM_FEATURES = 12;

        if (!regimeSensorModel || !featureSequence || featureSequence.length !== LSTM_LOOKBACK_WINDOW) {
            return { label: 'RANGING', confidence: 0.5 }; 
        }
        return tf.tidy(() => {
            const inputTensor = tf.tensor3d([featureSequence], [1, LSTM_LOOKBACK_WINDOW, NUM_FEATURES]);
            const prediction = regimeSensorModel.predict(inputTensor);
            const predictionData = prediction.dataSync();
            const predictedClassIndex = prediction.argMax(-1).dataSync()[0];
            const predictedLabel = REGIME_LABELS[predictedClassIndex];
            const highestProbability = predictionData[predictedClassIndex];

            return { 
                label: predictedLabel || 'RANGING',
                confidence: highestProbability || 0.5
            };
        });
    }
    
    function getRegimeColorClass(key) {
        switch(key) {
            case 'BULL_TREND': return 'text-base text-green-400';
            case 'BEAR_TREND': return 'text-base text-red-400';
            case 'RANGING': return 'text-base text-yellow-400';
            case 'LOW_VOLATILITY': return 'text-base text-blue-400';
            default: return 'text-base text-gray-500';
        }
    }
// ======================================================
    function toggleAssetInputs(enabled) {
        const symbolInput = document.getElementById('live-symbol-input');
        const timeframeSelect = document.getElementById('live-timeframe-select');
        
        if (symbolInput) symbolInput.disabled = !enabled;
        if (timeframeSelect) timeframeSelect.disabled = !enabled;
        if (symbolInput) symbolInput.classList.toggle('opacity-50', !enabled);
        if (timeframeSelect) timeframeSelect.classList.toggle('opacity-50', !enabled);
    }

    function toggleFibView(event) {
        event.stopPropagation();
        isFibRetracementVisible = !isFibRetracementVisible;
        if (realtimeCache.main.latestScalpingSetup) {
            displayLiveSignal(realtimeCache.main.latestScalpingSetup);
        }
    }

    function formatDollar(amount, symbol) {
        if (amount === null || isNaN(amount)) return '$0.00';
        return formatPrice(amount, symbol); 
    }

    function toggleAftFilterModal(show) {
        const modal = document.getElementById('aft-filter-modal');
        if (modal) {
            modal.classList.toggle('hidden', !show);
        }
    }

    function getAftAllowedStrategies() {
        const checkedBoxes = document.querySelectorAll('.aft-strategy-filter:checked');
        return Array.from(checkedBoxes).map(box => box.value);
    }

    async function syncAccountViaProxy() {
        const proxyUrl = 'http://localhost:3000'; 
        console.log(`‚öôÔ∏è Menggunakan Proxy: Meminta status akun dari ${proxyUrl}/sync-futures-account`);
        
        try {
            const response = await fetch(`${proxyUrl}/sync-futures-account`); 
            
            if (!response.ok) {
                console.error("‚ùå Proxy Down atau Error (Cek Terminal Node.js Anda)");
                throw new Error(`Proxy Error: ${response.statusText}`);
            }
            
            const accountData = await response.json();
            return accountData;
        } catch (error) {
            console.error("‚ùå GAGAL MENGIRIM PERMINTAAN SYNC KE PROXY:", error);
            throw new Error("Gagal terhubung ke server Proxy lokal (Cek Terminal Node.js Anda).");
        }
    }

    async function sendBinanceRequest(method, endpoint, isSigned = true, params = {}) {
        const proxyUrl = 'http://localhost:3000'; 
        if (method === 'GET' && (endpoint === '/account' || endpoint === '/positionRisk')) {
             console.log(`‚öôÔ∏è Proxy GET: Meminta status akun dari ${proxyUrl}/sync-futures-account`);
             const response = await fetch(`${proxyUrl}/sync-futures-account`);
             
             if (!response.ok) {
                 console.error("‚ùå Proxy Down atau Error (GET SYNC):", response.statusText);
                 throw new Error(`Proxy Error: ${response.statusText}`);
             }
             const accountData = await response.json();

             if (endpoint === '/account') return accountData;
             if (endpoint === '/positionRisk') {
                 return accountData.positions.map(pos => ({
                     symbol: pos.symbol, entryPrice: parseFloat(pos.entryPrice),
                     positionAmt: parseFloat(pos.positionAmt), unrealizedProfit: parseFloat(pos.unrealizedProfit),
                     liquidationPrice: parseFloat(pos.liquidationPrice),
                 })).filter(pos => parseFloat(pos.positionAmt) !== 0);
             }
        }

        console.log(`üåê PROXY ${method}: Mengirim permintaan ke ${proxyUrl}/proxy-request...`);

        const fetchOptions = {
            method: 'POST', 
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                method: method, 
                endpoint: endpoint, 
                params: params,
                isSigned: isSigned 
            })
        };

        try {
            const response = await fetch(`${proxyUrl}/proxy-request`, fetchOptions);
            const responseData = await response.json();
            
            if (!response.ok || responseData.code < 0) {
                console.error(`‚ùå GAGAL EKSEKUSI ${method} ${endpoint} PROXY:`, responseData);
                throw new Error(`Proxy Request Gagal: ${responseData.msg || response.statusText}`);
            }
            
            return responseData; 

        } catch (error) {
            console.error("‚ùå GAGAL TERHUBUNG/EKSEKUSI PERMINTAAN PROXY:", error.message);
            throw new Error(`Koneksi Proxy Gagal: ${error.message}`);
        }
    }

    async function switchChartTimeframe(newTimeframe) {
        if (newTimeframe === currentChartTimeframe) return; 
        const symbol = liveSymbolInput.value.toUpperCase();
        currentChartTimeframe = newTimeframe; 
        chartsWrapper.style.opacity = '0.3';
        if (liveWebSocket) liveWebSocket.close();
        liveData = [];
        destroyCharts();
        await fetchInitialData(symbol, newTimeframe);
        connectToBinance(symbol, newTimeframe);
        renderAllCharts();
        chartsWrapper.style.opacity = '1';
    }

    async function initializePrecisionMap() {
        try {
            const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            const data = await response.json();
            
            data.symbols.forEach(symbolInfo => {
                const priceFilter = symbolInfo.filters.find(f => f.filterType === 'PRICE_FILTER');
                if (priceFilter && priceFilter.tickSize) {
                    const tickSize = parseFloat(priceFilter.tickSize);
                    if (tickSize > 0) {
                        precisionMap[symbolInfo.symbol] = Math.round(-Math.log10(tickSize));
                    } else {
                        precisionMap[symbolInfo.symbol] = 0;
                    }
                }
            });
        } catch (error) {
            console.error("Gagal membuat database presisi, akan menggunakan format default:", error);
        }
    }

    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }

    async function fetchInitialData(symbol, interval) {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=500`;
        const response = await fetch(url);
        liveData = await response.json();
    }

    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'spot') {
        const baseUrl = marketType === 'futures' ? 'https://fapi.binance.com/fapi/v1' : 'https://api.binance.com/api/v3';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = `Binance API error for ${endpoint} (${marketType}): ${errorData.msg || response.statusText}`;
                throw new Error(errorMessage);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from ${url}: ${error.message}`);
            throw new Error(`Gagal mengambil data untuk ${endpoint} dari Binance ${marketType.toUpperCase()}.`);
        }
    }

    async function fetchFuturesSymbols() {
        const datalist = document.getElementById('future-symbols');
        if (!datalist) return;

        try {
            console.log("Memuat daftar simbol Binance Futures untuk auto-suggest...");
            const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            if (!response.ok) throw new Error("Gagal mengambil data exchange info.");
            
            const data = await response.json();
            const symbols = data.symbols
                .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
                .map(s => s.symbol);
            datalist.innerHTML = symbols.map(symbol => 
                `<option value="${symbol}">`
            ).join('');
            
            console.log(`‚úÖ ${symbols.length} simbol Futures berhasil dimuat untuk auto-suggest.`);
        } catch (error) {
            console.error("‚ùå Gagal memuat daftar simbol Futures:", error);
        }
    }

    async function checkBinanceLatency() {
        const latencyDisplay = document.getElementById('ping-latency-display');
        if (!latencyDisplay) return;

        try {
            const startTime = performance.now();
            await fetch('https://fapi.binance.com/fapi/v1/ping');
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);

            latencyDisplay.textContent = ` ${latency} ms`;
            if (latency < 150) {
                latencyDisplay.className = 'positive'; 
            } else if (latency < 200) {
                latencyDisplay.className = 'text-yellow-400';
            } else {
                latencyDisplay.className = 'negative'; 
            }
        } catch (error) {
            latencyDisplay.textContent = 'Ping: Error';
            latencyDisplay.className = 'negative';
        }
    }

    async function updateHtfCompass(timeframe) {
        const resultEl = document.getElementById('htf-compass-result');
        const symbol = liveSymbolInput.value.toUpperCase();
        if (!symbol) return;

        resultEl.textContent = `Menganalisis VWAP ${timeframe}...`;
        resultEl.className = 'text-center mt-2 text-sm text-yellow-500';

        try {
            const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: 100 }, 'futures');
            if (!klines || klines.length < 20) throw new Error("Data HTF tidak cukup untuk VWAP");

            const htfVwap = calculateVWAP(klines, klines.length); 
            const currentPrice = currentMarketPrice;

            if (currentPrice > htfVwap) {
                resultEl.textContent = `‚ñ≤ Di atas VWAP ${timeframe}`;
                resultEl.className = 'text-center mt-2 text-sm positive';
                htfTrend = 'UPTREND'; 
            } else {
                resultEl.textContent = `‚ñº Di bawah VWAP ${timeframe}`;
                resultEl.className = 'text-center mt-2 text-sm negative';
                htfTrend = 'DOWNTREND'; 
            }
        } catch (error) {
            console.error(`Gagal update kompas HTF untuk ${timeframe}:`, error);
            resultEl.textContent = `Error (${timeframe})`;
            resultEl.className = 'text-center mt-2 text-sm negative';
            htfTrend = 'NEUTRAL'; 
        }
    }

    async function updateMarketStructurePanel(symbol, timeframe) {
        const resistanceEl = document.getElementById('htf-resistance-price');
        const supportEl = document.getElementById('htf-support-price');

        if (!resistanceEl || !supportEl) return;

       try {
            const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: 100 }, 'futures');
            if (klines.length < 20) {
                resistanceEl.textContent = 'N/A';
                supportEl.textContent = 'N/A';
                return;
            }

            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));

            const significantHigh = Math.max(...highs);
            const significantLow = Math.min(...lows);

            resistanceEl.textContent = formatPrice(significantHigh, symbol);
            supportEl.textContent = formatPrice(significantLow, symbol);

        } catch (error) {
            console.error("Gagal update Market Structure:", error);
            resistanceEl.textContent = 'Error';
            supportEl.textContent = 'Error';
        }
    }

    function getChartBaseOptions(height) {
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 32,
            height: height,
            layout: { background: { color: '#151414' }, textColor: '#E0E0E0' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: 'rgba(255, 255, 255, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                borderColor: '#4B5563',
                rightOffset: 10,
            },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: { borderColor: '#4B5563' }
        };
    }

    function destroyCharts() {
        charts.forEach(chart => { if (chart) chart.remove(); });
        charts = [];
        candlestickSeries = null;
        ['main-chart-container', 'volume-chart-container', 'rsi-chart-container', 'stoch-chart-container', 'macd-chart-container'].forEach(id => {
            const container = document.getElementById(id);
            if (container) container.innerHTML = '';
        });
    }

    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if (!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (otherChart && chart !== otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }

    function renderAllCharts() {
        if (!liveData || liveData.length < 50) return;       
        destroyCharts();

        const formattedKlines = liveData.map(d => ({ 
            time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]), 
            low: parseFloat(d[3]), close: parseFloat(d[4]) 
        }));        
        const closes = formattedKlines.map(k => k.close);
        const ema21Data = calculateEMA(closes, 21).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
        const ema89Data = calculateEMA(closes, 89).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
        const volumeData = liveData.map(d => ({ 
            time: d[0] / 1000, value: parseFloat(d[5]), 
            color: parseFloat(d[4]) >= parseFloat(d[1]) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' 
        }));
        const rsiValues = calculateRSI(closes, 14);
        const stochRsiData = calculateStochasticRSI(closes, 9, 9, 3, 3);
        const macdData = calculateMACD(closes);
        const alignData = (dataArray) => {
            if (!dataArray || dataArray.length === 0) return [];
            const offset = formattedKlines.length - dataArray.length;
            return dataArray.map((value, index) => {
                const kline = formattedKlines[index + offset];
                if (kline && value !== undefined) {
                    return { time: kline.time, value };
                }
                return null;
            }).filter(Boolean);
        };
        const macdLineData = alignData(macdData.macdLine);
        const signalLineData = alignData(macdData.signalLine);
        const histogramData = macdData.histogram.map((item, index) => {
            const offset = formattedKlines.length - macdData.histogram.length;
            const kline = formattedKlines[index + offset];
            if (kline && item !== undefined) {
                return { time: kline.time, value: item.value, color: item.color };
            }
            return null;
        }).filter(Boolean);

        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);
        candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false });
        candlestickSeries.setData(formattedKlines);
        ema21Series = mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false });
        ema21Series.setData(ema21Data);
        ema89Series = mainChart.addLineSeries({ color: '#FF6D00', lineWidth: 1, priceLineVisible: false });
        ema89Series.setData(ema89Data);

        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
        charts.push(volumeChart);
        volumeSeries = volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } });
        volumeSeries.setData(volumeData);

        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(120));
        charts.push(rsiChart);
        rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 });
        rsiSeries.setData(alignData(rsiValues));

        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(120));
        charts.push(stochChart);
        stochKSeries = stochChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: '%K' });
        stochKSeries.setData(alignData(stochRsiData.kLine));
        stochDSeries = stochChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: '%D' });
        stochDSeries.setData(alignData(stochRsiData.dLine));

        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(120));
        charts.push(macdChart);
        macdHistSeries = macdChart.addHistogramSeries({ base: 0 });
        macdHistSeries.setData(histogramData);
        macdLineSeries = macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceLineVisible: false });
        macdLineSeries.setData(macdLineData);
        signalLineSeries = macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceLineVisible: false });
        signalLineSeries.setData(signalLineData);

        syncCharts(...charts);
    }

    function updateAllCharts(newKline) {
        if (!isChartsVisible || !candlestickSeries) return;
        const formattedKline = { time: newKline.t / 1000, open: parseFloat(newKline.o), high: parseFloat(newKline.h), low: parseFloat(newKline.l), close: parseFloat(newKline.c) };
        candlestickSeries.update(formattedKline);
        if (volumeSeries) {
            volumeSeries.update({ time: formattedKline.time, value: parseFloat(newKline.v), color: parseFloat(newKline.c) >= parseFloat(newKline.o) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' });
        }
        const closes = liveData.map(k => parseFloat(k[4]));
        if (rsiSeries) {
            rsiSeries.update({ time: formattedKline.time, value: calculateRSI(closes, 14).pop() });
        }
        if (stochKSeries && stochDSeries) {
            const stochData = calculateStochasticRSI(closes, 9, 9, 3, 3); 
            stochKSeries.update({ time: formattedKline.time, value: stochData.kLine.pop() });
            stochDSeries.update({ time: formattedKline.time, value: stochData.dLine.pop() });
        }
        if (macdLineSeries && signalLineSeries && macdHistSeries) {
            const macdData = calculateMACD(closes);
            const lastHist = macdData.histogram.pop();
            macdLineSeries.update({ time: formattedKline.time, value: macdData.macdLine.pop() });
            signalLineSeries.update({ time: formattedKline.time, value: macdData.signalLine.pop() });
            if(lastHist) {
                macdHistSeries.update({ time: formattedKline.time, value: lastHist.value, color: lastHist.color });
            }
        }
        if(ema21Series) {
             ema21Series.update({ time: formattedKline.time, value: calculateEMA(closes, 21).pop() });
        }
        if(ema89Series) {
             ema89Series.update({ time: formattedKline.time, value: calculateEMA(closes, 50).pop() });
        }
    }

    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        const chartsWrapper = document.getElementById('charts-wrapper');
        const toggleBtn = document.getElementById('toggle-charts-btn');
        
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleBtn.textContent = 'HIDE CHART';
            renderAllCharts();
        } else {
            chartsWrapper.style.display = 'none';
            toggleBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }

    async function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }
        activeDnaFilename = file.name;
        
        const reader = new FileReader();
        reader.onload = async function(e) { 
            try {
                const dnaData = JSON.parse(e.target.result);
                const symbolInput = document.getElementById('live-symbol-input');
                const timeframeSelect = document.getElementById('live-timeframe-select');
                const importedSinyalPanel = document.getElementById('imported-sinyal-panel');
                
                importedSinyalPanel.innerHTML = ''; 

                if (!dnaData.metadata || !dnaData.parameters || !dnaData.weights) {
                    importedSinyalPanel.innerHTML = `<p class="text-center text-sm negative">‚ùå Format file DNA tidak valid. Pastikan file diekspor dari Genesis Engine.</p>`;
                    return;
                }
        
                const dnaType = dnaData.metadata.dnaType || 'Static_v1';

                activeStrategy.metadata = dnaData.metadata;
                activeStrategy.parameters = dnaData.parameters;
                
                if (dnaType.startsWith('AutoSwitch')) {
                    activeStrategy.dnaType = 'AutoSwitch_v1';
                    activeStrategy.autoWeights = dnaData.weights;
                    activeStrategy.weights = dnaData.weights.RANGING 
                                            || dnaData.weights.BULL_TREND 
                                            || userSettings.presets.default.weights;

                    document.getElementById('dna-status-display').textContent = `DNA: AutoSwitch (${dnaData.metadata.sourceAsset} ${dnaData.metadata.sourceTimeframe})`;
                    document.getElementById('current-regime-status-container').classList.remove('hidden'); 
                    await loadRegimeSensorModel(); 

                    alert(`‚úÖ DNA AutoSwitch_v1 dari ${dnaData.metadata.sourceAsset} berhasil dimuat. Dashboard beroperasi dalam mode adaptif.`);

                } else {
                    const { sourceAsset, sourceTimeframe } = dnaData.metadata;
                    activeStrategy.dnaType = 'Static_v1';
                    activeStrategy.weights = dnaData.weights; 
                    activeStrategy.autoWeights = null;
                    
                    symbolInput.value = sourceAsset ? sourceAsset.toUpperCase() : symbolInput.value;
                    timeframeSelect.value = sourceTimeframe || timeframeSelect.value;
                    
                    document.getElementById('dna-status-display').textContent = `DNA: Static (${sourceAsset} ${sourceTimeframe || 'N/A'})`;
                    document.getElementById('current-regime-status-container').classList.add('hidden');

                    alert(`‚úÖ DNA Strategi Statis (Static) berhasil dimuat.`);
                }

                displayImportedStrategy(); 
                document.getElementById('live-data-input-section').classList.remove('hidden');
                document.getElementById('weather-forecast-section').classList.remove('hidden');
        
                const importContentWrapper = document.getElementById('import-content-wrapper');
                if (importContentWrapper && importContentWrapper.classList.contains('expanded')) {
                    importContentWrapper.classList.remove('expanded');
                    document.getElementById('toggle-import-icon').style.transform = 'rotate(-90deg)';
                }

            } catch (error) {
                importedSinyalPanel.innerHTML = `<p class="text-center text-sm negative">‚ùå Terjadi kesalahan memproses: ${error.message}</p>`;
                console.error("Error parsing DNA JSON (Handle Import):", error);
            }
        };
        reader.readAsText(file);
    }

    function displayImportedStrategy() {
        const strategyData = activeStrategy;
        if (!strategyData || !strategyData.metadata || !strategyData.parameters) {
            importedSinyalPanel.innerHTML = `<p class="text-center text-sm text-gray-400">Gagal memuat strategi. (Data State tidak lengkap)</p>`;
            return;
        }
        const getSafeParam = (obj, key, fallback = 'N/A') => {
            const val = obj[key];
            if (typeof val === 'number') return val.toFixed(2);
            return val || fallback;
        };
        
        const getSafeWeight = (weights, key, fallback = 0.0) => {
            const val = weights[key];
            if (typeof val === 'number') return val.toFixed(2);
            return fallback.toFixed(2);
        };

        const paramHtml = `
            <p class="mt-2">Parameter Strategi</p>
            <p class="font-mono text-xs">
                R:R Ratio: ${getSafeParam(strategyData.parameters, 'riskRewardRatio')} | 
                EMA: ${getSafeParam(strategyData.parameters, 'pullbackEmaPeriod', 'N/A')} | 
                Bias: ${getSafeParam(strategyData.parameters, 'biasThreshold', 'N/A')} |
                ATR Filter: ${getSafeParam(strategyData.parameters, 'atrFilterThreshold', 'N/A')}
            </p>
        `;

        let weightsDetailHtml = '';
        const isAutoSwitch = strategyData.dnaType === 'AutoSwitch_v1' && strategyData.autoWeights;

        if (isAutoSwitch) {
            const regimes = Object.keys(strategyData.autoWeights);
            
            weightsDetailHtml = `
                <p class="mt-4 text-purple-400">Bobot Dinamis (AutoSwitch - ${regimes.length} Rezim):</p>
                <div class="grid grid-cols-2 gap-2 mt-2 text-xs font-mono">
            `;
            
            regimes.forEach(regimeKey => {
                const weights = strategyData.autoWeights[regimeKey]?.weights || {};
                const isCorrupt = typeof weights.ma === 'undefined';

                weightsDetailHtml += `
                    <div class="p-2 rounded-md ${isCorrupt ? 'bg-red-900/50' : 'bg-gray-900/50'}">
                        <p class="${isCorrupt ? 'text-red-500' : 'text-yellow-400'}">${regimeKey.replace('_', ' ')}</p>
                        <ul class="text-gray-400 mt-1 space-y-0.5">
                            <li>MA: ${getSafeWeight(weights, 'ma')}</li>
                            <li>RSI Div: ${getSafeWeight(weights, 'rsiDivergence')}</li>
                            <li>MACD: ${getSafeWeight(weights, 'macd')}</li>
                            <li>BB Squeeze: ${getSafeWeight(weights, 'bbSqueeze')}</li>
                        </ul>
                    </div>
                `;
            });

            weightsDetailHtml += `</div>`;
            
        } else {
            const weights = strategyData.weights || {};
            weightsDetailHtml = `
                <p class="mt-4">Bobot Statis:</p>
                <ul class="text-xs font-mono space-y-1 mt-2">
                    <li>MA: ${getSafeWeight(weights, 'ma')}</li>
                    <li>RSI Divergence: ${getSafeWeight(weights, 'rsiDivergence')}</li>
                    <li>MACD: ${getSafeWeight(weights, 'macd')}</li>
                    <li>Pivot: ${getSafeWeight(weights, 'pivot')}</li>
                    <li>VWAP: ${getSafeWeight(weights, 'vwap')}</li>
                    <li>Ichimoku: ${getSafeWeight(weights, 'ichimoku')}</li>
                    <li>Candle Pattern: ${getSafeWeight(weights, 'candlePattern')}</li>
                    <li>BB Squeeze: ${getSafeWeight(weights, 'bbSqueeze')}</li>
                    <li>PSAR: ${getSafeWeight(weights, 'psar')}</li>
                </ul>
            `;
        }

        importedSinyalPanel.innerHTML = `
            <div class="mt-2 text-center">
                <p class="">Metadata Strategi</p>
                <p class="font-mono text-xs">
                    Tipe DNA: ${strategyData.metadata.dnaType} |
                    Aset: ${strategyData.metadata.sourceAsset || 'N/A'} |
                    Timeframe: ${strategyData.metadata.sourceTimeframe || 'N/A'}
                </p>
                
                ${paramHtml}
                ${weightsDetailHtml}

                <p class="text-gray-400 text-xs mt-4">Strategi diimpor berhasil. Dashboard siap beradaptasi.</p>
            </div>
        `;
    }

    function connectToBinance(symbol, interval) {
        if (liveWebSocket) {
            liveWebSocket.close();
        }
        const baseUrl = 'wss://fstream.binance.com';
        const wsUrl = `${baseUrl}/ws/${symbol.toLowerCase()}@kline_${interval}`;
  
        liveWebSocket = new WebSocket(wsUrl);
        liveWebSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.k) {
                updateLiveKlines(message.k);
            }
        };
        liveWebSocket.onclose = () => {
            setTimeout(() => connectToBinance(symbol, interval), 2500);
        };

        liveWebSocket.onerror = (error) => {
            console.error("WebSocket Error:", error);
        };
    }

    function connectToOrderFlow(symbol) {
        if (orderFlowSocket) {
            orderFlowSocket.close();
        }
        const baseUrl = 'wss://fstream.binance.com';
        const wsUrl = `${baseUrl}/ws/${symbol.toLowerCase()}@depth5@100ms`;
        orderFlowSocket = new WebSocket(wsUrl);
        orderFlowSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            updateOrderFlowPanel(message); 
        };
        orderFlowSocket.onclose = () => {
            setTimeout(() => connectToOrderFlow(symbol), 2500);
        };

        orderFlowSocket.onerror = (error) => {
            console.error("Order Flow WebSocket Error:", error);
        };
    }

    function updateOrderFlowPanel(message) {
        const barElement = document.getElementById('order-flow-bar');
        const textElement = document.getElementById('order-flow-text');

        if (!barElement || !textElement || !message.b || !message.a) {
            return; 
        }

        const bids = message.b;
        const asks = message.a;

        let currentBidVolume = 0;
        for (let i = 0; i < bids.length; i++) {
            currentBidVolume += parseFloat(bids[i][1]); 
        }

        let currentAskVolume = 0;
        for (let i = 0; i < asks.length; i++) {
            currentAskVolume += parseFloat(asks[i][1]);
        }

        orderBookHistory.avgVolumes.push({ bids: currentBidVolume, asks: currentAskVolume });
        if (orderBookHistory.avgVolumes.length > orderBookHistory.maxSize) {
            orderBookHistory.avgVolumes.shift();
        }

        const totalHistory = orderBookHistory.avgVolumes.reduce((acc, val) => {
            acc.bids += val.bids;
            acc.asks += val.asks;
            return acc;
        }, { bids: 0, asks: 0 });
        const avgBidVolume = totalHistory.bids / orderBookHistory.avgVolumes.length;
        const avgAskVolume = totalHistory.asks / orderBookHistory.avgVolumes.length;
        const totalAvgVolume = avgBidVolume + avgAskVolume;
        if (totalAvgVolume === 0) return;

        const bidDominancePercent = (avgBidVolume / totalAvgVolume) * 100;
        const askDominancePercent = 100 - bidDominancePercent;

        barElement.style.width = `${bidDominancePercent.toFixed(2)}%`;
        textElement.textContent = `${bidDominancePercent.toFixed(0)}% | ${askDominancePercent.toFixed(0)}%`;
    }

    function updateLiveKlines(newKline) {
        currentMarketPrice = parseFloat(newKline.c);
        const currentBiasStatus = realtimeCache.main.latestScalpingSetup?.bias.status || 'NEUTRAL';
        const isCurrentSignalActive = !currentBiasStatus.includes('NEUTRAL');
        
        const currentType = currentBiasStatus.includes('LONG') ? 'LONG' : (currentBiasStatus.includes('SHORT') ? 'SHORT' : 'NEUTRAL');
        
        if (isCurrentSignalActive && signalActiveStartTime === null) {
            signalActiveStartTime = Date.now();
            lastStableSignal = currentType; 
            console.log(`üìä [Signal Log] Sinyal ${currentType} dimulai.`);
        } else if (!isCurrentSignalActive && signalActiveStartTime !== null && lastStableSignal !== 'NEUTRAL') {
            const durationMs = Date.now() - signalActiveStartTime;
            if (durationMs > 1000) { 
                logSignalCycle(lastStableSignal, durationMs / 1000, currentBiasStatus, 'Netralisasi');
            }
            signalActiveStartTime = null; 
            lastStableSignal = 'NEUTRAL';
        } else if (isCurrentSignalActive && signalActiveStartTime !== null) {
            const lastType = lastStableSignal; 
            const isActualReversal = (lastType === 'LONG' && currentType === 'SHORT') || (lastType === 'SHORT' && currentType === 'LONG');

            if (isActualReversal) {
                const durationMs = Date.now() - signalActiveStartTime;
                if (durationMs > 1000) {
                    logSignalCycle(lastStableSignal, durationMs / 1000, currentBiasStatus, 'Sinyal Balik');
                }

                signalActiveStartTime = Date.now();
                lastStableSignal = currentType;
                console.log(`üìä [Signal Log] Sinyal ${currentType} dimulai (setelah Reversal).`);
            } 
        }

        if (liveData.length > 0 && liveData[liveData.length - 1][0] === newKline.t) {
            liveData[liveData.length - 1] = [newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T];
            realtimeCache.main.klines[realtimeCache.main.klines.length - 1] = [newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T, newKline.q, newKline.n, newKline.V, newKline.Q, newKline.B];
        } else {
            liveData.push([newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T]);
            realtimeCache.main.klines.push([newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T, newKline.q, newKline.n, newKline.V, newKline.Q, newKline.B]);
            if (liveData.length > 500) liveData.shift();
            if (realtimeCache.main.klines.length > 500) realtimeCache.main.klines.shift();
        }
        updateAllCharts(newKline);
        if(realtimeCache.main.tickerData) {
            realtimeCache.main.tickerData.lastPrice = currentMarketPrice.toString();
        }
        const livePriceDisplay = document.getElementById('live-price-display');
        if (livePriceDisplay) {
            livePriceDisplay.textContent = formatPrice(currentMarketPrice, realtimeCache.main.symbol);
        }
        const marketPriceInput = tsCalcElements.marketPrice;
        const formattedPrice = formatPrice(currentMarketPrice, realtimeCache.main.symbol); 
        if (document.activeElement !== marketPriceInput) {
            marketPriceInput.value = formattedPrice.replace('$', ''); 
        }
    }

    function logSignalCycle(type, durationSeconds, endState, endReason) {
        const filename = activeDnaFilename;
        if (!signalLogState.statsByDnaFile[filename]) {
            signalLogState.statsByDnaFile[filename] = { totalCycles: 0, longCount: 0, shortCount: 0, durations: [], history: [] };
        }
        
        const stats = signalLogState.statsByDnaFile[filename];
        stats.totalCycles++;
        if (type === 'LONG') stats.longCount++;
        if (type === 'SHORT') stats.shortCount++;
        stats.durations.push(durationSeconds);

        const logEntry = {
            type: type,
            duration: durationSeconds.toFixed(1),
            endState: endState,
            endReason: endReason,
            timestamp: new Date().toLocaleTimeString()
        };
        stats.history.unshift(logEntry);
        
        if (stats.history.length > 50) stats.history.pop(); 
        console.log(`‚úÖ [AFT Log] ${type} selesai. Durasi: ${durationSeconds.toFixed(1)}s. Alasan: ${endReason}.`);
    }
    
    function displayLiveSignal(signalData) {
        realtimeCache.main.latestScalpingSetup = signalData;
        const symbol = document.getElementById('live-symbol-input').value.toUpperCase();
        const { bias, scores, entry, sl, tp1, tp2, tp3 } = signalData;
        const newSignalState = bias.status;
        const biasColor = newSignalState.includes('LONG') ? 'positive' : (newSignalState.includes('SHORT') ? 'negative' : 'text-gray-400');
        const isCurrentlyActive = !newSignalState.includes('NEUTRAL');

        if (newSignalState !== lastStableSignal) {
            if (isCurrentlyActive) { signalStartTime = Date.now(); } else { signalStartTime = null; }
            lastStableSignal = newSignalState;
        }

        if (timeElapsedInterval) { clearInterval(timeElapsedInterval); timeElapsedInterval = null; }
        const updateTimerDisplay = () => { 
            const el = document.getElementById('signal-time-elapsed'); 
            if (el && signalStartTime) { el.textContent = `Aktif sejak: ${formatTimeElapsed(Date.now() - signalStartTime)}`; } 
        };
        if (isCurrentlyActive) { timeElapsedInterval = setInterval(updateTimerDisplay, 1000); }

        const bullVal = scores?.bull || 0;
        const bearVal = scores?.bear || 0;
        const totalConfluence = bullVal + bearVal;
        const bullPercent = totalConfluence > 0 ? (bullVal / totalConfluence) * 100 : 50;
        const bearPercent = 100 - bullPercent;

        let bullColor = bullVal > bearVal ? '#2ebd85' : '#80cbc4';
        let bearColor = bearVal > bullVal ? '#f6465d' : '#e57373';
        let bullTextColor = bullVal > bearVal ? 'text-black' : 'text-gray-900/70';
        let bearTextColor = bearVal > bullVal ? 'text-white' : 'text-gray-200/70';

        if (bullVal + bearVal < activeStrategy.parameters.biasThreshold) {
            bullColor = '#4b5563';
            bearColor = '#374151';
            bullTextColor = 'text-gray-200/70';
            bearTextColor = 'text-gray-200/70';
        }

        const closes = liveData.map(k => parseFloat(k[4]));
        const ema21 = calculateEMA(closes, 21).pop() || 0;
        const ema89 = calculateEMA(closes, 89).pop() || 0;
        const emaStatus = ema21 > ema89 ? 'Strong Uptrend' : (ema89 > ema21 ? 'Strong Downtrend' : 'Netral');
        const emaClass = emaStatus.includes('Uptrend') ? 'positive' : (emaStatus.includes('Downtrend') ? 'negative' : 'text-gray-400');
        const candleResult = findCandlestickPatterns(liveData);
        const emaStatusDisplay = document.getElementById('ema-status-display');
        const emaValuesDisplay = document.getElementById('ema-values-display');
        const candlestickSvgContainer = document.getElementById('candlestick-svg-container');
        const candlestickPatternDisplay = document.getElementById('candlestick-pattern-display');

        if (emaStatusDisplay) {
            emaStatusDisplay.textContent = emaStatus;
            emaStatusDisplay.className = `font-mono text-sm font-semibold ${emaClass}`;
        }
        if (emaValuesDisplay) {
            emaValuesDisplay.textContent = `21:${formatPrice(ema21, symbol)} / 89:${formatPrice(ema89, symbol)}`;
        }
        if (candlestickSvgContainer) {
            candlestickSvgContainer.innerHTML = candleResult.svg;
        }
        if (candlestickPatternDisplay) {
            candlestickPatternDisplay.textContent = `${candleResult.pattern} (${candleResult.bias.toUpperCase()})`;
            candlestickPatternDisplay.className = `text-xs font-semibold ${candleResult.bias.includes('BULLISH') ? 'positive' : (candleResult.bias.includes('BEARISH') ? 'negative' : 'text-gray-400')}`;
        }

        document.getElementById('live-signal-content').innerHTML = `
            <div class="space-y-4">
                <div class="text-center">
                    <p class="text-xl font-semibold ${biasColor} mb-1">${lastStableSignal}</p> 
                    <p class="text-sm text-gray-400"></p>
                        <div class="flex justify-center items-center font-mono text-sm border-b border-gray-700/50 pb-2 mb-2 pt-2">
                            <span class="text-gray-500 mr-2">Stoch %K:</span>
                            <span id="stoch-k-value" class="text-white font-semibold">--</span>
                            <span class="text-gray-500 mx-4">||</span>
                            <span class="text-gray-500 mr-2">Stoch %D:</span>
                            <span id="stoch-d-value" class="text-white font-semibold">--</span>
                        </div>
                        <p id="stoch-momentum-display" class="text-center text-xs font-mono text-gray-500 mt-2">Momentum: --</p>
                    <div class="my-3 px-2">
                        <div class="flex justify-between items-center text-xs font-mono mb-1">
                            <span class="text-lg positive">${bullVal.toFixed(1)}</span>
                            <span class="text-gray-400 text-sm"></span>
                            <span class="text-lg negative">${bearVal.toFixed(1)}</span>
                        </div>
                        <div class="w-full bg-gray-800 rounded-full h-2.5 flex border border-gray-700">
                            <div class="bg-green-500 h-full rounded-l-full" style="width: ${bullPercent}%;"></div>
                            <div class="bg-red-500 h-full rounded-r-full" style="width: ${bearPercent}%;"></div>
                        </div>
                    </div>
                    <p class="text-base font-mono text-gray-400 p-2 rounded-md bg-gray-900/50 mt-2">
                        ${bias.detail}
                    </p>
                </div>

                <hr class="border-gray-700"/>
                <p id="signal-time-elapsed" class="text-center text-xs font-mono text-gray-500 mt-2">${isCurrentlyActive ? 'Aktif sejak: 00m 00s' : '‚Äî Sinyal Netral ‚Äî'}</p>
                <hr class="border-gray-700"/>
                
                <div class="grid grid-cols-2 gap-4">
                    <div class="text-center">
                        <p class="text-sm text-yellow-400">${formatPrice(entry.price, symbol)}</p>
                        <p class="text-xs text-gray-400">Entry</p>
                        <p class="text-xs text-yellow-500">(${entry.percentage ? entry.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-red-400">${formatPrice(sl.price, symbol)}</p>
                        <p class="text-xs text-gray-400">Stop Loss</p>
                        <p class="text-xs text-red-500">(${sl.percentage ? sl.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                </div>
                <hr class="border-gray-700"/>
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <p class="text-sm text-green-400">${formatPrice(tp1.price, symbol)}</p>
                        <p class="text-xs text-gray-400">TP 1 (Struktural)</p>
                        <p class="text-xs text-green-500">(${tp1.percentage ? tp1.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-green-400">${formatPrice(tp2.price, symbol)}</p>
                        <p class="text-xs text-gray-400">TP 2 (R:R 1:1.5)</p>
                        <p class="text-xs text-green-500">(${tp2.percentage ? tp2.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm ${tp3.price ? 'text-green-400' : 'text-gray-400'}">${formatPrice(tp3.price, symbol)}</p>
                        <p class="text-xs text-gray-400">TP 3 (R:R 1:4.0)</p> 
                        <p class="text-xs ${tp3.price ? 'text-green-500' : 'text-gray-500'}">(${tp3.percentage ? tp3.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                
                </div>
            </div>
        `;

        if (isCurrentlyActive) { updateTimerDisplay(); }
        
        const fibContainer = document.getElementById('fib-targets-display');
        if (fibContainer && signalData.fib_levels && (signalData.fib_levels.extension || signalData.fib_levels.retracement)) {
            let title = '';
            let buttonHTML = '';
            let contentHTML = '';
            const symbol = realtimeCache.main.symbol;

            if (isFibRetracementVisible && signalData.fib_levels.retracement) {
                const retrLevels = signalData.fib_levels.retracement.levels;
                const fibType = signalData.fib_levels.retracement.type || '';
                const fibColor = signalData.bias.status.includes('LONG') ? 'negative' : 'positive';
                
                title = `üéØ Fibonacci Retracement Targets (${fibType})`;
                buttonHTML = `<button onclick="toggleFibView(event)" class="btn-secondary !text-xs !py-0.5 !px-2">Show Extension</button>`;
                contentHTML = `
                    <div class="grid grid-cols-2 gap-x-6 gap-y-1">
                        <div class="flex justify-between"><span class="text-gray-400">0</span><span class="${fibColor}">${formatPrice(retrLevels.level_0, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.236</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_236, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.382</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_382, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.5</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_5, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.618</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_618, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.786</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_786, symbol)}</span></div>
                        <div class="flex justify-between col-span-2"><span class="text-gray-400">1</span><span class="${fibColor}">${formatPrice(retrLevels.level_1, symbol)}</span></div>
                    </div>`;

            } else if (signalData.fib_levels.extension) {
                const extLevels = signalData.fib_levels.extension.levels;
                const fibType = signalData.fib_levels.extension.type || '';
                const fibColor = signalData.bias.status.includes('LONG') ? 'positive' : 'negative';

                title = `üéØ Fibonacci Extension Targets (${fibType})`;
                buttonHTML = `<button onclick="toggleFibView(event)" class="btn-secondary !text-xs !py-0.5 !px-2">Show Retracement</button>`;
                contentHTML = `
                    <div class="grid grid-cols-2 gap-x-6 gap-y-1">
                        <div class="flex justify-between"><span class="text-gray-400">0</span><span class="${fibColor}">${formatPrice(extLevels.level_0, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.618</span><span class="${fibColor}">${formatPrice(extLevels.level_0_618, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">1</span><span class="${fibColor}">${formatPrice(extLevels.level_1, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">1.272</span><span class="${fibColor}">${formatPrice(extLevels.level_1_272, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">1.618</span><span class="${fibColor}">${formatPrice(extLevels.level_1_618, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">2.618</span><span class="${fibColor}">${formatPrice(extLevels.level_2_618, symbol)}</span></div>
                    </div>`;
            }

            fibContainer.innerHTML = `
                <details class="w-full max-w-sm">
                    <summary class="cursor-pointer flex justify-between items-center list-none -mb-1">
                        <span class="text-xs text-yellow-400">${title}</span>
                        ${buttonHTML}
                    </summary>
                    <div class="text-xs font-mono bg-gray-800/50 p-2 rounded-md mt-2">
                        ${contentHTML}
                    </div>
                </details>
            `;

        } else if (fibContainer) {
            fibContainer.innerHTML = '';
        }

        if (realtimeCache.main.allIndicators && realtimeCache.main.allIndicators.stoch) {
            const stochData = realtimeCache.main.allIndicators.stoch;
            const lastK = stochData.kLine && stochData.kLine.length > 0 ? stochData.kLine.slice(-1).pop() : NaN;
            const lastD = stochData.dLine && stochData.dLine.length > 0 ? stochData.dLine.slice(-1).pop() : NaN;
            const prevK = realtimeCache.indicators.lastStochK || lastK;
            
            let directionK = '';
            let colorK = 'text-gray-400';

            if (lastK > prevK) {
                directionK = '‚ñ≤';
                colorK = 'positive font-bold';
            } else if (lastK < prevK) {
                directionK = '‚ñº';
                colorK = 'negative font-bold';
            } else {
                 directionK = '‚Äî'; 
            }

            const stochKEl = document.getElementById('stoch-k-value');
            const stochDEl = document.getElementById('stoch-d-value');
            const stochMomentumEl = document.getElementById('stoch-momentum-display'); 

            if (stochKEl && stochDEl) {
                stochKEl.textContent = `${isNaN(lastK) ? '--' : lastK.toFixed(2)} ${directionK}`;
                stochKEl.className = `font-mono text-sm ${colorK}`; 
                stochDEl.textContent = isNaN(lastD) ? '--' : lastD.toFixed(2);
            }

            if (stochMomentumEl && stochData.momentumStatus) {
                let momentumText = stochData.momentumStatus.replace(/_/g, ' '); 
                let momentumClass = 'text-gray-500';

                if (momentumText.includes('BULLISH')) momentumClass = 'positive font-semibold';
                else if (momentumText.includes('BEARISH')) momentumClass = 'negative font-semibold';

                stochMomentumEl.textContent = `Momentum: ${momentumText}`;
                stochMomentumEl.className = `text-center text-xs font-mono mt-2 ${momentumClass}`;
            }
            updateEmaRibbonTable();
        }
    }
    
    function updateStrategyFilterUI() {
        const allCheckboxes = document.querySelectorAll('.aft-strategy-filter');
        allCheckboxes.forEach(checkbox => {
            const strategyName = checkbox.value;
            const lossStreak = strategyLossStreaks[strategyName] || 0;

            if (lossStreak >= 3) {
                checkbox.checked = false;
                checkbox.disabled = true;
            } else {
                checkbox.disabled = false;
            }
        });
    }

    function setupAFTPanel() {
        const clearBtn = document.getElementById('clear-signal-log-btn');
        const forceActivateBtn = document.getElementById('force-reactivate-btn'); 

        if (forceActivateBtn) { 
            forceActivateBtn.addEventListener('click', forceActivateStrategies);
        }

        setupToggle('toggle-signal-log-btn', 'signal-log-content-wrapper', 'toggle-signal-log-icon', false);
    }

    function forceActivateStrategies() {
        if (confirm("Anda yakin ingin MENGAKTIFKAN KEMBALI SEMUA strategi? Ini akan mereset semua penghitung lose streak untuk sesi ini.")) {
            for (const key in strategyLossStreaks) { delete strategyLossStreaks[key]; }

            console.log("üî• [FORCE RE-ACTIVATE] Mereset semua filter strategi.");
            
            const allCheckboxes = document.querySelectorAll('.aft-strategy-filter');
            allCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
                checkbox.disabled = false; 
            });

            console.log("Semua strategi telah diaktifkan kembali.");
            alert("Semua strategi telah DIAKTIFKAN kembali.");
        }
    }

    function toggleApiKeyModal(show) {
        const modal = document.getElementById('api-key-modal');
        if (modal) {
            modal.classList.toggle('hidden', !show);
        }
    }

    function formatPrice(price, symbol) {
        if (price === null || isNaN(price) || typeof price !== 'number') {
            return 'N/A'; 
        }

        let currentSymbol = symbol || realtimeCache.main.symbol;
        let precision = undefined; 

        if (currentSymbol === 'BTCUSDT' || currentSymbol === 'ETHUSDT') {
            return `$${price.toFixed(2)}`; 
        }

        if (currentSymbol && precisionMap.hasOwnProperty(currentSymbol)) {
             precision = precisionMap[currentSymbol]; 
        }

        if (typeof precision === 'number') {
            return `$${price.toFixed(precision)}`;
        } else {
            if (price >= 1) {
                return `$${price.toFixed(2)}`;
            } else {
                return `$${price.toFixed(8)}`; 
            }
        }
    }

    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) return;
        
        contentWrapper.classList.add('collapsible-content');
        
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };

        let isVisible = startVisible;
        applyState(isVisible);
        
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }

    function formatTimeElapsed(ms) {
        if (ms < 0 || isNaN(ms)) return '--';
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        const pad = (num) => num.toString().padStart(2, '0');
        return `${pad(minutes)}m ${pad(remainingSeconds)}s`;
    }

    function resetLiveSession() {
        if (window.syncInterval) clearInterval(window.syncInterval);
        if (window.liveInterval) clearInterval(window.liveInterval);
        if (latencyInterval) clearInterval(latencyInterval);
        latencyInterval = null;
        liveInterval = null; 

        if (liveWebSocket) {
            liveWebSocket.onclose = null; 
            liveWebSocket.close();
            liveWebSocket = null;
        }
        if (orderFlowSocket) {
            orderFlowSocket.onclose = null;
            orderFlowSocket.close();
            orderFlowSocket = null;
        }

        liveData = [];
        currentMarketPrice = 0;

        document.getElementById('live-signal-content').innerHTML = '<p class="text-center text-sm text-gray-400">...</p>';
        document.getElementById('live-price-display').textContent = '$0.00';
        if (assetSymbolDisplay) assetSymbolDisplay.textContent = '--';
        document.getElementById('htf-compass-result').textContent = '-- Pilih Timeframe --';

        if(realtimeCache.main) {
            realtimeCache.main.latestScalpingSetup = null;
        }

        document.getElementById('connect-api-status-text').textContent = 'üîå BINANCE';
        document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-gray-500';
        document.getElementById('api-status-text').textContent = 'View Only';
    }

    function setButtonState(button, isLoading, text = null) {
        const btnText = button.querySelector('span');
        const btnLoader = button.querySelector('.loader');
        
        button.disabled = isLoading;

        if (btnText) {
            btnText.classList.toggle('hidden', isLoading);
        }
        if (btnLoader) {
            btnLoader.classList.toggle('hidden', !isLoading);
        }
        if (text && btnText && !isLoading) {
            btnText.textContent = text;
        }
    }

    function htfButtonHandler() {
        document.querySelectorAll('.htf-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        const newTimeframe = this.dataset.timeframe;
        const symbol = liveSymbolInput.value.toUpperCase();

        updateHtfCompass(newTimeframe); 
        updateMarketStructurePanel(symbol, newTimeframe); 
        lastMarketStructureUpdate = 0; 
    }

    function runLiveProjection(tradeCount) {
        if (!activeStrategy || !activeStrategy.metadata || !activeStrategy.metadata.qc_validation) {
            alert("Mohon impor file DNA strategi yang sudah divalidasi dengan Monte Carlo terlebih dahulu.");
            return;
        }

        const qcData = activeStrategy.metadata.qc_validation;
        const avgPnl = qcData.avgPnl_per_trade;
        const stdDevPnl = qcData.stdDevPnl_per_trade;

        if (typeof avgPnl !== 'number' || typeof stdDevPnl !== 'number' || stdDevPnl === 0) {
            alert("Error: Data statistik (avgPnl/stdDevPnl) tidak valid atau standar deviasi nol. Jalankan simulasi Monte Carlo lagi.");
            return;
        }

        const startEquityEl = document.getElementById('forecast-start-equity');
        if (!startEquityEl) { 
            alert("Gagal memuat panel hasil proyeksi. Coba muat ulang dasbor.");
            return;
        }

        const startEquity = paperTrade.state.balance;
        const numSimulations = 1000;
        const equityCurves = [];

        for (let i = 0; i < numSimulations; i++) {
            let currentEquity = startEquity;
            const curve = [startEquity];
            for (let j = 0; j < tradeCount; j++) {
                let u1 = Math.random();
                let u2 = Math.random();
                let z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                const randomPnl = z0 * stdDevPnl + avgPnl;
                currentEquity += randomPnl;
                curve.push(currentEquity);
            }
            equityCurves.push(curve);
        }

        const numTrades = equityCurves[0].length - 1;
        const finalEquities = equityCurves.map(c => c.slice(-1)[0]);
        const avgFinalEquity = finalEquities.reduce((sum, eq) => sum + eq, 0) / finalEquities.length;
        
        const worstCase = finalEquities.sort((a,b) => a-b)[Math.floor(finalEquities.length * 0.05)];
        const lossProbability = (finalEquities.filter(eq => eq < startEquity).length / numSimulations) * 100;
        
        document.getElementById('forecast-start-equity').textContent = formatPrice(startEquity, realtimeCache.main.symbol);
        document.getElementById('forecast-avg-pnl').textContent = formatPrice(avgFinalEquity - startEquity, realtimeCache.main.symbol);
        document.getElementById('forecast-loss-prob').textContent = `${lossProbability.toFixed(1)}%`;
        document.getElementById('forecast-worst-case').textContent = formatPrice(worstCase, realtimeCache.main.symbol);

        renderProjectionChart(equityCurves, startEquity);
    }

    function renderProjectionChart(equityCurves, startEquity) {
        const ctx = document.getElementById('forecast-chart').getContext('2d');
        if (forecastChart) forecastChart.destroy();
        
        const numTrades = equityCurves[0].length - 1;
        const finalEquities = equityCurves.map(c => c.slice(-1)[0]);
        const avgFinalEquity = finalEquities.reduce((sum, eq) => sum + eq, 0) / finalEquities.length;
        const worstCase = finalEquities.sort((a,b) => a-b)[Math.floor(finalEquities.length * 0.05)];
        const lossProbability = (finalEquities.filter(eq => eq < startEquity).length / 1000) * 100;
        const resultsContainer = document.getElementById('forecast-results');
        if (resultsContainer) {
            resultsContainer.innerHTML = `
                <span>Modal Awal Proyeksi</span><span id="forecast-start-equity" class="text-right font-semibold">${formatPrice(startEquity, realtimeCache.main.symbol)}</span>
                <span>Potensi PNL Rata-rata</span><span id="forecast-avg-pnl" class="text-right font-semibold">${formatPrice(avgFinalEquity - startEquity, realtimeCache.main.symbol)}</span>
                <span>Probabilitas Loss</span><span id="forecast-loss-prob" class="text-right font-semibold">${lossProbability.toFixed(1)}%</span>
                <span>Worst Case (5%)</span><span id="forecast-worst-case" class="text-right font-semibold">${formatPrice(worstCase, realtimeCache.main.symbol)}</span>
            `;
        }

        const avgCurve = Array(numTrades + 1).fill(0).map((_, i) => equityCurves.reduce((sum, curve) => sum + curve[i], 0) / equityCurves.length);
        const labels = Array.from({ length: numTrades + 1 }, (_, i) => `Trade ${i}`);
        
        const data = {
            labels,
            datasets: [{
                label: 'Jalur Ekuitas Rata-rata',
                data: avgCurve,
                borderColor: '#F59E0B',
                tension: 0.1,
                pointRadius: 0
            }]
        };
        
        forecastChart = new Chart(ctx, {
            type: 'line', data: data, options: {
                responsive: true,
                scales: { y: { beginAtZero: false, title: { display: true, text: 'Ekuitas (USD)' } }, x: { title: { display: true, text: 'Jumlah Trade' } } }
            }
        });
    }

    function debounce(func, timeout = 300) {
        let timer;
        return (...args) => {
            clearTimeout(timer);
            timer = setTimeout(() => { func.apply(this, args); }, timeout);
        };
    }

    function getSignClass(value) {
        if (value > 0) return 'positive';
        if (value < 0) return 'negative';
        return 'text-gray-400';
    }

    function setupAftSizingBindings() {
        const balanceInput = document.getElementById('aft-wallet-balance');
        const costInput = document.getElementById('aft-cost-input');
        const slider = document.getElementById('aft-margin-slider');
        const initialBalance = paperTrade.state.balance || 250;
        
        balanceInput.value = initialBalance.toFixed(2);
        costInput.value = (initialBalance * 0.05).toFixed(2); 

        slider.addEventListener('input', () => {
            const percentage = parseFloat(slider.value) / 100;
            const newCost = initialBalance * percentage;
            costInput.value = newCost.toFixed(2);
        });

        costInput.addEventListener('input', () => {
            const costValue = parseFloat(costInput.value) || 0;
            const percentage = initialBalance > 0 ? (costValue / initialBalance) * 100 : 0;
            slider.value = Math.min(100, percentage);
        });
    }

    function initializeNewCalculator() {
        const { elements, state } = tsCalc;
        
        elements.sellBtn.classList.add('opacity-50');
        state.positionType = 'long';

        elements.crossBtn.addEventListener('click', () => {
            state.marginMode = 'cross';
            elements.crossBtn.classList.add('active');
            elements.isolatedBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.isolatedBtn.addEventListener('click', () => {
            state.marginMode = 'isolated';
            elements.isolatedBtn.classList.add('active');
            elements.crossBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.buyBtn.addEventListener('click', () => {
            state.positionType = 'long';
            elements.buyBtn.classList.remove('opacity-50');
            elements.sellBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi LONG simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('long', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
            
            tsCalc.recalculate();
        });
        elements.sellBtn.addEventListener('click', () => {
            state.positionType = 'short';
            elements.sellBtn.classList.remove('opacity-50');
            elements.buyBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi SHORT simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('short', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
                
            tsCalc.recalculate();
        });
        elements.tpslToggle.addEventListener('change', () => {
            elements.tpslInputs.classList.toggle('hidden', !elements.tpslToggle.checked);
        });
        elements.slider.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const percentage = parseFloat(elements.slider.value);
            const newCost = (currentWalletBalance * (percentage / 100));
            elements.cost.value = newCost.toFixed(2);
            tsCalc.recalculate();
        });
        ['cost', 'leverage', 'walletBalance', 'marketPrice'].forEach(id => {
            elements[id].addEventListener('input', () => tsCalc.recalculate());
        });
        elements.cost.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const costValue = parseFloat(elements.cost.value) || 0;
            const percentage = currentWalletBalance > 0 ? (costValue / currentWalletBalance) * 100 : 0;
            elements.slider.value = Math.min(100, percentage);
        });
        elements.autofillBtn.addEventListener('click', () => tsCalc.autofill());
        elements.tsOptionsBtn.addEventListener('click', () => tsCalc.toggleModal(true));
        elements.modalCloseBtn.addEventListener('click', () => tsCalc.toggleModal(false));
        elements.modalContainer.addEventListener('click', (e) => {
            if (e.target === elements.modalContainer) tsCalc.toggleModal(false);
        });
        elements.modalSaveBtn.addEventListener('click', () => {
            state.callbackRate = parseFloat(elements.modalCallbackRate.value);
            state.activationPrice = parseFloat(elements.modalActivationPrice.value);
            tsCalc.toggleModal(false);
            tsCalc.recalculate();
        });

        tsCalc.recalculate();
    }
// ===================
// Event Listener
// ===================  
    document.addEventListener('DOMContentLoaded', async () => { 
        lastUsedApiMode = false;
        await initializePrecisionMap(); 
        await fetchFuturesSymbols();
        
        const startLiveBtn = document.getElementById('start-live-btn');
        const startLiveText = startLiveBtn.querySelector('span'); 
        const connectApiBtn = document.getElementById('connect-api-btn');

        setupToggle('toggle-ts-calc-btn', 'ts-calc-content-wrapper', 'toggle-ts-calc-icon', false);
        setupToggle('toggle-paper-trading-btn', 'paper-trading-content-wrapper', 'toggle-paper-trading-icon', true);
        setupToggle('toggle-import-btn', 'import-content-wrapper', 'toggle-import-icon', false);
        setupToggle('toggle-forecast-btn', 'forecast-content-wrapper', 'toggle-forecast-icon', false);
        setupToggle('toggle-signal-log-btn', 'signal-log-content-wrapper', 'toggle-signal-log-icon', false); 
        toggleChartsBtn.addEventListener('click', toggleChartsVisibility);
        
        importFile.addEventListener('change', (event) => {
            handleFileImport(event);
        });

        tsCalcElements = {
            leverage: document.getElementById('ts-leverage'),
            cost: document.getElementById('ts-cost'),
            slider: document.getElementById('ts-margin-slider'),
            walletBalance: document.getElementById('ts-wallet-balance'),
            marketPrice: document.getElementById('ts-market-price'),
            tpslToggle: document.getElementById('ts-tpsl-toggle'),
            tpslInputs: document.getElementById('ts-tpsl-inputs'),
            takeProfit: document.getElementById('ts-take-profit'),
            stopLoss: document.getElementById('ts-stop-loss'),
            resultCost: document.getElementById('ts-result-cost'),
            resultMax: document.getElementById('ts-result-max'),
            resultPosSize: document.getElementById('ts-result-position-size'),
            resultLiqPrice: document.getElementById('ts-result-liq-price'),
            resultStatus: document.getElementById('ts-result-status'),
            resultSlPrice: document.getElementById('ts-result-sl-price'),
            resultRoe: document.getElementById('ts-result-roe'),
            crossBtn: document.getElementById('ts-mode-cross'),
            isolatedBtn: document.getElementById('ts-mode-isolated'),
            buyBtn: document.getElementById('ts-buy-long-btn'),
            sellBtn: document.getElementById('ts-sell-short-btn'),
            autofillBtn: document.getElementById('autofill-ts-btn'),
            tsOptionsBtn: document.getElementById('ts-trailing-stop-options'),
            modalContainer: document.getElementById('ts-modal-container'),
            modalCallbackRate: document.getElementById('ts-modal-callback-rate'),
            modalActivationPrice: document.getElementById('ts-modal-activation-price'),
            modalSaveBtn: document.getElementById('ts-modal-save-btn'),
            modalCloseBtn: document.getElementById('ts-modal-close-btn')
        };
        
        tsCalc = {
            elements: tsCalcElements, 
            state: {
                marginMode: 'cross', leverage: 50, cost: 0, entryPrice: 0,
                walletBalance: 1000, tp: null, sl: null, callbackRate: null,
                activationPrice: null, positionType: 'long'
            },
                
            toggleModal: function(show) {
                if (show) this.elements.modalContainer.classList.remove('hidden');
                else this.elements.modalContainer.classList.add('hidden');
            },

            recalculate: function() {
                const balance = paperTrade.state.balance || 0;
                const unrealizedPnl = paperTrade.state.position ? (paperTrade.state.position.pnl || 0) : 0;
                const totalEquity = balance + unrealizedPnl; 

                this.elements.walletBalance.value = balance.toFixed(2);            
                this.state.walletBalance = balance;
                this.state.leverage = parseFloat(this.elements.leverage.value) || 50;
                this.state.cost = parseFloat(this.elements.cost.value) || 0;
                const entry = parseFloat(this.elements.marketPrice.value) || currentMarketPrice || 0;
                if (entry === 0) return;

                const positionSize = this.state.cost * this.state.leverage;
                this.elements.resultCost.textContent = `${this.state.cost.toFixed(2)} USDT`;
                this.elements.resultPosSize.textContent = `${positionSize.toFixed(2)} USDT`;
                        
                let liqPrice = 0;
                if (positionSize > 0) {
                    const maintenanceMarginRate = 0.005; // Standard Binance Rate

                if (this.state.marginMode === 'isolated') {
                    const marginForLiq = this.state.cost; 
                    const priceChange = (marginForLiq / positionSize) * (1 - maintenanceMarginRate);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                    } else {      
                        const marginForLiq = this.state.walletBalance;
                        const priceChange = (marginForLiq / positionSize) * (1 - maintenanceMarginRate);
                        liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                    }
                }
                this.elements.resultLiqPrice.textContent = liqPrice > 0 ? formatPrice(liqPrice) : 'N/A';
            },

            autofill: function() {
                const setup = realtimeCache.main.latestScalpingSetup;    
                    if (!setup || typeof setup.entry.price !== 'number') {
                    alert("Setup sinyal belum siap atau pasar sedang sideways. Tidak bisa auto-fill.");
                    return;
                }
                    
                const isLong = setup.bias.status.includes('LONG');
                this.state.positionType = isLong ? 'long' : 'short';
                    
                if(isLong) {
                    this.elements.buyBtn.classList.remove('opacity-50');
                    this.elements.sellBtn.classList.add('opacity-50');
                } else {
                    this.elements.sellBtn.classList.remove('opacity-50');
                    this.elements.buyBtn.classList.add('opacity-50');
                }

                const formattedMarkPrice = formatPrice(currentMarketPrice, realtimeCache.main.symbol).replace('$', '');
                this.elements.marketPrice.value = formattedMarkPrice; 
                    
                if(typeof setup.tp1.price === 'number') {
                    const formattedTP = formatPrice(setup.tp1.price, realtimeCache.main.symbol).replace('$', '');
                    this.elements.takeProfit.value = formattedTP;
                }
                    
                if(typeof setup.sl.price === 'number') {
                    const formattedSL = formatPrice(setup.sl.price, realtimeCache.main.symbol).replace('$', '');
                    this.elements.stopLoss.value = formattedSL;
                }

                this.elements.tpslToggle.checked = true;
                this.elements.tpslInputs.classList.remove('hidden');
                this.elements.cost.focus();
                this.recalculate();
                this.elements.leverage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };


        
        const autoTradeBtn = document.getElementById('enable-auto-trade-btn');
        if (autoTradeBtn) {
            autoTradeBtn.addEventListener('click', () => {
                isAutoTradeEnabled = !isAutoTradeEnabled; 

                if (isAutoTradeEnabled) {
                    autoTradeBtn.textContent = '‚èπÔ∏è DISABLE AUTO-TRADE';
                    autoTradeBtn.classList.remove('!bg-gray-600', 'hover:!bg-gray-500');
                    autoTradeBtn.classList.add('!bg-green-600', 'hover:!bg-green-500');
                    console.log("ü§ñ Auto-Trade DIAKTIFKAN. Bot akan mengeksekusi sinyal yang valid.");
                    alert("Auto-Trade DIAKTIFKAN!");
                } else {
                    autoTradeBtn.textContent = '‚ñ∂Ô∏è ENABLE AUTO-TRADE';
                    autoTradeBtn.classList.remove('!bg-green-600', 'hover:!bg-green-500');
                    autoTradeBtn.classList.add('!bg-gray-600', 'hover:!bg-gray-500');
                    console.log("ü§ñ Auto-Trade DINONAKTIFKAN. Bot hanya akan menganalisis pasar.");
                    alert("Auto-Trade DINONAKTIFKAN.");
                }
            });
        }

        const openAftFilterBtn = document.getElementById('open-aft-filter-btn');
        const closeAftFilterBtn = document.getElementById('close-aft-filter-btn');

        if (openAftFilterBtn) {
            openAftFilterBtn.addEventListener('click', () => toggleAftFilterModal(true));
        }
        if (closeAftFilterBtn) {
            closeAftFilterBtn.addEventListener('click', () => toggleAftFilterModal(false));
        }

        if (connectApiBtn) {
            connectApiBtn.addEventListener('click', async () => {
                const currentText = connectApiBtn.querySelector('span').textContent;

                if (lastUsedApiMode) {
                    if (confirm("Anda yakin ingin memutuskan koneksi PROXY? Ini akan mengakhiri sinkronisasi saldo LIVE.")) {
                        lastUsedApiMode = false;
                        setButtonState(connectApiBtn, false, "üîå BINANCE");
                        document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-gray-500';
                        document.getElementById('api-status-text').textContent = 'View Only';
                            
                        if (window.syncInterval) clearInterval(window.syncInterval);

                        if (startLiveText.textContent.includes("STOP")) {
                            resetLiveSession(); 
                            setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START SIM"); 
                        } else if (startLiveBtn) {
                            setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START SIM");
                        }
                            
                        return;
                    }
                }
                    
                setButtonState(connectApiBtn, true, "SYNCING BALANCE...");
                    
                try {
                    lastUsedApiMode = true;
                    await paperTrade.syncAccountState(); 

                    if (startLiveBtn) {
                        setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START LIVE");
                    }
                        
                    setButtonState(connectApiBtn, false, "üî• PROXY CONNECTED");
                } catch (e) {
                    lastUsedApiMode = false; 
                    setButtonState(connectApiBtn, false, "üîå BINANCE");
                }
            });
        }

        startLiveBtn.addEventListener('click', () => {
            const currentLabel = startLiveBtn.querySelector('span').textContent;
            const isLiveMode = currentLabel.includes('LIVE'); 

            if (currentLabel.includes("STOP")) {
                startAnalysisSession(lastUsedApiMode); 
                return;
            }
    
            if (isLiveMode && !lastUsedApiMode) { 
                alert("Gagal memulai Live Trade. Mohon klik tombol 'LIVE TRADE' di pojok kiri atas terlebih dahulu untuk sync/set API Keys.");
                lastUsedApiMode = false; 
                setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START ANALYSIS"); 
                return;
            }
            
            console.log(`Memulai sesi dengan mode: ${isLiveMode ? 'LIVE TRADE' : 'SIMULASI'}`);
        
            if (!isLiveMode) {
                paperTrade.init(); 
            }
            
            startAnalysisSession(isLiveMode); 
        });

        document.querySelectorAll('.chart-tf-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const newTimeframe = this.dataset.timeframe;
                        
                document.querySelectorAll('.chart-tf-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                            
                switchChartTimeframe(newTimeframe);
            });
        });

        const runProjectionBtn = document.getElementById('run-live-projection-btn');
            if (runProjectionBtn) {
                runProjectionBtn.addEventListener('click', () => {
                    const tradeCountInput = document.getElementById('forecast-trade-count');
                    if (tradeCountInput) {
                        const tradeCount = parseInt(tradeCountInput.value, 10);
                        if (tradeCount > 0) {
                            runLiveProjection(tradeCount);
                        } else {
                            alert("Jumlah trade untuk proyeksi harus lebih besar dari 0.");
                        }
                    }
                });
            }

            if (startLiveBtn) {
                setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START SIM"); 
            }
            
        document.getElementById('dump-trigger-timeframe-select').addEventListener('change', function() {
            const newTf = this.value;
            console.log(`Dump Risk Timeframe diubah ke: ${newTf}`);
        });
          
        document.querySelectorAll('.htf-btn').forEach(btn => {
            btn.addEventListener('click', htfButtonHandler);
        });

        document.getElementById('sim-reset-account-btn')?.addEventListener('click', () => {
            paperTrade.resetAccount(true); 
        });

        document.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                const activeElement = document.activeElement;
                const startBtn = document.getElementById('start-live-btn');
                
                if (activeElement === startBtn) {
                    event.preventDefault(); 
                    startBtn.click();
                    return;
                }
                
                const symbolInput = document.getElementById('live-symbol-input');
                const timeframeSelect = document.getElementById('live-timeframe-select');

                if (activeElement === symbolInput) {
                    event.preventDefault();
                    timeframeSelect.focus(); 
                } else if (activeElement === timeframeSelect) {
                    event.preventDefault();
                    startBtn.focus(); 
                } else if (!activeElement || activeElement.tagName === 'BODY') {
                    startBtn.focus();
                }
            }
        });
        
        if (document.getElementById('start-live-btn')) {
            document.getElementById('start-live-btn').setAttribute('tabindex', '0');
        }

        initializeNewCalculator();
        setupAFTPanel();
        await loadRegimeSensorModel();
        startFundingCountdown();
        setupAftSizingBindings()
    });
</script>

</body>
</html>