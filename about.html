<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOLDEN DASHBOARD</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

<style>body{font-family:'Inter',sans-serif;background-color:#000000;color:#E0E0E0;}.card{background-color:#151414;border:1px solid #333;border-radius:.75rem;}.positive{color:#4ade80;}.negative{color:#f87171;}.btn-primary{background-color:#c97c00;color:#1f2937;font-weight:600;padding:.625rem 1.25rem;border-radius:.5rem;transition:background-color .3s;display:flex;align-items:center;justify-content:center;gap:.5rem;}.btn-primary:hover{background-color:#eb9413;}.btn-special{background-color:#8B5CF6;color:white;font-weight:600;padding:.625rem 1.25rem;border-radius:.5rem;transition:background-color .3s;display:flex;align-items:center;justify-content:center;gap:.5rem;}.btn-special:hover{background-color:#7C3AED;}.tab-button.active{border-bottom:2px solid #c97c00;font-weight:600;}.toggle-btn{transition:background-color .3s;}.toggle-btn.active{background-color:#c97c00;}.toggle-icon{transition:transform .3s ease-in-out;}.toggle-icon.rotate-180{transform:rotate(180deg);}.indicator-label{min-width:100px;}.hidden-panel{display:none;}.input-primary{background-color:#2c2c2c;border:1px solid #444;border-radius:.5rem;padding:.625rem 1rem;width:100%;color:#E0E0E0;}.loader{display:flex;justify-content:center;align-items:center;gap:4px;}.dot{width:8px;height:8px;background-color:#e1e1e1;border-radius:50%;animation:bounce 1.4s infinite ease-in-out both;}.dot:nth-child(1){animation-delay:-.32s;}.dot:nth-child(2){animation-delay:-.16s;}@keyframes bounce{0%,80%,100%{transform:scale(0);}40%{transform:scale(1.0);}}.collapsible-content{display:grid;grid-template-rows:0fr;transition:grid-template-rows .4s ease-in-out;}.collapsible-content.expanded{grid-template-rows:1fr;}.collapsible-content>div{overflow:hidden;}.btn-secondary{background-color:#374151;color:#E0E0E0;font-weight:600;transition:background-color .3s;}.btn-secondary:hover{background-color:#4b5563;}.chart-tf-btn.active{background-color:#c97c00;color:#1f2937;}.calc-binance-style .btn-group{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-bottom:1.5rem;}.calc-binance-style .btn-group button{padding:10px;border-radius:6px;cursor:pointer;background-color:#2c2f36;border:1px solid #3a3f4a;color:#e0e0e0;font-weight:500;transition:background-color .2s;}.calc-binance-style .btn-group button:hover{background-color:#3a3f4a;}.calc-binance-style .btn-group button.active{background-color:#f0b90b;color:#14151a;border-color:#f0b90b;}.calc-binance-style .input-group{position:relative;margin-bottom:1rem;}.calc-binance-style .input-field{width:100%;padding:12px;background-color:#2c2f36;border:1px solid #3a3f4a;border-radius:8px;color:#e0e0e0;font-size:1.1em;}.calc-binance-style .input-label-top{font-size:.8em;color:#848e9c;margin-bottom:8px;}.calc-binance-style .margin-slider{width:100%;-webkit-appearance:none;appearance:none;height:4px;background:#3a3f4a;outline:none;border-radius:2px;margin:1.5rem 0;}.calc-binance-style .margin-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:#f0b90b;cursor:pointer;border-radius:50%;}.calc-binance-style .slider-ticks{display:flex;justify-content:space-between;font-size:.75rem;color:#848e9c;}.calc-binance-style .exec-buttons{display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:1.5rem;}.calc-binance-style .exec-buttons button{padding:14px;font-size:1.1em;font-weight:600;border:none;border-radius:8px;cursor:pointer;}.calc-binance-style .btn-buy{background-color:#2ebd85;color:white;}.calc-binance-style .btn-sell{background-color:#f6465d;color:white;}.calc-binance-style .calc-result-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:1rem;font-size:.85em;color:#848e9c;}.calc-binance-style .calc-result-grid span:nth-child(even){text-align:right;font-weight:600;color:#e0e0e0;}#ts-modal-content .input-field{background-color:#2c2f36;border:1px solid #3a3f4a;}#ts-modal-close-btn{font-size:2rem;line-height:1;}
        .top-bar-sticky {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: #000000;
            border-bottom: 1px solid #333;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .blinking-status {
            animation: blink 1.5s infinite;
        }
</style>
</head>
<body class="p-8">

<header class="text-center mb-8"><h1 class="text-3xl font-semibold"></h1><p class="text-gray-400"></p></header>

    <main class="max-w-7xl mx-auto space-y-8">
        <section id="api-connection-section" class="card top-bar-sticky">
    <div class="flex justify-between items-center gap-2">
        
        <div>
            <button id="connect-api-btn" class="btn-primary">
                <span id="connect-api-status-text">⚡️ LIVE TRADE</span>
            </button>
        </div>

        <div id="api-status-display" class="flex items-center gap-2 text-sm font-mono">
            <div class="flex items-center gap-2">
                <span><span id="live-price-display" class="text-lg font-mono text-yellow-400">$0.00</span></span>
                <div id="api-status-dot" class="w-3 h-3 rounded-full bg-gray-500"></div>
                <span id="api-status-text" class="text-gray-400">View Only</span>
            </div>
            
            <div class="border-l border-gray-600 pl-4">
                <span id="ping-latency-display" class="text-gray-400">Ping: -- ms</span>
            </div>
        </div>

    </div>
</section>

        <section id="imported-strategy-section" class="card p-4">
            <button id="toggle-import-btn" class="w-full flex justify-between items-center text-left">
                <h2 class="text-lg font-semibold">DNA STRATEGI</h2>
                <svg id="toggle-import-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <div id="import-content-wrapper" class="collapsible-content">
                    <div class="pt-4 mt-4 border-t border-gray-700">
                        <div class="flex items-center space-x-4">
                            <label for="import-file" class="btn-special cursor-pointer flex-grow text-center">
                                Import DNA (.json)
                            </label>
                            <input type="file" id="import-file" class="hidden" accept=".json" />
                        </div>
                        
                        <div class="mt-2 text-center">
                            <span id="dna-status-display" class="text-sm font-mono text-gray-500">
                                Status: Belum ada DNA dimuat.
                            </span>
                        </div>
                        <div id="imported-sinyal-panel" class="mt-4 pt-4 border-t border-gray-700">
                            <p class="text-center text-sm text-gray-400"></p>
                        </div>
                    </div>
                </div>
        </section>

        <section id="live-data-input-section" class="card p-3">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                <input type="text" id="live-symbol-input" placeholder="BTCUSDT" value="BTCUSDT" class="input-primary flex-grow text-center uppercase">
                <select id="live-timeframe-select" class="input-primary">
                    <option value="1m">1m</option>
                    <option value="5m" selected>5m</option>
                    <option value="15m">15m</option>
                    <option value="1h">1h</option>
                </select>
                <button id="start-live-btn" class="btn-primary">
                    <span>▶️ START LIVE</span>
                    <div class="loader w-5 h-5 hidden">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </button>
            </div>

            <section id="charts-wrapper" class="card p-4 my-4" style="display: none;">
                <h2 class="text-xl font-semibold mb-4">Live Chart</h2>
                <div id="chart-timeframe-selector" class="flex flex-wrap gap-2 mb-4 border-b border-gray-700 pb-4">
                    <button data-timeframe="1m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1m</button>
                    <button data-timeframe="5m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3 active">5m</button>
                    <button data-timeframe="15m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                    <button data-timeframe="1h" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1h</button>
                </div>
                <div class="chart-container relative">
                    <div class="pane-title">Price</div>
                    <div id="main-chart-container" style="height: 450px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Volume</div>
                    <div id="volume-chart-container" style="height: 100px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">RSI (14)</div>
                    <div id="rsi-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Stochastic RSI</div>
                    <div id="stoch-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">MACD</div>
                    <div id="macd-chart-container" style="height: 120px;"></div>
                </div>
            </section>
            <button id="toggle-charts-btn" class="btn-primary w-full mt-4">SHOW CHART</button>

            <div id="live-signal-panel" class="card p-3 mt-6">
                <h2 class="text-xl font-semibold mb-4 text-orange-500 flex items-center justify-between">
                    <span></span>
                    
                </h2>
                <div id="htf-compass-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-normal text-gray-400">HTF Compass</span>
                        <div id="htf-compass-selector" class="flex flex-wrap gap-2">
                            <button data-timeframe="5m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">5m</button>
                            <button data-timeframe="15m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                            <button data-timeframe="1h" class="htf-btn btn-secondary !text-xs !py-1 !px-3 active">1H</button>
                            <button data-timeframe="4h" class="htf-btn btn-secondary !text-xs !py-1 !px-3">4H</button>
                        </div>
                    </div>
                    <div id="htf-compass-result" class="text-center mt-2 text-sm">
                        -- Pilih Timeframe --
                    </div>
                    <div class="grid grid-cols-2 gap-2 mt-3 text-center">
                        <div>
                            <p id="htf-resistance-price" class="font-mono text-lg negative">--</p>
                            <p class="text-xs text-gray-500">HTF Resistance</p>
                        </div>
                        <div>
                            <p id="htf-support-price" class="font-mono text-lg positive">--</p>
                            <p class="text-xs text-gray-500">HTF Support</p>
                        </div>
                        <div id="fib-targets-display" class="mt-3 flex justify-center col-span-2">
                            </div>
                    </div>
                    <div class="mt-4">
                        <details>
                            <summary class="cursor-pointer text-sm text-gray-400 hover:text-white">Sentiment & Volatility Indicators</summary>
                            <div id="sentiment-indicators-content" class="pt-2 mt-2 border-t border-gray-700 text-xs space-y-1 font-mono">
                                <div class="flex justify-between"><span>Parabolic SAR</span><span id="sentiment-psar">--</span></div>
                                <div class="flex justify-between"><span>Rate of Change (12)</span><span id="sentiment-roc">--</span></div>
                                <div class="flex justify-between"><span>ADX (14)</span><span id="sentiment-adx">--</span></div>
                                <div class="flex justify-between"><span>ATR (% of Price)</span><span id="sentiment-atr">--</span></div>
                                <hr class="border-gray-700/50 my-1"/>
                                <div class="flex justify-between"><span>L/S Ratio (Global)</span><span id="sentiment-ls-global">--</span></div>
                                <div class="flex justify-between"><span>L/S Ratio (Top)</span><span id="sentiment-ls-top">--</span></div>
                                <div class="flex justify-between"><span>Funding Interval</span><span id="sentiment-funding-interval">--:--:--</span></div>
                                <div class="flex justify-between"><span>Funding Rate</span><span id="sentiment-funding">--</span></div>
                                <div class="flex justify-between"><span>Open Interest</span><span id="sentiment-oi">--</span></div>
                            </div>
                        </details>
                    </div>
                </div>
                <div id="order-flow-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <span class="text-sm font-normal text-gray-400">Order Flow Imbalance</span>
                    <div class="mt-2 w-full bg-gray-700 rounded-full h-4 relative">
                        <div id="order-flow-bar" class="bg-gradient-to-r from-green-500 to-red-500 h-4 rounded-full" style="width: 50%;"></div>
                        <div id="order-flow-text" class="absolute inset-0 flex items-center justify-center text-xs font-bold text-white">
                            50% | 50%
                        </div>
                    </div>
                    <div class="flex justify-between text-xs mt-1">
                        <span class="text-green-400">BIDS</span>
                        <span class="text-red-400">ASKS</span>
                    </div>
                </div>
                <div id="live-signal-content">
                    <p class="text-center text-sm text-gray-400"></p>
                </div>
                
            </div>
        </section>

        <section id="paper-trading-section" class="card p-3">
            <button id="toggle-paper-trading-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-xl font-semibold">Auto/Manual Trading</h2>
                <svg id="toggle-paper-trading-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
                
            <div id="paper-trading-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-700 space-y-4">
                    <div id="sim-metrics-dashboard" class="card p-4 mt-4 bg-gray-900/50">
                            <h3 class="text-sm font-normal mb-3 text-yellow-400 border-b border-gray-700 pb-1">
                                Dasbor Performa Kuantitatif
                            </h3>
                            <div class="grid grid-cols-3 md:grid-cols-7 gap-2 text-center">
                                <div>
                                    <p class="text-xs text-gray-500">💰 Total P/L</p>
                                    <p id="sim-result-pnl" class="font-mono text-sm negative">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">🎯 Win Rate</p>
                                    <p id="sim-result-winrate" class="font-mono text-sm">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">📈 Profit Factor</p>
                                    <p id="sim-result-profit-factor" class="font-mono text-sm">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">Trades</p>
                                    <p id="sim-result-total-trades" class="font-mono text-sm">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">📉 Max Drawdown</p>
                                    <p id="sim-result-max-drawdown" class="font-mono text-sm negative">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">🎲 Expectancy</p>
                                    <p id="sim-result-expectancy" class="font-mono text-sm">--</p>
                                </div>
                                <div>
                                    <p class="text-xs text-gray-500">🔥 Max Lose Streak</p>
                                    <p id="sim-result-losing-streak" class="font-mono text-sm">--</p>
                                </div>
                                </div> <div id="strategy-performance-panel" class="mt-4 pt-3 border-t border-gray-700">
                                    <h4 class="text-xs text-gray-500 mb-2 text-center">Performa Per Strategi</h4>
                                    <div class="overflow-x-auto">
                                        <table class="min-w-full text-xs text-left">
                                            <thead class="text-gray-400">
                                                <tr>
                                                    <th class="py-1 px-2">Strategi</th>
                                                    <th class="py-1 px-2 text-center">Trades</th>
                                                    <th class="py-1 px-2 text-center">Win Rate</th>
                                                    <th class="py-1 px-2 text-right">Total P/L</th>
                                                </tr>
                                            </thead>
                                            <tbody id="strategy-performance-body">
                                                <tr><td colspan="4" class="py-2 text-center text-gray-600">-- Data akan muncul setelah ada riwayat trade --</td></tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                    <div class="flex justify-between items-center gap-2">
                        
                        <div class="grid grid-cols-3 gap-3 text-center flex-grow">
                            <div>
                                <p class="text-xs text-gray-500">Equity</p>
                                <p id="sim-equity" class="font-mono text-lg text-blue-400">$1000.00</p>
                            </div>
                            <div>
                                <p class="text-xs text-gray-500">Unrealized PNL</p>
                                <p id="sim-unrealized-pnl" class="font-mono text-lg text-gray-400">$0.00</p>
                            </div>
                            <div>
                                <p class="text-xs text-gray-500">Available Margin</p>
                                <p id="sim-available-margin" class="font-mono text-lg text-gray-400">$1000.00</p>
                            </div>
                        </div>
                        <div class="flex flex-col gap-2">
                            <button id="open-aft-filter-btn" class="btn-secondary !text-xs !py-1 !px-3">⚙️ Filter Strategi</button>
                            <button id="sim-reset-account-btn" class="btn-secondary !text-xs !py-1 !px-3">Reset Account</button>
                        </div>
                    </div>
                    </div>

                    <div id="sim-active-position-container" class="hidden">
                        <h3 class="text-yellow-400 mb-2">Active Position</h3>
                        <div class="p-3 rounded-md bg-gray-800/50 text-sm space-y-2">
                            <div class="flex justify-between items-center">
                                <span id="sim-position-header" class="text-lg">LONG / 20x</span>
                                <button id="sim-close-position-btn" class="btn-primary !bg-red-600 !text-xs !py-1 !px-3">Close Position</button>
                            </div>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                <div>
                                    <span class="text-gray-400">Size:</span>
                                    <span id="sim-position-size" class="font-mono"></span>
                                </div>
                                <div>
                                    <span class="text-gray-400">Entry:</span>
                                    <span id="sim-position-entry" class="font-mono"></span>
                                </div>
                                <div>
                                    <span class="text-gray-400">Mark:</span>
                                    <span id="sim-position-mark" class="font-mono"></span>
                                </div>
                                <div>
                                    <span class="text-gray-400">Liq:</span>
                                    <span id="sim-position-liq" class="font-mono"></span>
                                </div>
                            </div>
                            <div class="pt-2 border-t border-dashed border-gray-700">
                                <span class="text-gray-400">PNL (ROE %):</span>
                                <span id="sim-position-pnl" class="font-mono text-lg ml-2"></span>
                            </div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-gray-400">Trade History</h3>
                            <div class="flex gap-2">
                                <button id="sim-export-btn" class="btn-secondary !text-[10px] !py-0.5 !px-2">Export CSV</button>
                                <button id="sim-import-btn" class="btn-secondary !text-[10px] !py-0.5 !px-2">Import CSV</button>
                                <input type="file" id="sim-import-input" class="hidden" accept=".csv">
                            </div>
                        </div>
                        <div id="sim-trade-history-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                            <p class="text-center text-gray-600">No trade history yet.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="custom-console-section" class="card p-3 mt-8">
            <h2 class="text-xl font-semibold text-blue-400 mb-4">🖥️ Dashboard Console Log</h2>
            <div id="live-console-output" class="bg-black p-2 rounded-md max-h-64 overflow-y-auto text-xs font-mono border border-gray-700">
                <p class="text-gray-500">Console Log siap...</p>
            </div>
        </section>

        <section id="trailing-stop-calc-section" class="card p-3">
            <button id="toggle-ts-calc-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-xl font-semibold">Kalkulator Eksekusi</h2>
                <svg id="toggle-ts-calc-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>

            <div id="ts-calc-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 calc-binance-style">
                    <button id="autofill-ts-btn" class="btn-primary w-full mb-4">
                        ⚡️ Auto-fill dari Setup Scalping
                    </button>
                    <div class="btn-group">
                        <button id="ts-mode-cross" class="active">Cross</button>
                        <input type="number" id="ts-leverage" value="20" class="input-field text-center" style="padding-right: 2.5rem;">
                        <button id="ts-mode-isolated" class="">Isolated</button>
                        <button id="ts-trailing-stop-options">⚙️ TS</button>
                    </div>

                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label for="ts-wallet-balance" class="input-label-top">Available Balance ($)</label>
                            <input type="number" id="ts-wallet-balance" class="input-field" value="1000">
                        </div>
                        <div class="input-group">
                            <label for="ts-cost" class="input-label-top">Cost / Modal ($)</label>
                            <input type="number" id="ts-cost" class="input-field" placeholder="0.00">
                        </div>
                    </div>

                    <div>
                        <input type="range" min="0" max="100" value="0" class="margin-slider" id="ts-margin-slider">
                        <div class="slider-ticks">
                            <span>0%</span>
                            <span>25%</span>
                            <span>50%</span>
                            <span>75%</span>
                            <span>100%</span>
                        </div>
                    </div>

                    <div class="input-group mt-6">
                        <label for="ts-market-price" class="input-label-top">Harga Pasar Saat Ini ($)</label>
                        <input type="number" id="ts-market-price" class="input-field" placeholder="Harga market saat ini...">
                    </div>

                    <div class="tpsl-section">
                        <div class="flex items-center gap-2">
                            <input type="checkbox" id="ts-tpsl-toggle" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 text-yellow-500">
                            <label for="ts-tpsl-toggle" class="text-sm">TP/SL</label>
                        </div>
                        <div id="ts-tpsl-inputs" class="hidden mt-4 space-y-4">
                            <div class="input-group">
                                <label for="ts-take-profit" class="input-label-top">Take Profit</label>
                                <input type="number" id="ts-take-profit" class="input-field" placeholder="Mark">
                            </div>
                            <div class="input-group">
                                <label for="ts-stop-loss" class="input-label-top">Stop Loss</label>
                                <input type="number" id="ts-stop-loss" class="input-field" placeholder="Mark">
                            </div>
                        </div>
                    </div>

                    <div class="exec-buttons">
                        <button class="btn-buy" id="ts-buy-long-btn">Buy/Long</button>
                        <button class="btn-sell" id="ts-sell-short-btn">Sell/Short</button>
                    </div>

                    <div class="calc-result-grid">
                        <span>Cost</span>
                        <span id="ts-result-cost">--</span>
                        <span>Max</span>
                        <span id="ts-result-max">--</span>
                        <span>Position Size</span>
                        <span id="ts-result-position-size">--</span>
                        <span>Liq. Price</span>
                        <span id="ts-result-liq-price">--</span>
                        <span class="pt-2 border-t border-dashed border-gray-700">Status TS</span>
                        <span id="ts-result-status" class="pt-2 border-t border-dashed border-gray-700">--</span>
                        <span>Harga Stop Loss TS</span>
                        <span id="ts-result-sl-price">--</span>
                        <span>Potensi ROE</span>
                        <span id="ts-result-roe">--</span>
                    </div>
                </div>
            </div>

            <div id="ts-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
                <div id="ts-modal-content" class="bg-gray-800 p-3 rounded-xl shadow-2xl w-full max-w-md">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-semibold">Pengaturan Trailing Stop</h3>
                        <button id="ts-modal-close-btn" class="text-gray-400 hover:text-white">&times;</button>
                    </div>
                    <div class="space-y-4">
                        <div class="form-group">
                            <label for="ts-modal-callback-rate">Callback Rate (%)</label>
                            <input type="number" id="ts-modal-callback-rate" class="input-field" placeholder="cth: 0.5">
                        </div>
                        <div class="form-group">
                            <label for="ts-modal-activation-price">Harga Aktivasi ($)</label>
                            <input type="number" id="ts-modal-activation-price" class="input-field" placeholder="cth: 65000">
                        </div>
                    </div>
                    <div class="mt-6 text-right">
                        <button id="ts-modal-save-btn" class="btn-primary">Simpan Pengaturan</button>
                    </div>
                </div>
            </div>
        </section>

        <section id="signal-log-analysis-section" class="card p-3">
            <button id="toggle-signal-log-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-xl font-semibold text-purple-400">🔬 Signal Log</h2>
                <svg id="toggle-signal-log-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>

            <p id="signal-log-asset-title" class="text-sm font-mono text-gray-400 mb-4 ml-1">
                -- [File: --]
            </p>

            <div id="signal-log-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-700 space-y-4">
                    <div class="flex justify-end mb-4">
                        <button id="clear-signal-log-btn" class="btn-secondary !text-xs !py-1 !px-3 !bg-red-600 hover:!bg-red-700">
                            Hapus Riwayat Log (AFT)
                        </button>
                    </div>

                    <div id="signal-summary-grid" class="grid grid-cols-2 md:grid-cols-4 gap-2 text-center">
                        <div><p class="text-xs text-gray-500">Total Sinyal (Long/Short)</p><p id="stat-total-count" class="font-mono font-semibold text-lg text-white">0 (0/0)</p></div>
                        <div><p class="text-xs text-gray-500">Durasi Rata-rata</p><p id="stat-mean-duration" class="font-mono font-semibold text-lg text-yellow-400">00m 00s</p></div>
                        <div><p class="text-xs text-gray-500">Durasi Terlama</p><p id="stat-longest-duration" class="font-mono font-semibold text-lg positive">00m 00s</p></div>
                        <div><p class="text-xs text-gray-500">Rasio Stabilitas (Std. Dev)</p><p id="stat-std-dev" class="font-mono font-semibold text-lg text-blue-400">0.00s</p></div>
                    </div>

                    <div id="signal-log-history-container" class="mt-4">
                        <h3 class="text-sm font-semibold text-gray-400 mb-2">Log Siklus Sinyal (Durasi > 1s)</h3>
                        <div class="overflow-x-auto p-2 bg-gray-900/50 rounded-md">
                            <table class="min-w-full text-xs text-left text-gray-400">
                                <thead class="text-gray-400 uppercase bg-gray-700/50">
                                    <tr>
                                        <th scope="col" class="px-3 py-1">TIPE</th><th scope="col" class="px-3 py-1">DURASI</th>
                                        <th scope="col" class="px-3 py-1">SKOR AKHIR</th><th scope="col" class="px-3 py-1">BERAKHIR KARENA</th>
                                    </tr>
                                </thead>
                                <tbody id="signal-log-history-body">
                                    <tr class="text-center"><td colspan="4" class="py-2 text-gray-600">Tidak ada siklus sinyal tercatat.</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <section id="weather-forecast-section" class="card p-3 hidden">
            <button id="toggle-forecast-btn" class="w-full flex justify-between items-center text-left mb-4">
                <h2 class="text-xl font-semibold">Monte Carlo Simulation</h2>
                <svg id="toggle-forecast-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <div id="forecast-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                    <div class="flex items-center space-x-4">
                        <label for="forecast-trade-count" class="text-gray-400">Proyeksikan untuk</label>
                        <input type="number" id="forecast-trade-count" value="50" class="input-primary w-24 text-center">
                        <span class="text-gray-400">trade ke depan</span>
                        <button id="run-live-projection-btn" class="btn-primary flex-grow">Jalankan Proyeksi</button>
                    </div>
                    <div id="forecast-chart-container" class="mt-4">
                        <canvas id="forecast-chart"></canvas>
                    </div>
                    <div id="forecast-results" class="calc-result-grid mt-4">
                        <span>Modal Awal Proyeksi</span><span id="forecast-start-equity" class="text-right font-semibold">--</span>
                        <span>Potensi PNL Rata-rata</span><span id="forecast-avg-pnl" class="text-right font-semibold">--</span>
                        <span>Probabilitas Loss</span><span id="forecast-loss-prob" class="text-right font-semibold">--</span>
                        <span>Worst Case (5%)</span><span id="forecast-worst-case" class="text-right font-semibold">--</span>
                    </div>
                </div>
            </div>
        </section>
    </main>
<div id="aft-filter-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
    <div class="bg-gray-800 p-3 rounded-xl shadow-2xl w-full max-w-2xl relative max-h-[95vh] m-auto">
        
        <div class="flex justify-between items-center mb-4 pr-8">
            <h3 class="text-lg font-semibold text-yellow-400">Auto Trade Settings (Risk Management)</h3>
            <button id="close-aft-filter-btn" class="text-gray-400 hover:text-white text-3xl absolute top-2 right-2 p-2 leading-none">&times;</button>
        </div>

        <div class="overflow-y-auto max-h-[85vh] pr-3">

            <div class="mb-6 pb-4 border-b border-gray-700">
                <h4 class="font-semibold text-base mb-3">Filter Stabilitas Rezim AI (Fase 2)</h4>
                <div class="flex gap-2">
                    <label class="flex-1 p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="regime-filter-mode" value="REAKTIF" class="form-radio" checked>
                        <span class="ml-2 font-semibold">Reaktif (Tanpa Filter)</span>
                        <p class="text-xs text-gray-400 mt-1">Masuk posisi segera setelah sinyal muncul, mengabaikan stabilitas rezim AI.</p>
                    </label>
                    <label class="flex-1 p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="regime-filter-mode" value="KONFIRMASI" class="form-radio">
                        <span class="ml-2 font-semibold text-yellow-400">Konfirmasi (Filter Ketat)</span>
                        <p class="text-xs text-gray-400 mt-1">Memerlukan mayoritas 3 dari 4 prediksi rezim terakhir selaras dengan sinyal.</p>
                    </label>
                </div>
            </div>
            <div class="mb-6 pb-4 border-b border-gray-700">
                <h4 class="font-semibold text-base mb-3">Mode Eksekusi Entri</h4>
                <div class="flex gap-2">
                    <label class="flex-1 p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="entry-mode" value="AGRESIF" class="form-radio" checked>
                        <span class="ml-2 font-semibold">Agresif</span>
                        <p class="text-xs text-gray-400 mt-1">Masuk di harga pasar saat sinyal muncul. Cepat, tapi berisiko mendapat harga kurang ideal.</p>
                    </label>
                    <label class="flex-1 p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="entry-mode" value="PRESISI" class="form-radio">
                        <span class="ml-2 font-semibold">Presisi</span>
                        <p class="text-xs text-gray-400 mt-1">Menunggu harga pasar menyentuh rekomendasi `Entry`. Lebih aman, tapi berisiko ketinggalan.</p>
                    </label>
                </div>
            </div>
            
            <div class="mb-6 pb-4 border-b border-gray-700">
                <h4 class="font-semibold text-base mb-3">Position Sizing Mode</h4>
                <div class="grid grid-cols-2 gap-2">
                    <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="sizing-mode" value="RISK_BASED" class="form-radio" checked>
                        <span class="ml-2 font-semibold text-red-400">Risk-Based (2%)</span>
                        <p class="text-xs text-gray-400 mt-1">Sistem akan menyesuaikan modal agar risiko kerugian SL hanya 2% dari Equity.</p>
                    </label>
                    <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="sizing-mode" value="FIXED_MARGIN" class="form-radio">
                        <span class="ml-2 font-semibold text-yellow-400">Fixed Margin (10%)</span>
                        <p class="text-xs text-gray-400 mt-1">Menggunakan 10% dari Equity sebagai modal, mengabaikan jarak Stop Loss.</p>
                    </label>
                </div>
            </div>
            <div class="mb-6 pb-4 border-b border-gray-700">
                <h4 class="font-semibold text-base mb-3">Trailing Stop (TS) Mode</h4>
                <div class="grid grid-cols-3 gap-2">
                    <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="ts-mode" value="PERCENTAGE" class="form-radio">
                        <span class="ml-2 font-semibold">Persentase</span>
                        <p class="text-xs text-gray-400 mt-1">TS mengikuti harga puncak/lembah dengan jarak persentase tetap (Callback Rate).</p>
                    </label>
                    <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="ts-mode" value="ATR" class="form-radio" checked>
                        <span class="ml-2 font-semibold text-blue-400">ATR</span>
                        <p class="text-xs text-gray-400 mt-1">TS menjaga jarak berdasarkan 1.5x nilai volatilitas (ATR) terakhir. Adaptif terhadap pasar.</p>
                    </label>
                    <label class="p-3 border border-gray-600 rounded-lg cursor-pointer hover:bg-gray-700">
                        <input type="radio" name="ts-mode" value="PSAR" class="form-radio">
                        <span class="ml-2 font-semibold text-purple-400">PSAR</span>
                        <p class="text-xs text-gray-400 mt-1">TS menggunakan titik Parabolic SAR sebagai level stop. Efektif untuk mengikuti momentum.</p>
                    </label>
                </div>
            </div>
            <div>
                <h4 class="font-semibold text-base mb-3">Filter Strategi Aktif</h4>
                <div class="grid grid-cols-2 gap-x-8 gap-y-2 text-sm">
                    <div class="space-y-2">
                        <h4 class="font-semibold border-b border-gray-600 pb-1">STRATEGI LONG</h4>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG FOLLOW TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Follow Trend</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG COUNTER TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Counter Trend</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG REVERSION" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Mean Reversion</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG BREAKOUT SETUP" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Breakout</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="LONG BIAS (STATIC)" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Static Bias</span></label>
                    </div>
                    <div class="space-y-2">
                        <h4 class="font-semibold border-b border-gray-600 pb-1">STRATEGI SHORT</h4>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT FOLLOW TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Follow Trend</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT COUNTER TREND" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Counter Trend</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT REVERSION" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Mean Reversion</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT BREAKOUT SETUP" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Breakout</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="checkbox" value="SHORT BIAS (STATIC)" class="aft-strategy-filter form-checkbox h-4 w-4 bg-gray-700 border-gray-600 text-yellow-500" checked><span>Static Bias</span></label>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script>
// ===================================================================
// BAGIAN 1: DEKLARASI VARIABEL GLOBAL & STATE APLIKASI
// ===================================================================
    let nextFundingTimestamp = 0;
    let isFibRetracementVisible = false; // Default untuk menampilkan Extension
    let lastUsedApiMode = false; // false = Offline, true = Online
    let latencyInterval = null;
    let binanceApiKeys = { key: 'PROXY_KEY_ACTIVE', secret: 'PROXY_SECRET_ACTIVE' };
    let liveData = null; 
    const userSettings = {
            presets: {
                'default': { weights: { ma: 2, rsiDivergence: 2.5, macd: 2, pivot: 2, vwap: 2, ichimoku: 3, candlePattern: 1.5, obvDivergence: 3.0, bbSqueeze: 1.5, psar: 1, roc: 1, bollingerBands: 1, rsi: 1.5, stoch: 1, linreg: 1 } },
            }
    };
    let liveWebSocket = null;
    let orderFlowSocket = null;
    let liveInterval = null;
    let currentChartTimeframe = '5m';
    let htfTrend = 'NEUTRAL';
    let latestSignalSetup = null;
    let currentMarketPrice = 0;
    let precisionMap = {};   
    let isChartsVisible = false;
    let charts = [];
    let candlestickSeries = null;
    let volumeSeries = null;
    let rsiSeries = null;
    let stochKSeries = null;
    let stochDSeries = null;
    let macdLineSeries = null;
    let signalLineSeries = null;
    let macdHistSeries = null;
    let ema21Series = null;
    let ema50Series = null;
    let forecastChart;
    let signalStartTime = null; 
    let timeElapsedInterval = null; 
    let lastStableSignal = 'NONE';
    let signalActiveStartTime = null;
    let activeDnaFilename = '--';
    let regimeSensorModel = null;
    let activeStrategy = {
        dnaType: 'Static_v1',
        weights: userSettings.presets.default.weights, // Default Weights
        autoWeights: null, // Untuk DNA AutoSwitch_v1
        // 🔥 TAMBAHAN KRUSIAL: Default metadata dan parameters
        metadata: {
            dnaType: 'Static_v1',
            sourceAsset: 'BTCUSDT',
            sourceTimeframe: '5m',
            filename: 'DEFAULT_PRESET.json'
        },
        parameters: {
            riskRewardRatio: 1.5,
            pullbackEmaPeriod: 13,
            biasThreshold: 10.0,
            atrFilterThreshold: 0.0,
            swingLookback: 20
        }
    };
    let regimeMemory = ['RANGING', 'RANGING', 'RANGING', 'RANGING'];
    let lastAiUpdate = 0; 
    let lastMarketStructureUpdate = 0; 
    
    const AI_UPDATE_INTERVAL_MS = 60000; // 1 menit
    const MS_UPDATE_INTERVAL_MS = 30000; // 30 detik
    const REGIME_MEMORY_SIZE = 4;
    const dnaStatusDisplay = document.getElementById('dna-status-display');
    const aiStatusDisplay = document.getElementById('ai-status');
    const activeRegimeDisplay = document.getElementById('active-regime-display');
    const REGIME_LABELS = ['BULL_TREND', 'BEAR_TREND', 'RANGING', 'LOW_VOLATILITY'];
    const importFile = document.getElementById('import-file');
    const importedStrategySection = document.getElementById('imported-strategy-section');
    const importedSinyalPanel = document.getElementById('imported-sinyal-panel');
    const liveSymbolInput = document.getElementById('live-symbol-input');
    const liveTimeframeSelect = document.getElementById('live-timeframe-select');
    const startLiveBtn = document.getElementById('start-live-btn');
    const liveDataInputSection = document.getElementById('live-data-input-section');
    const liveSignalPanel = document.getElementById('live-signal-panel');
    const startLiveText = startLiveBtn.querySelector('span');
    const startLiveLoader = startLiveBtn.querySelector('.loader');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');

    const paperTradeElements = {
        equity: document.getElementById('sim-equity'),
        unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
        availableMargin: document.getElementById('sim-available-margin'),
        resetBtn: document.getElementById('sim-reset-account-btn'),
        positionContainer: document.getElementById('sim-active-position-container'),
        positionHeader: document.getElementById('sim-position-header'),
        closePositionBtn: document.getElementById('sim-close-position-btn'),
        positionSize: document.getElementById('sim-position-size'),
        positionEntry: document.getElementById('sim-position-entry'),
        positionMark: document.getElementById('sim-position-mark'),
        positionLiq: document.getElementById('sim-position-liq'),
        positionPnl: document.getElementById('sim-position-pnl'),
        tradeHistoryList: document.getElementById('sim-trade-history-list'),
        exportBtn: document.getElementById('sim-export-btn'),
        importBtn: document.getElementById('sim-import-btn'),
        importInput: document.getElementById('sim-import-input')
    };
    const tsCalcElements = {
        leverage: document.getElementById('ts-leverage'),
        cost: document.getElementById('ts-cost'),
        slider: document.getElementById('ts-margin-slider'),
        walletBalance: document.getElementById('ts-wallet-balance'),
        marketPrice: document.getElementById('ts-market-price'),
        tpslToggle: document.getElementById('ts-tpsl-toggle'),
        tpslInputs: document.getElementById('ts-tpsl-inputs'),
        takeProfit: document.getElementById('ts-take-profit'),
        stopLoss: document.getElementById('ts-stop-loss'),
        resultCost: document.getElementById('ts-result-cost'),
        resultMax: document.getElementById('ts-result-max'),
        resultPosSize: document.getElementById('ts-result-position-size'),
        resultLiqPrice: document.getElementById('ts-result-liq-price'),
        resultStatus: document.getElementById('ts-result-status'),
        resultSlPrice: document.getElementById('ts-result-sl-price'),
        resultRoe: document.getElementById('ts-result-roe'),
        crossBtn: document.getElementById('ts-mode-cross'),
        isolatedBtn: document.getElementById('ts-mode-isolated'),
        buyBtn: document.getElementById('ts-buy-long-btn'),
        sellBtn: document.getElementById('ts-sell-short-btn'),
        autofillBtn: document.getElementById('autofill-ts-btn'),
        tsOptionsBtn: document.getElementById('ts-trailing-stop-options'),
        modalContainer: document.getElementById('ts-modal-container'),
        modalCallbackRate: document.getElementById('ts-modal-callback-rate'),
        modalActivationPrice: document.getElementById('ts-modal-activation-price'),
        modalSaveBtn: document.getElementById('ts-modal-save-btn'),
        modalCloseBtn: document.getElementById('ts-modal-close-btn')
    };
    const TIMEFRAME_MAP_MS = {
        '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
        '1h': 3600000, '4h': 14400000, '1d': 86400000
     };    
    const timeframeParameterMap = {
        '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };    
    const realtimeCache = {
        main: {
            symbol: null,
            tickerData: {},
            latestScalpingSetup: null
        },
        indicators: {
            bullScore: 0,
            bearScore: 0,
            htfTrend: 'NEUTRAL',
            atr: 0,
            entryPrice: null, 
            stopLoss: null,
            tp1: null,
            tp2: null 
        }
    };
    const paperTrade = {
            state: {
                balance: 1000,
                position: null,
                history: [],
                ts: {
                    enabled: true,          // Aktifkan TS secara default
                    callbackRate: 0.8,      // Jarak TS dari harga puncak (0.8%)
                    activationProfit: 0.5   // TS baru aktif setelah profit mencapai 0.5%
                }
            },
            elements: {
                equity: document.getElementById('sim-equity'),
                unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
                availableMargin: document.getElementById('sim-available-margin'),
                resetBtn: document.getElementById('sim-reset-account-btn'),
                positionContainer: document.getElementById('sim-active-position-container'),
                positionHeader: document.getElementById('sim-position-header'),
                closePositionBtn: document.getElementById('sim-close-position-btn'),
                positionSize: document.getElementById('sim-position-size'),
                positionEntry: document.getElementById('sim-position-entry'),
                positionMark: document.getElementById('sim-position-mark'),
                positionLiq: document.getElementById('sim-position-liq'),
                positionPnl: document.getElementById('sim-position-pnl'),
                
                tradeHistoryList: document.getElementById('sim-trade-history-list'),
            },
            init: function() {
                //this.loadState();
                this.elements.resetBtn.addEventListener('click', () => this.resetAccount());
                this.elements.closePositionBtn.addEventListener('click', () => this.closePosition());
                
                const importBtn = document.getElementById('sim-import-btn');
                const importInput = document.getElementById('sim-import-input');
                document.getElementById('sim-export-btn').addEventListener('click', exportHistoryToCSV);
                importBtn.addEventListener('click', () => importInput.click());
                importInput.addEventListener('change', importHistoryFromCSV);
                
                setInterval(() => this.update(), 500);
                this.render();
            },
            syncAccountState: async function() {
                if (binanceApiKeys.key && binanceApiKeys.secret) {
                    try {
                        // 1. Ambil data Akun (Balance)
                        const accountData = await sendBinanceRequest('GET', '/account', true, null);
                        const positionData = await sendBinanceRequest('GET', '/positionRisk', true, null);
                        // Asumsi: Kita hanya tertarik pada aset USDT
                        const usdtBalance = accountData.assets.find(a => a.asset === 'USDT');
                        
                        // Pastikan variabel diupdate di objek 'this' (paperTrade)
                        this.equity = parseFloat(usdtBalance.walletBalance);
                        this.availableMargin = parseFloat(usdtBalance.availableBalance);
                        
                        // Hitung total Unrealized PNL dari semua posisi
                        let totalUnrealizedPnl = positionData.reduce((sum, pos) => {
                            return sum + parseFloat(pos.unrealizedProfit);
                        }, 0);

                        // --- LOGIKA FAIL-SAFE (LIQUIDATION CHECK) 🔥 ---
                        const minBalanceThreshold = 1.00; // Batas Minimum ($1.00)
                        
                        if (this.availableMargin <= minBalanceThreshold) {
                            
                            // 🚨 Peringatan dan Fallback ke Simulasi
                            alert(`🚨 AKUN LIKUIDASI/SALDO KOSONG! Margin Tersedia ($${this.availableMargin.toFixed(2)}) di bawah $${minBalanceThreshold.toFixed(2)}. Trading LIVE dihentikan. Beralih ke mode SIMULASI.`);

                            // Hentikan interval Live Trade
                            if (window.syncInterval) clearInterval(window.syncInterval);
                            if (window.liveInterval) clearInterval(window.liveInterval);

                            // Panggil fungsi Fallback (asumsi fungsi ini sudah Anda tambahkan)
                            fallbackToSimulationMode(); 
                            
                            return; // Hentikan fungsi sinkronisasi lebih lanjut
                        }
                        // --- AKHIR LOGIKA FAIL-SAFE ---


                        // 2. Update status posisi (Untuk dashboard)
                        this.positions = positionData
                            .filter(pos => parseFloat(pos.positionAmt) !== 0)
                            .map(pos => ({
                                symbol: pos.symbol,
                                entryPrice: parseFloat(pos.entryPrice),
                                positionAmt: parseFloat(pos.positionAmt),
                                unrealizedPnl: parseFloat(pos.unrealizedProfit),
                                // ... tambahkan data posisi lain yang Anda butuhkan
                            }));
                        
                        // 3. Update UI (Angka-angka di dashboard)
                        document.getElementById('sim-equity').textContent = `$${this.equity.toFixed(2)}`;
                        document.getElementById('sim-unrealized-pnl').textContent = `$${totalUnrealizedPnl.toFixed(2)}`;
                        document.getElementById('sim-available-margin').textContent = `$${this.availableMargin.toFixed(2)}`;


                    } catch (error) {
                        console.error("Error syncing account state. Check API Keys/Connectivity:", error);
                        // Tambahkan error handling visual jika gagal koneksi
                        document.getElementById('api-status-text').textContent = 'ERROR (Check API)';
                    }
                }
            },
            // Fungsi ini HANYA bertugas mengirim order OPEN ke Binance
            executeApiOpen: async function(tradeType, leverage, cost, entryPrice) {
                const symbol = realtimeCache.main.symbol;
                const side = (tradeType === 'long') ? 'BUY' : 'SELL';
                const quantity = (cost * leverage) / entryPrice;
                const symbolInfo = precisionMap[symbol]; 
                const quantityPrecision = symbolInfo ? symbolInfo.quantityPrecision : 3;
                if (parseFloat(quantity.toFixed(quantityPrecision)) === 0) {
                    console.error("❌ GAGAL MEMBUKA POSISI: Quantity yang dihitung SANGAT KECIL atau NOL. Order dihentikan secara lokal.");
                    alert("GAGAL MEMBUKA POSISI: Kuantitas Order Nol. Periksa modal atau leverage Anda.");
                    return; 
                }
                const orderParams = {
                    symbol: symbol, side: side, type: 'MARKET',
                    quantity: quantity.toFixed(quantityPrecision)
                };

                try {
                    console.log(`🚀 MENGIRIM ORDER OPEN ${side} KE BINANCE...`, orderParams);
                    const orderResponse = await sendBinanceRequest('POST', '/v1/order', orderParams);
                    console.log('✅ RESPON BINANCE (OPEN):', orderResponse);
                    // Sinkronisasi akan dipanggil oleh interval, jadi tidak perlu di sini
                } catch (error) {
                    console.error("❌ GAGAL MEMBUKA POSISI API:", error);
                    alert(`GAGAL MEMBUKA POSISI API: ${error.message}`);
                }
            },

            // Fungsi ini HANYA bertugas mengirim order CLOSE ke Binance
            executeApiClose: async function() {
                const pos = this.state.position;
                if (!pos) return;

                const orderParams = {
                    symbol: pos.symbol,
                    side: (pos.type === 'long') ? 'SELL' : 'BUY',
                    type: 'MARKET',
                    quantity: pos.quantity.toFixed(precisionMap[pos.symbol] || 3),
                    reduceOnly: 'true'
                };

                try {
                    console.log(`⏹️ MENGIRIM ORDER CLOSE KE BINANCE...`, orderParams);
                    const orderResponse = await sendBinanceRequest('POST', '/v1/order', orderParams);
                    console.log('✅ RESPON BINANCE (CLOSE):', orderResponse);
                } catch (error) {
                    console.error("❌ GAGAL MENUTUP POSISI API:", error);
                    alert(`GAGAL MENUTUP POSISI API: ${error.message}`);
                }
            },

            openPosition: function(type, leverage, cost, entryPrice, tp1, tp2, flag = 'Manual', signalPrice, biasStatus = 'N/A') {
                
                // 1. Pengecekan Saldo untuk Mode LIVE
                if (lastUsedApiMode) {
                    // Cek saldo riil yang sudah di-sync (availableMargin)
                    if (this.availableMargin <= 0.01) { 
                        alert("🚨 SALDO RIIL NOL atau KRITIS. Tidak dapat membuka posisi Live Trade.");
                        // Fail-safe untuk mencegah open di kondisi kritis
                        if (window.syncInterval) clearInterval(window.syncInterval);
                        if (window.liveInterval) clearInterval(window.liveInterval);
                        fallbackToSimulationMode();
                        return;
                    }
                    
                    // Mode ONLINE: Panggil eksekutor API
                    // KRUSIAL: Panggil fungsi GLOBAL executeApiOpen (tanpa 'this.')
                    executeApiOpen(type, leverage, cost, entryPrice); 
                    return; // Hentikan di sini, sinkronisasi akan menangani update state
                }
                
                // --- Jika kode sampai di sini, artinya kita di MODE OFFLINE/SIMULASI ---

                // Jika kode sampai di sini, artinya kita di MODE OFFLINE
                if (this.state.position) {
                    console.warn("Posisi baru diblokir, posisi lama masih aktif.");
                    return;
                }
                if (cost > this.state.balance) {
                    alert("Modal tidak cukup.");
                    return;
                }

                const positionSize = cost * leverage;
                const quantity = entryPrice > 0 ? positionSize / entryPrice : 0;
                const maintenanceMarginRate = 0.005; 
                
                // 🔥 MODIFIKASI KRUSIAL: Selalu gunakan SELURUH saldo (this.state.balance) 
                // sebagai margin untuk mensimulasikan Cross Margin (DEFAULT AFT)
                const marginUsedForLiq = this.state.balance; 
                
                const liqPriceChange = (marginUsedForLiq / positionSize) * (1 - maintenanceMarginRate);
                
                const liqPrice = type === 'long' 
                    ? entryPrice * (1 - liqPriceChange) 
                    : entryPrice * (1 + liqPriceChange);
                
                // Asumsi SL awal adalah SL struktural dari setup
                const slPrice = (type === 'long') 
                    ? (realtimeCache.main.latestScalpingSetup?.sl.price || 0) 
                    : (realtimeCache.main.latestScalpingSetup?.sl.price || 0);

                this.state.balance -= cost;
                this.state.position = {
                    type: type,
                    entryPrice: entryPrice,
                    signalPrice: signalPrice,
                    quantity: quantity,
                    leverage: leverage,
                    cost: cost,
                    liqPrice: liqPrice,
                    sl: slPrice, // SL awal disetel ke SL struktural
                    tp1: tp1,
                    tp2: tp2,
                    tp1Hit: false,
                    flag: flag,
                    symbol: realtimeCache.main.symbol,
                    biasStatus: biasStatus,
                    trailingStopPrice: type === 'long' ? 0 : 99999999,
                    highestMarkPrice: entryPrice,
                    lowestMarkPrice: entryPrice,
                    isSafe: false, 
                };
                
                // 🔥 LOG BARU UNTUK OPEN POSITION
                console.log(`🚀 OPEN: Posisi ${type.toUpperCase()} ${flag} (${leverage}x) dibuka pada ${formatPrice(entryPrice)}. Modal: ${formatDollar(cost)}.`);
                
                this.saveState();
                this.render();
            },
            partialClosePosition: function(percentageToClose, closeReason = 'AFT - TP1 Hit') {
                const pos = this.state.position;
                if (!pos) return;

                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                const quantityToClose = pos.quantity * percentageToClose;
                const pnl = (pos.type === 'long' ? (markPrice - pos.entryPrice) : (pos.entryPrice - markPrice)) * quantityToClose;
                
                // Kembalikan modal & profit ke balance
                const costToReturn = pos.cost * percentageToClose;
                this.state.balance += (costToReturn + pnl);

                // Tambahkan ke history sebagai trade parsial
                this.state.history.unshift({
                    symbol: pos.symbol, type: pos.type, entryPrice: pos.entryPrice,
                    closePrice: markPrice, pnl: pnl, roe: (pnl / costToReturn) * 100,
                    closedAt: new Date(), flag: 'AFT_PARTIAL', closeReason: closeReason
                });
                
                // Kurangi ukuran posisi yang tersisa
                pos.quantity -= quantityToClose;
                pos.cost -= costToReturn;

                console.log(`✅ PARTIAL CLOSE: ${percentageToClose*100}% posisi ditutup di ${formatPrice(markPrice)}. PNL: ${formatPrice(pnl)}`);
                
                this.saveState();
                this.render();
            },
            moveStopLossToBreakEven: function() {
                const pos = this.state.position;
                if (!pos) return;
                pos.sl = pos.entryPrice;
                console.log(`🔒 RISK-FREE: Stop Loss dipindahkan ke Break-Even (${formatPrice(pos.entryPrice)})`);
                this.saveState();
            },
            closePosition: function(closeReason = 'Manual') { 
                // --- HYBRID LOGIC ---
                if (lastUsedApiMode) {
                    // Mode ONLINE: Panggil eksekutor API
                    this.executeApiClose();
                    return; // Hentikan di sini, sinkronisasi akan menangani update state
                }
                // --- END HYBRID LOGIC ---

                // Jika kode sampai di sini, artinya kita di MODE OFFLINE
                if (!this.state.position) return;
                
                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) {
                    console.warn("Tidak bisa menutup posisi, harga pasar tidak tersedia.");
                    return;
                }
                
                const pos = this.state.position;
                const pnl = (pos.type === 'long') 
                    ? (markPrice - pos.entryPrice) * pos.quantity 
                    : (pos.entryPrice - markPrice) * pos.quantity;

                const slippage = (pos.type === 'long')
                    ? (pos.entryPrice - pos.signalPrice)
                    : (pos.signalPrice - pos.entryPrice);

                let finalPnl = pnl;
                let liquidated = false;
                let finalRoe;
                
                // 🔥 LOGIKA BATASAN KERAS (HARD CAP) UNTUK MENCEGAH EQUITY NEGATIF
                const futureEquity = this.state.balance + finalPnl; 
                
                if (futureEquity < 0) {
                    // Jika hasil penutupan membuat saldo negatif, asumsikan total loss 100% modal
                    const maxLoss = pos.cost; 
                    finalPnl = -maxLoss; // PNL maks adalah modal yang dialokasikan
                    liquidated = true;
                    closeReason = 'SIM_LIQUIDATION_CAP'; // Alasan penutupan
                    
                    // Log di console untuk LIQUIDATION CAPPED
                    console.log(`❌ LIQUIDATED (CAPPED): Posisi ${pos.type.toUpperCase()} Capped. Total Loss: ${formatDollar(maxLoss)}. Alasan: ${closeReason}`);
                    
                    this.state.balance -= maxLoss; // Hanya kurangi modal yang dialokasikan
                } else {
                    // Logika normal jika tidak membuat saldo negatif
                    this.state.balance += (pos.cost + finalPnl);
                    
                    // Log di console untuk penutupan normal
                    finalRoe = (finalPnl / pos.cost) * 100;
                    console.log(`⏹️ CLOSED: Posisi ${pos.type.toUpperCase()} ditutup di ${formatPrice(markPrice)}. PNL: ${formatDollar(finalPnl)} (${finalRoe.toFixed(2)}%). Alasan: ${closeReason}`);
                }
                
                // Hitung ROE akhir untuk disimpan ke History
                finalRoe = (finalPnl / pos.cost) * 100;

                this.state.history.unshift({
                    symbol: realtimeCache.main.symbol,
                    type: pos.type,
                    entryPrice: pos.entryPrice,
                    closePrice: markPrice,
                    pnl: finalPnl,
                    roe: finalRoe,
                    slippage: slippage,
                    closedAt: new Date(),
                    liquidated: liquidated, // Set status liquidated
                    flag: pos.flag,
                    biasStatus: pos.biasStatus || 'N/A',
                    closeReason: closeReason 
                });
                
                if (this.state.history.length > 20) this.state.history.pop();

                this.state.position = null;
                this.saveState();
                this.render();
            },
            checkTrailingStop: function() {
                const pos = this.state.position;
                const tsConfig = this.state.ts;

                // Keluar jika TS tidak aktif, tidak ada posisi, atau callback rate 0
                if (!pos || !tsConfig.enabled || !tsConfig.callbackRate) return null;

                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                const isLong = pos.type === 'long';
                const profitPercent = ((markPrice - pos.entryPrice) / pos.entryPrice) * (isLong ? 1 : -1) * 100;

                // 1. Cek Aktivasi: TS hanya berjalan jika profit sudah melampaui ambang batas aktivasi
                if (profitPercent < tsConfig.activationProfit) {
                    return null; // Belum profit cukup, TS belum aktif
                }

                // 2. Tentukan Harga Puncak/Lembah Terbaru
                const extremumPrice = isLong ? pos.highestMarkPrice : pos.lowestMarkPrice;

                // 3. Hitung Stop Price Dinamis Berdasarkan Callback Rate
                const callbackAmount = extremumPrice * (tsConfig.callbackRate / 100);
                const dynamicStopPrice = isLong ? extremumPrice - callbackAmount : extremumPrice + callbackAmount;

                // 4. Perbarui Trailing Stop Price Internal Jika Harga Bergerak Menguntungkan
                if (isLong && dynamicStopPrice > pos.trailingStopPrice) {
                    pos.trailingStopPrice = dynamicStopPrice;
                } else if (!isLong && dynamicStopPrice < pos.trailingStopPrice) {
                    pos.trailingStopPrice = dynamicStopPrice;
                }

                // 5. Cek Pemicu Stop Loss
                if ((isLong && markPrice <= pos.trailingStopPrice) || (!isLong && markPrice >= pos.trailingStopPrice)) {
                    console.log(`🚨 TRAILING STOP HIT! Mark: ${markPrice.toFixed(4)}, TS Price: ${pos.trailingStopPrice.toFixed(4)}`);
                    return 'TRAILING_STOP_HIT';
                }

                return null; // TS belum terpicu
            },
            update: function() {
                const pos = this.state.position;
                if (!pos) {
                    this.render(); 
                    return;
                }

                if (pos.symbol !== realtimeCache.main.symbol) {
                    return;
                }

                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) return;

                const isLong = pos.type === 'long';
                const pnl = (pos.type === 'long') 
                    ? (markPrice - pos.entryPrice) * pos.quantity 
                    : (pos.entryPrice - markPrice) * pos.quantity;
                const profitPercent = (pnl / pos.cost) * 100;

                if (isLong) {
                    pos.highestMarkPrice = Math.max(pos.highestMarkPrice || pos.entryPrice, markPrice);
                } else {
                    pos.lowestMarkPrice = Math.min(pos.lowestMarkPrice || pos.entryPrice, markPrice);
                }

                const BE_THRESHOLD = 0.5;
                if (!pos.isSafe && profitPercent >= BE_THRESHOLD) {
                    this.moveStopLossToBreakEven();
                    const tsConfig = this.state.ts;
                    console.log(`🔒 TS AKTIF: Posisi mencapai ${BE_THRESHOLD}% profit. Trailing Stop (${tsConfig.callbackRate}%) mulai berjalan dari harga puncak/lembah.`);
                    pos.isSafe = true;
                    this.saveState();
                }

                if (!pos.tp1Hit && pos.tp1 && ((isLong && markPrice >= pos.tp1) || (!isLong && markPrice <= pos.tp1))) {
                    this.partialClosePosition(0.5); 
                    pos.tp1Hit = true; 
                    this.saveState();
                }

                const selectedTsMode = document.querySelector('input[name="ts-mode"]:checked')?.value || 'PERCENTAGE';
                if (pos.isSafe) { 
                    let dynamicStopPrice = 0;
                    const extremumPrice = isLong ? pos.highestMarkPrice : pos.lowestMarkPrice;
                    if (selectedTsMode === 'ATR') {
                        const klinesSnapshot = liveData.slice(-50);
                        const atrValue = calculateATR(klinesSnapshot, 14).value;
                        const atrMultiplier = 1.5;
                        if (atrValue > 0) {
                            dynamicStopPrice = isLong ? extremumPrice - (atrValue * atrMultiplier) : extremumPrice + (atrValue * atrMultiplier);
                        }
                    } else if (selectedTsMode === 'PSAR') {
                        const klinesSnapshot = liveData.slice(-50);
                        const psarData = calculateParabolicSAR(klinesSnapshot);
                        if (psarData && typeof psarData.value === 'number') {
                            dynamicStopPrice = psarData.value;
                        }
                    } else {
                        const tsConfig = this.state.ts;
                        const callbackAmount = extremumPrice * (tsConfig.callbackRate / 100);
                        dynamicStopPrice = isLong ? extremumPrice - callbackAmount : extremumPrice + callbackAmount;
                    }
                    if (dynamicStopPrice > 0) {
                        if ((isLong && dynamicStopPrice > pos.trailingStopPrice) || (!isLong && dynamicStopPrice < pos.trailingStopPrice)) {
                            pos.trailingStopPrice = dynamicStopPrice;
                        }
                    }
                    if ((isLong && markPrice <= pos.trailingStopPrice) || (!isLong && markPrice >= pos.trailingStopPrice)) {
                        this.closePosition(`AFT - TRAILING STOP (${selectedTsMode})`);
                        return;
                    }
                }

                const slHit = (isLong && markPrice <= pos.sl) || (!isLong && markPrice >= pos.sl);
                if (slHit) {
                    this.closePosition('AFT - STOP LOSS');
                    return;
                }
                const liquidated = (isLong && markPrice <= pos.liqPrice) || (!isLong && markPrice >= pos.liqPrice);
                if (liquidated) {
                    this.closePosition('LIQUIDATION');
                    return;
                }

                const currentBias = realtimeCache.main.latestScalpingSetup?.bias.status || 'NEUTRAL';
                const isReversalSignal = (isLong && currentBias.includes('SHORT')) || (!isLong && currentBias.includes('LONG'));
                if (isReversalSignal) {
                    this.closePosition('AFT - REVERSAL SIGNAL');
                    return;
                }

                const roe = (pnl / pos.cost) * 100;

                // PERBAIKAN: Gunakan formatPrice dengan simbol yang benar
                document.getElementById('sim-unrealized-pnl').textContent = formatPrice(pnl, pos.symbol);
                document.getElementById('sim-unrealized-pnl').className = pnl >= 0 ? 'positive font-mono font-semibold text-lg' : 'negative font-mono font-semibold text-lg';
                document.getElementById('sim-position-pnl').textContent = `${formatPrice(pnl, pos.symbol)} (${roe.toFixed(2)}%)`;
                document.getElementById('sim-position-pnl').className = pnl >= 0 ? 'positive font-mono font-semibold text-lg ml-2' : 'negative font-mono font-semibold text-lg ml-2';
                document.getElementById('sim-position-mark').textContent = formatPrice(markPrice, pos.symbol);

                this.saveState();
            },
            render: function() {
                const pos = this.state.position;
                
                // --- LOGIC RENDER SALDO & POSISI AKTIF (SAMA SEPERTI SEBELUMNYA) ---
                if (pos) {
                    const equity = this.state.balance + pos.cost;
                    this.elements.equity.textContent = formatDollar(equity);
                    this.elements.availableMargin.textContent = formatDollar(this.state.balance);
                    this.elements.positionContainer.classList.remove('hidden');
                    this.elements.positionHeader.textContent = `${pos.type.toUpperCase()} / ${pos.leverage}x`;
                    this.elements.positionHeader.className = `font-semibold text-lg ${pos.type === 'long' ? 'positive' : 'negative'}`;
                    this.elements.positionSize.textContent = formatPrice(pos.cost * pos.leverage);
                    this.elements.positionEntry.textContent = formatPrice(pos.entryPrice);
                    this.elements.positionLiq.textContent = formatPrice(pos.liqPrice);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-semibold text-lg text-gray-400';
                } else {
                    this.elements.equity.textContent = formatDollar(this.state.balance);
                    this.elements.availableMargin.textContent = formatDollar(this.state.balance);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-semibold text-lg text-gray-400';
                    this.elements.positionContainer.classList.add('hidden');
                }

                // --- LOGIC RENDER TRADE HISTORY (SAMA SEPERTI SEBELUMNYA) ---
                if (this.state.history && this.state.history.length > 0) {
                    this.elements.tradeHistoryList.innerHTML = this.state.history.map(trade => `
                        <div class="p-1.5 rounded-md ${trade.pnl >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'}">
                            <div class="flex justify-between items-center">
                                <div>
                                    <span class="${trade.type === 'long' ? 'positive' : 'negative'}">${trade.symbol} ${trade.type.toUpperCase()}</span>
                                    <span class="text-gray-400 text-[10px] ml-2">${trade.closedAt.toLocaleTimeString()}</span>
                                </div>
                                <div class="font-mono text-right ${trade.pnl >= 0 ? 'positive' : 'negative'}">
                                    ${formatDollar(trade.pnl)} (${trade.roe.toFixed(2)}%) ${trade.liquidated ? '🔥' : ''}
                                </div>
                            </div>
                            <div class="text-gray-400 text-[10px] font-mono flex justify-between mt-1 pt-1 border-t border-gray-700/50">
                                <span>Entry: ${formatPrice(trade.entryPrice)}</span>
                                <span>Close: ${formatPrice(trade.closePrice)}</span>
                                <span>Slippage: ${trade.slippage ? trade.slippage.toFixed(getPrecisionForAsset(trade.entryPrice)) : 'N/A'}</span>
                            </div>
                        </div>
                    `).join('');
                } else {
                    this.elements.tradeHistoryList.innerHTML = '<p class="text-center text-gray-600">No trade history yet.</p>';
                }
                
                // 🔥 KOREKSI KRITIS: PANGGIL METRIK DAN UPDATE DISPLAY KUANTITATIF DENGAN SAFETY CHECK 🔥
                const metrics = this.calculateMetrics();
                const hasTrades = metrics.totalTrades > 0;
                
                const pnlEl = document.getElementById('sim-result-pnl');

                if (hasTrades && pnlEl) {
                    // Jika ada trade, tampilkan data yang sudah dihitung
                    pnlEl.textContent = `${formatDollar(metrics.totalPnl)} (${metrics.pnlPercent.toFixed(2)}%)`;
                    pnlEl.className = `font-mono text-sm ${metrics.totalPnl >= 0 ? 'positive' : 'negative'}`;
                    
                    document.getElementById('sim-result-winrate').textContent = `${(metrics.winRate || 0).toFixed(2)}%`;
                    document.getElementById('sim-result-profit-factor').textContent = metrics.profitFactor === Infinity ? '∞' : (metrics.profitFactor || 0).toFixed(2);
                    document.getElementById('sim-result-total-trades').textContent = `${metrics.totalTrades}`;
                    
                    document.getElementById('sim-result-max-drawdown').textContent = `${(metrics.maxDrawdown || 0).toFixed(2)}%`;
                    
                    const expectancyEl = document.getElementById('sim-result-expectancy');
                    expectancyEl.textContent = `${(metrics.expectancy || 0).toFixed(2)} USD`;
                    expectancyEl.className = `${(metrics.expectancy || 0) >= 0 ? 'positive' : 'negative'} font-mono text-sm`;
                    
                    document.getElementById('sim-result-losing-streak').textContent = `${metrics.maxLosingStreak}`;
                } else if (pnlEl) {
                    // Jika TIDAK ADA TRADE, tampilkan placeholder ('--')
                    pnlEl.textContent = '--';
                    pnlEl.className = 'font-mono text-sm negative'; // Default ke negative/placeholder
                    document.getElementById('sim-result-winrate').textContent = '--';
                    document.getElementById('sim-result-profit-factor').textContent = '--';
                    document.getElementById('sim-result-total-trades').textContent = '--';
                    document.getElementById('sim-result-max-drawdown').textContent = '--';
                    document.getElementById('sim-result-expectancy').textContent = '--';
                    document.getElementById('sim-result-losing-streak').textContent = '--';
                }
                // 🔥 AKHIR KOREKSI 🔥
                // --- START MODIFIKASI FASE 4-B: TAMPILKAN PERFORMA STRATEGI ---
                const strategyPerformanceData = analyzeStrategyPerformance(this.state.history);
                const performanceBody = document.getElementById('strategy-performance-body');

                if (performanceBody) {
                    performanceBody.innerHTML = ''; // Kosongkan tabel dulu

                    if (Object.keys(strategyPerformanceData).length > 0) {
                        // Urutkan berdasarkan jumlah trade terbanyak
                        const sortedStrategies = Object.entries(strategyPerformanceData)
                            .sort(([, a], [, b]) => b.trades - a.trades);

                        sortedStrategies.forEach(([strategyName, stats]) => {
                            const pnlClass = stats.totalPnl > 0 ? 'positive' : (stats.totalPnl < 0 ? 'negative' : 'text-gray-400');
                            const row = document.createElement('tr');
                            row.className = 'border-b border-gray-800/50';
                            row.innerHTML = `
                                <td class="py-1 px-2 text-gray-300">${strategyName.replace(/LONG |SHORT /g, '')} <span class="${strategyName.includes('LONG') ? 'positive' : 'negative'}">(${strategyName.includes('LONG') ? 'L' : 'S'})</span></td>
                                <td class="py-1 px-2 text-center">${stats.trades}</td>
                                <td class="py-1 px-2 text-center">${stats.winRate.toFixed(1)}%</td>
                                <td class="py-1 px-2 text-right font-mono ${pnlClass}">${stats.totalPnl.toFixed(2)}</td>
                            `;
                            performanceBody.appendChild(row);
                        });
                    } else {
                        performanceBody.innerHTML = '<tr><td colspan="4" class="py-2 text-center text-gray-600">-- Data akan muncul setelah ada riwayat trade AFT --</td></tr>';
                    }
                }
                // --- AKHIR MODIFIKASI FASE 4-B ---
            },
            resetAccount: function(confirmFirst = true) { 
                const doReset = () => {
                    // Jika offline, reset ke 1000. Jika online, biarkan balance dari API.
                    // this.state.balance = 1000; // Baris ini bisa dihapus atau disesuaikan
                    this.state.position = null;
                    this.state.history = [];
                    this.saveState();
                    this.render();
                };

                if (confirmFirst) {
                    if (confirm("Apakah Anda yakin ingin mereset akun simulasi? Semua riwayat akan hilang.")) {
                        this.state.balance = 1000; // Saat reset manual, kembalikan ke 1000
                        doReset();
                    }
                } else {
                    // Saat dipanggil oleh sistem, jangan ubah balance, hanya reset posisi & histori
                    doReset();
                }
            },
            calculateMetrics: function() {
                const history = this.state.history.filter(t => !t.liquidated);
                if (history.length === 0) {
                    return { totalPnl: 0, winRate: 0, profitFactor: 0, totalTrades: 0, maxDrawdown: 0, expectancy: 0, maxLosingStreak: 0 };
                }

                let totalPnl = 0, grossProfit = 0, grossLoss = 0, wins = 0;
                
                // 🔥 FIX KRUSIAL: SALDO AWAL UNTUK PERHITUNGAN DRAWDOWN 🔥
                // Saldo awal adalah Saldo Akhir (this.state.balance) MINUS total PNL dari seluruh history.
                // Ini mengembalikan saldo ke titik sebelum trading dimulai, untuk perhitungan DD yang akurat.
                const totalPnlHistory = history.reduce((sum, trade) => sum + trade.pnl, 0);
                let initialBalance = (this.state.balance || 1000) - totalPnlHistory;
                initialBalance = Math.max(1, initialBalance); // Pastikan tidak negatif

                let equity = initialBalance;
                let peakEquity = equity;
                let maxDrawdown = 0;
                let losingStreak = 0, maxLosingStreak = 0;
                
                // Sortir history agar dari yang paling TUA ke TERBARU
                // (Penting untuk perhitungan Drawdown yang benar)
                const sortedHistory = [...history].reverse(); 

                sortedHistory.forEach(trade => {
                    const realizedPnl = trade.pnl;
                    
                    totalPnl += realizedPnl;
                    equity += realizedPnl; 
                    
                    peakEquity = Math.max(peakEquity, equity);
                    const drawdown = ((peakEquity - equity) / peakEquity) * 100;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);

                    if (realizedPnl > 0) {
                        grossProfit += realizedPnl;
                        wins++;
                        losingStreak = 0; 
                    } else {
                        grossLoss += Math.abs(realizedPnl);
                        losingStreak++;
                        maxLosingStreak = Math.max(maxLosingStreak, losingStreak);
                    }
                });

                const winRate = (wins / history.length) * 100;
                const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : Infinity;
                const expectancy = totalPnl / history.length;
                const pnlPercent = ((totalPnl / initialBalance) * 100);

                return {
                    totalPnl: totalPnl,
                    pnlPercent: pnlPercent,
                    winRate: winRate,
                    profitFactor: profitFactor,
                    totalTrades: history.length,
                    maxDrawdown: maxDrawdown,
                    expectancy: expectancy,
                    maxLosingStreak: maxLosingStreak
                };
            },
            saveState: function() {
                localStorage.setItem('paperTradeState', JSON.stringify(this.state));
            },
            loadState: function() {
                const defaultState = {
                    balance: 1000,
                    position: null,
                    history: [],
                    ts: {
                        enabled: true,
                        callbackRate: 0.3,
                        activationProfit: 1.0
                    }
                };

                const savedState = localStorage.getItem('paperTradeState');
                if (savedState) {
                    try {
                        const parsedState = JSON.parse(savedState);
                        
                        // Gabungkan state default dengan state tersimpan
                        this.state = { ...defaultState, ...parsedState };

                        // 🔥 PERBAIKAN KRUSIAL: Memastikan history dan tanggalnya diformat dengan benar
                        if (this.state.history && Array.isArray(this.state.history)) {
                            this.state.history = this.state.history.map(trade => ({
                                ...trade,
                                // Pastikan 'closedAt' dipulihkan sebagai objek Date
                                closedAt: new Date(trade.closedAt) 
                            }));
                        } else {
                            this.state.history = [];
                        }
                    } catch (e) {
                        console.error("Gagal mem-parsing state tersimpan, kembali ke default.", e);
                        this.state = defaultState;
                    }
                } else {
                    this.state = defaultState;
                }
            },
    };
    const signalLogState = {
        statsByDnaFile: {}, 
    };
    const savedLog = localStorage.getItem('aftSignalLog');
        if (savedLog) {
            try {
                const parsedLog = JSON.parse(savedLog);
                if (parsedLog && Object.keys(parsedLog.statsByDnaFile).length > 0) {
                    signalLogState.statsByDnaFile = parsedLog.statsByDnaFile;
                }
            } catch (e) {
                console.error("Gagal memuat log AFT dari local storage.", e);
            }
        }
    
    const signalPanel = document.getElementById('live-signal-panel');
    const aiStatusHtml = `
       <div id="current-regime-status-container" class="card p-4 mt-2 hidden">
            <h3 class="text-lg font-semibold mb-2 text-yellow-500">🧠</h3>
            <div class="space-y-1 text-sm">
                <p class="flex justify-between"><span>Status AI (Sensor):</span> <span id="ai-status" class="font-medium text-gray-400">LOADING...</span></p>
                <p class="flex justify-between">
                    <span>Keyakinan Prediksi:</span> 
                    <span id="regime-confidence-score" class="font-medium text-gray-400">--</span>
                </p>
                <p class="flex justify-between !mt-2 border-t border-gray-700 pt-2">
                    <span class="text-base">Mode Aktif (Rezim):</span> 
                    <span id="active-regime-display" class="text-base text-purple-400">LOADING...</span>
                </p>
            </div>
        </div>
    `;
    if(signalPanel) signalPanel.insertAdjacentHTML('beforebegin', aiStatusHtml);
// ===============================================================
// PENANAMAN MODEL AI SENSOR REZIM (Disalin dari Genesis Engine)
// ===============================================================
    const MODEL_ARTIFACTS_JSON_STRING = `
            {
                "format": "layers-model",
                "generatedBy": "TensorFlow.js tfjs-layers v4.2.0",
                "convertedBy": null,
                "modelTopology": {"class_name":"Sequential","config":{"name":"sequential_1","layers":[{"class_name":"LSTM","config":{"name":"lstm_LSTM1","trainable":true,"batch_input_shape":[null,10,12],"dtype":"float32","units":64,"activation":"relu","recurrent_activation":"hard_sigmoid","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"recurrent_initializer":{"class_name":"Orthogonal","config":{"gain":1,"seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"unit_forget_bias":null,"kernel_regularizer":null,"recurrent_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"recurrent_constraint":null,"bias_constraint":null,"dropout":0,"recurrent_dropout":0,"implementation":null,"return_sequences":false,"return_state":false,"go_backwards":false,"stateful":false,"unroll":false}},{"class_name":"Dropout","config":{"rate":0.2,"noise_shape":null,"seed":null,"name":"dropout_Dropout1","trainable":true}},{"class_name":"Dense","config":{"units":32,"activation":"relu","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense1","trainable":true}},{"class_name":"Dense","config":{"units":4,"activation":"softmax","use_bias":true,"kernel_initializer":{"class_name":"VarianceScaling","config":{"scale":1,"mode":"fan_avg","distribution":"normal","seed":null}},"bias_initializer":{"class_name":"Zeros","config":{}},"kernel_regularizer":null,"bias_regularizer":null,"activity_regularizer":null,"kernel_constraint":null,"bias_constraint":null,"name":"dense_Dense2","trainable":true}}]},"keras_version":"tfjs-layers 4.2.0","backend":"tensor_flow.js"},
                    "weightsManifest": [
                        {
                            "paths": ["weights.bin"],
                            "weights": [
                                {"name": "lstm_LSTM1/kernel", "shape": [12, 256], "dtype": "float32"},
                                {"name": "lstm_LSTM1/recurrent_kernel", "shape": [64, 256], "dtype": "float32"}, 
                                {"name": "lstm_LSTM1/bias", "shape": [256], "dtype": "float32"},
                                {"name": "dense_Dense1/kernel", "shape": [64, 32], "dtype": "float32"},
                                {"name": "dense_Dense1/bias", "shape": [32], "dtype": "float32"},
                                {"name": "dense_Dense2/kernel", "shape": [32, 4], "dtype": "float32"},
                                {"name": "dense_Dense2/bias", "shape": [4], "dtype": "float32"}
                            ]
                        }
                    ]
            }
    `;
    const WEIGHTS_BASE64_STRING = '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'; // <--- PASTIKAN TANDA INI ADA

// ===================================================================
// CUSTOM CONSOLE LOGGER
// ===================================================================

    (function() {
        const originalConsoleLog = console.log;
        const logPanel = document.getElementById('live-console-output');

        // Fungsi untuk memformat waktu saat ini
        function formatTime() {
            const now = new Date();
            return now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
        }

        // Ganti console.log bawaan
        console.log = function(...args) {
            // 1. Log ke console bawaan (agar developer tools tetap berfungsi)
            originalConsoleLog.apply(console, args);

            // 2. Log ke panel HTML jika elemen tersedia
            if (logPanel) {
                const message = args.map(arg => {
                    if (typeof arg === 'object' && arg !== null) {
                        try {
                            return JSON.stringify(arg);
                        } catch (e) {
                            return String(arg); // fallback
                        }
                    }
                    return String(arg);
                }).join(' ');

                const logEntry = document.createElement('p');
                logEntry.className = 'py-0.5 border-b border-gray-800 text-gray-400';
                logEntry.innerHTML = `<span class="text-blue-400">[${formatTime()}]</span> ${message}`;

                logPanel.prepend(logEntry); // Tambahkan log baru di atas

                // Batasi jumlah log untuk performa
                while (logPanel.children.length > 50) {
                    logPanel.removeChild(logPanel.lastChild);
                }
            }
        };
    })();

// ===================================================================

// ===================================================================
// BAGIAN 2: PUSTAKA FUNGSI KALKULASI MURNI 
// ===================================================================
    const tsCalc = {
        elements: tsCalcElements, 
        state: {
            marginMode: 'cross', leverage: 20, cost: 0, entryPrice: 0,
            walletBalance: 1000, tp: null, sl: null, callbackRate: null,
            activationPrice: null, positionType: 'long'
        },
        
        toggleModal: function(show) {
            if (show) this.elements.modalContainer.classList.remove('hidden');
            else this.elements.modalContainer.classList.add('hidden');
        },

        recalculate: function() {
            // Dapatkan equity total (modal awal + PNL realisasi) dari Trading Simulation
            // DEKLARASI DEFENSif: Gunakan 0 jika properti tidak ada
            const totalEquity = (paperTrade.state.balance || 0) + (paperTrade.state.position ? (paperTrade.state.position.cost || 0) : 0);
            
            // Perhitungan Cost/Modal Otomatis (10% dari Total Equity)
            const autoCost = totalEquity * 0.10; 

            // Update UI Balance (Equity Total)
            this.elements.walletBalance.value = totalEquity.toFixed(2);
            
            // Update UI Cost dan Slider dengan nilai AutoCost 10%
            this.elements.cost.value = autoCost.toFixed(2);
            this.elements.slider.value = 10; // Set slider ke 10%

            this.state.walletBalance = totalEquity;
            this.state.leverage = parseFloat(this.elements.leverage.value) || 20;
            this.state.cost = autoCost; // State cost disetel ke 10%
            
            const entry = parseFloat(this.elements.marketPrice.value) || currentMarketPrice || 0;
            if (entry === 0) return;

            const positionSize = this.state.cost * this.state.leverage;
            this.elements.resultCost.textContent = `${this.state.cost.toFixed(2)} USDT`;
            this.elements.resultPosSize.textContent = `${positionSize.toFixed(2)} USDT`;
            
            let liqPrice = 0;
            if (positionSize > 0) {
                // Logika Kalkulasi Liq Price (Cross vs Isolated)
                if (this.state.marginMode === 'isolated') {
                    const priceChange = (this.state.cost / positionSize) * (1 - 0.005);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                } else {
                    const priceChange = (this.state.walletBalance / positionSize) * (1 - 0.005);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                }
            }
            this.elements.resultLiqPrice.textContent = liqPrice > 0 ? formatPrice(liqPrice) : 'N/A';
        },

        autofill: function() {
            const setup = realtimeCache.main.latestScalpingSetup;
            
            if (!setup || typeof setup.entry.price !== 'number') {
                alert("Setup sinyal belum siap atau pasar sedang sideways. Tidak bisa auto-fill.");
                return;
            }
            
            const isLong = setup.bias.status.includes('LONG');
            this.state.positionType = isLong ? 'long' : 'short';
            
            if(isLong) {
                this.elements.buyBtn.classList.remove('opacity-50');
                this.elements.sellBtn.classList.add('opacity-50');
            } else {
                this.elements.sellBtn.classList.remove('opacity-50');
                this.elements.buyBtn.classList.add('opacity-50');
            }

            const precision = getPrecisionForAsset(currentMarketPrice);

            this.elements.marketPrice.value = currentMarketPrice.toFixed(precision);
            if(typeof setup.tp1.price === 'number') this.elements.takeProfit.value = setup.tp1.price.toFixed(precision);
            if(typeof setup.sl.price === 'number') this.elements.stopLoss.value = setup.sl.price.toFixed(precision);

            this.elements.tpslToggle.checked = true;
            this.elements.tpslInputs.classList.remove('hidden');
            this.elements.cost.focus();
            this.recalculate();
            this.elements.leverage.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    };

    const calculateEMA = (data, period) => {
        if (!data || data.length < period) {
            return [];
        }

        const k = 2 / (period + 1);
        let emaArray = [];

        if (data.length > 0) {
            let sum = 0;
            for (let i = 0; i < period; i++) {
            sum += data[i] || 0;
            }
            emaArray[period - 1] = sum / period;
            for (let i = period; i < data.length; i++) {
            emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
            }
        }

        return emaArray;
    };
    
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) {
            return [];
        }
        
        let sma = [];
        let sum = 0;

   
        for (let i = 0; i < period; i++) {
            sum += data[i];
        }
        sma.push(sum / period);

        for (let i = period; i < data.length; i++) {
            sum = sum - data[i - period] + data[i];
            sma.push(sum / period);
        }

        const alignedSma = [...Array(period - 1).fill(undefined), ...sma];
        
        return alignedSma;
    };

    const calculateRSI = (closes, period = 14) => {
        if (!closes || closes.length <= period) {
            return Array(closes.length).fill(undefined);
        }
        
        let gains = [];
        let losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let rsi = Array(period).fill(undefined);
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        rsi[period - 1] = (avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            rsi.push((avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
        }
        return rsi;
    };
    
    const calculateMACD = (closes, fast, slow, signal) => {
        if (fast === undefined) {
            fast = 12; slow = 26; signal = 9;
        }
        
        if (closes.length < slow) {
            return { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };
        }
        
        const emaFast = calculateEMA(closes, fast);
        const emaSlow = calculateEMA(closes, slow);
        const macdLine = emaSlow.map((slowVal, i) => {
            if (slowVal !== undefined && emaFast[i] !== undefined) {
                return emaFast[i] - slowVal;
            }
            return undefined;
        }).filter(v => v !== undefined);
        const signalLine = calculateEMA(macdLine, signal);
        const histogram = macdLine.map((macdVal, i) => {
            const sigVal = signalLine[i] !== undefined ? signalLine[i] : (signalLine.length > 0 ? signalLine.pop() : undefined);
            if (sigVal !== undefined) {
                const histValue = macdVal - sigVal;
                const prevHistValue = (i > 0 && macdLine[i - 1] !== undefined && signalLine[i - 1] !== undefined) ? (macdLine[i - 1] - signalLine[i - 1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        }).filter(v => v !== undefined);
        const lastMacd = macdLine.pop() || 0;
        const lastSig = signalLine.pop() || 0;
        const prevMacdLine = macdLine.pop() || 0;
        const prevSignalLine = signalLine.pop() || 0;
        let status = 'Netral';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) {
            status = 'Bullish Cross';
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) {
            status = 'Bearish Cross';
        }
        return { status, macdLine, signalLine, histogram };
    };

    const calculateStochasticRSI = (closes, rsiPeriod = 14, stochPeriod = 14, kSmooth = 3, dSmooth = 3) => {
        const rsiValues = calculateRSI(closes, rsiPeriod);
        const validRsi = rsiValues.filter(v => v !== undefined);
        if (validRsi.length < stochPeriod) {
            return { kLine: [], dLine: [], status: 'Netral' };
        }
        
        let stochArr = [];
        for (let i = stochPeriod - 1; i < validRsi.length; i++) {
            const window = validRsi.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((validRsi[i] - minR) / denom) * 100);
        }
        const kLineRaw = calculateSMA(stochArr, kSmooth);
        const dLineRaw = calculateSMA(kLineRaw.filter(v => v !== undefined), dSmooth);
        const kLine = kLineRaw.filter(v => v !== undefined);
        const dLine = dLineRaw.filter(v => v !== undefined);
        const lastK = kLine.pop() || 50;
        const lastD = dLine.pop() || 50;
        let status = 'Netral';
        if (lastK > 80 && lastD > 80) status = 'Overbought';
        else if (lastK < 20 && lastD < 20) status = 'Oversold';
        return { kLine, dLine, status };
    };

    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };
        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const rsiLows = findPivots(recentRSI, false), rsiHighs = findPivots(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH' };
        }
        return { status: 'NONE' };
    };

    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i-1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) obv.push(obv[i-1] + volume);
            else if (close < prevClose) obv.push(obv[i-1] - volume);
            else obv.push(obv[i-1]);
        }
        return obv;
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };

    const findCandlestickPatterns = (klines) => {
        if (!klines || klines.length < 2) return { bias: 'NETRAL' };
        const getCandle = (k) => {
            const [o, h, l, c] = k.slice(1, 5).map(parseFloat);
            return { open: o, close: c, isGreen: c > o, isRed: c < o };
        };
        const c1 = getCandle(klines[klines.length - 1]), c2 = getCandle(klines[klines.length - 2]);
        if (c2.isRed && c1.isGreen && c1.close > c2.open) return { bias: 'BULLISH' };
        if (c2.isGreen && c1.isRed && c1.close < c2.open) return { bias: 'BEARISH' };
        return { bias: 'NETRAL' };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) {
            return { upper: [], middle: [], lower: [], squeezeStatus: 'N/A' };
        }

        const middle = calculateSMA(closes, period);
        const upper = [];
        const lower = [];
        const width = [];

        let sum = 0;
        let sumOfSquares = 0;

        const initialSlice = closes.slice(0, period);
        for (const val of initialSlice) {
            sum += val;
            sumOfSquares += val * val;
        }

        const calculateAndPushBands = (currentSum, currentSumOfSquares) => {
            const mean = currentSum / period;
            const variance = (currentSumOfSquares / period) - (mean * mean);
            const stdev = Math.sqrt(Math.max(0, variance));
            upper.push(mean + (stdev * stdDev));
            lower.push(mean - (stdev * stdDev));
            width.push((stdev * stdDev * 2));
        };

        calculateAndPushBands(sum, sumOfSquares);

        for (let i = period; i < closes.length; i++) {
            const oldVal = closes[i - period];
            const newVal = closes[i];

            sum = sum - oldVal + newVal;
            sumOfSquares = sumOfSquares - (oldVal * oldVal) + (newVal * newVal);
            
            calculateAndPushBands(sum, sumOfSquares);
        }

        const lastWidth = width.filter(v => v !== undefined).pop();
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
        }

        const align = (arr) => [...Array(period - 1).fill(undefined), ...arr];

        return { 
            upper: align(upper), 
            middle: middle, 
            lower: align(lower), 
            squeezeStatus 
        };
    };

    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { value: 0, plusDI: 0, minusDI: 0 };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { value: adxValues.filter(v=>v!==undefined).pop() || 0, plusDI: plusDIs.pop() || 0, minusDI: minusDIs.pop() || 0 };
    };

    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline || prevDayKline.length < 5) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);
        if (isNaN(high) || isNaN(low) || isNaN(close)) return null;
        return { P: (high + low + close) / 3 };
    }

// --- TAMBAHAN BARU DIMULAI (KODE FUNGSI FIBONACCI YANG HILANG) ---

function findPivots(klines, lookback = 10) {
    const pivots = [];
    if (klines.length < lookback * 2 + 1) return [];

    for (let i = lookback; i < klines.length - lookback; i++) {
        const high = parseFloat(klines[i][2]);
        const low = parseFloat(klines[i][3]);
        let isHigh = true, isLow = true;

        for (let j = 1; j <= lookback; j++) {
            if (parseFloat(klines[i - j][2]) > high || parseFloat(klines[i + j][2]) > high) isHigh = false;
            if (parseFloat(klines[i - j][3]) < low || parseFloat(klines[i + j][3]) < low) isLow = false;
        }
        if (isHigh) pivots.push({ type: 'high', price: high, index: i });
        else if (isLow) pivots.push({ type: 'low', price: low, index: i });
    }
    return pivots;
}

function calculateSlope(p1, p2) {
    if (p2.index === p1.index) return Infinity;
    return (p2.price - p1.price) / (p2.index - p1.index);
}

function findLastSignificantSwing(klines) {
    const pivots = findPivots(klines.slice(-300), 5);
    if (pivots.length < 3) return null;

    for (let i = pivots.length - 1; i >= 2; i--) {
        const p3 = pivots[i];
        const p2 = pivots[i - 1];
        const p1 = pivots[i - 2];

        if (p1.type === 'low' && p2.type === 'high' && p3.type === 'low') {
            if (p3.price > p1.price) {
                return { A: p1, B: p2, C: p3, type: 'UP' };
            }
        }

        if (p1.type === 'high' && p2.type === 'low' && p3.type === 'high') {
            if (p3.price < p1.price) {
                return { A: p1, B: p2, C: p3, type: 'DOWN' };
            }
        }
    }
    return null;
}

function calculateAdvancedFibonacciExtension(swing) {
    if (!swing || !swing.A?.price || !swing.B?.price || !swing.C?.price || !swing.type) return null;
    const priceA = parseFloat(swing.A.price), priceB = parseFloat(swing.B.price), priceC = parseFloat(swing.C.price);
    if (isNaN(priceA) || isNaN(priceB) || isNaN(priceC)) return null;

    const impulseMove = Math.abs(priceB - priceA);
    const fibLevels = [0, 0.618, 1.0, 1.272, 1.618, 2.618];
    const calculatedLevels = {};

    fibLevels.forEach(level => {
        let targetPrice = (swing.type === 'UP') ? priceC + (impulseMove * level) : priceC - (impulseMove * level);
        calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
    });

    return {
        swingPoints: { A: priceA, B: priceB, C: priceC },
        type: swing.type,
        levels: calculatedLevels
    };
}

function calculateFibonacciRetracement(swing) {
    if (!swing || !swing.A?.price || !swing.B?.price) return null;
    const priceA = parseFloat(swing.A.price), priceB = parseFloat(swing.B.price);
    if (isNaN(priceA) || isNaN(priceB)) return null;

    const impulseMove = Math.abs(priceB - priceA);
    const retracementLevels = [0, 0.236, 0.382, 0.5, 0.618, 0.786, 1];
    const calculatedLevels = {};

    retracementLevels.forEach(level => {
        let targetPrice = (swing.type === 'UP') ? priceB - (impulseMove * level) : priceB + (impulseMove * level);
        calculatedLevels[`level_${level.toString().replace('.', '_')}`] = targetPrice;
    });

    return {
        swingPoints: { A: priceA, B: priceB },
        type: swing.type,
        levels: calculatedLevels
    };
}

// --- TAMBAHAN BARU SELESAI ---



    
    function calculateVWAP(klines, period = 20) {
        if (!klines || klines.length < period) return 0;
        let sumPV = 0, sumV = 0;
        const dataSlice = klines.slice(-period);
        dataSlice.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;
    }

    function calculateIchimokuCloud(klines) {
        if (klines.length < 52) return { status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        let tenkan = [], kijun = [];
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= 8 ? getHighLow(klines.slice(i - 8, i + 1)) : {};
            tenkan.push(tenkanHighLow.high ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= 25 ? getHighLow(klines.slice(i - 25, i + 1)) : {};
            kijun.push(kijunHighLow.high ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
        }
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = tenkan[tenkan.length - 1], lastKijun = kijun[kijun.length - 1];
        if (lastTenkan > lastKijun && lastPrice > lastKijun) return { status: "BULLISH" };
        if (lastTenkan < lastKijun && lastPrice < lastKijun) return { status: "BEARISH" };
        return { status: 'Netral' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { status: lastClose > sar ? 'Bullish' : 'Bearish', value: sar };
    }

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateLinearRegressionChannel(closes, period = 14) {
        if (closes.length < period) return { status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return { status: slope > 0 ? 'BULLISH' : 'BEARISH' };
    }

    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A', atrPercent: 0 };
        }
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        const rma = (data, p) => {
            let smoothed = [];
            let sum = 0;
            for(let i=0; i<data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    if (i === p - 1) smoothed.push(sum/p);
                    else smoothed.push(undefined);
                } else if (smoothed[i-1] !== undefined) {
                    smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return smoothed;
        };
        const atrValues = rma(trs, period);
        const atr = atrValues.pop() || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
        let status;
        if (atrPercent > 5) status = 'Very High';
        else if (atrPercent > 2.5) status = 'High';
        else if (atrPercent < 1) status = 'Low';
        else status = 'Normal';
        return { value: atr, status: status, atrPercent: atrPercent }; 
    }

// =====================================================================================================================================================================
    function startFundingCountdown() {
        setInterval(() => {
            const el = document.getElementById('sentiment-funding-interval');
            if (!el || nextFundingTimestamp === 0) {
                if (el) el.textContent = '--:--:--';
                return;
            }

            const diff = nextFundingTimestamp - Date.now();

            if (diff <= 0) {
                el.textContent = '00:00:00';
                return;
            }

            const hours = Math.floor(diff / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);

            const pad = (num) => num.toString().padStart(2, '0');
            el.textContent = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }, 1000); // Timer ini berjalan setiap detik
    }

    function updateSentimentDisplay(data) {
        const sentimentPanel = document.getElementById('sentiment-indicators-content');
        if (!sentimentPanel) return;

        const updateEl = (id, value, colorClass = '') => {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = colorClass;
            }
        };

        // Parabolic SAR
        const psarColor = data.psar === 'Bullish' ? 'positive' : (data.psar === 'Bearish' ? 'negative' : 'text-gray-400');
        updateEl('sentiment-psar', data.psar || '--', psarColor);

        // Rate of Change (ROC)
        const rocColor = data.roc > 0 ? 'positive' : (data.roc < 0 ? 'negative' : 'text-gray-400');
        updateEl('sentiment-roc', isNaN(data.roc) ? '--' : `${data.roc.toFixed(2)}%`, rocColor);

        // ADX
        const adxColor = data.adx > 25 ? 'positive' : 'text-gray-400'; // Trending if > 25
        updateEl('sentiment-adx', isNaN(data.adx) ? '--' : data.adx.toFixed(2), adxColor);

        // ATR
        const atrStatus = data.atr.status;
        let atrColor = 'text-gray-400';
        if (atrStatus === 'High' || atrStatus === 'Very High') atrColor = 'positive';
        if (atrStatus === 'Low' || atrStatus === 'Very Low') atrColor = 'text-yellow-500'; // More descriptive for low volatility
        updateEl('sentiment-atr', `${data.atr.atrPercent.toFixed(2)}% (${atrStatus})`, atrColor);
        
        // L/S Ratios
        updateEl('sentiment-ls-global', isNaN(data.lsGlobal) ? '--' : data.lsGlobal.toFixed(4));
        updateEl('sentiment-ls-top', isNaN(data.lsTop) ? '--' : data.lsTop.toFixed(4));
        
        // Funding Rate
        const fundingRatePercent = data.funding * 100;
        const fundingColor = fundingRatePercent > 0.01 ? 'negative' : (fundingRatePercent < 0 ? 'positive' : 'text-gray-400'); // High positive funding is generally bearish
        updateEl('sentiment-funding', `${fundingRatePercent.toFixed(4)}%`, fundingColor);

        // Open Interest
        let oiFormatted = '--';
        if (data.oi > 0) {
            if (data.oi >= 1e9) {
                oiFormatted = `$${(data.oi / 1e9).toFixed(2)}B`;
            } else if (data.oi >= 1e6) {
                oiFormatted = `$${(data.oi / 1e6).toFixed(2)}M`;
            } else {
                oiFormatted = `$${data.oi.toFixed(0)}`;
            }
        }
        updateEl('sentiment-oi', oiFormatted);
    }

    function toggleAftFilterModal(show) {
        const modal = document.getElementById('aft-filter-modal');
        if (modal) {
            modal.classList.toggle('hidden', !show);
            
            // 🔥 Perbaikan KRUSIAL untuk mobile: Mengunci scroll body
            if (show) {
                document.body.style.overflow = 'hidden'; // Kunci scroll
            } else {
                document.body.style.overflow = ''; // Bebaskan scroll
            }
        }
    }
    function fallbackToSimulationMode() {
        // Hapus API Keys agar tidak terhubung ke Live lagi
        binanceApiKeys.key = '';
        binanceApiKeys.secret = '';

        // Reset status UI ke mode Offline/Simulasi
        document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-yellow-500';
        document.getElementById('api-status-text').textContent = 'Offline (Lokal)';
        
        // Reset tombol koneksi
        const connectBtnSpan = document.getElementById('connect-api-status-text');
        connectBtnSpan.textContent = '🔗 SIMULASI'; // Kembalikan teks ke SIMULASI/OFFLINE
        connectBtnSpan.classList.remove('blinking-status');
        document.getElementById('connect-api-btn').classList.remove('!bg-red-600');
        
        // Panggil startSimulation(false) untuk memulai ulang di mode lokal
        startSimulation(false); 
    }
// === FUNGSI KONTEKSTUAL FINAL (LENGKAP DAN TERINTEGRASI) ===
// =====================================================================================================================================================================
    function getUltimateSignalScore(indicator, signalData, currentRegime, allIndicators) { 
        // Pastikan currentRegime adalah string yang valid, fallback ke 'STATIC' jika undefined/null.
        const regime = currentRegime || 'STATIC'; 

        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const confidence = (typeof signalData?.confidence === 'number') ? clamp(signalData.confidence, 0, 1) : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const weight = (activeStrategy.weights?.[indicator] || 0);     
        // --- Penentuan Konteks Tren Berdasarkan Rezim (Menggunakan 'regime' lokal) ---
        const isBullRegime = regime.includes('BULL');
        const isBearRegime = regime.includes('BEAR');
        const isRangeRegime = regime.includes('RANGING') || regime.includes('LOW_VOLATILITY');
        
        let score = 0;

        // 1. VWAP (Volume-Weighted Average Price)
        if (indicator === 'vwap') {
            if (text.includes('BULLISH')) score = isBullRegime ? 1.0 : 0.5; 
            else if (text.includes('BEARISH')) score = isBearRegime ? -1.0 : -0.5; 
        }
        
        // 2. OBV (On-Balance Volume)
        else if (indicator === 'obv') {
            const obvTrend = signalData?.trend;
            // AMBIL STATUS DARI OBJEK LENGKAP DENGAN SAFE ACCESS:
            const priceStatus = allIndicators?.vwap?.status; 

            if (obvTrend === 'Naik') {
                if (priceStatus === 'BULLISH') score = 1.0; 
                else if (priceStatus === 'BEARISH') score = 0.8; 
            } else if (obvTrend === 'Turun') {
                if (priceStatus === 'BEARISH') score = -1.0; 
                else if (priceStatus === 'BULLISH') score = -0.8; 
            }
        }

        // 3. Long/Short Ratio (L/S Ratio) - Kontra-indikator
        else if (indicator === 'lsRatio') {
            const ratio = parseFloat(signalData.longShortRatio) || 1.0;
            if (ratio > 1.2) score = -0.7; 
            else if (ratio < 0.8) score = 0.7;  
        }
        
        // 4. Funding Rate
        else if (indicator === 'fundingRate') {
            const rate = parseFloat(signalData.lastFundingRate) || 0;
            if (rate > 0.0005) score = -0.5; 
            else if (rate < -0.0005) score = 0.5; 
        }

        // 5. Open Interest (OI)
        else if (indicator === 'openInterest') {
            const oiStatus = signalData?.status;
            if (oiStatus === 'BULLISH_CONFIRMATION' && isBullRegime) score = 1.0; 
            else if (oiStatus === 'BEARISH_CONFIRMATION' && isBearRegime) score = -1.0; 
            else if (oiStatus === 'SHORT_SQUEEZE' && isBearRegime) score = 0.5;
            else if (oiStatus === 'LONG_SQUEEZE' && isBullRegime) score = -0.5; 
        }

        // 6. RSI
        else if (indicator === 'rsi') {
            const rsiValue = parseFloat(signalData.last) || 50;
            if (isRangeRegime) {
                if (rsiValue > 70) score = -1; 
                else if (rsiValue < 30) score = 1;  
            } else if (isBullRegime) {
                if (rsiValue < 50) score = 0.5; 
                else if (rsiValue > 80) score = -0.5; 
            } else if (isBearRegime) {
                if (rsiValue > 50) score = -0.5; 
                else if (rsiValue < 20) score = 0.5; 
            }
        } 
        
        // 7. Stoch RSI
        else if (indicator === 'stoch') {
            if (text.includes('OVERSOLD')) score = 1;
            else if (text.includes('OVERBOUGHT')) score = -1;
        }
        
        // 8. Bollinger Bands
        else if (indicator === 'bollingerBands') {
            if (signalData.rejection?.includes('Bullish')) score += 1;
            if (signalData.rejection?.includes('Bearish')) score -= 1;
            if (signalData.walkTheBands?.includes('Bullish')) score += 1;
            if (signalData.walkTheBands?.includes('Bearish')) score -= 1;
            
            if (isRangeRegime && (signalData.squeezeStatus === 'Squeeze!' || text.includes('SQUEEZE PRO'))) {
                score += 1.0; 
            }
        }
        
        // 9. Candle Pattern
        else if (indicator === 'candlePattern') {
            if (text.includes('BULLISH') && !isBearRegime) score = 1;
            else if (text.includes('BEARISH') && !isBullRegime) score = -1;
        }
        
        // 10. Logika Default (Pivot, MACD, Divergensi)
        else if (indicator === 'macd') {
            if (signalData.status === 'Bullish Cross') score = 1;
            else if (signalData.status === 'Bearish Cross') score = -1;
        }
        else if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) score = 1;
            else if (text.includes('BEAR')) score = -1;
        }
        else if (indicator === 'pivot' || indicator === 'psar' || indicator === 'linreg' || indicator === 'roc') {
            if (text.includes('BULL') || text.includes('UP') || text.includes('POSITIVE')) score = 1;
            else if (text.includes('BEAR') || text.includes('DOWN') || text.includes('NEGATIVE')) score = -1;
        }
        else if (text.includes('BULL') || text.includes('UP') || text.includes('POSITIVE') || text.includes('BID')) score = 1;
        else if (text.includes('BEAR') || text.includes('DOWN') || text.includes('NEGATIVE') || text.includes('ASK')) score = -1;

        return clamp(score, -1, 1) * weight * confidence;
    }

    function createTFAlignmentSummary(klines, timeframes, marketType) {
        const summary = {};
        
        let score = 0;
        timeframes.forEach(tf => {
            if (klines[tf] && klines[tf].length >= 50) {
                const closes = klines[tf].map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21);
                const ema50 = calculateEMA(closes, 50);
                const lastEma21 = ema21[ema21.length - 1];
                const lastEma50 = ema50[ema50.length - 1];
                summary[tf] = lastEma21 > lastEma50 ? 'UPTREND' : 'DOWNTREND';
            } else {
                summary[tf] = 'N/A';
            }
            if (summary[tf] === 'UPTREND') score++;
            else if (summary[tf] === 'DOWNTREND') score--;
        });
        return { summary, score };
    }

    function calculateConfluenceScoreForCandle(activeWeights, indicators, currentRegime) { 
        let totalBullScore = 0; 
        let totalBearScore = 0; 
        let maxPossibleScore = 0;

        for (const indicator in activeWeights) {
            if (indicators[indicator]) {
                const weight = activeWeights[indicator];
                const rawScore = getUltimateSignalScore(indicator, indicators[indicator], currentRegime, indicators);
                const weightedScore = rawScore * weight;
                if (weightedScore > 0) totalBullScore += weightedScore;
                if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                maxPossibleScore += Math.abs(weight);
            }
        }
        const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
        const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;
        return { 
            bull: bullPercentage, 
            bear: bearPercentage,
            totalBullScore: totalBullScore,
            totalBearScore: totalBearScore,
            maxPossibleScore: maxPossibleScore
        };
    }

    function calculateShortConfluenceScore(klinesSnapshot) {
            if (!klinesSnapshot || klinesSnapshot.length < 50) return { score: 0, breakdown: {} };

            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            let score = 0;
            let triggers = [];
            const rsiValues = calculateRSI(closes, 14);
            const lastRsi = rsiValues[rsiValues.length - 1];
            if (lastRsi > 72) {
                score += 3.5;
                triggers.push('RSI Overbought');
            }
            const macd = calculateMACD(closes);
            if (macd.status === 'Bearish Cross') {
                score += 2.5;
                triggers.push('MACD Cross');
            }
            const candlePattern = findCandlestickPatterns(klinesSnapshot);
            if (candlePattern.bias === 'BEARISH') {
                score += 2.0;
                triggers.push('Candle Pattern');
            }
            const lookbackPeriod = 15;
            const recentKlines = klinesSnapshot.slice(-lookbackPeriod);
            if (recentKlines.length >= 3) {
                let peakIndex = 0;
                for (let i = 1; i < recentKlines.length; i++) {
                    if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
                }
                if (peakIndex > 0 && peakIndex < lookbackPeriod - 2) {
                    const triggerCandleArr = recentKlines[peakIndex + 1];
                    if (triggerCandleArr) {
                        const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                        if (triggerCandle.Close < triggerCandle.Open) {
                            score += 3.5;
                            triggers.push('Red Candle After High');
                        }
                    }
                }
            }
            const rsiDivergence = detectRSIDivergence(closes, rsiValues);
            if (rsiDivergence.status === 'BEARISH') {
                score += 4.0;
                triggers.push('RSI Divergence');
            }
            return { score: Math.min(score, 10), triggers: triggers };
        }

    function getConfluenceAnalysis(klines) {
        if (!klines || klines.length < 50) {
            return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
        }

        let skorBullish = 0;
        let skorBearish = 0;
        const closes = klines.map(k => parseFloat(k[4]));

        const rsiValues = calculateRSI(closes);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const macd = calculateMACD(closes);
        const candlePattern = findCandlestickPatterns(klines);
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);

        if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
        if (macd.status === 'Bearish Cross') skorBearish += 2.0;
        if (lastRsi > 70) skorBearish += 1.5;
        if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

        if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
        if (macd.status === 'Bullish Cross') skorBullish += 2.0;
        if (lastRsi < 30) skorBullish += 1.5;
        if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
        
        const totalPossibleScore = 8.0;

        return { 
            skorBullish: (skorBullish / totalPossibleScore) * 10,
            skorBearish: (skorBearish / totalPossibleScore) * 10,
            detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
        };
    }
    
    function initializeNewCalculator() {
        const { elements, state } = tsCalc;
        
        elements.sellBtn.classList.add('opacity-50');
        state.positionType = 'long';

        elements.crossBtn.addEventListener('click', () => {
            state.marginMode = 'cross';
            elements.crossBtn.classList.add('active');
            elements.isolatedBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.isolatedBtn.addEventListener('click', () => {
            state.marginMode = 'isolated';
            elements.isolatedBtn.classList.add('active');
            elements.crossBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.buyBtn.addEventListener('click', () => {
            state.positionType = 'long';
            elements.buyBtn.classList.remove('opacity-50');
            elements.sellBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi LONG simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('long', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
            
            tsCalc.recalculate();
        });
        elements.sellBtn.addEventListener('click', () => {
            state.positionType = 'short';
            elements.sellBtn.classList.remove('opacity-50');
            elements.buyBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi SHORT simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('short', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
                
            tsCalc.recalculate();
        });
        elements.tpslToggle.addEventListener('change', () => {
            elements.tpslInputs.classList.toggle('hidden', !elements.tpslToggle.checked);
        });
        elements.slider.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const percentage = parseFloat(elements.slider.value);
            const newCost = (currentWalletBalance * (percentage / 100));
            elements.cost.value = newCost.toFixed(2);
            tsCalc.recalculate();
        });
        ['cost', 'leverage', 'walletBalance', 'marketPrice'].forEach(id => {
            elements[id].addEventListener('input', () => tsCalc.recalculate());
        });
        elements.cost.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const costValue = parseFloat(elements.cost.value) || 0;
            const percentage = currentWalletBalance > 0 ? (costValue / currentWalletBalance) * 100 : 0;
            elements.slider.value = Math.min(100, percentage);
        });
        elements.autofillBtn.addEventListener('click', () => tsCalc.autofill());
        elements.tsOptionsBtn.addEventListener('click', () => tsCalc.toggleModal(true));
        elements.modalCloseBtn.addEventListener('click', () => tsCalc.toggleModal(false));
        elements.modalContainer.addEventListener('click', (e) => {
            if (e.target === elements.modalContainer) tsCalc.toggleModal(false);
        });
        elements.modalSaveBtn.addEventListener('click', () => {
            state.callbackRate = parseFloat(elements.modalCallbackRate.value);
            state.activationPrice = parseFloat(elements.modalActivationPrice.value);
            tsCalc.toggleModal(false);
            tsCalc.recalculate();
        });

        tsCalc.recalculate();
    }

// ===============================================================
// --- FUNGSI UTAMA AI ---
// ===============================================================
// Tambahkan fungsi ini di area fungsi helper (sebelum startSimulation)
    async function waitForModel() {
        if (regimeSensorModel) return true;
        
        // Tunggu 50ms, coba lagi, maksimal 200 kali (10 detik)
        let attempts = 0;
        while (!regimeSensorModel && attempts < 200) {
            await new Promise(resolve => setTimeout(resolve, 50));
            attempts++;
        }
        return !!regimeSensorModel;
    } 

    function extractLSTMFeatures(klines) {
        const LSTM_LOOKBACK_WINDOW = 10;
        const NUM_FEATURES = 12;

        // Pastikan kita punya cukup data historis sebelum window yang kita analisis
        if (!klines || klines.length < LSTM_LOOKBACK_WINDOW + 15) { // Ditambah buffer untuk kalkulasi indikator awal
            console.warn(`[AI PREP] Data tidak cukup untuk ekstraksi fitur LSTM. Perlu > ${LSTM_LOOKBACK_WINDOW + 15}, tersedia: ${klines.length}`);
            return null;
        }

        // Ambil 10 kline terakhir untuk dianalisis sebagai sequence
        const sequenceKlines = klines.slice(-LSTM_LOOKBACK_WINDOW);
        if (sequenceKlines.length !== LSTM_LOOKBACK_WINDOW) return null;

        // Ambil data historis yang lebih panjang untuk kalkulasi indikator yang akurat
        const historicalKlines = klines.slice(-(LSTM_LOOKBACK_WINDOW + 20)); // Ambil 30 candle terakhir
        const historicalCloses = historicalKlines.map(k => parseFloat(k[4]));

        // --- PERBAIKAN UTAMA: Hitung semua indikator SEKALI saja pada data historis ---
        const rsiValues = calculateRSI(historicalCloses, 5);
        const macdData = calculateMACD(historicalCloses, 5, 8, 3);
        const bbData = calculateBollingerBands(historicalCloses, 5);
        const emaValues = calculateEMA(historicalCloses, 5);
        const stochRsiData = calculateStochasticRSI(rsiValues, 5, 5, 3, 3);

        // Ambil 10 nilai terakhir dari setiap hasil indikator
        const last10_RSI = rsiValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Line = macdData.macdLine.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Sig = macdData.signalLine.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_MACD_Hist = macdData.histogram.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_BB_Upper = bbData.upper.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_BB_Lower = bbData.lower.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_BB_Middle = bbData.middle.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_EMA = emaValues.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_StochK = stochRsiData.kLine.slice(-LSTM_LOOKBACK_WINDOW);
        const last10_StochD = stochRsiData.dLine.slice(-LSTM_LOOKBACK_WINDOW);

        let sequenceData = [];

        // Loop 10 kali untuk membangun setiap langkah dalam sequence
        for (let j = 0; j < LSTM_LOOKBACK_WINDOW; j++) {
            const klineForJ = sequenceKlines[j];
            const closeJ = parseFloat(klineForJ[4]);
            
            // Kalkulasi ATR & VWAP pada snapshot yang relevan hingga titik 'j'
            const klinesUpToJ = klines.slice(0, klines.length - LSTM_LOOKBACK_WINDOW + j + 1);
            const vwap_j = calculateVWAP(klinesUpToJ, 5);
            const atr_j = calculateATR(klinesUpToJ, 5).atrPercent;

            // Ambil nilai indikator yang sudah dihitung sebelumnya
            const rsi_j = last10_RSI[j] || 0;
            const ema_j = last10_EMA[j] || 0;
            const macd_line_j = last10_MACD_Line[j] || 0;
            const signal_line_j = last10_MACD_Sig[j] || 0;
            const macd_hist_j = last10_MACD_Hist[j]?.value || 0;
            const bb_upper_j = last10_BB_Upper[j] || closeJ;
            const bb_lower_j = last10_BB_Lower[j] || closeJ;
            const bb_middle_j = last10_BB_Middle[j] || closeJ;
            const k_j = last10_StochK[j] || 0;
            const d_j = last10_StochD[j] || 0;

            // --- Fitur Turunan (Derived Features) ---
            const macd_cross_j = (macd_line_j > signal_line_j) ? 1 : -1;
            const ema_dist_j = (ema_j > 0) ? (closeJ - ema_j) / ema_j : 0;
            const bb_width_j = (bb_middle_j > 0) ? (bb_upper_j - bb_lower_j) / bb_middle_j : 0;
            const bb_pos_j = (bb_upper_j - bb_lower_j) > 0 ? (closeJ - bb_lower_j) / (bb_upper_j - bb_lower_j) : 0.5;
            const vwap_dist_j = (vwap_j > 0) ? (closeJ - vwap_j) / vwap_j : 0;
            
            const prev_k = (j > 0) ? last10_StochK[j-1] || 0 : 0;
            const prev_d = (j > 0) ? last10_StochD[j-1] || 0 : 0;
            const stoch_cross_j = (prev_k <= prev_d && k_j > d_j) ? 1 : ((prev_k >= prev_d && k_j < d_j) ? -1 : 0);
            const stoch_state_j = (k_j > 80 && d_j > 80) ? 1 : ((k_j < 20 && d_j < 20) ? -1 : 0);

            // Kumpulkan semua 12 fitur menjadi satu array
            const featureArray = [
                rsi_j, macd_cross_j, macd_hist_j, ema_dist_j,
                bb_width_j, bb_pos_j, vwap_dist_j, atr_j,
                k_j, d_j, stoch_cross_j, stoch_state_j
            ].map(v => isFinite(v) ? v : 0); // Pastikan tidak ada nilai non-numerik

            if (featureArray.length === NUM_FEATURES) {
                sequenceData.push(featureArray);
            }
        }

        // Hanya kembalikan jika sequence lengkap (10 langkah)
        if (sequenceData.length === LSTM_LOOKBACK_WINDOW) {
            return sequenceData;
        }

        return null; // Kembalikan null jika gagal, ini akan memicu FALLBACK
    }

    async function loadRegimeSensorModel() {
        if (regimeSensorModel || typeof tf === 'undefined') {
            document.getElementById('ai-status').textContent = 'Auto Switch (No AI)'; 
            return;
        }

        console.log("🧠 Memuat Model Sensor Rezim (Final)...");
        try {
            const base64Handler = {
                load: async () => {
                    const modelArtifacts = JSON.parse(MODEL_ARTIFACTS_JSON_STRING);
                    const binaryString = window.atob(WEIGHTS_BASE64_STRING);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const weightData = bytes.buffer;

                    return {
                        modelTopology: modelArtifacts.modelTopology, 
                        weightSpecs: modelArtifacts.weightsManifest[0].weights, 
                        weightData: weightData
                    };
                }
            };

            regimeSensorModel = await tf.loadLayersModel(base64Handler);
            console.log('✅ Model Sensor Rezim berhasil dimuat dan siap bekerja!');
            document.getElementById('ai-status').textContent = 'AI Ready (LSTM TF.js)';

        } catch (error) {
            console.error("❌ GAGAL memuat Model Sensor Rezim:", error);
            document.getElementById('ai-status').textContent = 'ERROR';
            regimeSensorModel = null;
        }
    }

    function calculatePredictionInput(klinesSnapshot) {
        if (klinesSnapshot.length < 50 || typeof tf === 'undefined') return null; 
        const closes = klinesSnapshot.map(k => parseFloat(k[4]));
        const currentClose = closes[closes.length - 1];
        const rsiValues = calculateRSI(closes, 14);
        const stochRsiData = calculateStochasticRSI(closes);
        const macdData = calculateMACD(closes);
        const bbData = calculateBollingerBands(closes);
        const vwap = calculateVWAP(klinesSnapshot, 20);
        const atrData = calculateATR(klinesSnapshot);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const lastK = stochRsiData.kLine.filter(v => v !== undefined).pop() || 50;
        const lastD = stochRsiData.dLine.filter(v => v !== undefined).pop() || 50;
        const prevK = stochRsiData.kLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
        const prevD = stochRsiData.dLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
        const macdLine = macdData.macdLine.filter(v => v !== undefined).pop() || 0;
        const signalLine = macdData.signalLine.filter(v => v !== undefined).pop() || 0;
        const macdHist = macdData.histogram.filter(v => v !== undefined).pop()?.value || 0;
        const ema50 = calculateEMA(closes, 50).pop() || currentClose;
        const bbUpper = bbData.upper.filter(v => v !== undefined).pop() || currentClose;
        const bbLower = bbData.lower.filter(v => v !== undefined).pop() || currentClose;
        const bbMiddle = bbData.middle.filter(v => v !== undefined).pop() || currentClose; // Perlu untuk BB width

        const features = {
            rsi: lastRsi,
            macd_cross: macdLine > signalLine ? 1 : -1,
            macd_hist: macdHist,
            ema_dist: (currentClose - ema50) / ema50,
            bb_width: (bbUpper - bbLower) / bbMiddle,
            bb_pos: (bbUpper - bbLower) > 0 ? (currentClose - bbLower) / (bbUpper - bbLower) : 0.5,
            vwap_dist: vwap > 0 ? (currentClose - vwap) / vwap : 0,
            atr_percent: atrData.atrPercent,
            stoch_rsi_k: lastK,
            stoch_rsi_d: lastD,
            stoch_rsi_cross: (prevK <= prevD && lastK > lastD) ? 1 : ((prevK >= prevD && lastK < lastD) ? -1 : 0),
            stoch_rsi_state: (lastK > 80 && lastD > 80) ? 1 : ((lastK < 20 && lastD < 20) ? -1 : 0)
        };
        
        const featureOrder = ['rsi','macd_cross','macd_hist','ema_dist','bb_width','bb_pos','vwap_dist','atr_percent','stoch_rsi_k','stoch_rsi_d','stoch_rsi_cross','stoch_rsi_state'];
        const inputArray = featureOrder.map(key => features[key] || 0);

        if (inputArray.some(val => !isFinite(val))) {
            return null;
        }
        return inputArray;
    }

    async function predictMarketRegime(klinesSnapshot) {
        const featureSequence = extractLSTMFeatures(klinesSnapshot);
        const LSTM_LOOKBACK_WINDOW = 10;
        const NUM_FEATURES = 12;

        if (!regimeSensorModel || !featureSequence || featureSequence.length !== LSTM_LOOKBACK_WINDOW) {
            return { label: 'RANGING', confidence: 0.5 }; // Fallback aman
        }

        // Mengubah array 2D [10, 12] menjadi Tensor 3D [1, 10, 12]
        return tf.tidy(() => {
            const inputTensor = tf.tensor3d([featureSequence], [1, LSTM_LOOKBACK_WINDOW, NUM_FEATURES]);
            const prediction = regimeSensorModel.predict(inputTensor);
            const predictionData = prediction.dataSync();
            const predictedClassIndex = prediction.argMax(-1).dataSync()[0];
            const predictedLabel = REGIME_LABELS[predictedClassIndex];
            const highestProbability = predictionData[predictedClassIndex];

            // 🔥 Mengembalikan objek lengkap: label dan confidence score
            return { 
                label: predictedLabel || 'RANGING',
                confidence: highestProbability || 0.5
            };
        });
    }
    
    function getRegimeColorClass(key) {
        switch(key) {
            case 'BULL_TREND': return 'text-base text-green-400';
            case 'BEAR_TREND': return 'text-base text-red-400';
            case 'RANGING': return 'text-base text-yellow-400';
            case 'LOW_VOLATILITY': return 'text-base text-blue-400';
            default: return 'text-base text-gray-500';
        }
    }
// ===================================================================
// BAGIAN 2: FUNGSI-FUNGSI PEMBANTU (HELPERS) & KALKULASI
// ===================================================================
    function toggleFibView(event) {
        event.stopPropagation(); // Mencegah panel <details> tertutup saat tombol diklik
        isFibRetracementVisible = !isFibRetracementVisible;
        // Panggil ulang displayLiveSignal untuk me-render ulang panel dengan data terakhir
        if (realtimeCache.main.latestScalpingSetup) {
            displayLiveSignal(realtimeCache.main.latestScalpingSetup);
        }
    }

    function formatDollar(amount, symbol) {
    if (amount === null || isNaN(amount)) return '$0.00';
    // Sekarang memanggil formatPrice agar presisinya selalu benar
    return formatPrice(amount, symbol); 
}

    function toggleAftFilterModal(show) {
        const modal = document.getElementById('aft-filter-modal');
        if (modal) {
            modal.classList.toggle('hidden', !show);
        }
    }

    function getAftAllowedStrategies() {
        const checkedBoxes = document.querySelectorAll('.aft-strategy-filter:checked');
        return Array.from(checkedBoxes).map(box => box.value);
    }

    async function checkBinanceLatency() {
        const latencyDisplay = document.getElementById('ping-latency-display');
        if (!latencyDisplay) return;

        try {
            const startTime = performance.now();
            // Menggunakan endpoint /fapi/v1/ping yang sangat ringan dari Binance
            await fetch('https://fapi.binance.com/fapi/v1/ping');
            const endTime = performance.now();
            const latency = Math.round(endTime - startTime);

            latencyDisplay.textContent = `Ping: ${latency} ms`;
            if (latency < 150) {
                latencyDisplay.className = 'positive'; // Hijau jika cepat
            } else if (latency < 400) {
                latencyDisplay.className = 'text-yellow-400'; // Kuning jika sedang
            } else {
                latencyDisplay.className = 'negative'; // Merah jika lambat
            }
        } catch (error) {
            latencyDisplay.textContent = 'Ping: Error';
            latencyDisplay.className = 'negative';
        }
    }

    // GANTI FUNGSI INI
// GANTI SELURUH FUNGSI sendBinanceRequest DENGAN INI:
async function sendBinanceRequest(method, endpoint, isSigned = false, params = {}) {
    // 💥 Base URL menunjuk ke Proxy lokal Anda
    const proxyUrl = 'http://localhost:3000'; 
    
    // Perhatikan, kita hanya perlu satu endpoint GET untuk SYNC
    if (endpoint === '/account' || endpoint === '/positionRisk') { 
        
        console.log(`⚙️ Menggunakan Proxy: Meminta status akun dari ${proxyUrl}/sync-futures-account`);
        
        const response = await fetch(`${proxyUrl}/sync-futures-account`); 
        
        if (!response.ok) {
            console.error("❌ Proxy Down atau Error (Cek Terminal Node.js Anda)");
            throw new Error(`Proxy Error: ${response.statusText}`);
        }
        
        const accountData = await response.json();
        
        // Data yang dikembalikan oleh Proxy harus diproses untuk /account dan /positionRisk
        if (endpoint === '/account') {
             // Mengembalikan data mentah yang dibutuhkan untuk saldo
             return accountData;
        } else if (endpoint === '/positionRisk') {
            // Mengembalikan data yang diproses untuk posisi aktif (sesuai format aslinya)
            return accountData.positions.map(pos => ({
                symbol: pos.symbol,
                entryPrice: parseFloat(pos.entryPrice),
                positionAmt: parseFloat(pos.positionAmt),
                unrealizedProfit: parseFloat(pos.unrealizedProfit),
                liquidationPrice: parseFloat(pos.liquidationPrice),
            })).filter(pos => parseFloat(pos.positionAmt) !== 0); // Filter posisi yang nol
        }
    }
    
    // Untuk order placement (POST) - akan diimplementasikan setelah sinkronisasi saldo berhasil
    if (method === 'POST') {
        throw new Error("Order placement (POST) belum diimplementasikan di proxy lokal.");
    }

    throw new Error(`Endpoint ${endpoint} tidak didukung dalam mode Proxy.`);
}

    function toggleApiKeyModal(show) {
        const modal = document.getElementById('api-key-modal');
        if (modal) {
            modal.classList.toggle('hidden', !show);
        }
    }

    async function switchChartTimeframe(newTimeframe) {
        if (newTimeframe === currentChartTimeframe) return; 
        const symbol = liveSymbolInput.value.toUpperCase();
        currentChartTimeframe = newTimeframe; 

        chartsWrapper.style.opacity = '0.3';
        
        if (liveWebSocket) liveWebSocket.close();
        liveData = [];
        destroyCharts();

        await fetchInitialData(symbol, newTimeframe);
        
        connectToBinance(symbol, newTimeframe);
        
        renderAllCharts();
        
        chartsWrapper.style.opacity = '1';
    }

    async function initializePrecisionMap() {
        try {
            const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            const data = await response.json();
            
            data.symbols.forEach(symbolInfo => {
                const priceFilter = symbolInfo.filters.find(f => f.filterType === 'PRICE_FILTER');
                if (priceFilter && priceFilter.tickSize) {
                    const tickSize = parseFloat(priceFilter.tickSize);
                    if (tickSize > 0) {
                        precisionMap[symbolInfo.symbol] = Math.round(-Math.log10(tickSize));
                    } else {
                        precisionMap[symbolInfo.symbol] = 0;
                    }
                }
            });
        } catch (error) {
            console.error("Gagal membuat database presisi, akan menggunakan format default:", error);
        }
    }

    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }

    async function fetchInitialData(symbol, interval) {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=500`;
        const response = await fetch(url);
        liveData = await response.json();
    }

    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'futures') {
        const baseUrl = 'https://fapi.binance.com/fapi/v1';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = `Binance API error for ${endpoint}: ${errorData.msg || response.statusText}`;
                throw new Error(errorMessage);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from ${url}: ${error.message}`);
            throw new Error(`Gagal mengambil data untuk ${endpoint} dari Binance.`);
        }
    }

    async function updateHtfCompass(timeframe) {
        // === GANTI SELURUH ISI FUNGSI DENGAN KODE INI ===
        const resultEl = document.getElementById('htf-compass-result');
        const symbol = liveSymbolInput.value.toUpperCase();
        if (!symbol) return;

        resultEl.textContent = `Menganalisis VWAP ${timeframe}...`;
        resultEl.className = 'text-center mt-2 text-sm text-yellow-500';

        try {
            const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: 100 }, 'futures');
            if (!klines || klines.length < 20) throw new Error("Data HTF tidak cukup untuk VWAP");

            const htfVwap = calculateVWAP(klines, klines.length); // Hitung VWAP untuk seluruh data HTF
            const currentPrice = currentMarketPrice;

            if (currentPrice > htfVwap) {
                resultEl.textContent = `▲ Di atas VWAP ${timeframe}`;
                resultEl.className = 'text-center mt-2 text-sm positive';
                htfTrend = 'UPTREND'; 
            } else {
                resultEl.textContent = `▼ Di bawah VWAP ${timeframe}`;
                resultEl.className = 'text-center mt-2 text-sm negative';
                htfTrend = 'DOWNTREND'; 
            }
        } catch (error) {
            console.error(`Gagal update kompas HTF untuk ${timeframe}:`, error);
            resultEl.textContent = `Error (${timeframe})`;
            resultEl.className = 'text-center mt-2 text-sm negative';
            htfTrend = 'NEUTRAL'; 
        }
        // ================================================
    }

    async function updateMarketStructurePanel(symbol, timeframe) {
        const resistanceEl = document.getElementById('htf-resistance-price');
        const supportEl = document.getElementById('htf-support-price');

        // Safety check jika elemen tidak ditemukan
        if (!resistanceEl || !supportEl) return;

        try {
            // Ambil 100 candle dari timeframe yang lebih tinggi (misal: 4h)
            const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: 100 });
            if (klines.length < 20) {
                resistanceEl.textContent = 'N/A';
                supportEl.textContent = 'N/A';
                return;
            }

            // Logika sederhana: cari harga high tertinggi dan low terendah dari 100 candle terakhir
            const highs = klines.map(k => parseFloat(k[2]));
            const lows = klines.map(k => parseFloat(k[3]));

            const significantHigh = Math.max(...highs);
            const significantLow = Math.min(...lows);

            // Tampilkan di UI
            resistanceEl.textContent = formatPrice(significantHigh, symbol);
            supportEl.textContent = formatPrice(significantLow, symbol);

        } catch (error) {
            console.error("Gagal update Market Structure:", error);
            resistanceEl.textContent = 'Error';
            supportEl.textContent = 'Error';
        }
    }

    function analyzeStrategyPerformance(history) {
        if (!history || history.length === 0) {
            return {};
        }

        const performance = {};

        // 1. Inisialisasi semua strategi yang mungkin ada dari filter AFT
        const allStrategies = Array.from(document.querySelectorAll('.aft-strategy-filter')).map(el => el.value);
        allStrategies.forEach(strategyName => {
            performance[strategyName] = {
                trades: 0,
                wins: 0,
                totalPnl: 0,
                winRate: 0,
                consecutiveLosses: 0
            };
        });

        // 2. Proses setiap trade dalam riwayat
        // Kita proses dari yang paling tua ke yang paling baru
        const sortedHistory = [...history].reverse(); 

        sortedHistory.forEach(trade => {
            const strategyName = trade.biasStatus;

            // Hanya proses jika trade memiliki nama strategi & merupakan trade AFT
            if (strategyName && strategyName !== 'N/A' && trade.flag === 'AFT') {

                // Jika strategi dari history tidak ada di list awal (jarang terjadi), tambahkan
                if (!performance[strategyName]) {
                    performance[strategyName] = { trades: 0, wins: 0, totalPnl: 0, winRate: 0, consecutiveLosses: 0 };
                }

                const stats = performance[strategyName];
                stats.trades++;
                stats.totalPnl += trade.pnl;

                if (trade.pnl > 0) {
                    stats.wins++;
                    stats.consecutiveLosses = 0; // Reset kekalahan beruntun jika menang
                } else {
                    stats.consecutiveLosses++; // Tambah kekalahan beruntun jika kalah/BEP
                }
            }
        });

        // 3. Hitung Win Rate dan bersihkan strategi yang tidak pernah dipakai
        for (const strategyName in performance) {
            const stats = performance[strategyName];
            if (stats.trades > 0) {
                stats.winRate = (stats.wins / stats.trades) * 100;
            } else {
                // Hapus strategi dari hasil jika tidak pernah digunakan
                delete performance[strategyName];
            }
        }

        return performance;
    }

    function getChartBaseOptions(height) {
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 32,
            height: height,
            layout: { background: { color: '#151414' }, textColor: '#E0E0E0' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: 'rgba(255, 255, 255, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                borderColor: '#4B5563',
                rightOffset: 10,
            },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: { borderColor: '#4B5563' }
        };
    }

    function destroyCharts() {
        charts.forEach(chart => { if (chart) chart.remove(); });
        charts = [];
        candlestickSeries = null;
        ['main-chart-container', 'volume-chart-container', 'rsi-chart-container', 'stoch-chart-container', 'macd-chart-container'].forEach(id => {
            const container = document.getElementById(id);
            if (container) container.innerHTML = '';
        });
    }

    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if (!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (otherChart && chart !== otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }

    function renderAllCharts() {
        if (!liveData || liveData.length < 50) return;       
        destroyCharts();

        const formattedKlines = liveData.map(d => ({ 
            time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]), 
            low: parseFloat(d[3]), close: parseFloat(d[4]) 
        }));        
        const closes = formattedKlines.map(k => k.close);
        const ema21Data = calculateEMA(closes, 21).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
        const ema50Data = calculateEMA(closes, 50).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
        const volumeData = liveData.map(d => ({ 
            time: d[0] / 1000, value: parseFloat(d[5]), 
            color: parseFloat(d[4]) >= parseFloat(d[1]) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' 
        }));
        const rsiValues = calculateRSI(closes, 14);
        const stochRsiData = calculateStochasticRSI(closes);
        const macdData = calculateMACD(closes);
        const alignData = (dataArray) => {
            if (!dataArray || dataArray.length === 0) return [];
            const offset = formattedKlines.length - dataArray.length;
            return dataArray.map((value, index) => {
                const kline = formattedKlines[index + offset];
                if (kline && value !== undefined) {
                    return { time: kline.time, value };
                }
                return null;
            }).filter(Boolean);
        };
        const macdLineData = alignData(macdData.macdLine);
        const signalLineData = alignData(macdData.signalLine);
        const histogramData = macdData.histogram.map((item, index) => {
            const offset = formattedKlines.length - macdData.histogram.length;
            const kline = formattedKlines[index + offset];
            if (kline && item !== undefined) {
                return { time: kline.time, value: item.value, color: item.color };
            }
            return null;
        }).filter(Boolean);

        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);
        candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false });
        candlestickSeries.setData(formattedKlines);
        ema21Series = mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false });
        ema21Series.setData(ema21Data);
        ema50Series = mainChart.addLineSeries({ color: '#FF6D00', lineWidth: 1, priceLineVisible: false });
        ema50Series.setData(ema50Data);

        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
        charts.push(volumeChart);
        volumeSeries = volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } });
        volumeSeries.setData(volumeData);

        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(120));
        charts.push(rsiChart);
        rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 });
        rsiSeries.setData(alignData(rsiValues));

        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(120));
        charts.push(stochChart);
        stochKSeries = stochChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: '%K' });
        stochKSeries.setData(alignData(stochRsiData.kLine));
        stochDSeries = stochChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: '%D' });
        stochDSeries.setData(alignData(stochRsiData.dLine));

        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(120));
        charts.push(macdChart);
        macdHistSeries = macdChart.addHistogramSeries({ base: 0 });
        macdHistSeries.setData(histogramData);
        macdLineSeries = macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceLineVisible: false });
        macdLineSeries.setData(macdLineData);
        signalLineSeries = macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceLineVisible: false });
        signalLineSeries.setData(signalLineData);

        syncCharts(...charts);
    }

    function updateAllCharts(newKline) {
        if (!isChartsVisible || !candlestickSeries) return;
        const formattedKline = { time: newKline.t / 1000, open: parseFloat(newKline.o), high: parseFloat(newKline.h), low: parseFloat(newKline.l), close: parseFloat(newKline.c) };
        candlestickSeries.update(formattedKline);
        if (volumeSeries) {
            volumeSeries.update({ time: formattedKline.time, value: parseFloat(newKline.v), color: parseFloat(newKline.c) >= parseFloat(newKline.o) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' });
        }
        const closes = liveData.map(k => parseFloat(k[4]));
        if (rsiSeries) {
            rsiSeries.update({ time: formattedKline.time, value: calculateRSI(closes, 14).pop() });
        }
        if (stochKSeries && stochDSeries) {
            const stochData = calculateStochasticRSI(closes);
            stochKSeries.update({ time: formattedKline.time, value: stochData.kLine.pop() });
            stochDSeries.update({ time: formattedKline.time, value: stochData.dLine.pop() });
        }
        if (macdLineSeries && signalLineSeries && macdHistSeries) {
            const macdData = calculateMACD(closes);
            const lastHist = macdData.histogram.pop();
            macdLineSeries.update({ time: formattedKline.time, value: macdData.macdLine.pop() });
            signalLineSeries.update({ time: formattedKline.time, value: macdData.signalLine.pop() });
            if(lastHist) {
                macdHistSeries.update({ time: formattedKline.time, value: lastHist.value, color: lastHist.color });
            }
        }
        if(ema21Series) {
             ema21Series.update({ time: formattedKline.time, value: calculateEMA(closes, 21).pop() });
        }
        if(ema50Series) {
             ema50Series.update({ time: formattedKline.time, value: calculateEMA(closes, 50).pop() });
        }
    }

    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        const chartsWrapper = document.getElementById('charts-wrapper');
        const toggleBtn = document.getElementById('toggle-charts-btn');
        
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleBtn.textContent = 'HIDE CHART';
            renderAllCharts();
        } else {
            chartsWrapper.style.display = 'none';
            toggleBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }

    async function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }
        activeDnaFilename = file.name;
        
        const reader = new FileReader();
        reader.onload = async function(e) { 
            try {
                const dnaData = JSON.parse(e.target.result);
                const symbolInput = document.getElementById('live-symbol-input');
                const timeframeSelect = document.getElementById('live-timeframe-select');
                const importedSinyalPanel = document.getElementById('imported-sinyal-panel');
                
                importedSinyalPanel.innerHTML = ''; 

                if (!dnaData.metadata || !dnaData.parameters || !dnaData.weights) {
                    importedSinyalPanel.innerHTML = `<p class="text-center text-sm negative">❌ Format file DNA tidak valid. Pastikan file diekspor dari Genesis Engine.</p>`;
                    return;
                }
        
                const dnaType = dnaData.metadata.dnaType || 'Static_v1';
                
                // --- PENGISIAN STATE SECARA DEFENSif ---
                activeStrategy.metadata = dnaData.metadata;
                activeStrategy.parameters = dnaData.parameters;
                
                if (dnaType.startsWith('AutoSwitch')) {
                    // DNA Bunglon Dideteksi
                    activeStrategy.dnaType = 'AutoSwitch_v1';
                    activeStrategy.autoWeights = dnaData.weights;
                    
                    // Pastikan weights fallback terisi
                    activeStrategy.weights = dnaData.weights.RANGING 
                                            || dnaData.weights.BULL_TREND 
                                            || userSettings.presets.default.weights;

                    document.getElementById('dna-status-display').textContent = `DNA: AutoSwitch (${dnaData.metadata.sourceAsset} ${dnaData.metadata.sourceTimeframe})`;
                    document.getElementById('current-regime-status-container').classList.remove('hidden'); 
                    await loadRegimeSensorModel(); 

                    alert(`✅ DNA AutoSwitch_v1 dari ${dnaData.metadata.sourceAsset} berhasil dimuat. Dashboard beroperasi dalam mode adaptif.`);

                } else {
                    // DNA Statis/Generik Dideteksi
                    const { sourceAsset, sourceTimeframe } = dnaData.metadata;
                    activeStrategy.dnaType = 'Static_v1';
                    activeStrategy.weights = dnaData.weights; 
                    activeStrategy.autoWeights = null;
                    
                    symbolInput.value = sourceAsset ? sourceAsset.toUpperCase() : symbolInput.value;
                    timeframeSelect.value = sourceTimeframe || timeframeSelect.value;
                    
                    document.getElementById('dna-status-display').textContent = `DNA: Static (${sourceAsset} ${sourceTimeframe || 'N/A'})`;
                    document.getElementById('current-regime-status-container').classList.add('hidden');

                    alert(`✅ DNA Strategi Statis (Static) berhasil dimuat.`);
                }

                // PANGGIL DISPLAY TANPA ARGUMEN (Membaca state global yang sudah terisi penuh)
                displayImportedStrategy(); 
                updateSignalLogStatistics();
                document.getElementById('live-data-input-section').classList.remove('hidden');
                document.getElementById('weather-forecast-section').classList.remove('hidden');
        
                const importContentWrapper = document.getElementById('import-content-wrapper');
                if (importContentWrapper && importContentWrapper.classList.contains('expanded')) {
                    importContentWrapper.classList.remove('expanded');
                    // Opsional: putar ikon toggle jika Anda punya (toggle-import-icon)
                    document.getElementById('toggle-import-icon').style.transform = 'rotate(-90deg)';
                }

            } catch (error) {
                // Tampilkan error message yang lebih jelas di panel
                importedSinyalPanel.innerHTML = `<p class="text-center text-sm negative">❌ Terjadi kesalahan memproses: ${error.message}</p>`;
                console.error("Error parsing DNA JSON (Handle Import):", error);
            }
        };
        reader.readAsText(file);
    }

    function displayImportedStrategy() {
        const strategyData = activeStrategy;
        
        // Safety Check: Jika metadata atau parameters masih hilang, hentikan.
        if (!strategyData || !strategyData.metadata || !strategyData.parameters) {
            importedSinyalPanel.innerHTML = `<p class="text-center text-sm text-gray-400">Gagal memuat strategi. (Data State tidak lengkap)</p>`;
            return;
        }
        
        // Pemeriksaan Properti Wajib (untuk menghindari undefined is not object)
        const getSafeParam = (obj, key, fallback = 'N/A') => {
            const val = obj[key];
            if (typeof val === 'number') return val.toFixed(2);
            return val || fallback;
        };
        
        const getSafeWeight = (weights, key, fallback = 0.0) => {
            const val = weights[key];
            if (typeof val === 'number') return val.toFixed(2);
            return fallback.toFixed(2);
        };

        // --- Bagian Parameter Umum ---
        const paramHtml = `
            <p class="mt-2">Parameter Strategi</p>
            <p class="font-mono text-xs">
                R:R Ratio: ${getSafeParam(strategyData.parameters, 'riskRewardRatio')} | 
                EMA: ${getSafeParam(strategyData.parameters, 'pullbackEmaPeriod', 'N/A')} | 
                Bias: ${getSafeParam(strategyData.parameters, 'biasThreshold', 'N/A')} |
                ATR Filter: ${getSafeParam(strategyData.parameters, 'atrFilterThreshold', 'N/A')}
            </p>
        `;

        let weightsDetailHtml = '';
        const isAutoSwitch = strategyData.dnaType === 'AutoSwitch_v1' && strategyData.autoWeights;

        if (isAutoSwitch) {
            // --- TIPE 1: AUTO-SWITCH ---
            const regimes = Object.keys(strategyData.autoWeights);
            
            weightsDetailHtml = `
                <p class="mt-4 text-purple-400">Bobot Dinamis (AutoSwitch - ${regimes.length} Rezim):</p>
                <div class="grid grid-cols-2 gap-2 mt-2 text-xs font-mono">
            `;
            
            regimes.forEach(regimeKey => {
                const weights = strategyData.autoWeights[regimeKey]?.weights || {}; // Fallback ke objek kosong
                
                // Check dasar: Pastikan kita bisa menampilkan 
                const isCorrupt = typeof weights.ma === 'undefined';

                weightsDetailHtml += `
                    <div class="p-2 rounded-md ${isCorrupt ? 'bg-red-900/50' : 'bg-gray-900/50'}">
                        <p class="${isCorrupt ? 'text-red-500' : 'text-yellow-400'}">${regimeKey.replace('_', ' ')}</p>
                        <ul class="text-gray-400 mt-1 space-y-0.5">
                            <li>MA: ${getSafeWeight(weights, 'ma')}</li>
                            <li>RSI Div: ${getSafeWeight(weights, 'rsiDivergence')}</li>
                            <li>MACD: ${getSafeWeight(weights, 'macd')}</li>
                            <li>BB Squeeze: ${getSafeWeight(weights, 'bbSqueeze')}</li>
                        </ul>
                    </div>
                `;
            });

            weightsDetailHtml += `</div>`;
            
        } else {
            // --- TIPE 2: STATIS ---
            const weights = strategyData.weights || {};
            weightsDetailHtml = `
                <p class="font-semibold mt-4">Bobot Statis:</p>
                <ul class="text-xs font-mono space-y-1 mt-2">
                    <li>MA: ${getSafeWeight(weights, 'ma')}</li>
                    <li>RSI Divergence: ${getSafeWeight(weights, 'rsiDivergence')}</li>
                    <li>MACD: ${getSafeWeight(weights, 'macd')}</li>
                    <li>Pivot: ${getSafeWeight(weights, 'pivot')}</li>
                    <li>VWAP: ${getSafeWeight(weights, 'vwap')}</li>
                    <li>Ichimoku: ${getSafeWeight(weights, 'ichimoku')}</li>
                    <li>Candle Pattern: ${getSafeWeight(weights, 'candlePattern')}</li>
                    <li>BB Squeeze: ${getSafeWeight(weights, 'bbSqueeze')}</li>
                    <li>PSAR: ${getSafeWeight(weights, 'psar')}</li>
                </ul>
            `;
        }

        // --- RENDERING FINAL ---
        importedSinyalPanel.innerHTML = `
            <div class="mt-2 text-center">
                <p class="">Metadata Strategi</p>
                <p class="font-mono text-xs">
                    Tipe DNA: ${strategyData.metadata.dnaType} |
                    Aset: ${strategyData.metadata.sourceAsset || 'N/A'} |
                    Timeframe: ${strategyData.metadata.sourceTimeframe || 'N/A'}
                </p>
                
                ${paramHtml}
                ${weightsDetailHtml}

                <p class="text-gray-400 text-xs mt-4">Strategi diimpor berhasil. Dashboard siap beradaptasi.</p>
            </div>
        `;
    }

    // ======================================================================
// GANTI FUNGSI 'connectToBinance' LAMA ANDA DENGAN VERSI BARU INI
// ======================================================================
    function connectToBinance(symbol, interval) {
        if (liveWebSocket) {
            liveWebSocket.close();
        }
  
        const baseUrl = 'wss://fstream.binance.com';

        const wsUrl = `${baseUrl}/ws/${symbol.toLowerCase()}@kline_${interval}`;
        //console.log(`Menghubungkan ke WebSocket: ${wsUrl}`); // Untuk debugging
        
        liveWebSocket = new WebSocket(wsUrl);

        liveWebSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.k) {
                updateLiveKlines(message.k);
            }
        };

        liveWebSocket.onclose = () => {
            // Coba sambung kembali setelah jeda
            setTimeout(() => connectToBinance(symbol, interval), 5000);
        };

        liveWebSocket.onerror = (error) => {
            console.error("WebSocket Error:", error);
        };
    }

    function connectToOrderFlow(symbol) {
        if (orderFlowSocket) {
            orderFlowSocket.close();
        }

        const baseUrl = 'wss://fstream.binance.com';

        // Endpoint ini khusus untuk data order book (5 level kedalaman, update setiap 100ms)
        const wsUrl = `${baseUrl}/ws/${symbol.toLowerCase()}@depth5@100ms`;

        orderFlowSocket = new WebSocket(wsUrl);

        orderFlowSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            // Fungsi ini akan kita buat di langkah selanjutnya
            updateOrderFlowPanel(message); 
        };

        orderFlowSocket.onclose = () => {
            // Coba sambung kembali jika koneksi terputus
            setTimeout(() => connectToOrderFlow(symbol), 5000);
        };

        orderFlowSocket.onerror = (error) => {
            console.error("Order Flow WebSocket Error:", error);
        };
    }

    function updateOrderFlowPanel(message) {
        // Ambil elemen UI yang akan kita ubah
        const barElement = document.getElementById('order-flow-bar');
        const textElement = document.getElementById('order-flow-text');

        if (!barElement || !textElement || !message.b || !message.a) {
            return; // Hentikan jika ada yang salah dengan data atau UI
        }

        // 'b' adalah bids (pembeli), 'a' adalah asks (penjual)
        const bids = message.b;
        const asks = message.a;

        // Hitung total volume dari 5 level order book teratas
        let totalBidVolume = 0;
        for (let i = 0; i < bids.length; i++) {
            totalBidVolume += parseFloat(bids[i][1]); // Index 1 adalah kuantitas/volume
        }

        let totalAskVolume = 0;
        for (let i = 0; i < asks.length; i++) {
            totalAskVolume += parseFloat(asks[i][1]);
        }

        const totalVolume = totalBidVolume + totalAskVolume;
        if (totalVolume === 0) return;

        // Hitung persentase dominasi pembeli
        const bidDominancePercent = (totalBidVolume / totalVolume) * 100;
        const askDominancePercent = 100 - bidDominancePercent;

        // Perbarui tampilan bar dan teksnya
        barElement.style.width = `${bidDominancePercent.toFixed(2)}%`;
        textElement.textContent = `${bidDominancePercent.toFixed(0)}% | ${askDominancePercent.toFixed(0)}%`;
    }

    function updateLiveKlines(newKline) {
        currentMarketPrice = parseFloat(newKline.c);
        if (liveData.length > 0 && liveData[liveData.length - 1][0] === newKline.t) {
            liveData[liveData.length - 1] = [newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T];
        } else {
            liveData.push([newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T]);
            if (liveData.length > 500) liveData.shift();
        }
        updateAllCharts(newKline);
        if(realtimeCache.main.tickerData) {
            realtimeCache.main.tickerData.lastPrice = currentMarketPrice.toString();
        }
        const livePriceDisplay = document.getElementById('live-price-display');
        if (livePriceDisplay) {
            livePriceDisplay.textContent = formatPrice(currentMarketPrice, realtimeCache.main.symbol);
        }
        const marketPriceInput = tsCalcElements.marketPrice;
        if (document.activeElement !== marketPriceInput) {
            marketPriceInput.value = currentMarketPrice.toFixed(getPrecisionForAsset(currentMarketPrice));
        }
    }
    
function displayLiveSignal(signalData) {
        realtimeCache.main.latestScalpingSetup = signalData;
        const symbol = document.getElementById('live-symbol-input').value.toUpperCase();
        const { bias, scores, entry, sl, tp1, tp2, tp3 } = signalData;
        const newSignalState = bias.status;
        const biasColor = newSignalState.includes('LONG') ? 'positive' : (newSignalState.includes('SHORT') ? 'negative' : 'text-gray-400');
        const isCurrentlyActive = !newSignalState.includes('NEUTRAL');

        if (newSignalState !== lastStableSignal) {
            if (isCurrentlyActive) { signalStartTime = Date.now(); } else { signalStartTime = null; }
            lastStableSignal = newSignalState;
        }

        if (timeElapsedInterval) { clearInterval(timeElapsedInterval); timeElapsedInterval = null; }
        const updateTimerDisplay = () => { 
            const el = document.getElementById('signal-time-elapsed'); 
            if (el && signalStartTime) { el.textContent = `Aktif sejak: ${formatTimeElapsed(Date.now() - signalStartTime)}`; } 
        };
        if (isCurrentlyActive) { timeElapsedInterval = setInterval(updateTimerDisplay, 1000); }

        const bullVal = scores?.bull || 0;
        const bearVal = scores?.bear || 0;
        const totalConfluence = bullVal + bearVal;
        const bullPercent = totalConfluence > 0 ? (bullVal / totalConfluence) * 100 : 50;
        const bearPercent = 100 - bullPercent;

        document.getElementById('live-signal-content').innerHTML = `
            <div class="space-y-4">
                <div class="text-center">
                    <p class="text-xl font-semibold ${biasColor} mb-1">${lastStableSignal}</p> 
                    <p class="text-sm text-gray-400">Contextual Bias</p>

                    <div class="my-3 px-2">
                        <div class="flex justify-between items-center text-xs font-mono mb-1">
                            <span class="font-bold text-lg positive">${bullVal.toFixed(1)}</span>
                            <span class="text-gray-400 text-sm">Confluence Meter</span>
                            <span class="font-bold text-lg negative">${bearVal.toFixed(1)}</span>
                        </div>
                        <div class="w-full bg-gray-800 rounded-full h-2.5 flex border border-gray-700">
                            <div class="bg-green-500 h-full rounded-l-full" style="width: ${bullPercent}%;"></div>
                            <div class="bg-red-500 h-full rounded-r-full" style="width: ${bearPercent}%;"></div>
                        </div>
                    </div>
                    <p class="text-base font-mono text-gray-400 p-2 rounded-md bg-gray-900/50 mt-2">
                        ${bias.detail}
                    </p>
                </div>

                <hr class="border-gray-700"/>
                <p id="signal-time-elapsed" class="text-center text-sm font-mono text-gray-500 mt-2">${isCurrentlyActive ? 'Aktif sejak: 00m 00s' : '— Sinyal Netral —'}</p>
                <hr class="border-gray-700"/>

                <div class="grid grid-cols-2 gap-4">
                    <div class="text-center">
                        <p class="text-lg text-yellow-400">${formatPrice(entry.price, symbol)}</p>
                        <p class="text-sm text-gray-400">Entry</p>
                        <p class="text-xs text-yellow-500">(${entry.percentage ? entry.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-lg text-red-400">${formatPrice(sl.price, symbol)}</p>
                        <p class="text-sm text-gray-400">Stop Loss</p>
                        <p class="text-xs text-red-500">(${sl.percentage ? sl.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                </div>
                <hr class="border-gray-700"/>
                <div class="grid grid-cols-3 gap-4">
                    <div class="text-center">
                        <p class="text-lg text-green-400">${formatPrice(tp1.price, symbol)}</p>
                        <p class="text-sm text-gray-400">TP 1 (Struktural)</p>
                        <p class="text-xs text-green-500">(${tp1.percentage ? tp1.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-lg text-green-400">${formatPrice(tp2.price, symbol)}</p>
                        <p class="text-sm text-gray-400">TP 2 (R:R 1:1.5)</p>
                        <p class="text-xs text-green-500">(${tp2.percentage ? tp2.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-lg ${tp3.price ? 'text-green-400' : 'text-gray-400'}">${formatPrice(tp3.price, symbol)}</p>
                        <p class="text-sm text-gray-400">TP 3 (R:R 1:2)</p>
                        <p class="text-xs ${tp3.price ? 'text-green-500' : 'text-gray-500'}">(${tp3.percentage ? tp3.percentage.toFixed(2) : '--'}%)</p>
                    </div>
                
                </div>
            </div>
        `;

        if (isCurrentlyActive) { updateTimerDisplay(); }
        
        const fibContainer = document.getElementById('fib-targets-display');
        if (fibContainer && signalData.fib_levels && (signalData.fib_levels.extension || signalData.fib_levels.retracement)) {
            let title = '';
            let buttonHTML = '';
            let contentHTML = '';
            const symbol = realtimeCache.main.symbol;

            if (isFibRetracementVisible && signalData.fib_levels.retracement) {
                const retrLevels = signalData.fib_levels.retracement.levels;
                const fibType = signalData.fib_levels.retracement.type || '';
                const fibColor = signalData.bias.status.includes('LONG') ? 'negative' : 'positive';
                
                title = `🎯 Fibonacci Retracement Targets (${fibType})`;
                buttonHTML = `<button onclick="toggleFibView(event)" class="btn-secondary !text-[10px] !py-0.5 !px-2">Show Extension</button>`;
                contentHTML = `
                    <div class="grid grid-cols-2 gap-x-6 gap-y-1">
                        <div class="flex justify-between"><span class="text-gray-400">0</span><span class="${fibColor}">${formatPrice(retrLevels.level_0, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.236</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_236, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.382</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_382, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.5</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_5, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.618</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_618, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.786</span><span class="${fibColor}">${formatPrice(retrLevels.level_0_786, symbol)}</span></div>
                        <div class="flex justify-between col-span-2"><span class="text-gray-400">1</span><span class="${fibColor}">${formatPrice(retrLevels.level_1, symbol)}</span></div>
                    </div>`;

            } else if (signalData.fib_levels.extension) {
                const extLevels = signalData.fib_levels.extension.levels;
                const fibType = signalData.fib_levels.extension.type || '';
                const fibColor = signalData.bias.status.includes('LONG') ? 'positive' : 'negative';

                title = `🎯 Fibonacci Extension Targets (${fibType})`;
                buttonHTML = `<button onclick="toggleFibView(event)" class="btn-secondary !text-[10px] !py-0.5 !px-2">Show Retracement</button>`;
                contentHTML = `
                    <div class="grid grid-cols-2 gap-x-6 gap-y-1">
                        <div class="flex justify-between"><span class="text-gray-400">0</span><span class="${fibColor}">${formatPrice(extLevels.level_0, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">0.618</span><span class="${fibColor}">${formatPrice(extLevels.level_0_618, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">1</span><span class="${fibColor}">${formatPrice(extLevels.level_1, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">1.272</span><span class="${fibColor}">${formatPrice(extLevels.level_1_272, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">1.618</span><span class="${fibColor}">${formatPrice(extLevels.level_1_618, symbol)}</span></div>
                        <div class="flex justify-between"><span class="text-gray-400">2.618</span><span class="${fibColor}">${formatPrice(extLevels.level_2_618, symbol)}</span></div>
                    </div>`;
            }

            fibContainer.innerHTML = `
                <details class="w-full max-w-sm">
                    <summary class="cursor-pointer flex justify-between items-center list-none -mb-1">
                        <span class="text-xs text-yellow-400">${title}</span>
                        ${buttonHTML}
                    </summary>
                    <div class="text-xs font-mono bg-gray-800/50 p-2 rounded-md mt-2">
                        ${contentHTML}
                    </div>
                </details>
            `;

        } else if (fibContainer) {
            fibContainer.innerHTML = '';
        }
    }

    function updateSignalLogStatistics() {
        let allDurations = [];
        let totalCycles = 0;
        let longCount = 0;
        let shortCount = 0;
        
        for (const file in signalLogState.statsByDnaFile) {
            const stats = signalLogState.statsByDnaFile[file];
            allDurations.push(...stats.durations);
            totalCycles += stats.totalCycles;
            longCount += stats.longCount;
            shortCount += stats.shortCount;
        }

        const durations = allDurations; 
        
        // A. Durasi Rata-rata dan Standar Deviasi (Academis!)
        let mean = 0, longest = 0, stdDev = 0;
        if (durations.length > 0) {
            const sum = durations.reduce((a, b) => a + b, 0);
            mean = sum / durations.length;
            longest = Math.max(...durations);
            
            const variance = durations.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / durations.length;
            stdDev = Math.sqrt(variance);
        }
        
        // B. Perbarui Grid Statistik
        document.getElementById('stat-total-count').textContent = `${totalCycles} (${longCount}/${shortCount})`;
        document.getElementById('stat-mean-duration').textContent = formatTimeElapsed(mean * 1000);
        document.getElementById('stat-longest-duration').textContent = formatTimeElapsed(longest * 1000);
        document.getElementById('stat-std-dev').textContent = `${stdDev.toFixed(2)}s`;


        // C. Perbarui Judul ASET/DNA (Pivot Table Title)
        const symbolInput = document.getElementById('live-symbol-input');
        const currentSymbol = symbolInput ? symbolInput.value.toUpperCase() : 'N/A';
        
        // 🔥 Perbaikan: Ambil nama file dari metadata strategi jika belum diinisialisasi
        if (activeDnaFilename === '--' && activeStrategy.metadata) {
            activeDnaFilename = activeStrategy.metadata.filename || '--';
        }

        const titleEl = document.getElementById('signal-log-asset-title');
        if (titleEl) {
            titleEl.textContent = `${currentSymbol} [DNA: ${activeDnaFilename}]`;
        }
        
        // D. Perbarui Log Histori (TABEL BARU)
        const currentFileStats = signalLogState.statsByDnaFile[activeDnaFilename] || { totalCycles: 0, longCount: 0, shortCount: 0, durations: [], history: [] };
        const historyBody = document.getElementById('signal-log-history-body');
        
        if (currentFileStats.totalCycles > 0) {
            historyBody.innerHTML = currentFileStats.history.map(log => {
                const colorClass = log.type === 'LONG' ? 'positive' : 'negative';
                const durationText = `${log.duration}s`;
                const endReason = log.endState.includes('NEUTRAL') ? 'Netralisasi' : 'Sinyal Balik';
                
                return `
                    <tr class="hover:bg-gray-800">
                        <td class="px-3 py-1 ${colorClass} ">${log.type}</td>
                        <td class="px-3 py-1 font-mono">${durationText}</td>
                        <td class="px-3 py-1 font-mono">${log.endState.split('(')[0].trim()}</td>
                        <td class="px-3 py-1 text-gray-500">${endReason}</td>
                    </tr>
                `;
            }).join('');
        } else {
            historyBody.innerHTML = `
                <tr class="text-center">
                    <td colspan="4" class="py-2 text-gray-600">Tidak ada siklus sinyal tercatat.</td>
                </tr>
            `;
        }

        try {
            localStorage.setItem('aftSignalLog', JSON.stringify(signalLogState));
        } catch (e) {
            console.error("Gagal menyimpan log AFT ke local storage:", e);
        }
    }

    function formatPrice(price, symbol) {
        if (price === null || isNaN(price) || typeof price !== 'number') {
            return 'N/A';
        }

        // 1. Coba dapatkan presisi dari simbol yang diberikan secara spesifik.
        let precision = precisionMap[symbol];

        // 2. JIKA GAGAL (atau simbol tidak diberikan): Gunakan simbol utama yang sedang aktif sebagai fallback.
        if (typeof precision !== 'number' && realtimeCache.main.symbol) {
            precision = precisionMap[realtimeCache.main.symbol];
        }

        // 3. Jika presisi berhasil ditemukan (dari salah satu cara di atas), format harga.
        if (typeof precision === 'number') {
            return `$${price.toFixed(precision)}`;
        } 
        
        // 4. Fallback terakhir jika semua gagal (seharusnya jarang terjadi setelah sesi live dimulai).
        else {
            return price >= 1 ? `$${price.toFixed(2)}` : `$${parseFloat(price.toFixed(8))}`;
        }
    }

    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) return;
        
        contentWrapper.classList.add('collapsible-content');
        
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };

        let isVisible = startVisible;
        applyState(isVisible);
        
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }

    function formatTimeElapsed(ms) {
        if (ms < 0 || isNaN(ms)) return '--';
        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        const pad = (num) => num.toString().padStart(2, '0');
        return `${pad(minutes)}m ${pad(remainingSeconds)}s`;
    }

    function exportHistoryToCSV() {
        const history = paperTrade.state.history;
        if (history.length === 0) {
            alert("Tidak ada riwayat trading untuk diekspor.");
            return;
        }

        const headers = ["Symbol", "Type", "EntryPrice", "ClosePrice", "PNL", "ROE", "ClosedAt", "Liquidated"];
        let csvContent = headers.join(",") + "\r\n";

        history.forEach(trade => {
            const row = [
                trade.symbol,
                trade.type,
                trade.entryPrice || 'N/A', 
                trade.closePrice || 'N/A', 
                trade.pnl,
                trade.roe,
                trade.closedAt.toISOString(),
                trade.liquidated ? 'TRUE' : 'FALSE'
            ];
            csvContent += row.join(",") + "\r\n";
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        const timestamp = new Date().toISOString().slice(0, 10);
        link.setAttribute("download", `trade_history_${timestamp}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function importHistoryFromCSV(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= 1) {
                alert("File CSV kosong atau hanya berisi header.");
                return;
            }

            const importedHistory = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length < 8) continue; 

                try {
                    const trade = {
                        symbol: values[0].trim(),
                        type: values[1].trim(),
                        entryPrice: parseFloat(values[2]),
                        closePrice: parseFloat(values[3]),
                        pnl: parseFloat(values[4]),
                        roe: parseFloat(values[5]),
                        closedAt: new Date(values[6].trim()),
                        liquidated: values[7].trim().toUpperCase() === 'TRUE'
                    };
                    importedHistory.push(trade);
                } catch (error) {
                    alert(`Error saat memproses baris ke-${i+1}. Cek format file Anda.`);
                    return;
                }
            }
            
            if (confirm(`Impor akan menimpa ${importedHistory.length} riwayat trading yang ada. Lanjutkan?`)) {
                paperTrade.state.history = importedHistory.reverse();
                paperTrade.saveState();
                paperTrade.render();
                alert("Impor riwayat trading berhasil!");
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 9;
        return 8;
    }

    function resetLiveSession() {
        // 🔥 KRUSIAL: TUTUP POSISI PAPER TRADING DULU SEBELUM MATIKAN WS
        if (paperTrade.state.position) {
            paperTrade.closePosition('SYSTEM_RESET');
            console.log("✅ SYSTEM_RESET: Posisi aktif simulasi ditutup paksa.");
        }
        
        if (window.syncInterval) clearInterval(window.syncInterval);
        if (latencyInterval) {
            clearInterval(latencyInterval);
            latencyInterval = null;
        }
        const latencyDisplay = document.getElementById('ping-latency-display');
        if (latencyDisplay) latencyDisplay.textContent = 'Ping: -- ms';
        if (liveInterval) {
            clearInterval(liveInterval);
            liveInterval = null;
        }
        if (liveWebSocket) {
            liveWebSocket.onclose = null; 
            liveWebSocket.close();
            liveWebSocket = null;
        }
        if (orderFlowSocket) {
            orderFlowSocket.onclose = null;
            orderFlowSocket.close();
            orderFlowSocket = null;
        }
        liveData = [];
        currentMarketPrice = 0;

        document.getElementById('live-signal-content').innerHTML = '<p class="text-center text-sm text-gray-400">...</p>';
        document.getElementById('live-price-display').textContent = '$0.00';
        document.getElementById('htf-compass-result').textContent = '-- Pilih Timeframe --';
        
        if(realtimeCache.main) {
            realtimeCache.main.latestScalpingSetup = null;
        }
    }

    function setButtonState(button, isLoading, text = null) {
        const btnText = button.querySelector('span');
        const btnLoader = button.querySelector('.loader');
        
        button.disabled = isLoading;

        if (btnText) {
            btnText.classList.toggle('hidden', isLoading);
        }
        if (btnLoader) {
            btnLoader.classList.toggle('hidden', !isLoading);
        }
        if (text && btnText && !isLoading) {
            btnText.textContent = text;
        }
    }

 async function startSimulation(useApi = false) {
    lastUsedApiMode = useApi;
    if (startLiveText.textContent.includes("STOP")) {
        resetLiveSession();
        setButtonState(startLiveBtn, false, "▶️ START LIVE");
        return;
    }

    // --- SINKRONISASI AI (AWAL) ---
    setButtonState(startLiveBtn, true, "Menunggu AI Ready...");
    const modelReady = await waitForModel();
    if (!modelReady) {
        alert("Gagal memuat model AI (TF.js). Beralih ke mode AutoSwitch Without AI");
        setButtonState(startLiveBtn, false, "▶️ START LIVE");
        return;
    }
    
    resetLiveSession();
    setButtonState(startLiveBtn, true, "Memulai Sesi...");

    try {
        // 🔥 LOGIKA PERBAIKAN KRUSIAL: CEK POSISI CROSS-SYMBOL DI AWAL START
        //const symbol = liveSymbolInput.value.toUpperCase();
        //const currentPositionSymbol = paperTrade.state.position?.symbol;

        //if (currentPositionSymbol && currentPositionSymbol !== symbol) {
            //console.warn(`[CROSS-SYMBOL] Posisi aktif ${currentPositionSymbol} ditutup paksa karena ganti aset ke ${symbol}.`);
            //paperTrade.closePosition('SYMBOL_SWITCH'); // Tutup posisi lama
        //}
        
        // --- SETUP SALDO DAN KONEKSI ---
        if (useApi) {
            // (Logika koneksi API di sini)
            await paperTrade.syncAccountState(); // Sinkronisasi pertama
            if (window.syncInterval) clearInterval(window.syncInterval);
            window.syncInterval = setInterval(() => paperTrade.syncAccountState(), 500);
        } else {
            // Jaga Saldo Normal (TIDAK ADA RESET OTOMATIS DI SINI)
            paperTrade.loadState(); // 🔥 KRUSIAL: Ambil state terakhir (misal: saldo $1000.00)
            paperTrade.render(); 
            
            // Atur status UI
            document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-yellow-500';
            document.getElementById('api-status-text').textContent = 'View Only/Sim';
        }
        
        // --- SETUP DATA DASAR ---
        const symbol = liveSymbolInput.value.toUpperCase();
        // Cek & Log posisi yang berbeda (TIDAK ADA PENUTUPAN PAKSA)
        const currentPositionSymbol = paperTrade.state.position?.symbol;
        if (currentPositionSymbol && currentPositionSymbol !== symbol) {
            console.warn(`[CROSS-SYMBOL] Posisi ${currentPositionSymbol} TIDAK ditutup, tetapi tidak akan diupdate dalam sesi live ${symbol} ini.`);
            // Posisi lama tetap ada di state, tetapi tidak akan diupdate oleh paperTrade.update()
        }
        // PENTING: Pindahkan penetapan simbol di sini
        realtimeCache.main.symbol = symbol; 
        const timeframe = liveTimeframeSelect.value;
        
        await fetchInitialData(symbol, timeframe);
        connectToBinance(symbol, timeframe);
        connectToOrderFlow(symbol);
        await checkBinanceLatency();
        latencyInterval = setInterval(checkBinanceLatency, 1000);

        // 🔥 KRUSIAL: LAKUKAN HARD RESET JIKA SALDO CORRUPT SAAT INI (SETELAH GANTI SIMBOL)
        if (paperTrade.state.balance < 0 || paperTrade.state.balance > 5000) {
             console.warn(`[DATA CORRUPT] Saldo terdeteksi corrupt (${formatDollar(paperTrade.state.balance)}). Melakukan Hard Reset Saldo ke $1000.`);
             paperTrade.resetAccount(false); // Reset total ke $1000 tanpa konfirmasi
        }

        setButtonState(startLiveBtn, false, "⏹️ STOP LIVE");
        liveSignalPanel.classList.remove('hidden');
        updateHtfCompass('1h');
        setupAFTPanel();

        document.querySelectorAll('.htf-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // 1. Logic standar (mengatur tombol aktif)
                document.querySelectorAll('.htf-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const newTimeframe = btn.dataset.timeframe;
                const symbol = liveSymbolInput.value.toUpperCase();

                // 2. Update VWAP Trend (Kompas)
                updateHtfCompass(newTimeframe); 

                // 3. 🔥 PERBAIKAN KRUSIAL: Update Resistance/Support menggunakan timeframe baru
                updateMarketStructurePanel(symbol, newTimeframe); 

                // Opsional: Reset throttling agar segera update
                lastMarketStructureUpdate = 0; 
            });
        });

        // =================================================
        // 🔥 INTI LOGIKA LIVE INTERVAL (LOOP BERULANG) 🔥
        // =================================================
        liveInterval = setInterval(async () => {
            if (!liveData || liveData.length < 50 || !activeStrategy || !activeStrategy.metadata) return;

            // --- 1. FETCH DATA SENTIMEN ASYNC ---
            const symbol = realtimeCache.main.symbol;
           // GANTI SELURUH BLOK LAMA (LOGIKA PEMANGGILAN MARKET STRUCTURE) DENGAN KODE BARU INI:
            // ----------------------------------------------------------------------

            // 1. Tentukan Timeframe: Ambil dari tombol HTF yang sedang aktif (misalnya 1H atau 4H)
            const activeHtfButton = document.querySelector('.htf-btn.active');
            const selectedHtfTimeframe = activeHtfButton ? activeHtfButton.dataset.timeframe : '4h'; // Default ke 4H

            // 2. Throttling: Hanya jalankan Market Structure setiap 30 detik
            if (Date.now() - lastMarketStructureUpdate > MS_UPDATE_INTERVAL_MS) {
                // PANGGIL Market Structure (Resistance/Support) dengan Timeframe yang dipilih
                updateMarketStructurePanel(symbol, selectedHtfTimeframe); 
                
                // Reset timer
                lastMarketStructureUpdate = Date.now();
            }

            // ----------------------------------------------------------------------

            let fundingRateData = { lastFundingRate: 0 };
            let lsRatioData = { longShortRatio: 1.0 };
            let lsTopRatioRes; // <-- Tambahkan deklarasi ini
            let openInterestData = [];
            
            try {
                let fundingRes, lsRatioRes, openInterestRes;
                [fundingRes, lsRatioRes, lsTopRatioRes, openInterestRes] = await Promise.all([
                    fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${symbol}`),
                    fetch(`https://fapi.binance.com/futures/data/globalLongShortAccountRatio?symbol=${symbol}&period=5m&limit=1`),
                    fetch(`https://fapi.binance.com/futures/data/topLongShortAccountRatio?symbol=${symbol}&period=5m&limit=1`),
                    fetch(`https://fapi.binance.com/futures/data/openInterestHist?symbol=${symbol}&period=5m&limit=2`)
                ]);

                if (fundingRes.ok) {
                    fundingRateData = await fundingRes.json();
                    nextFundingTimestamp = fundingRateData.nextFundingTime || 0; // <-- Tambahkan baris ini
                }
                if (lsRatioRes.ok) {
                    const lsData = await lsRatioRes.json();
                    if (lsData.length > 0) lsRatioData = lsData[0];
                }
                if (openInterestRes.ok) openInterestData = await openInterestRes.json();
            } catch (e) { console.error("Gagal mengambil data sentimen:", e); }

            const klinesSnapshot = liveData.slice(-500); 

            let lsTopRatioData = { longShortRatio: 0 };
            if (lsTopRatioRes.ok) {
                const lsTopData = await lsTopRatioRes.json();
                if (lsTopData.length > 0) lsTopRatioData = lsTopData[0];
            }

            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            const lastClose = closes.slice(-1)[0];
            const prevClose = closes.slice(-2)[0];
            const currentMarketPrice = lastClose;
            const parameters = activeStrategy.parameters;
                        const biasThreshold = parameters.biasThreshold;

            // --- 2. PREDIKSI AI dan WEIGHTS (DITHROTTLING FASE 7) ---
            
            // Dapatkan nilai rezim dan confidence terakhir dari UI/state (jika ada) sebagai fallback
            let detectedRegime = document.getElementById('active-regime-display')?.textContent.replace(/\s/g, '_') || 'RANGING'; 
            let regimeConfidence = parseFloat(document.getElementById('regime-confidence-score')?.textContent) / 100 || 0.5;

            // 🔥 FASE 7: THROTTLING PREDIKSI AI (HANYA UPDATE JIKA WAKTUNYA TIBA) 🔥
            if (Date.now() - lastAiUpdate > AI_UPDATE_INTERVAL_MS) {
                const newPrediction = await predictMarketRegime(klinesSnapshot);
                if (newPrediction && typeof newPrediction.confidence === 'number') {
                     detectedRegime = newPrediction.label;
                     regimeConfidence = newPrediction.confidence;
                }
                lastAiUpdate = Date.now();
            }
            
            const currentRegime = detectedRegime; // Tetapkan currentRegime untuk dipakai oleh logika AFT

            // 🔥 FASE 6: UPDATE UI CONFIDENCE SCORE 🔥
            const confidenceElement = document.getElementById('regime-confidence-score');
            if (confidenceElement) {
                confidenceElement.textContent = `${(regimeConfidence * 100).toFixed(1)}%`;
                // Menambahkan kelas warna berdasarkan confidence
                confidenceElement.className = `font-mono ${regimeConfidence > 0.8 ? 'positive' : (regimeConfidence < 0.6 ? 'negative' : 'text-yellow-400')}`;
            }

            regimeMemory.push(currentRegime);
            if (regimeMemory.length > REGIME_MEMORY_SIZE) {
                regimeMemory.shift(); // Hapus elemen tertua
            }

            let currentWeights = activeStrategy.weights;
            let activeRegimeKey = 'STATIC';
            
            if (activeStrategy.dnaType === 'AutoSwitch_v1' && activeStrategy.autoWeights) {
                activeRegimeKey = currentRegime;
                const dnaKey = currentRegime.toLowerCase().replace(/_(\w)/g, (match, letter) => letter.toUpperCase());

                if (activeStrategy.autoWeights[dnaKey]) { 
                    currentWeights = activeStrategy.autoWeights[dnaKey].weights; 
                    document.getElementById('active-regime-display').textContent = activeRegimeKey.replace('_', ' ');
                    document.getElementById('active-regime-display').className = getRegimeColorClass(activeRegimeKey);
                } else {
                    document.getElementById('active-regime-display').textContent = 'FALLBACK (Default)';
                    document.getElementById('active-regime-display').className = 'font-bold text-base text-gray-500';
                    currentWeights = activeStrategy.weights;
                }
            } else {
                activeRegimeKey = 'STATIC';
            }
            
            // --- 3. KALKULASI SEMUA INDIKATOR DAN SKOR ---
            const atrData = calculateATR(klinesSnapshot, 14);
            const rsiValues = calculateRSI(closes, 14);
            const htfStatus = calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop() ? 'BULLISH' : 'DOWNTREND';
            
            const indicators = {
                ma: { status: htfStatus },
                rsi: { status: rsiValues.slice(-1)[0] > 70 ? 'Overbought' : (rsiValues.slice(-1)[0] < 30 ? 'Oversold' : 'Netral'), last: rsiValues.slice(-1)[0] },
                macd: calculateMACD(closes),
                rsiDivergence: detectRSIDivergence(closes, rsiValues),
                candlePattern: findCandlestickPatterns(klinesSnapshot.slice(-2)),
                obv: { trend: calculateOBV(klinesSnapshot).pop() > calculateOBV(klinesSnapshot).slice(-2)[0] ? 'Naik' : 'Turun' },
                bbSqueeze: { status: calculateBollingerBands(closes).squeezeStatus },
                psar: calculateParabolicSAR(klinesSnapshot),
                roc: calculateROC(closes),
                vwap: { status: lastClose > calculateVWAP(klinesSnapshot) ? 'BULLISH' : 'BEARISH' },
                ichimoku: calculateIchimokuCloud(klinesSnapshot),
                fundingRate: { lastFundingRate: parseFloat(fundingRateData.lastFundingRate) },
                lsRatio: { longShortRatio: parseFloat(lsRatioData.longShortRatio) },
                openInterest: { status: (openInterestData && openInterestData.length === 2) 
                    ? ( (lastClose - prevClose > 0 && parseFloat(openInterestData[1].sumOpenInterestValue) > parseFloat(openInterestData[0].sumOpenInterestValue)) ? 'BULLISH_CONFIRMATION' : ((lastClose - prevClose < 0 && parseFloat(openInterestData[1].sumOpenInterestValue) > parseFloat(openInterestData[0].sumOpenInterestValue)) ? 'BEARISH_CONFIRMATION' : 'NETRAL') )
                    : 'NETRAL' }
            };
            let entryPrice = calculateEMA(closes, parameters.pullbackEmaPeriod).pop();
            // Kalkulasi Skor Konfluensi & Fibonacci
                const confluenceScores = calculateConfluenceScoreForCandle(currentWeights, indicators, currentRegime);
                let fibRetracementLevels = null;
                let fibExtensionLevels = null;

                // Cari ayunan harga (swing) signifikan terakhir
                const lastSwing = findLastSignificantSwing(klinesSnapshot);

                if (lastSwing) {
                    fibRetracementLevels = calculateFibonacciRetracement(lastSwing);
                    fibExtensionLevels = calculateAdvancedFibonacciExtension(lastSwing);
                }

                // --- PENGUATAN SKOR KONFLUENSI DARI FIBONACCI (KODE DEFINITIF) ---
                if (fibRetracementLevels && fibRetracementLevels.levels) {
                    const entryPriceCandle = entryPrice; 
                    const zoneTop = Math.max(fibRetracementLevels.levels.level_0_5, fibRetracementLevels.levels.level_0_618);
                    const zoneBottom = Math.min(fibRetracementLevels.levels.level_0_5, fibRetracementLevels.levels.level_0_618);

                    if (entryPriceCandle >= zoneBottom && entryPriceCandle <= zoneTop) {
                        const fiboBoostValue = 15.0;

                        if (confluenceScores.bull > confluenceScores.bear) { 
                            confluenceScores.totalBullScore += fiboBoostValue;
                            console.log(`🧠 Fibo Boost: Skor Bullish +${fiboBoostValue} (Entri di Golden Zone)`);
                        } else if (confluenceScores.bear > confluenceScores.bull) { 
                            confluenceScores.totalBearScore += fiboBoostValue;
                            console.log(`🧠 Fibo Boost: Skor Bearish +${fiboBoostValue} (Entri di Golden Zone)`);
                        }
                        confluenceScores.maxPossibleScore += fiboBoostValue;
                    }
                }

                // Hitung ulang persentase SETELAH potensi boost dari Fibo
                const bullScore = confluenceScores.maxPossibleScore > 0 ? (confluenceScores.totalBullScore / confluenceScores.maxPossibleScore) * 100 : 0;
                const bearScore = confluenceScores.maxPossibleScore > 0 ? (confluenceScores.totalBearScore / confluenceScores.maxPossibleScore) * 100 : 0;
                // --- AKHIR BLOK PENGUATAN SKOR ---
            
            // --- 4. PENENTUAN BIAS DAN SETUP TP/SL (PULIH) ---
            const isLongBias_LTF = bullScore > bearScore && (bullScore - bearScore) > biasThreshold;
            const isShortBias_LTF = bearScore > bullScore && (bearScore - bullScore) > biasThreshold;
            
            
            let stopLoss = 0, tp1 = 0, tp2 = 0, tp3 = 0; 
            let biasStatus = 'NEUTRAL';
            const currentRegimeDisplay = activeRegimeKey; 
            const atrThresholdPersen = parameters.atrFilterThreshold * 100;
            const currentATR_Persen = atrData.atrPercent;

            if (isLongBias_LTF) {
                if (currentRegime === 'BULL_TREND') biasStatus = 'LONG FOLLOW TREND';
                else if (currentRegime === 'BEAR_TREND') biasStatus = 'LONG COUNTER TREND';
                else if (currentRegime === 'RANGING') biasStatus = 'LONG REVERSION';
                else if (currentRegime === 'LOW_VOLATILITY') biasStatus = 'LONG BREAKOUT SETUP';
                else biasStatus = 'LONG BIAS (STATIC)';
            } else if (isShortBias_LTF) {
                if (currentRegime === 'BEAR_TREND') biasStatus = 'SHORT FOLLOW TREND';
                else if (currentRegime === 'BULL_TREND') biasStatus = 'SHORT COUNTER TREND';
                else if (currentRegime === 'RANGING') biasStatus = 'SHORT REVERSION';
                else if (currentRegime === 'LOW_VOLATILITY') biasStatus = 'SHORT BREAKOUT SETUP';
                else biasStatus = 'SHORT BIAS (STATIC)';
            } else {
                biasStatus = 'NEUTRAL - NO BIAS';
            }
            
            // ATR Filter
            const isATRBlocked = currentATR_Persen < atrThresholdPersen;
            if (!biasStatus.includes('NEUTRAL') && isATRBlocked) {
                biasStatus = 'NEUTRAL - LOW VOLATILITY FILTERED';
            }

            // Hitung SL/TP hanya jika ada sinyal
            if (entryPrice && !biasStatus.includes('NEUTRAL')) {
                const swingLookback = parameters.swingLookback || 20;
                const recentSwingLow = Math.min(...klinesSnapshot.slice(-swingLookback).map(k => parseFloat(k[3])));
                const recentSwingHigh = Math.max(...klinesSnapshot.slice(-swingLookback).map(k => parseFloat(k[2])));
                const rrRatio = parameters.riskRewardRatio; // Biasanya 1.5

                if (biasStatus.includes('LONG')) {
                    // SL ke Swing Low (dengan buffer 0.1%)
                    stopLoss = recentSwingLow * 0.999;
                    const riskAmount = Math.abs(entryPrice - stopLoss);
                    
                    // TP1: Ke Swing High (Struktural)
                    tp1 = recentSwingHigh;
                    // TP2: R:R 1:1.5
                    tp2 = entryPrice + (riskAmount * 1.5);
                    // 🔥 TP3: R:R 1:2 (Standar Industri)
                    tp3 = entryPrice + (riskAmount * 2.0); 

                } else { // SHORT
                    // SL ke Swing High (dengan buffer 0.1%)
                    stopLoss = recentSwingHigh * 1.001;
                    const riskAmount = Math.abs(stopLoss - entryPrice);
                    
                    // TP1: Ke Swing Low (Struktural)
                    tp1 = recentSwingLow;
                    // TP2: R:R 1:1.5
                    tp2 = entryPrice - (riskAmount * 1.5);
                    // 🔥 TP3: R:R 1:2 (Standar Industri)
                    tp3 = entryPrice - (riskAmount * 2.0);
                }
            }

            // --- 5. EKSEKUSI AFT DAN PEMBARUAN UI ---
            const regimeDisplay = currentRegimeDisplay.replace('_', ' ');
            const atrOperator = currentATR_Persen < atrThresholdPersen ? '&lt;' : '&ge;';
            const atrCheckDisplay = `${currentATR_Persen.toFixed(2)}% ${atrOperator} ${atrThresholdPersen.toFixed(2)}%`;
            
            const finalBiasDetail = `${regimeDisplay} | ${bullScore.toFixed(2)} 🐂 vs 🐻 ${bearScore.toFixed(2)} | ATR: ${atrCheckDisplay}`;
            
            const signalData = {
                bias: { 
                    status: biasStatus, 
                    // Skor Bull/Bear dihapus dari sini dan dipindah ke objeknya sendiri
                    detail: `${regimeDisplay} | ATR: ${atrCheckDisplay}` 
                },
                scores: { // Objek baru untuk menyimpan skor mentah
                    bull: bullScore,
                    bear: bearScore
                },
                entry: { price: entryPrice, percentage: entryPrice ? ((entryPrice - currentMarketPrice) / currentMarketPrice) * 100 : null },
                sl: { price: stopLoss, percentage: stopLoss && entryPrice ? ((stopLoss - entryPrice) / entryPrice) * 100 : null },
                tp1: { price: tp1, percentage: tp1 && entryPrice ? ((tp1 - entryPrice) / entryPrice) * 100 : null },
                tp2: { price: tp2, percentage: tp2 && entryPrice ? ((tp2 - entryPrice) / entryPrice) * 100 : null },
                tp3: { price: tp3, percentage: tp3 && entryPrice ? ((tp3 - entryPrice) / entryPrice) * 100 : null },
            
                fib_levels: {
                    retracement: fibRetracementLevels,
                    extension: fibExtensionLevels
                }
            };
            
            const activePosition = paperTrade.state.position;
            const currentTradeType = biasStatus.includes('LONG') ? 'long' : (biasStatus.includes('SHORT') ? 'short' : 'none');
            const isSignalActive = !biasStatus.includes('NEUTRAL');

            let positionAction = 'HOLD';
            let closeReason = 'N/A';
            
            if (activePosition) {
                const positionIsLong = activePosition.type === 'long';
                
                // 🔥 LOGIKA FASE 3: AI-POWERED EXIT (Pengecekan Rezim) 🔥
                const isRegimeAgainst = 
                    (positionIsLong && currentRegime === 'BEAR_TREND') || 
                    (!positionIsLong && currentRegime === 'BULL_TREND');

                if (isRegimeAgainst) {
                    positionAction = 'CLOSE_ONLY';
                    closeReason = `AI-REGIME_REVERSAL (${currentRegime})`;
                    console.log(`🚨 [AFT EXIT] Posisi ${activePosition.type.toUpperCase()} ditutup: Rezim AI berubah menjadi ${currentRegime}!`);
                } else {
                    // Logika Exit yang sudah ada (Sinyal Balik atau Netral)
                    const isSignalReversal = (positionIsLong && currentTradeType === 'short') || (!positionIsLong && currentTradeType === 'long');
                    const isSignalNeutralized = biasStatus.includes('NEUTRAL');
                    
                    if (isSignalReversal) {
                        positionAction = 'REVERSE_AND_CLOSE';
                        closeReason = 'REVERSAL';
                    } else if (isSignalNeutralized) {
                        positionAction = 'CLOSE_ONLY';
                        closeReason = 'NEUTRALIZED';
                    }
                }
            }

            if (positionAction === 'REVERSE_AND_CLOSE' || positionAction === 'CLOSE_ONLY') {
                paperTrade.closePosition('AFT - ' + closeReason); 
                tsCalc.recalculate();
            }

            // ======================================================================
            // LOGIKA AUTO ENTRY
            // ======================================================================
            const signalPrice = currentMarketPrice;
            
            
            realtimeCache.main.latestScalpingSetup = signalData; 

            displayLiveSignal(signalData);
            
            if (isSignalActive && !activePosition) {
                const allowedStrategies = getAftAllowedStrategies();

                // --- TAMBAHKAN BLOK YANG HILANG DI SINI ---
                const regimeFilterMode = document.querySelector('input[name="regime-filter-mode"]:checked')?.value || 'KONFIRMASI';
                let isRegimeStable = true;
                if (regimeFilterMode === 'KONFIRMASI') {
                    const requiredRegime = biasStatus.includes('LONG') ? 'BULL_TREND' : 'BEAR_TREND';
                    const opposingRegime = biasStatus.includes('LONG') ? 'BEAR_TREND' : 'BULL_TREND';
                    const requiredCount = regimeMemory.filter(r => r === requiredRegime).length;
                    const opposingCount = regimeMemory.filter(r => r === opposingRegime).length;
                    if (requiredCount < (REGIME_MEMORY_SIZE / 2) + 1 || opposingCount > 0) {
                        isRegimeStable = false;
                        console.log(`❌ [AFT FILTER] Ditolak: Stabilitas Rezim tidak terpenuhi. Memori: ${requiredCount}x ${requiredRegime}.`);
                    } else {
                        console.log(`✅ [AFT FILTER] Diterima: Stabilitas Rezim terpenuhi.`);
                    }
                }
    // --- AKHIR BLOK YANG DITAMBAHKAN ---

                
                // Cek kedua filter
                if (allowedStrategies.includes(biasStatus) && isRegimeStable) {
                    const selectedEntryMode = document.querySelector('input[name="entry-mode"]:checked').value;
                    const tradeType = currentTradeType;
                    let entryPriceFinal = 0;

                    if (selectedEntryMode === 'AGRESIF') {
                        entryPriceFinal = currentMarketPrice;
                    } else { // Mode PRESISI
                        const suggestedEntry = entryPrice;
                        const triggerConditionMet = (tradeType === 'long' && currentMarketPrice <= suggestedEntry) ||
                                                    (tradeType === 'short' && currentMarketPrice >= suggestedEntry);
                        if (triggerConditionMet) {
                            entryPriceFinal = currentMarketPrice;
                        }
                    }
                    
                    // --- UPGRADE LOGIKA POSITION SIZING ---
                    if (entryPriceFinal > 0 && stopLoss > 0) { // Pastikan SL juga valid
                        const metrics = paperTrade.calculateMetrics();
                        let dynamicRiskPercent = 2.0; // Risiko default
                        if (metrics.winRate > 55 && metrics.profitFactor > 1.5 && metrics.totalTrades > 5) {
                            dynamicRiskPercent = 3.0; // Naikkan risiko saat performa bagus
                        } else if (metrics.winRate < 45 && metrics.totalTrades > 5) {
                            dynamicRiskPercent = 1.0; // Turunkan risiko saat performa buruk
                        }

                        // 1. Tentukan Sizing Mode
                        const selectedSizingMode = document.querySelector('input[name="sizing-mode"]:checked')?.value || 'RISK_BASED';
                        const totalEquity = paperTrade.state.balance || 1000;
                        const leverage = 30; // Leverage tetap (bisa diubah)
                        let cost = 0; // Modal yang akan digunakan

                        if (selectedSizingMode === 'RISK_BASED') {
                            // LOGIKA 1: RISK-BASED (2% dari Equity)
                            const RISK_PER_TRADE_PERCENT = dynamicRiskPercent;
                            const amountToRisk = totalEquity * (RISK_PER_TRADE_PERCENT / 100);
                            const slDistance = Math.abs(entryPriceFinal - stopLoss);
                            
                            if (slDistance > 0) {
                                const quantity = amountToRisk / slDistance;
                                cost = (quantity * entryPriceFinal) / leverage;
                            } else {
                                console.warn("SL Distance nol, membatalkan trade berbasis risiko.");
                                return;
                            }
                            
                        } else if (selectedSizingMode === 'FIXED_MARGIN') {
                            // LOGIKA 2: FIXED MARGIN (10% dari Equity)
                            const MODAL_PERCENT = 10;
                            cost = totalEquity * (MODAL_PERCENT / 100);
                        }
                        
                        // 2. Safety Check & Eksekusi
                        if (cost > 0 && cost < totalEquity) {
                            paperTrade.openPosition(tradeType, leverage, cost, entryPriceFinal, tp1, tp2, 'AFT', signalPrice, biasStatus);
                        } else {
                            console.warn(`[AFT] Perhitungan Cost tidak valid ($${cost.toFixed(2)}) atau melebihi saldo. Posisi tidak dibuka.`);
                        }
                    }
                }
            }

            paperTrade.update();

            document.getElementById('active-regime-display').textContent = currentRegime.replace('_', ' ');
            
            // ++ START BLOK BARU
            // Kalkulasi data untuk panel sentiment
            const psarData = calculateParabolicSAR(klinesSnapshot);
            const rocValue = ((closes[closes.length - 1] - closes[closes.length - 1 - 12]) / closes[closes.length - 1 - 12]) * 100;
            const adxData = calculateADX(klinesSnapshot);
            const oiValue = openInterestData.length > 0 ? parseFloat(openInterestData[1].sumOpenInterestValue) : 0;

            // Panggil fungsi untuk update UI
            updateSentimentDisplay({
                psar: psarData.status,
                roc: rocValue,
                adx: adxData.value,
                atr: atrData,
                lsGlobal: parseFloat(lsRatioData.longShortRatio),
                lsTop: parseFloat(lsTopRatioData.longShortRatio),
                funding: parseFloat(fundingRateData.lastFundingRate),
                oi: oiValue
            });
            // ++ END BLOK BARU

            document.getElementById('active-regime-display').className = getRegimeColorClass(currentRegime);
            document.getElementById('ai-status').textContent = 'AI Ready (LSTM TF.js)'; // Kunci status ke SIAP (TF.js)

            // --- START MODIFIKASI FASE 4-C: LOGIKA SELF-OPTIMIZATION ---
            try {
                const strategyPerformanceForCheck = analyzeStrategyPerformance(paperTrade.state.history);
                const CONSECUTIVE_LOSS_THRESHOLD = 3;

                for (const strategyName in strategyPerformanceForCheck) {
                    const stats = strategyPerformanceForCheck[strategyName];

                    if (stats.consecutiveLosses >= CONSECUTIVE_LOSS_THRESHOLD) {
                        // Cari checkbox yang sesuai di modal filter
                        const checkbox = document.querySelector(`.aft-strategy-filter[value="${strategyName}"]`);

                        // Jika checkbox ada dan masih tercentang, nonaktifkan
                        if (checkbox && checkbox.checked) {
                            checkbox.checked = false;
                            console.log(`🔥 [AFT OPTIMIZE] Strategi "${strategyName}" dinonaktifkan sementara karena ${CONSECUTIVE_LOSS_THRESHOLD} kekalahan beruntun.`);
                        }
                    }
                }
            } catch (e) {
                // Abaikan error jika terjadi, agar interval utama tidak berhenti
            }
            // --- AKHIR MODIFIKASI FASE 4-C ---

        }, 5000); // end of setInterval

    } catch (error) {
        console.error("Gagal memulai sesi (dari dalam startSimulation):", error);
        
        // PENTING: Pindah ke mode Bunglon di sini jika AI gagal
        document.getElementById('active-regime-display').textContent = 'FALLBACK (Gagal AI)';
        document.getElementById('ai-status').textContent = 'AutoSwitch (No-AI)';
        
        setButtonState(startLiveBtn, false, "▶️ START LIVE");
        resetLiveSession();
    }
}
// =====================================================================================================================================================================

// ===================================================================
// MODUL PRAKIRAAN CUACA
// ===================================================================
    function runLiveProjection(tradeCount) {
        // 1. Cek Data DNA dan QC (Monte Carlo)
        if (!activeStrategy || !activeStrategy.metadata || !activeStrategy.metadata.qc_validation) {
            alert("Mohon impor file DNA strategi yang sudah divalidasi dengan Monte Carlo terlebih dahulu.");
            return;
        }

        const qcData = activeStrategy.metadata.qc_validation;
        const avgPnl = qcData.avgPnl_per_trade;
        const stdDevPnl = qcData.stdDevPnl_per_trade;

        // Cek terakhir untuk memastikan data statistik ada
        if (typeof avgPnl !== 'number' || typeof stdDevPnl !== 'number' || stdDevPnl === 0) {
            alert("Error: Data statistik (avgPnl/stdDevPnl) tidak valid atau standar deviasi nol. Jalankan simulasi Monte Carlo lagi.");
            return;
        }

        // 2. Cek Keselamatan Elemen HTML (Safety Check)
        const startEquityEl = document.getElementById('forecast-start-equity');
        if (!startEquityEl) { 
            alert("Gagal memuat panel hasil proyeksi. Coba muat ulang dasbor.");
            return;
        }

        // 3. Logika Simulasi Monte Carlo
        const startEquity = paperTrade.state.balance;
        const numSimulations = 1000;
        const equityCurves = [];

        for (let i = 0; i < numSimulations; i++) {
            let currentEquity = startEquity;
            const curve = [startEquity];
            for (let j = 0; j < tradeCount; j++) {
                // Gunakan fungsi distribusi normal (Box-Muller transform)
                let u1 = Math.random();
                let u2 = Math.random();
                let z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                const randomPnl = z0 * stdDevPnl + avgPnl;
                currentEquity += randomPnl;
                curve.push(currentEquity);
            }
            equityCurves.push(curve);
        }
        
        // 4. Hitung dan Tampilkan Hasil
        
        // Hitung rata-rata dan zona probabilitas
        const numTrades = equityCurves[0].length - 1;
        const finalEquities = equityCurves.map(c => c.slice(-1)[0]);
        const avgFinalEquity = finalEquities.reduce((sum, eq) => sum + eq, 0) / finalEquities.length;
        
        const worstCase = finalEquities.sort((a,b) => a-b)[Math.floor(finalEquities.length * 0.05)];
        const lossProbability = (finalEquities.filter(eq => eq < startEquity).length / numSimulations) * 100;
        
        // Perbarui Output di Grid Hasil
        document.getElementById('forecast-start-equity').textContent = formatPrice(startEquity, realtimeCache.main.symbol);
        document.getElementById('forecast-avg-pnl').textContent = formatPrice(avgFinalEquity - startEquity, realtimeCache.main.symbol);
        document.getElementById('forecast-loss-prob').textContent = `${lossProbability.toFixed(1)}%`;
        document.getElementById('forecast-worst-case').textContent = formatPrice(worstCase, realtimeCache.main.symbol);

        // 5. Render Chart
        renderProjectionChart(equityCurves, startEquity);
    }

    function renderProjectionChart(equityCurves, startEquity) {
        const ctx = document.getElementById('forecast-chart').getContext('2d');
        if (forecastChart) forecastChart.destroy();
        
        // 1. Ambil Data Agregat
        const numTrades = equityCurves[0].length - 1;
        const finalEquities = equityCurves.map(c => c.slice(-1)[0]);
        const avgFinalEquity = finalEquities.reduce((sum, eq) => sum + eq, 0) / finalEquities.length;
        const worstCase = finalEquities.sort((a,b) => a-b)[Math.floor(finalEquities.length * 0.05)];
        const lossProbability = (finalEquities.filter(eq => eq < startEquity).length / 1000) * 100;

        // 2. KODE KRITIS: MEMASTIKAN STRUKTUR OUTPUT HASIL SELALU DIBUAT ULANG
        const resultsContainer = document.getElementById('forecast-results');
        if (resultsContainer) {
            resultsContainer.innerHTML = `
                <span>Modal Awal Proyeksi</span><span id="forecast-start-equity" class="text-right font-semibold">${formatPrice(startEquity, realtimeCache.main.symbol)}</span>
                <span>Potensi PNL Rata-rata</span><span id="forecast-avg-pnl" class="text-right font-semibold">${formatPrice(avgFinalEquity - startEquity, realtimeCache.main.symbol)}</span>
                <span>Probabilitas Loss</span><span id="forecast-loss-prob" class="text-right font-semibold">${lossProbability.toFixed(1)}%</span>
                <span>Worst Case (5%)</span><span id="forecast-worst-case" class="text-right font-semibold">${formatPrice(worstCase, realtimeCache.main.symbol)}</span>
            `;
        }

        const avgCurve = Array(numTrades + 1).fill(0).map((_, i) => equityCurves.reduce((sum, curve) => sum + curve[i], 0) / equityCurves.length);
        const labels = Array.from({ length: numTrades + 1 }, (_, i) => `Trade ${i}`);
        
        const data = {
            labels,
            datasets: [{
                label: 'Jalur Ekuitas Rata-rata',
                data: avgCurve,
                borderColor: '#F59E0B',
                tension: 0.1,
                pointRadius: 0
            }]
        };
        
        forecastChart = new Chart(ctx, {
            type: 'line', data: data, options: {
                responsive: true,
                scales: { y: { beginAtZero: false, title: { display: true, text: 'Ekuitas (USD)' } }, x: { title: { display: true, text: 'Jumlah Trade' } } }
            }
        });
    }

    function clearSignalLogHistory() {
        if (!confirm("Apakah Anda yakin ingin menghapus semua riwayat Signal Log (AFT) dan mereset statistik?")) {
            return;
        }
        
        // 1. Reset state log
        signalLogState.statsByDnaFile = {};
        
        // 2. Clear variabel live
        signalActiveStartTime = null;
        
        // 3. Update tampilan UI
        updateSignalLogStatistics();
        // 🔥 INJEKSI KRUSIAL: Hapus dari Local Storage
        localStorage.removeItem('aftSignalLog');
        // 4. Pastikan timer yang sedang berjalan dihentikan
        if (timeElapsedInterval) {
            clearInterval(timeElapsedInterval);
            timeElapsedInterval = null;
        }

        // 5. Reset tampilan timer aktif menjadi netral
        const timeElapsedEl = document.getElementById('signal-time-elapsed');
        if (timeElapsedEl) {
            timeElapsedEl.textContent = '— Sinyal Netral —';
            timeElapsedEl.classList.remove('text-red-500', 'text-yellow-400');
            timeElapsedEl.classList.add('text-gray-500');
        }

        alert("Riwayat Signal Log AFT berhasil direset.");
    }

    function setupAFTPanel() {
        const clearBtn = document.getElementById('clear-signal-log-btn');
        if (clearBtn) {
            clearBtn.addEventListener('click', clearSignalLogHistory);
        }
        
        setupToggle('toggle-signal-log-btn', 'signal-log-content-wrapper', 'toggle-signal-log-icon', false);

        updateSignalLogStatistics();
    }
// ===================================================================
// Event listener untuk tombol import (GANTI SELURUH BLOK INI)
// ===================================================================      
    document.addEventListener('DOMContentLoaded', async () => { 
        lastUsedApiMode = false;
        await initializePrecisionMap(); 
        
        setupToggle('toggle-ts-calc-btn', 'ts-calc-content-wrapper', 'toggle-ts-calc-icon', false);
        setupToggle('toggle-paper-trading-btn', 'paper-trading-content-wrapper', 'toggle-paper-trading-icon', true);
        setupToggle('toggle-import-btn', 'import-content-wrapper', 'toggle-import-icon', true);
        setupToggle('toggle-forecast-btn', 'forecast-content-wrapper', 'toggle-forecast-icon', true);
        setupToggle('toggle-signal-log-btn', 'signal-log-content-wrapper', 'toggle-signal-log-icon', true); 
        toggleChartsBtn.addEventListener('click', toggleChartsVisibility);
        
        importFile.addEventListener('change', (event) => {
            handleFileImport(event);
        });

        const openAftFilterBtn = document.getElementById('open-aft-filter-btn');
        const closeAftFilterBtn = document.getElementById('close-aft-filter-btn');

        if (openAftFilterBtn) {
            openAftFilterBtn.addEventListener('click', () => toggleAftFilterModal(true));
        }
        if (closeAftFilterBtn) {
            closeAftFilterBtn.addEventListener('click', () => toggleAftFilterModal(false));
        }
        // Listener baru untuk alur kerja API
        const connectApiBtn = document.getElementById('connect-api-btn');
        if (connectApiBtn) {
            connectApiBtn.addEventListener('click', () => {
                // Logika hanya untuk menandakan bahwa proxy sudah dikonfigurasi
                lastUsedApiMode = true; 
                document.getElementById('api-status-dot').className = 'w-3 h-3 rounded-full bg-green-500';
                document.getElementById('api-status-text').textContent = 'PROXY LIVE READY';
                document.getElementById('connect-api-status-text').textContent = '⚡️ PROXY CONNECTED'; 
                alert("✅ Proxy Connected. Tekan '▶️ START LIVE' untuk sinkronisasi saldo.");
            });
        }

        startLiveBtn.addEventListener('click', () => {
            const startLiveText = startLiveBtn.querySelector('span');

            // Cek kondisi STOP
            if (startLiveText && startLiveText.textContent.includes("STOP")) {
                resetLiveSession();
                setButtonState(startLiveBtn, false, "▶️ START LIVE");
                return;
            }
            
            // 🔥 KRUSIAL: Panggil mode yang terakhir disimpan
            const targetMode = lastUsedApiMode; // Target mode adalah mode API yang disimpan
            
            if (targetMode && !binanceApiKeys.key) {
                // Mencegah start jika mode LIVE dipilih tapi kunci hilang
                alert("Gagal memulai Live Trade. Mohon masukkan kembali kunci API Anda.");
                lastUsedApiMode = false;
                startSimulation(false); // Fallback ke simulasi
                return;
            }
            
            console.log(`Memulai sesi dengan mode: ${targetMode ? 'LIVE TRADE' : 'SIMULASI'}`);
            startSimulation(targetMode); // Panggil mode yang disimpan
        });

        document.querySelectorAll('.chart-tf-btn').forEach(btn => { /* ... (kode event listener chart Anda) */ });
        const runProjectionBtn = document.getElementById('run-live-projection-btn');
        if (runProjectionBtn) {
            runProjectionBtn.addEventListener('click', () => {
                const tradeCountInput = document.getElementById('forecast-trade-count');
                if (tradeCountInput) {
                    const tradeCount = parseInt(tradeCountInput.value, 10);
                    if (tradeCount > 0) {
                        runLiveProjection(tradeCount);
                    } else {
                        alert("Jumlah trade untuk proyeksi harus lebih besar dari 0.");
                    }
                }
            });
        }
        // Inisialisasi akhir
        initializeNewCalculator();
        paperTrade.init();
        await loadRegimeSensorModel();
        updateSignalLogStatistics();
        startFundingCountdown();
    });

</script>

</body>
</html>