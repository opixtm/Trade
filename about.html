<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOLDEN DASHBOARD - LIVE STRATEGY</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>

    <style>
    body { font-family: 'Inter', sans-serif; background-color: #000000; color: #E0E0E0; }
        .card { background-color: #151414; border: 1px solid #333; border-radius: 0.75rem; }
        .positive { color: #4ade80; }
        .negative { color: #f87171; }
        .btn-primary { background-color: #c97c00; color: #1f2937; font-weight: 600; padding: 0.625rem 1.25rem; border-radius: 0.5rem; transition: background-color 0.3s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-primary:hover { background-color: #eb9413; }
        .btn-special { background-color: #8B5CF6; color: white; font-weight: 600; padding: 0.625rem 1.25rem; border-radius: 0.5rem; transition: background-color 0.3s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-special:hover { background-color: #7C3AED; }
        .tab-button.active { border-bottom: 2px solid #c97c00; font-weight: 600; }
        .toggle-btn { transition: background-color 0.3s; }
        .toggle-btn.active { background-color: #c97c00; }
        .toggle-icon { transition: transform 0.3s ease-in-out; }
        .toggle-icon.rotate-180 { transform: rotate(180deg); }
        .indicator-label { min-width: 100px; }
        .hidden-panel { display: none; }
        .input-primary {
            background-color: #2c2c2c;
            border: 1px solid #444;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #E0E0E0;
        }
        .loader { display: flex; justify-content: center; align-items: center; gap: 4px; }
        .dot { width: 8px; height: 8px; background-color: #e1e1e1; border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both; }
        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        /* ▼▼▼ TAMBAHKAN BLOK CSS INI KE DALAM <style> ▼▼▼ */

        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }

        /* ▲▲▲ AKHIR DARI BLOK CSS ▲▲▲ */
        /* ▼▼▼ TAMBAHKAN BLOK CSS INI KE DALAM <style> ▼▼▼ */

        .btn-secondary {
            background-color: #374151; /* Warna abu-abu gelap */
            color: #E0E0E0;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Sedikit lebih terang saat disentuh mouse */
        }
        .chart-tf-btn.active {
            background-color: #c97c00; /* Warna kuning/gold untuk yang aktif */
            color: #1f2937; /* Teks gelap agar kontras */
        }

        /* ▲▲▲ AKHIR DARI BLOK CSS ▲▲▲ */
    </style>
</head>
<body class="p-8">

    <header class="text-center mb-8">
        <h1 class="text-3xl font-bold"></h1>
        <p class="text-gray-400"></p>
    </header>

    <main class="max-w-7xl mx-auto space-y-8">
        <section id="imported-strategy-section" class="card p-4">
            <button id="toggle-import-btn" class="w-full flex justify-between items-center text-left">
                <h2 class="text-lg font-bold">DNA STRATEGI</h2>
                <svg id="toggle-import-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <div id="import-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-700">
                    <div class="flex items-center space-x-4">
                        <label for="import-file" class="btn-special cursor-pointer flex-grow text-center">
                            PILIH FILE DNA STRATEGI (.json)
                        </label>
                        <input type="file" id="import-file" class="hidden" accept=".json" />
                    </div>
                    <div id="imported-sinyal-panel" class="mt-4 pt-4 border-t border-gray-700">
                        <p class="text-center text-sm text-gray-400"></p>
                    </div>
                </div>
            </div>
        </section>

        <section id="live-data-input-section" class="card p-6 hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <input type="text" id="live-symbol-input" placeholder="BTCUSDT" value="BTCUSDT" class="input-primary flex-grow text-center uppercase">
                <select id="live-timeframe-select" class="input-primary">
                    <option value="1m">1m</option>
                    <option value="5m" selected>5m</option>
                    <option value="15m">15m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                </select>
                <button id="start-live-btn" class="btn-primary">
                    <span>▶️ START LIVE</span>
                    <div class="loader w-5 h-5 hidden">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </button>
            </div>
            
            <section id="charts-wrapper" class="card p-4 my-4" style="display: none;">
                <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                
                <div id="chart-timeframe-selector" class="flex flex-wrap gap-2 mb-4 border-b border-gray-700 pb-4">
                    <button data-timeframe="1m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1m</button>
                    <button data-timeframe="5m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3 active">5m</button>
                    <button data-timeframe="15m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                    <button data-timeframe="1h" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1h</button>
                </div>
                <div class="chart-container relative">
                    <div class="pane-title">Price</div>
                    <div id="main-chart-container" style="height: 450px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Volume</div>
                    <div id="volume-chart-container" style="height: 100px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">RSI (14)</div>
                    <div id="rsi-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Stochastic RSI</div>
                    <div id="stoch-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">MACD</div>
                    <div id="macd-chart-container" style="height: 120px;"></div>
                </div>
            </section>
            <button id="toggle-charts-btn" class="btn-primary w-full mt-4">SHOW CHART</button>

            <div id="live-signal-panel" class="card p-6 mt-6">
                <h2 class="text-xl font-bold mb-4 text-yellow-400 flex items-center justify-between">
                    <span></span>
                    <span><span id="live-price-display" class="font-mono text-white">$0.00</span></span>
                </h2>
                <div id="htf-compass-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-semibold text-gray-400">HTF Compass</span>
                        <div id="htf-compass-selector" class="flex flex-wrap gap-2">
                            <button data-timeframe="5m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">5m</button>
                            <button data-timeframe="15m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                            <button data-timeframe="30m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">30m</button>
                            <button data-timeframe="1h" class="htf-btn btn-secondary !text-xs !py-1 !px-3 active">1H</button>
                            <button data-timeframe="4h" class="htf-btn btn-secondary !text-xs !py-1 !px-3">4H</button>
                            <button data-timeframe="1d" class="htf-btn btn-secondary !text-xs !py-1 !px-3">1D</button>
                        </div>
                    </div>
                    <div id="htf-compass-result" class="text-center mt-2 text-lg font-bold">
                        -- Pilih Timeframe --
                    </div>
                </div>
                <div id="live-signal-content">
                    <p class="text-center text-sm text-gray-400">Tekan "START LIVE" untuk melihat sinyal.</p>
                </div>
                <div id="live-signal-content">
                    <p class="text-center text-sm text-gray-400">Tekan "START LIVE" untuk melihat sinyal.</p>
                </div>
            </div>
        </section>
    </main>


<script>
document.addEventListener('DOMContentLoaded', () => {
    const importFile = document.getElementById('import-file');
    const importedStrategySection = document.getElementById('imported-strategy-section');
    const importedSinyalPanel = document.getElementById('imported-sinyal-panel');
    const liveSymbolInput = document.getElementById('live-symbol-input');
    const liveTimeframeSelect = document.getElementById('live-timeframe-select');
    const startLiveBtn = document.getElementById('start-live-btn');
    const liveDataInputSection = document.getElementById('live-data-input-section');
    const liveSignalPanel = document.getElementById('live-signal-panel');
    const startLiveText = startLiveBtn.querySelector('span');
    const startLiveLoader = startLiveBtn.querySelector('.loader');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
const chartsWrapper = document.getElementById('charts-wrapper');
        const TIMEFRAME_MAP_MS = {
            '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
            '1h': 3600000, '4h': 14400000, '1d': 86400000
        };
    
        const timeframeParameterMap = {
            '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
        };
        const userSettings = {
            presets: {
                'default': { weights: { ma: 2, rsiDivergence: 2.5, macd: 2, pivot: 2, vwap: 2, ichimoku: 3, candlePattern: 1.5, obvDivergence: 3.0, bbSqueeze: 1.5, psar: 1, roc: 1, bollingerBands: 1, rsi: 1.5, stoch: 1, linreg: 1 } },
            }
        };
       
        let activeStrategy = null;
        let liveData = null; 
        let liveWebSocket = null;
        let liveInterval = null;
        let currentChartTimeframe = '5m';

// ===================================================================
// ▼▼▼ TAMBAHKAN SELURUH BLOK "MESIN CHARTING" INI ▼▼▼

let charts = [];
let candlestickSeries = null;
let isChartsVisible = false;

// ▼▼▼ TAMBAHKAN FUNGSI BARU INI DI PUSTAKA KALKULASI ▼▼▼

async function switchChartTimeframe(newTimeframe) {
    if (newTimeframe === currentChartTimeframe) return; // Jangan lakukan apa-apa jika timeframe sama

    console.log(`Mengganti timeframe chart ke: ${newTimeframe}`);
    const symbol = liveSymbolInput.value.toUpperCase();
    currentChartTimeframe = newTimeframe; // Update timeframe saat ini

    // Tampilkan status loading
    chartsWrapper.style.opacity = '0.3';
    
    // Hentikan koneksi dan data lama
    if (liveWebSocket) liveWebSocket.close();
    liveData = [];
    destroyCharts();

    // Ambil data baru
    await fetchInitialData(symbol, newTimeframe);
    
    // Sambungkan koneksi baru
    connectToBinance(symbol, newTimeframe);
    
    // Render ulang chart dengan data baru
    renderAllCharts();
    
    // Kembalikan opacity setelah selesai
    chartsWrapper.style.opacity = '1';
}

function getChartBaseOptions(height) {
    return {
        width: document.getElementById('charts-wrapper').clientWidth - 32,
        height: height,
        layout: { background: { color: '#151414' }, textColor: '#E0E0E0' },
        grid: { vertLines: { color: 'transparent' }, horzLines: { color: 'rgba(255, 255, 255, 0.1)' } },
        timeScale: { 
            timeVisible: true, 
            borderColor: '#4B5563',
            rightOffset: 10,
        },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderColor: '#4B5563' }
    };
}

function destroyCharts() {
    charts.forEach(chart => { if (chart) chart.remove(); });
    charts = [];
    candlestickSeries = null;
    ['main-chart-container', 'volume-chart-container', 'rsi-chart-container', 'stoch-chart-container', 'macd-chart-container'].forEach(id => {
        const container = document.getElementById(id);
        if (container) container.innerHTML = '';
    });
}

// ▼▼▼ PASTE BLOK INI UNTUK MENGGANTIKAN DUA FUNGSI YANG DIHAPUS ▼▼▼

function syncCharts(...chartsToSync) {
    chartsToSync.forEach(chart => {
        if (!chart) return;
        chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
            chartsToSync.forEach(otherChart => {
                // Pastikan referensi chart valid dan bukan chart itu sendiri
                if (otherChart && chart !== otherChart) {
                    otherChart.timeScale().setVisibleRange(timeRange);
                }
            });
        });
    });
}

function renderAllCharts() {
    if (!liveData || liveData.length < 50) return;
    
    destroyCharts();

    const formattedKlines = liveData.map(d => ({ 
        time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]), 
        low: parseFloat(d[3]), close: parseFloat(d[4]) 
    }));
    
    const closes = formattedKlines.map(k => k.close);

    // Kalkulasi Indikator
    const ema21Data = calculateEMA(closes, 21).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
    const ema50Data = calculateEMA(closes, 50).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
    const bbData = calculateBollingerBands(closes);
    const formatBB = (data) => data.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time && d.value !== undefined);
    const bbUpperData = formatBB(bbData.upper);
    const bbMiddleData = formatBB(bbData.middle);
    const bbLowerData = formatBB(bbData.lower);

    const rsiValues = calculateRSI(closes, 14);
    const stochRsiData = calculateStochasticRSI(closes);
    const macdData = calculateMACD(closes);
    const volumeData = liveData.map(d => ({ 
        time: d[0] / 1000, value: parseFloat(d[5]), 
        color: parseFloat(d[4]) >= parseFloat(d[1]) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' 
    }));

    // --- PERBAIKAN LOGIKA PENYELARASAN DATA MACD ---
    const alignData = (dataArray) => {
        const offset = formattedKlines.length - dataArray.length;
        return dataArray.map((value, index) => {
            const kline = formattedKlines[index + offset];
            if (kline && value !== undefined) {
                return { time: kline.time, value };
            }
            return null;
        }).filter(Boolean);
    };
    const macdLineData = alignData(macdData.macdLine);
    const signalLineData = alignData(macdData.signalLine);
    const histogramData = macdData.histogram.map((item, index) => {
        const offset = formattedKlines.length - macdData.histogram.length;
        const kline = formattedKlines[index + offset];
        if (kline && item !== undefined) {
            return { time: kline.time, value: item.value, color: item.color };
        }
        return null;
    }).filter(Boolean);
    // --- AKHIR PERBAIKAN ---

    // Render Charts
    const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
    charts.push(mainChart);
    candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false });
    candlestickSeries.setData(formattedKlines);
    
    mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false }).setData(ema21Data);
    mainChart.addLineSeries({ color: '#FF6D00', lineWidth: 1, priceLineVisible: false }).setData(ema50Data);
    mainChart.addLineSeries({ color: 'rgba(150, 150, 150, 0.5)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, priceLineVisible: false }).setData(bbUpperData);
    mainChart.addLineSeries({ color: 'rgba(200, 200, 200, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, priceLineVisible: false }).setData(bbMiddleData);
    mainChart.addLineSeries({ color: 'rgba(150, 150, 150, 0.5)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, priceLineVisible: false }).setData(bbLowerData);

    const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
    charts.push(volumeChart);
    volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } }).setData(volumeData);

    const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(120));
    charts.push(rsiChart);
    rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 }).setData(alignData(rsiValues));

    const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(120));
    charts.push(stochChart);
    stochChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: '%K' }).setData(alignData(stochRsiData.kLine));
    stochChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: '%D' }).setData(alignData(stochRsiData.dLine));

    const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(120));
    charts.push(macdChart);
    macdChart.addHistogramSeries({ base: 0 }).setData(histogramData);
    macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceLineVisible: false }).setData(macdLineData);
    macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceLineVisible: false }).setData(signalLineData);
    
    // Panggil fungsi sinkronisasi setelah semua chart dibuat
    syncCharts(mainChart, volumeChart, rsiChart, stochChart, macdChart);
}

function updateAllCharts(newKline) {
    if (!isChartsVisible || !candlestickSeries) return;
    
    const formattedKline = { 
        time: newKline.t / 1000, open: parseFloat(newKline.o), high: parseFloat(newKline.h), 
        low: parseFloat(newKline.l), close: parseFloat(newKline.c) 
    };
    candlestickSeries.update(formattedKline);
    
    // Di sini Anda bisa menambahkan logika untuk update indikator secara real-time
    // Namun untuk saat ini, merender ulang saat candle baru dimulai sudah cukup efisien.
}

function toggleChartsVisibility() {
    isChartsVisible = !isChartsVisible;
    const chartsWrapper = document.getElementById('charts-wrapper');
    const toggleBtn = document.getElementById('toggle-charts-btn');
    
    if (isChartsVisible) {
        chartsWrapper.style.display = 'block';
        toggleBtn.textContent = 'HIDE CHART';
        renderAllCharts();
    } else {
        chartsWrapper.style.display = 'none';
        toggleBtn.textContent = 'SHOW CHART';
        destroyCharts();
    }
}
// ▲▲▲ AKHIR DARI BLOK "MESIN CHARTING" ▲▲▲
// ===================================================================
    function displayImportedStrategy(strategyData) {
        if (!strategyData) {
            importedSinyalPanel.innerHTML = `<p class="text-center text-sm text-gray-400">Gagal memuat strategi.</p>`;
            return;
        }

        importedSinyalPanel.innerHTML = `
            <div class="mt-2 text-center">
                <p class="font-mono text-sm">Profit Factor: ${strategyData.fitness.toFixed(2)} | Win Rate: ${strategyData.metrics.winRate.toFixed(2)}% | Total Trades: ${strategyData.metrics.totalTrades}</p>
                <p class="font-bold mt-2">Parameter Strategi</p>
                <p class="font-mono text-xs">R:R Ratio: ${strategyData.riskRewardRatio.toFixed(2)} | EMA: ${strategyData.pullbackEmaPeriod} | Bias: ${strategyData.biasThreshold}</p>
                
                <p class="font-bold mt-4">Bobot Indikator</p>
                <ul class="text-xs font-mono space-y-1 mt-2">
                    <li>MA: ${strategyData.weights.ma.toFixed(2)}</li>
                    <li>RSI Divergence: ${strategyData.weights.rsiDivergence.toFixed(2)}</li>
                    <li>MACD: ${strategyData.weights.macd.toFixed(2)}</li>
                    <li>Pivot: ${strategyData.weights.pivot.toFixed(2)}</li>
                    <li>VWAP: ${strategyData.weights.vwap.toFixed(2)}</li>
                    <li>Ichimoku: ${strategyData.weights.ichimoku.toFixed(2)}</li>
                    <li>Candle Pattern: ${strategyData.weights.candlePattern.toFixed(2)}</li>
                    <li>BB Squeeze: ${strategyData.weights.bbSqueeze.toFixed(2)}</li>
                    <li>PSAR: ${strategyData.weights.psar.toFixed(2)}</li>
                    <li>ATR Filter: ${strategyData.atrFilterThreshold}</li>
                </ul>

                <p class="text-gray-400 text-xs mt-4">Strategi diimpor berhasil. Dasbor siap.</p>
            </div>
        `;
    }

    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }

    function connectToBinance(symbol, interval) {
        if (liveWebSocket) {
            liveWebSocket.close();
        }
        
        const wsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`;
        liveWebSocket = new WebSocket(wsUrl);

        liveWebSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.k) {
                // Perbarui data live dengan kline baru
                updateLiveKlines(message.k);
            }
        };

        liveWebSocket.onclose = () => {
            console.log("Koneksi WebSocket terputus. Mencoba terhubung kembali...");
            setTimeout(() => connectToBinance(symbol, interval), 5000);
        };
    }

    function updateLiveKlines(newKline) {
        if (liveData.length > 0 && liveData[liveData.length - 1][0] === newKline.t) {
            liveData[liveData.length - 1] = [newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T];
        } else {
            liveData.push([newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T]);
            if (liveData.length > 500) {
                liveData.shift();
            }
            if (isChartsVisible) renderAllCharts(); 
        }
        updateAllCharts(newKline); 
    }
    
    async function fetchInitialData(symbol, interval) {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=500`;
        const response = await fetch(url);
        liveData = await response.json();
    }

function displayLiveSignal(signalData) {
    const entryPrice = signalData.entry.price !== null ? formatPrice(signalData.entry.price) : 'N/A';
    const entryPercentage = signalData.entry.percentage !== null ? `(${signalData.entry.percentage.toFixed(2)}%)` : '';
    const slPrice = signalData.sl.price !== null ? formatPrice(signalData.sl.price) : 'N/A';
    const slPercentage = signalData.sl.percentage !== null ? `(${signalData.sl.percentage.toFixed(2)}%)` : '';
    const tp1Price = signalData.tp1.price !== null ? formatPrice(signalData.tp1.price) : 'N/A';
    const tp1Percentage = signalData.tp1.percentage !== null ? `(${signalData.tp1.percentage.toFixed(2)}%)` : '';
    const tp2Price = signalData.tp2.price !== null ? formatPrice(signalData.tp2.price) : 'N/A';
    const tp2Percentage = signalData.tp2.percentage !== null ? `(${signalData.tp2.percentage.toFixed(2)}%)` : '';
    const tp3Price = signalData.tp3.price !== null ? formatPrice(signalData.tp3.price) : 'N/A';
    const tp3Percentage = signalData.tp3.percentage !== null ? `(${signalData.tp3.percentage.toFixed(2)}%)` : '';

    const biasColor = signalData.bias.status.includes('LONG') ? 'positive' : (signalData.bias.status.includes('SHORT') ? 'negative' : 'text-gray-400');
    
    document.getElementById('live-signal-content').innerHTML = `
        <div class="space-y-4">
            <div class="grid grid-cols-3 gap-2">
                <div class="text-center">
                    <p class="font-bold text-lg ${biasColor}">${signalData.bias.status}</p>
                    <p class="text-sm text-gray-400">Contextual Bias</p>
                    <p class="text-xs ${biasColor}">(${signalData.bias.detail})</p>
                </div>
                <div class="text-center">
                    <p class="font-bold text-lg text-yellow-400">${entryPrice}</p>
                    <p class="text-sm text-gray-400">Entry</p>
                    <p class="text-xs text-yellow-400">${entryPercentage}</p>
                </div>
                <div class="text-center">
                    <p class="font-bold text-lg text-red-400">${slPrice}</p>
                    <p class="text-sm text-gray-400">Stop Loss</p>
                    <p class="text-xs text-red-400">${slPercentage}</p>
                </div>
            </div>
            <hr class="border-gray-700"/>
            <div class="grid grid-cols-3 gap-2">
                <div class="text-center">
                    <p class="font-bold text-lg text-green-400">${tp1Price}</p>
                    <p class="text-sm text-gray-400">TP 1 (Struktural)</p>
                    <p class="text-xs text-green-400">${tp1Percentage}</p>
                </div>
                <div class="text-center">
                    <p class="font-bold text-lg text-green-400">${tp2Price}</p>
                    <p class="text-sm text-gray-400">TP 2 (R:R 1:1.5)</p>
                    <p class="text-xs text-green-400">${tp2Percentage}</p>
                </div>
                <div class="text-center">
                    <p class="font-bold text-lg text-gray-400">${tp3Price}</p>
                    <p class="text-sm text-gray-400">TP 3 (Key Level)</p>
                    <p class="text-xs text-gray-400">${tp3Percentage}</p>
                </div>
            </div>
        </div>
    `;
}

function formatPrice(price) {
    if (price === null || isNaN(price)) {
        return 'N/A';
    }

    if (price >= 1) {
        return `$${price.toFixed(2)}`;
    } else {
        // This will show up to 8 digits and remove trailing zeros
        return `$${parseFloat(price).toFixed(8).replace(/\.?0+$/, '')}`;
    }
}

// ▼▼▼ TAMBAHKAN FUNGSI BARU INI DI BAGIAN PUSTAKA KALKULASI ▼▼▼

function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
    const button = document.getElementById(buttonId);
    const contentWrapper = document.getElementById(contentWrapperId);
    const icon = document.getElementById(iconId);
    if (!button || !contentWrapper || !icon) return;
    
    contentWrapper.classList.add('collapsible-content');
    
    const applyState = (isVisible) => {
        if (isVisible) {
            contentWrapper.classList.add('expanded');
            icon.style.transform = 'rotate(0deg)';
        } else {
            contentWrapper.classList.remove('expanded');
            icon.style.transform = 'rotate(-90deg)';
        }
    };

    let isVisible = startVisible;
    applyState(isVisible);
    
    button.addEventListener('click', () => {
        isVisible = !isVisible;
        applyState(isVisible);
    });
}

// ▼▼▼ TAMBAHKAN FUNGSI BARU INI DI BAGIAN PUSTAKA KALKULASI ▼▼▼
async function updateHtfCompass(timeframe) {
    const resultEl = document.getElementById('htf-compass-result');
    const symbol = liveSymbolInput.value.toUpperCase();
    if (!symbol) return;

    resultEl.textContent = `Menganalisis ${timeframe}...`;
    resultEl.className = 'text-center mt-2 text-lg font-bold text-yellow-500';

    try {
        // 1. Ambil 51 candle terakhir dari HTF yang dipilih
        const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: 51 }, 'futures');
        if (!klines || klines.length < 51) {
            throw new Error("Data tidak cukup");
        }
        
        const closes = klines.map(k => parseFloat(k[4]));
        
        // 2. Lakukan kalkulasi EMA sederhana
        const ema21 = calculateEMA(closes, 21).pop();
        const ema50 = calculateEMA(closes, 50).pop();

        // 3. Tentukan tren dan perbarui UI
        if (ema21 > ema50) {
            resultEl.textContent = `▲ UPTREND (${timeframe})`;
            resultEl.className = 'text-center mt-2 text-lg font-bold positive';
        } else {
            resultEl.textContent = `▼ DOWNTREND (${timeframe})`;
            resultEl.className = 'text-center mt-2 text-lg font-bold negative';
        }

    } catch (error) {
        console.error(`Gagal update kompas HTF untuk ${timeframe}:`, error);
        resultEl.textContent = `Error (${timeframe})`;
        resultEl.className = 'text-center mt-2 text-lg font-bold negative';
    }
}

// ▼▼▼ TAMBAHKAN FUNGSI INI DI BAGIAN ATAS PUSTAKA KALKULASI ▼▼▼

async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'futures') {
    // Note: Default marketType diubah ke 'futures' karena dasbor ini untuk perpetual
    const baseUrl = 'https://fapi.binance.com/fapi/v1';
    const query = new URLSearchParams(params).toString();
    const url = `${baseUrl}/${endpoint}?${query}`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            const errorData = await response.json();
            const errorMessage = `Binance API error for ${endpoint}: ${errorData.msg || response.statusText}`;
            throw new Error(errorMessage);
        }
        return response.json();
    } catch (error) {
        console.error(`Network Error fetching from ${url}: ${error.message}`);
        throw new Error(`Gagal mengambil data untuk ${endpoint} dari Binance.`);
    }
}

// ... (sisa fungsi kalkulasi lainnya seperti calculateEMA, dll.)
// ===================================================================
// BAGIAN 2: PUSTAKA FUNGSI KALKULASI MURNI 
// ===================================================================
    const calculateEMA = (data, period) => {
        if (!data || data.length < period) {
            return [];
        }

        const k = 2 / (period + 1);
        let emaArray = [];

        if (data.length > 0) {
            let sum = 0;
            for (let i = 0; i < period; i++) {
            sum += data[i] || 0;
            }
            emaArray[period - 1] = sum / period;
            for (let i = period; i < data.length; i++) {
            emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
            }
        }

        return emaArray;
    };
    
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) {
            return [];
        }
        
        let sma = [];
        let sum = 0;

   
        for (let i = 0; i < period; i++) {
            sum += data[i];
        }
        sma.push(sum / period);

        for (let i = period; i < data.length; i++) {
            sum = sum - data[i - period] + data[i];
            sma.push(sum / period);
        }

        const alignedSma = [...Array(period - 1).fill(undefined), ...sma];
        
        return alignedSma;
    };

    const calculateRSI = (closes, period = 14) => {
    if (!closes || closes.length <= period) {
        return Array(closes.length).fill(undefined);
    }
    
    let gains = [];
    let losses = [];
    for (let i = 1; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        gains.push(diff > 0 ? diff : 0);
        losses.push(diff < 0 ? -diff : 0);
    }
    let rsi = Array(period).fill(undefined);
    let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
    let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
    rsi[period - 1] = (avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        rsi.push((avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
    }
    return rsi;
};
    
    const calculateMACD = (closes, fast, slow, signal) => {
    // PERBAIKAN: Gunakan nilai default jika parameter tidak disediakan
    if (fast === undefined) {
        fast = 12; slow = 26; signal = 9;
    }
    
    if (closes.length < slow) {
        return { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };
    }
    
    const emaFast = calculateEMA(closes, fast);
    const emaSlow = calculateEMA(closes, slow);
    const macdLine = emaSlow.map((slowVal, i) => {
        if (slowVal !== undefined && emaFast[i] !== undefined) {
            return emaFast[i] - slowVal;
        }
        return undefined;
    }).filter(v => v !== undefined);
    const signalLine = calculateEMA(macdLine, signal);
    const histogram = macdLine.map((macdVal, i) => {
        const sigVal = signalLine[i] !== undefined ? signalLine[i] : (signalLine.length > 0 ? signalLine.pop() : undefined);
        if (sigVal !== undefined) {
            const histValue = macdVal - sigVal;
            const prevHistValue = (i > 0 && macdLine[i - 1] !== undefined && signalLine[i - 1] !== undefined) ? (macdLine[i - 1] - signalLine[i - 1]) : 0;
            return {
                value: histValue,
                color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
            };
        }
        return undefined;
    }).filter(v => v !== undefined);
    const lastMacd = macdLine.pop() || 0;
    const lastSig = signalLine.pop() || 0;
    const prevMacdLine = macdLine.pop() || 0;
    const prevSignalLine = signalLine.pop() || 0;
    let status = 'Netral';
    if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) {
        status = 'Bullish Cross';
    } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) {
        status = 'Bearish Cross';
    }
    return { status, macdLine, signalLine, histogram };
};

    const calculateStochasticRSI = (closes, rsiPeriod = 14, stochPeriod = 14, kSmooth = 3, dSmooth = 3) => {
    const rsiValues = calculateRSI(closes, rsiPeriod);
    const validRsi = rsiValues.filter(v => v !== undefined);
    if (validRsi.length < stochPeriod) {
        return { kLine: [], dLine: [], status: 'Netral' };
    }
    
    let stochArr = [];
    for (let i = stochPeriod - 1; i < validRsi.length; i++) {
        const window = validRsi.slice(i - stochPeriod + 1, i + 1);
        const minR = Math.min(...window);
        const maxR = Math.max(...window);
        const denom = maxR - minR;
        stochArr.push(denom === 0 ? 0 : ((validRsi[i] - minR) / denom) * 100);
    }
    const kLineRaw = calculateSMA(stochArr, kSmooth);
    const dLineRaw = calculateSMA(kLineRaw.filter(v => v !== undefined), dSmooth);
    const kLine = kLineRaw.filter(v => v !== undefined);
    const dLine = dLineRaw.filter(v => v !== undefined);
    const lastK = kLine.pop() || 50;
    const lastD = dLine.pop() || 50;
    let status = 'Netral';
    if (lastK > 80 && lastD > 80) status = 'Overbought';
    else if (lastK < 20 && lastD < 20) status = 'Oversold';
    return { kLine, dLine, status };
};

    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };
        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const rsiLows = findPivots(recentRSI, false), rsiHighs = findPivots(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH' };
        }
        return { status: 'NONE' };
    };

    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i-1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) obv.push(obv[i-1] + volume);
            else if (close < prevClose) obv.push(obv[i-1] - volume);
            else obv.push(obv[i-1]);
        }
        return obv;
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };

    const findCandlestickPatterns = (klines) => {
        if (!klines || klines.length < 2) return { bias: 'NETRAL' };
        const getCandle = (k) => {
            const [o, h, l, c] = k.slice(1, 5).map(parseFloat);
            return { open: o, close: c, isGreen: c > o, isRed: c < o };
        };
        const c1 = getCandle(klines[klines.length - 1]), c2 = getCandle(klines[klines.length - 2]);
        if (c2.isRed && c1.isGreen && c1.close > c2.open) return { bias: 'BULLISH' };
        if (c2.isGreen && c1.isRed && c1.close < c2.open) return { bias: 'BEARISH' };
        return { bias: 'NETRAL' };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) {
            return { upper: [], middle: [], lower: [], squeezeStatus: 'N/A' };
        }

        // Dependensi: Memanggil fungsi calculateSMA yang sekarang sudah lebih cepat.
        const middle = calculateSMA(closes, period);
        const upper = [];
        const lower = [];
        const width = [];

        // Optimasi kalkulasi deviasi standar dengan sliding window
        let sum = 0;
        let sumOfSquares = 0;

        // Inisialisasi untuk jendela pertama
        const initialSlice = closes.slice(0, period);
        for (const val of initialSlice) {
            sum += val;
            sumOfSquares += val * val;
        }

        // Fungsi untuk menghitung dan menambahkan band
        const calculateAndPushBands = (currentSum, currentSumOfSquares) => {
            const mean = currentSum / period;
            const variance = (currentSumOfSquares / period) - (mean * mean);
            const stdev = Math.sqrt(Math.max(0, variance)); // Hindari akar negatif karena presisi float

            upper.push(mean + (stdev * stdDev));
            lower.push(mean - (stdev * stdDev));
            width.push((stdev * stdDev * 2));
        };

        // Hitung untuk jendela pertama
        calculateAndPushBands(sum, sumOfSquares);

        // Gunakan sliding window untuk sisa data
        for (let i = period; i < closes.length; i++) {
            const oldVal = closes[i - period];
            const newVal = closes[i];

            sum = sum - oldVal + newVal;
            sumOfSquares = sumOfSquares - (oldVal * oldVal) + (newVal * newVal);
            
            calculateAndPushBands(sum, sumOfSquares);
        }
        
        // Logika Squeeze (tidak berubah)
        const lastWidth = width.filter(v => v !== undefined).pop();
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            // ... logika squeeze tetap sama
        }

        // Menambahkan 'undefined' di awal untuk menjaga kompatibilitas
        const align = (arr) => [...Array(period - 1).fill(undefined), ...arr];

        return { 
            upper: align(upper), 
            middle: middle, // middle sudah memiliki 'undefined' dari calculateSMA
            lower: align(lower), 
            squeezeStatus 
        };
    };

    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { value: 0, plusDI: 0, minusDI: 0 };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { value: adxValues.filter(v=>v!==undefined).pop() || 0, plusDI: plusDIs.pop() || 0, minusDI: minusDIs.pop() || 0 };
    };

    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline || prevDayKline.length < 5) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);
        if (isNaN(high) || isNaN(low) || isNaN(close)) return null;
        return { P: (high + low + close) / 3 };
    }

    function calculateVWAP(klines, period = 20) {
        if (!klines || klines.length < period) return 0;
        let sumPV = 0, sumV = 0;
        const dataSlice = klines.slice(-period);
        dataSlice.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;
    }

    function calculateIchimokuCloud(klines) {
        if (klines.length < 52) return { status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        let tenkan = [], kijun = [];
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= 8 ? getHighLow(klines.slice(i - 8, i + 1)) : {};
            tenkan.push(tenkanHighLow.high ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= 25 ? getHighLow(klines.slice(i - 25, i + 1)) : {};
            kijun.push(kijunHighLow.high ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
        }
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = tenkan[tenkan.length - 1], lastKijun = kijun[kijun.length - 1];
        if (lastTenkan > lastKijun && lastPrice > lastKijun) return { status: "BULLISH" };
        if (lastTenkan < lastKijun && lastPrice < lastKijun) return { status: "BEARISH" };
        return { status: 'Netral' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateLinearRegressionChannel(closes, period = 14) {
        if (closes.length < period) return { status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return { status: slope > 0 ? 'BULLISH' : 'BEARISH' };
    }

    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A', atrPercent: 0 };
        }
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        const rma = (data, p) => {
            let smoothed = [];
            let sum = 0;
            for(let i=0; i<data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    if (i === p - 1) smoothed.push(sum/p);
                    else smoothed.push(undefined);
                } else if (smoothed[i-1] !== undefined) {
                    smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return smoothed;
        };
        const atrValues = rma(trs, period);
        const atr = atrValues.pop() || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
        let status;
        if (atrPercent > 5) status = 'Very High';
        else if (atrPercent > 2.5) status = 'High';
        else if (atrPercent < 1) status = 'Low';
        else status = 'Normal';
        return { value: atr, status: status, atrPercent: atrPercent }; 
    }

    function getUltimateSignalScore(indicator, signalData) {
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const mapRange = (x, inMin, inMax, outMin, outMax) => {
            const t = (x - inMin) / (inMax - inMin);
            return outMin + clamp(t, 0, 1) * (outMax - outMin);
        };       
        const confidence = (typeof signalData?.confidence === 'number')
            ? clamp(signalData.confidence, 0, 1)
            : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const biasSigned = (typeof signalData?.biasSigned === 'number')
            ? Math.sign(signalData.biasSigned)
            : null;
        if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'openInterest') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('UP')) return +1 * confidence;
            if (text.includes('DOWN')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'funding' || indicator === 'fundingRate') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 0;
            const s = Math.max(-1, Math.min(1, v / 0.0025));
            return s * confidence;
            }
        if (indicator === 'lsr' || indicator === 'lsRatio') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 1;
            const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
            return s * confidence;
            }
        if (indicator === 'orderBookBias') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BID')) return +1 * confidence;
            if (text.includes('ASK')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'bbSqueeze') {
            const st = (signalData?.status || '').toString().toUpperCase();
            if (st.includes('RELEASE')) return +1 * confidence;
            if (st.includes('ON')) return 0;
            if (st.includes('OFF')) return 0.3 * confidence;
            return 0;
        }
        return 0;
    }

    function createTFAlignmentSummary(klines, timeframes, marketType) {
        const summary = {};
        
        let score = 0;
        timeframes.forEach(tf => {
            if (klines[tf] && klines[tf].length >= 50) {
                const closes = klines[tf].map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21);
                const ema50 = calculateEMA(closes, 50);
                const lastEma21 = ema21[ema21.length - 1];
                const lastEma50 = ema50[ema50.length - 1];
                summary[tf] = lastEma21 > lastEma50 ? 'UPTREND' : 'DOWNTREND';
            } else {
                summary[tf] = 'N/A';
            }
            if (summary[tf] === 'UPTREND') score++;
            else if (summary[tf] === 'DOWNTREND') score--;
        });
        return { summary, score };
    }

    function calculateConfluenceScoreForCandle(activeWeights, indicators) {
            let totalBullScore = 0, totalBearScore = 0, maxPossibleScore = 0;

            for (const indicator in activeWeights) {
                if (indicators[indicator]) {
                    const weight = activeWeights[indicator];
                    // getUltimateSignalScore akan mengambil sinyal yang sudah matang
                    const rawScore = getUltimateSignalScore(indicator, indicators[indicator]);
                    const weightedScore = rawScore * weight;

                    if (weightedScore > 0) totalBullScore += weightedScore;
                    if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                    maxPossibleScore += Math.abs(weight);
                }
            }

            const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
            const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;

            return { bull: bullPercentage, bear: bearPercentage };
        }
    
    function calculateShortConfluenceScore(klinesSnapshot) {
            if (!klinesSnapshot || klinesSnapshot.length < 50) return { score: 0, breakdown: {} };

            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            let score = 0;
            let triggers = [];
            const rsiValues = calculateRSI(closes, 14);
            const lastRsi = rsiValues[rsiValues.length - 1];
            if (lastRsi > 72) {
                score += 3.5;
                triggers.push('RSI Overbought');
            }
            const macd = calculateMACD(closes);
            if (macd.status === 'Bearish Cross') {
                score += 2.5;
                triggers.push('MACD Cross');
            }
            const candlePattern = findCandlestickPatterns(klinesSnapshot);
            if (candlePattern.bias === 'BEARISH') {
                score += 2.0;
                triggers.push('Candle Pattern');
            }
            const lookbackPeriod = 15;
            const recentKlines = klinesSnapshot.slice(-lookbackPeriod);
            if (recentKlines.length >= 3) {
                let peakIndex = 0;
                for (let i = 1; i < recentKlines.length; i++) {
                    if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
                }
                if (peakIndex > 0 && peakIndex < lookbackPeriod - 2) {
                    const triggerCandleArr = recentKlines[peakIndex + 1];
                    if (triggerCandleArr) {
                        const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                        if (triggerCandle.Close < triggerCandle.Open) {
                            score += 3.5;
                            triggers.push('Red Candle After High');
                        }
                    }
                }
            }
            const rsiDivergence = detectRSIDivergence(closes, rsiValues);
            if (rsiDivergence.status === 'BEARISH') {
                score += 4.0;
                triggers.push('RSI Divergence');
            }
            return { score: Math.min(score, 10), triggers: triggers };
        }

    function getConfluenceAnalysis(klines) {
        if (!klines || klines.length < 50) {
            return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
        }

        let skorBullish = 0;
        let skorBearish = 0;
        const closes = klines.map(k => parseFloat(k[4]));

        const rsiValues = calculateRSI(closes);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const macd = calculateMACD(closes);
        const candlePattern = findCandlestickPatterns(klines);
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);

        if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
        if (macd.status === 'Bearish Cross') skorBearish += 2.0;
        if (lastRsi > 70) skorBearish += 1.5;
        if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

        if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
        if (macd.status === 'Bullish Cross') skorBullish += 2.0;
        if (lastRsi < 30) skorBullish += 1.5;
        if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
        
        const totalPossibleScore = 8.0;

        return { 
            skorBullish: (skorBullish / totalPossibleScore) * 10,
            skorBearish: (skorBearish / totalPossibleScore) * 10,
            detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
        };
    }
    
// ===================================================================
// Event listener untuk tombol import
// ===================================================================       
    setupToggle('toggle-import-btn', 'import-content-wrapper', 'toggle-import-icon', true);
    toggleChartsBtn.addEventListener('click', toggleChartsVisibility);
    importFile.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const strategyData = JSON.parse(e.target.result);
            activeStrategy = strategyData;
            displayImportedStrategy(activeStrategy);
            importedStrategySection.classList.remove('hidden');
            document.getElementById('live-data-input-section').classList.remove('hidden'); // PERBAIKAN: Memastikan panel muncul
            console.log("Strategi berhasil diimpor:", activeStrategy);
        } catch (error) {
            console.error(error);
            alert("Gagal memuat file. Pastikan file adalah file JSON yang valid.");
            importedStrategySection.classList.add('hidden');
        }
    };
    reader.readAsText(file);
});

startLiveBtn.addEventListener('click', async () => {
    if (!activeStrategy) {
        alert("Mohon impor file DNA strategi terlebih dahulu.");
        return;
    }

    startLiveText.classList.add('hidden');
    startLiveLoader.classList.remove('hidden');
    startLiveBtn.disabled = true;

    const symbol = liveSymbolInput.value.toUpperCase();
    const timeframe = liveTimeframeSelect.value;
    
    // Hentikan interval dan koneksi WebSocket yang sudah ada
    if (liveInterval) clearInterval(liveInterval);
    if (liveWebSocket) liveWebSocket.close();

    // === PERBAIKAN: Hapus data lama sebelum mengambil yang baru ===
    liveData = [];
    // ==========================================================
    
    await fetchInitialData(symbol, timeframe);
    
    connectToBinance(symbol, timeframe);
    
    startLiveText.classList.remove('hidden');
    startLiveLoader.classList.add('hidden');
    startLiveBtn.disabled = false;

    liveSignalPanel.classList.remove('hidden');

    // Inisialisasi kompas dengan timeframe default (1H) saat start
    updateHtfCompass('1h'); 

    // Tambahkan event listener untuk semua tombol kompas
    document.querySelectorAll('.htf-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            // Hapus status aktif dari semua tombol, lalu aktifkan yang diklik
            document.querySelectorAll('.htf-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // Panggil fungsi untuk update kompas dengan timeframe yang dipilih
            const newTimeframe = btn.dataset.timeframe;
            updateHtfCompass(newTimeframe);
        });
    });

    liveInterval = setInterval(() => {
    if (liveData && liveData.length > 50) {
        const closes = liveData.map(k => parseFloat(k[4]));
        const recentKlines = liveData.slice(-activeStrategy.swingLookback);

        const confluenceScores = calculateConfluenceScoreForCandle(activeStrategy.weights, {
            ma: { status: calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop() ? 'BULLISH' : 'BEARISH' },
            rsi: { status: calculateRSI(closes, 14).pop() > 70 ? 'Overbought' : (calculateRSI(closes, 14).pop() < 30 ? 'Oversold' : 'Netral') },
            stoch: calculateStochasticRSI(closes),
            macd: calculateMACD(closes),
            rsiDivergence: detectRSIDivergence(closes, calculateRSI(closes, 14)),
            obvDivergence: detectOBVDivergence(closes, liveData),
            pivot: { status: (closes[closes.length - 1] > calculatePivotPoints(liveData.slice(-2,-1)[0])?.P) ? 'BULLISH' : 'BEARISH' },
            vwap: { status: (closes[closes.length - 1] > calculateVWAP(liveData)) ? 'BULLISH' : 'BEARISH' },
            ichimoku: calculateIchimokuCloud(liveData),
            candlePattern: findCandlestickPatterns(recentKlines),
            bollingerBands: calculateBollingerBands(closes),
            bbSqueeze: { status: calculateBollingerBands(closes).squeezeStatus },
            psar: calculateParabolicSAR(liveData),
            roc: calculateROC(closes),
            linreg: calculateLinearRegressionChannel(closes)
        });

        const currentPrice = parseFloat(liveData[liveData.length - 1][4]);

        let biasStatus = 'NEUTRAL', biasDetail = '';
        let entryPrice = null, stopLoss = null, tp1 = null, tp2 = null;

        if (confluenceScores.bull > confluenceScores.bear + activeStrategy.biasThreshold) {
            // --- AWAL PERBAIKAN LOGIKA LONG ---
            const emaEntry = calculateEMA(closes, activeStrategy.pullbackEmaPeriod).pop();
            entryPrice = emaEntry;
            biasStatus = (currentPrice > entryPrice) ? 'LONG - FOLLOW TREND' : 'LONG - COUNTER TREND';
            biasDetail = `Bull (${confluenceScores.bull.toFixed(1)}) vs Bear (${confluenceScores.bear.toFixed(1)})`;

            const recentSwingLow = Math.min(...liveData.slice(-activeStrategy.swingLookback).map(k => parseFloat(k[3])));
            const recentSwingHigh = Math.max(...liveData.slice(-activeStrategy.swingLookback).map(k => parseFloat(k[2])));
            
            stopLoss = recentSwingLow;
            tp1 = recentSwingHigh; // TP1 sekarang Struktural
            tp2 = entryPrice + (Math.abs(entryPrice - stopLoss) * 1.5); // TP2 sekarang R:R 1:1.5
            // --- AKHIR PERBAIKAN LOGIKA LONG ---

        } else if (confluenceScores.bear > confluenceScores.bull + activeStrategy.biasThreshold) {
            // --- AWAL PERBAIKAN LOGIKA SHORT ---
            const emaEntry = calculateEMA(closes, activeStrategy.pullbackEmaPeriod).pop();
            entryPrice = emaEntry;
            biasStatus = (currentPrice < entryPrice) ? 'SHORT - FOLLOW TREND' : 'SHORT - COUNTER TREND';
            biasDetail = `Bull (${confluenceScores.bull.toFixed(1)}) vs Bear (${confluenceScores.bear.toFixed(1)})`;

            const recentSwingHigh = Math.max(...liveData.slice(-activeStrategy.swingLookback).map(k => parseFloat(k[2])));
            const recentSwingLow = Math.min(...liveData.slice(-activeStrategy.swingLookback).map(k => parseFloat(k[3])));

            stopLoss = recentSwingHigh;
            tp1 = recentSwingLow; // TP1 sekarang Struktural
            tp2 = entryPrice - (Math.abs(stopLoss - entryPrice) * 1.5); // TP2 sekarang R:R 1:1.5
            // --- AKHIR PERBAIKAN LOGIKA SHORT ---

        } else {
            biasStatus = 'NEUTRAL';
            biasDetail = `Bull (${confluenceScores.bull.toFixed(1)}) vs Bear (${confluenceScores.bear.toFixed(1)})`;
        }

        const signalData = {
            bias: { status: biasStatus, detail: biasDetail },
            entry: { price: entryPrice, percentage: entryPrice ? ((entryPrice - currentPrice) / currentPrice) * 100 : null },
            sl: { price: stopLoss, percentage: stopLoss && entryPrice ? ((stopLoss - entryPrice) / entryPrice) * 100 : null },
            tp1: { price: tp1, percentage: tp1 && entryPrice ? ((tp1 - entryPrice) / entryPrice) * 100 : null },
            tp2: { price: tp2, percentage: tp2 && entryPrice ? ((tp2 - entryPrice) / entryPrice) * 100 : null },
            tp3: { price: null, percentage: null }
        };
        
        displayLiveSignal(signalData);
        document.getElementById('live-price-display').textContent = formatPrice(currentPrice);
    }
}, 5000);

});

document.querySelectorAll('.chart-tf-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        // Update tampilan tombol yang aktif
        document.querySelectorAll('.chart-tf-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Panggil fungsi pengganti timeframe
        const newTimeframe = btn.dataset.timeframe;
        switchChartTimeframe(newTimeframe);
    });
});
});
</script>

</body>
</html>