<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GOLDEN DASHBOARD - LIVE STRATEGY</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>

    <style>
    body { font-family: 'Inter', sans-serif; background-color: #000000; color: #E0E0E0; }
        .card { background-color: #151414; border: 1px solid #333; border-radius: 0.75rem; }
        .positive { color: #4ade80; }
        .negative { color: #f87171; }
        .btn-primary { background-color: #c97c00; color: #1f2937; font-weight: 600; padding: 0.625rem 1.25rem; border-radius: 0.5rem; transition: background-color 0.3s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-primary:hover { background-color: #eb9413; }
        .btn-special { background-color: #8B5CF6; color: white; font-weight: 600; padding: 0.625rem 1.25rem; border-radius: 0.5rem; transition: background-color 0.3s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-special:hover { background-color: #7C3AED; }
        .tab-button.active { border-bottom: 2px solid #c97c00; font-weight: 600; }
        .toggle-btn { transition: background-color 0.3s; }
        .toggle-btn.active { background-color: #c97c00; }
        .toggle-icon { transition: transform 0.3s ease-in-out; }
        .toggle-icon.rotate-180 { transform: rotate(180deg); }
        .indicator-label { min-width: 100px; }
        .hidden-panel { display: none; }
        .input-primary {
            background-color: #2c2c2c;
            border: 1px solid #444;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            width: 100%;
            color: #E0E0E0;
        }
        .loader { display: flex; justify-content: center; align-items: center; gap: 4px; }
        .dot { width: 8px; height: 8px; background-color: #e1e1e1; border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both; }
        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        /* ‚ñº‚ñº‚ñº TAMBAHKAN BLOK CSS INI KE DALAM <style> ‚ñº‚ñº‚ñº */

        .collapsible-content {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        .collapsible-content.expanded {
            grid-template-rows: 1fr;
        }
        .collapsible-content > div {
            overflow: hidden;
        }

        .btn-secondary {
            background-color: #374151; /* Warna abu-abu gelap */
            color: #E0E0E0;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Sedikit lebih terang saat disentuh mouse */
        }
        .chart-tf-btn.active {
            background-color: #c97c00; /* Warna kuning/gold untuk yang aktif */
            color: #1f2937; /* Teks gelap agar kontras */
        }

        .calc-binance-style .btn-group { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 1.5rem; }
        .calc-binance-style .btn-group button { padding: 10px; border-radius: 6px; cursor: pointer; background-color: #2c2f36; border: 1px solid #3a3f4a; color: #e0e0e0; font-weight: 500; transition: background-color 0.2s; }
        .calc-binance-style .btn-group button:hover { background-color: #3a3f4a; }
        .calc-binance-style .btn-group button.active { background-color: #f0b90b; color: #14151a; border-color: #f0b90b; }
        .calc-binance-style .input-group { position: relative; margin-bottom: 1rem; }
        .calc-binance-style .input-field { width: 100%; padding: 12px; background-color: #2c2f36; border: 1px solid #3a3f4a; border-radius: 8px; color: #e0e0e0; font-size: 1.1em; }
        .calc-binance-style .input-label-top { font-size: 0.8em; color: #848e9c; margin-bottom: 8px; }
        .calc-binance-style .margin-slider { width: 100%; -webkit-appearance: none; appearance: none; height: 4px; background: #3a3f4a; outline: none; border-radius: 2px; margin: 1.5rem 0; }
        .calc-binance-style .margin-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #f0b90b; cursor: pointer; border-radius: 50%; }
        .calc-binance-style .slider-ticks { display: flex; justify-content: space-between; font-size: 0.75rem; color: #848e9c; }
        .calc-binance-style .exec-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 1.5rem; }
        .calc-binance-style .exec-buttons button { padding: 14px; font-size: 1.1em; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; }
        .calc-binance-style .btn-buy { background-color: #2ebd85; color: white; }
        .calc-binance-style .btn-sell { background-color: #f6465d; color: white; }
        .calc-binance-style .calc-result-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 1rem; font-size: 0.85em; color: #848e9c; }
        .calc-binance-style .calc-result-grid span:nth-child(even) { text-align: right; font-weight: 600; color: #e0e0e0; }
        #ts-modal-content .input-field { background-color: #2c2f36; border: 1px solid #3a3f4a; }
        #ts-modal-close-btn { font-size: 2rem; line-height: 1; }

    </style>
</head>
<body class="p-8">

    <header class="text-center mb-8">
        <h1 class="text-3xl font-bold"></h1>
        <p class="text-gray-400"></p>
    </header>

    <main class="max-w-7xl mx-auto space-y-8">
        <section id="imported-strategy-section" class="card p-4">
            <button id="toggle-import-btn" class="w-full flex justify-between items-center text-left">
                <h2 class="text-lg font-bold">DNA STRATEGI</h2>
                <svg id="toggle-import-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
            <div id="import-content-wrapper" class="collapsible-content">
                <div class="pt-4 mt-4 border-t border-gray-700">
                    <div class="flex items-center space-x-4">
                        <label for="import-file" class="btn-special cursor-pointer flex-grow text-center">
                            PILIH FILE DNA STRATEGI (.json)
                        </label>
                        <input type="file" id="import-file" class="hidden" accept=".json" />
                    </div>
                    <div id="imported-sinyal-panel" class="mt-4 pt-4 border-t border-gray-700">
                        <p class="text-center text-sm text-gray-400"></p>
                    </div>
                </div>
            </div>
        </section>

        <section id="live-data-input-section" class="card p-6 hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <input type="text" id="live-symbol-input" placeholder="BTCUSDT" value="BTCUSDT" class="input-primary flex-grow text-center uppercase">
                <select id="live-timeframe-select" class="input-primary">
                    <option value="1m">1m</option>
                    <option value="5m" selected>5m</option>
                    <option value="15m">15m</option>
                    <option value="1h">1h</option>
                    <option value="4h">4h</option>
                </select>
                <button id="start-live-btn" class="btn-primary">
                    <span>‚ñ∂Ô∏è START LIVE</span>
                    <div class="loader w-5 h-5 hidden">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </button>
            </div>
            
            <section id="charts-wrapper" class="card p-4 my-4" style="display: none;">
                <h2 class="text-xl font-bold mb-4">Live Chart</h2>
                
                <div id="chart-timeframe-selector" class="flex flex-wrap gap-2 mb-4 border-b border-gray-700 pb-4">
                    <button data-timeframe="1m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1m</button>
                    <button data-timeframe="5m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3 active">5m</button>
                    <button data-timeframe="15m" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                    <button data-timeframe="1h" class="chart-tf-btn btn-secondary !text-xs !py-1 !px-3">1h</button>
                </div>
                <div class="chart-container relative">
                    <div class="pane-title">Price</div>
                    <div id="main-chart-container" style="height: 450px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Volume</div>
                    <div id="volume-chart-container" style="height: 100px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">RSI (14)</div>
                    <div id="rsi-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">Stochastic RSI</div>
                    <div id="stoch-chart-container" style="height: 120px;"></div>
                </div>
                <div class="chart-container relative mt-2 pt-2 border-t border-gray-700">
                    <div class="pane-title">MACD</div>
                    <div id="macd-chart-container" style="height: 120px;"></div>
                </div>
            </section>
            <button id="toggle-charts-btn" class="btn-primary w-full mt-4">SHOW CHART</button>

            <div id="live-signal-panel" class="card p-6 mt-6">
                <h2 class="text-xl font-bold mb-4 text-yellow-400 flex items-center justify-between">
                    <span></span>
                    <span><span id="live-price-display" class="font-mono text-white">$0.00</span></span>
                </h2>
                <div id="htf-compass-container" class="mb-4 p-3 rounded-lg bg-gray-900/50 border border-gray-700">
                    <div class="flex justify-between items-center">
                        <span class="text-sm font-semibold text-gray-400">HTF Compass</span>
                        <div id="htf-compass-selector" class="flex flex-wrap gap-2">
                            <button data-timeframe="5m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">5m</button>
                            <button data-timeframe="15m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">15m</button>
                            <button data-timeframe="30m" class="htf-btn btn-secondary !text-xs !py-1 !px-3">30m</button>
                            <button data-timeframe="1h" class="htf-btn btn-secondary !text-xs !py-1 !px-3 active">1H</button>
                            <button data-timeframe="4h" class="htf-btn btn-secondary !text-xs !py-1 !px-3">4H</button>
                            <button data-timeframe="1d" class="htf-btn btn-secondary !text-xs !py-1 !px-3">1D</button>
                        </div>
                    </div>
                    <div id="htf-compass-result" class="text-center mt-2 text-lg font-bold">
                        -- Pilih Timeframe --
                    </div>
                </div>
                <div id="live-signal-content">
                    <p class="text-center text-sm text-gray-400">Tekan "START LIVE" untuk melihat sinyal.</p>
                </div>
                <div id="live-signal-content">
                    <p class="text-center text-sm text-gray-400">Tekan "START LIVE" untuk melihat sinyal.</p>
                </div>
            </div>
        </section>
        <section id="trailing-stop-calc-section" class="card p-6">
                            <button id="toggle-ts-calc-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-xl font-bold">Kalkulator Eksekusi</h2>
                                <svg id="toggle-ts-calc-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>
                            
                            <div id="ts-calc-content-wrapper" class="collapsible-content">
                                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 calc-binance-style">
                                    <button id="autofill-ts-btn" class="btn-primary w-full mb-4">
                                        ‚ö°Ô∏è Auto-fill dari Setup Scalping
                                    </button>
                                    <div class="btn-group">
                                        <button id="ts-mode-cross" class="active">Cross</button>
                                        <input type="number" id="ts-leverage" value="20" class="input-field text-center" style="padding-right: 2.5rem;">
                                        <button id="ts-mode-isolated" class="">Isolated</button>
                                        <button id="ts-trailing-stop-options">‚öôÔ∏è TS</button>
                                    </div>

                                    <div class="grid grid-cols-2 gap-3">
                                        <div class="input-group">
                                            <label for="ts-wallet-balance" class="input-label-top">Available Balance ($)</label>
                                            <input type="number" id="ts-wallet-balance" class="input-field" value="1000">
                                        </div>
                                        <div class="input-group">
                                            <label for="ts-cost" class="input-label-top">Cost / Modal ($)</label>
                                            <input type="number" id="ts-cost" class="input-field" placeholder="0.00">
                                        </div>
                                    </div>

                                    <div>
                                        <input type="range" min="0" max="100" value="0" class="margin-slider" id="ts-margin-slider">
                                        <div class="slider-ticks">
                                            <span>0%</span>
                                            <span>25%</span>
                                            <span>50%</span>
                                            <span>75%</span>
                                            <span>100%</span>
                                        </div>
                                    </div>

                                    <div class="input-group mt-6">
                                        <label for="ts-market-price" class="input-label-top">Harga Pasar Saat Ini ($)</label>
                                        <input type="number" id="ts-market-price" class="input-field" placeholder="Harga market saat ini...">
                                    </div>

                                    <div class="tpsl-section">
                                        <div class="flex items-center gap-2">
                                            <input type="checkbox" id="ts-tpsl-toggle" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 text-yellow-500">
                                            <label for="ts-tpsl-toggle" class="text-sm">TP/SL</label>
                                        </div>
                                        <div id="ts-tpsl-inputs" class="hidden mt-4 space-y-4">
                                            <div class="input-group">
                                                <label for="ts-take-profit" class="input-label-top">Take Profit</label>
                                                <input type="number" id="ts-take-profit" class="input-field" placeholder="Mark">
                                            </div>
                                            <div class="input-group">
                                                <label for="ts-stop-loss" class="input-label-top">Stop Loss</label>
                                                <input type="number" id="ts-stop-loss" class="input-field" placeholder="Mark">
                                            </div>
                                        </div>
                                    </div>

                                    <div class="exec-buttons">
                                        <button class="btn-buy" id="ts-buy-long-btn">Buy/Long</button>
                                        <button class="btn-sell" id="ts-sell-short-btn">Sell/Short</button>
                                    </div>

                                    <div class="calc-result-grid">
                                        <span>Cost</span>
                                        <span id="ts-result-cost">--</span>
                                        <span>Max</span>
                                        <span id="ts-result-max">--</span>
                                        <span>Position Size</span>
                                        <span id="ts-result-position-size">--</span>
                                        <span>Liq. Price</span>
                                        <span id="ts-result-liq-price">--</span>
                                        <span class="pt-2 border-t border-dashed border-gray-700">Status TS</span>
                                        <span id="ts-result-status" class="pt-2 border-t border-dashed border-gray-700">--</span>
                                        <span>Harga Stop Loss TS</span>
                                        <span id="ts-result-sl-price">--</span>
                                        <span>Potensi ROE</span>
                                        <span id="ts-result-roe">--</span>
                                    </div>
                                </div>
                            </div>

                            <div id="ts-modal-container" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
                                <div id="ts-modal-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-lg font-bold">Pengaturan Trailing Stop</h3>
                                        <button id="ts-modal-close-btn" class="text-gray-400 hover:text-white">&times;</button>
                                    </div>
                                    <div class="space-y-4">
                                        <div class="form-group">
                                            <label for="ts-modal-callback-rate">Callback Rate (%)</label>
                                            <input type="number" id="ts-modal-callback-rate" class="input-field" placeholder="cth: 0.5">
                                        </div>
                                        <div class="form-group">
                                            <label for="ts-modal-activation-price">Harga Aktivasi ($)</label>
                                            <input type="number" id="ts-modal-activation-price" class="input-field" placeholder="cth: 65000">
                                        </div>
                                    </div>
                                    <div class="mt-6 text-right">
                                        <button id="ts-modal-save-btn" class="btn-primary">Simpan Pengaturan</button>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="paper-trading-section" class="card p-6">
                            <button id="toggle-paper-trading-btn" class="w-full flex justify-between items-center text-left mb-4">
                                <h2 class="text-xl font-bold">Trading Simulation</h2>
                                <svg id="toggle-paper-trading-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                </svg>
                            </button>

                            <div id="paper-trading-content-wrapper" class="collapsible-content">
                                <div class="pt-4 mt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-center">
                                        <div>
                                            <p class="text-xs text-gray-500">Equity</p>
                                            <p id="sim-equity" class="font-mono font-bold text-lg text-blue-400">$1,000.00</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-500">Unrealized PNL</p>
                                            <p id="sim-unrealized-pnl" class="font-mono font-bold text-lg text-gray-400">$0.00</p>
                                        </div>
                                        <div>
                                            <p class="text-xs text-gray-500">Available Margin</p>
                                            <p id="sim-available-margin" class="font-mono font-bold text-lg text-gray-400">$1,000.00</p>
                                        </div>
                                        <div class="flex items-center justify-center">
                                            <button id="sim-reset-account-btn" class="btn-secondary !text-xs !py-1 !px-2">Reset Account</button>
                                        </div>
                                    </div>

                                    <div id="sim-active-position-container" class="hidden">
                                        <h3 class="font-semibold text-yellow-400 mb-2">Active Position</h3>
                                        <div class="p-3 rounded-md bg-gray-800/50 text-sm space-y-2">
                                            <div class="flex justify-between items-center">
                                                <span id="sim-position-header" class="font-bold text-lg">LONG / 20x</span>
                                                <button id="sim-close-position-btn" class="btn-primary !bg-red-600 !text-xs !py-1 !px-3">Close Position</button>
                                            </div>
                                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                                <div>
                                                    <span class="text-gray-400">Size:</span>
                                                    <span id="sim-position-size" class="font-mono"></span>
                                                </div>
                                                <div>
                                                    <span class="text-gray-400">Entry:</span>
                                                    <span id="sim-position-entry" class="font-mono"></span>
                                                </div>
                                                <div>
                                                    <span class="text-gray-400">Mark:</span>
                                                    <span id="sim-position-mark" class="font-mono"></span>
                                                </div>
                                                <div>
                                                    <span class="text-gray-400">Liq:</span>
                                                    <span id="sim-position-liq" class="font-mono"></span>
                                                </div>
                                            </div>
                                            <div class="pt-2 border-t border-dashed border-gray-700">
                                                <span class="text-gray-400">PNL (ROE %):</span>
                                                <span id="sim-position-pnl" class="font-mono font-bold text-lg ml-2"></span>
                                            </div>
                                        </div>
                                    </div>

                                    <div>
                                        <div class="flex justify-between items-center mb-2">
                                            <h3 class="font-semibold text-gray-400">Trade History</h3>
                                            <div class="flex gap-2">
                                                <button id="sim-export-btn" class="btn-secondary !text-[10px] !py-0.5 !px-2">Export CSV</button>
                                                <button id="sim-import-btn" class="btn-secondary !text-[10px] !py-0.5 !px-2">Import CSV</button>
                                                <input type="file" id="sim-import-input" class="hidden" accept=".csv">
                                            </div>
                                        </div>
                                        <div id="sim-trade-history-list" class="space-y-2 text-xs max-h-48 overflow-y-auto">
                                            <p class="text-center text-gray-600">No trade history yet.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>
    </main>


<script>
// ===================================================================
// BAGIAN 1: DEKLARASI VARIABEL GLOBAL & STATE APLIKASI
// ===================================================================
    let activeStrategy = null;
    let liveData = null; 
    let liveWebSocket = null;
    let liveInterval = null;
    let currentChartTimeframe = '5m';
    let htfTrend = 'NEUTRAL';
    let latestSignalSetup = null;
    let currentMarketPrice = 0;
    let charts = [];
    let candlestickSeries = null;
    let isChartsVisible = false;
    let precisionMap = {};   

    const importFile = document.getElementById('import-file');
    const importedStrategySection = document.getElementById('imported-strategy-section');
    const importedSinyalPanel = document.getElementById('imported-sinyal-panel');
    const liveSymbolInput = document.getElementById('live-symbol-input');
    const liveTimeframeSelect = document.getElementById('live-timeframe-select');
    const startLiveBtn = document.getElementById('start-live-btn');
    const liveDataInputSection = document.getElementById('live-data-input-section');
    const liveSignalPanel = document.getElementById('live-signal-panel');
    const startLiveText = startLiveBtn.querySelector('span');
    const startLiveLoader = startLiveBtn.querySelector('.loader');
    const toggleChartsBtn = document.getElementById('toggle-charts-btn');
    const chartsWrapper = document.getElementById('charts-wrapper');
    const paperTradeElements = {
        equity: document.getElementById('sim-equity'),
        unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
        availableMargin: document.getElementById('sim-available-margin'),
        resetBtn: document.getElementById('sim-reset-account-btn'),
        positionContainer: document.getElementById('sim-active-position-container'),
        positionHeader: document.getElementById('sim-position-header'),
        closePositionBtn: document.getElementById('sim-close-position-btn'),
        positionSize: document.getElementById('sim-position-size'),
        positionEntry: document.getElementById('sim-position-entry'),
        positionMark: document.getElementById('sim-position-mark'),
        positionLiq: document.getElementById('sim-position-liq'),
        positionPnl: document.getElementById('sim-position-pnl'),
        tradeHistoryList: document.getElementById('sim-trade-history-list'),
        exportBtn: document.getElementById('sim-export-btn'),
        importBtn: document.getElementById('sim-import-btn'),
        importInput: document.getElementById('sim-import-input')
    };
    const tsCalcElements = {
        leverage: document.getElementById('ts-leverage'),
        cost: document.getElementById('ts-cost'),
        slider: document.getElementById('ts-margin-slider'),
        walletBalance: document.getElementById('ts-wallet-balance'),
        marketPrice: document.getElementById('ts-market-price'),
        tpslToggle: document.getElementById('ts-tpsl-toggle'),
        tpslInputs: document.getElementById('ts-tpsl-inputs'),
        takeProfit: document.getElementById('ts-take-profit'),
        stopLoss: document.getElementById('ts-stop-loss'),
        resultCost: document.getElementById('ts-result-cost'),
        resultMax: document.getElementById('ts-result-max'),
        resultPosSize: document.getElementById('ts-result-position-size'),
        resultLiqPrice: document.getElementById('ts-result-liq-price'),
        resultStatus: document.getElementById('ts-result-status'),
        resultSlPrice: document.getElementById('ts-result-sl-price'),
        resultRoe: document.getElementById('ts-result-roe'),
        crossBtn: document.getElementById('ts-mode-cross'),
        isolatedBtn: document.getElementById('ts-mode-isolated'),
        buyBtn: document.getElementById('ts-buy-long-btn'),
        sellBtn: document.getElementById('ts-sell-short-btn'),
        autofillBtn: document.getElementById('autofill-ts-btn'),
        tsOptionsBtn: document.getElementById('ts-trailing-stop-options'),
        modalContainer: document.getElementById('ts-modal-container'),
        modalCallbackRate: document.getElementById('ts-modal-callback-rate'),
        modalActivationPrice: document.getElementById('ts-modal-activation-price'),
        modalSaveBtn: document.getElementById('ts-modal-save-btn'),
        modalCloseBtn: document.getElementById('ts-modal-close-btn')
    };

    const TIMEFRAME_MAP_MS = {
        '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
        '1h': 3600000, '4h': 14400000, '1d': 86400000
     };
    
    const timeframeParameterMap = {
        '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };
    
    const userSettings = {
            presets: {
                'default': { weights: { ma: 2, rsiDivergence: 2.5, macd: 2, pivot: 2, vwap: 2, ichimoku: 3, candlePattern: 1.5, obvDivergence: 3.0, bbSqueeze: 1.5, psar: 1, roc: 1, bollingerBands: 1, rsi: 1.5, stoch: 1, linreg: 1 } },
            }
    };
    

    const realtimeCache = {
        main: {
            symbol: null,
            tickerData: {},
            latestScalpingSetup: null
        }
    };

    const paperTrade = {
        state: {
            balance: 1000,
            position: null, // { type: 'long'/'short', entryPrice: 65000, quantity: 0.1, leverage: 20, cost: 325 }
            history: []
        },
        elements: {
            equity: document.getElementById('sim-equity'),
            unrealizedPnl: document.getElementById('sim-unrealized-pnl'),
            availableMargin: document.getElementById('sim-available-margin'),
            resetBtn: document.getElementById('sim-reset-account-btn'),
            
            positionContainer: document.getElementById('sim-active-position-container'),
            positionHeader: document.getElementById('sim-position-header'),
            closePositionBtn: document.getElementById('sim-close-position-btn'),
            positionSize: document.getElementById('sim-position-size'),
            positionEntry: document.getElementById('sim-position-entry'),
            positionMark: document.getElementById('sim-position-mark'),
            positionLiq: document.getElementById('sim-position-liq'),
            positionPnl: document.getElementById('sim-position-pnl'),
            
            tradeHistoryList: document.getElementById('sim-trade-history-list'),
        },

            init: function() {
                this.loadState();
                this.elements.resetBtn.addEventListener('click', () => this.resetAccount());
                this.elements.closePositionBtn.addEventListener('click', () => this.closePosition());
                
                const importBtn = document.getElementById('sim-import-btn');
                const importInput = document.getElementById('sim-import-input');
                document.getElementById('sim-export-btn').addEventListener('click', exportHistoryToCSV);
                importBtn.addEventListener('click', () => importInput.click());
                importInput.addEventListener('change', importHistoryFromCSV);
                
                setInterval(() => this.update(), 500);
                this.render();
            },

            openPosition: function(type, leverage, cost, entryPrice) {
                if (this.state.position) {
                    alert("Hanya 1 posisi yang bisa dibuka dalam satu waktu.");
                    return;
                }
                if (cost > this.state.balance) {
                    alert("Modal tidak cukup untuk membuka posisi.");
                    return;
                }

                const positionSize = cost * leverage;
                const quantity = entryPrice > 0 ? positionSize / entryPrice : 0;
                const maintenanceMarginRate = 0.005; 
                const liqPriceChange = (cost / positionSize) * (1 - maintenanceMarginRate);
                const liqPrice = type === 'long' 
                    ? entryPrice * (1 - liqPriceChange) 
                    : entryPrice * (1 + liqPriceChange);

                this.state.balance -= cost;
                this.state.position = {
                    type: type,
                    entryPrice: entryPrice,
                    quantity: quantity,
                    leverage: leverage,
                    cost: cost,
                    liqPrice: liqPrice
                };
                
                this.saveState();
                this.render();
            },

            closePosition: function() {
                if (!this.state.position) return;
                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) {
                    alert("Tidak bisa menutup posisi, harga pasar tidak tersedia.");
                    return;
                }
                
                const pos = this.state.position;
                const pnl = (pos.type === 'long') 
                    ? (markPrice - pos.entryPrice) * pos.quantity 
                    : (pos.entryPrice - markPrice) * pos.quantity;

                this.state.balance += (pos.cost + pnl);
                
                this.state.history.unshift({
                    symbol: realtimeCache.main.symbol,
                    type: pos.type,
                    entryPrice: pos.entryPrice,
                    closePrice: markPrice,
                    pnl: pnl,
                    roe: (pnl / pos.cost) * 100,
                    closedAt: new Date(),
                    liquidated: false
                });
                
                if (this.state.history.length > 20) this.state.history.pop();

                this.state.position = null;
                this.saveState();
                this.render();
            },

            update: function() {
                if (!this.state.position) return;
                
                const markPrice = parseFloat(realtimeCache.main.tickerData.lastPrice);
                if (isNaN(markPrice)) return;
                
                const pos = this.state.position;
                const pnl = (pos.type === 'long') 
                    ? (markPrice - pos.entryPrice) * pos.quantity 
                    : (pos.entryPrice - markPrice) * pos.quantity;
                
                const equity = this.state.balance + pos.cost + pnl;
                
                this.elements.equity.textContent = formatPrice(equity);
                this.elements.unrealizedPnl.textContent = formatPrice(pnl);
                this.elements.unrealizedPnl.className = `font-mono font-bold text-lg ${pnl >= 0 ? 'positive' : 'negative'}`;
                this.elements.positionMark.textContent = formatPrice(markPrice);
                
                const roe = (pnl / pos.cost) * 100;
                this.elements.positionPnl.textContent = `${formatPrice(pnl)} (${roe.toFixed(2)}%)`;
                this.elements.positionPnl.className = `font-mono font-bold text-lg ml-2 ${pnl >= 0 ? 'positive' : 'negative'}`;

                if ((pos.type === 'long' && markPrice <= pos.liqPrice) || (pos.type === 'short' && markPrice >= pos.liqPrice)) {
                    alert(`Posisi ${pos.type.toUpperCase()} terlikuidasi!`);
                    this.state.history.unshift({
                        symbol: realtimeCache.main.symbol,
                        type: pos.type,
                        entryPrice: pos.entryPrice,
                        closePrice: markPrice,
                        pnl: -pos.cost,
                        roe: -100,
                        closedAt: new Date(),
                        liquidated: true
                    });
                    this.state.position = null;
                    this.saveState();
                    this.render();
                }
            },

            render: function() {
                const pos = this.state.position;
                
                if (pos) {
                    const equity = this.state.balance + pos.cost;
                    this.elements.equity.textContent = formatPrice(equity);
                    this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                    this.elements.positionContainer.classList.remove('hidden');
                    this.elements.positionHeader.textContent = `${pos.type.toUpperCase()} / ${pos.leverage}x`;
                    this.elements.positionHeader.className = `font-bold text-lg ${pos.type === 'long' ? 'positive' : 'negative'}`;
                    this.elements.positionSize.textContent = formatPrice(pos.cost * pos.leverage);
                    this.elements.positionEntry.textContent = formatPrice(pos.entryPrice);
                    this.elements.positionLiq.textContent = formatPrice(pos.liqPrice);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                } else {
                    this.elements.equity.textContent = formatPrice(this.state.balance);
                    this.elements.availableMargin.textContent = formatPrice(this.state.balance);
                    this.elements.unrealizedPnl.textContent = '$0.00';
                    this.elements.unrealizedPnl.className = 'font-mono font-bold text-lg text-gray-400';
                    this.elements.positionContainer.classList.add('hidden');
                }

                if (this.state.history.length > 0) {
                    this.elements.tradeHistoryList.innerHTML = this.state.history.map(trade => `
                        <div class="p-1.5 rounded-md ${trade.pnl >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'}">
                            <div class="flex justify-between items-center">
                                <div>
                                    <span class="font-bold ${trade.type === 'long' ? 'positive' : 'negative'}">${trade.symbol} ${trade.type.toUpperCase()}</span>
                                    <span class="text-gray-400 text-[10px] ml-2">${trade.closedAt.toLocaleTimeString()}</span>
                                </div>
                                <div class="font-mono text-right ${trade.pnl >= 0 ? 'positive' : 'negative'}">
                                    ${formatPrice(trade.pnl)} (${trade.roe.toFixed(2)}%) ${trade.liquidated ? 'üî•' : ''}
                                </div>
                            </div>
                            <div class="text-gray-400 text-[10px] font-mono flex justify-between mt-1 pt-1 border-t border-gray-700/50">
                                <span>Entry: ${formatPrice(trade.entryPrice)}</span>
                                <span>Close: ${formatPrice(trade.closePrice)}</span>
                            </div>
                        </div>
                    `).join('');
                } else {
                    this.elements.tradeHistoryList.innerHTML = '<p class="text-center text-gray-600">No trade history yet.</p>';
                }
            },

            resetAccount: function() {
                if (confirm("Apakah Anda yakin ingin mereset akun simulasi? Semua riwayat akan hilang.")) {
                    this.state.balance = 1000;
                    this.state.position = null;
                    this.state.history = [];
                    this.saveState();
                    this.render();
                }
            },

            saveState: function() {
                localStorage.setItem('paperTradeState', JSON.stringify(this.state));
            },

            loadState: function() {
                const savedState = localStorage.getItem('paperTradeState');
                if (savedState) {
                    this.state = JSON.parse(savedState);
                    if (this.state.history) {
                        this.state.history.forEach(trade => trade.closedAt = new Date(trade.closedAt));
                    }
                }
            }
    };
        
// ===================================================================
// BAGIAN 2: FUNGSI-FUNGSI PEMBANTU (HELPERS) & KALKULASI
// ===================================================================
    async function switchChartTimeframe(newTimeframe) {
        if (newTimeframe === currentChartTimeframe) return; 

        console.log(`Mengganti timeframe chart ke: ${newTimeframe}`);
        const symbol = liveSymbolInput.value.toUpperCase();
        currentChartTimeframe = newTimeframe; 

        chartsWrapper.style.opacity = '0.3';
        
        if (liveWebSocket) liveWebSocket.close();
        liveData = [];
        destroyCharts();

        await fetchInitialData(symbol, newTimeframe);
        
        connectToBinance(symbol, newTimeframe);
        
        renderAllCharts();
        
        chartsWrapper.style.opacity = '1';
    }

    async function initializePrecisionMap() {
        try {
            console.log("Mengambil data presisi aset dari Binance...");
            const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            const data = await response.json();
            
            data.symbols.forEach(symbolInfo => {
                const priceFilter = symbolInfo.filters.find(f => f.filterType === 'PRICE_FILTER');
                if (priceFilter && priceFilter.tickSize) {
                    // Logika untuk mengubah tickSize (misal "0.001") menjadi jumlah digit (3)
                    const tickSize = parseFloat(priceFilter.tickSize);
                    if (tickSize > 0) {
                        // Menggunakan logaritma untuk cara yang matematis dan andal
                        precisionMap[symbolInfo.symbol] = Math.round(-Math.log10(tickSize));
                    } else {
                        precisionMap[symbolInfo.symbol] = 0;
                    }
                }
            });
            console.log("Database presisi berhasil dibuat.", precisionMap['BTCUSDT'], precisionMap['ADAUSDT']);
        } catch (error) {
            console.error("Gagal membuat database presisi, akan menggunakan format default:", error);
            // Jika gagal, kita bisa biarkan map kosong dan formatPrice akan punya fallback
        }
    }

    async function fetchAllAggregateTrades(symbol, marketType, startTime, endTime) {
        const params = { symbol, startTime, endTime, limit: 1000 };
        return await fetchBinanceAPIData('aggTrades', params, marketType);
    }

    async function fetchInitialData(symbol, interval) {
        const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=500`;
        const response = await fetch(url);
        liveData = await response.json();
    }

    async function fetchBinanceAPIData(endpoint, params = {}, marketType = 'futures') {
        const baseUrl = 'https://fapi.binance.com/fapi/v1';
        const query = new URLSearchParams(params).toString();
        const url = `${baseUrl}/${endpoint}?${query}`;
        try {
            const response = await fetch(url);
            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = `Binance API error for ${endpoint}: ${errorData.msg || response.statusText}`;
                throw new Error(errorMessage);
            }
            return response.json();
        } catch (error) {
            console.error(`Network Error fetching from ${url}: ${error.message}`);
            throw new Error(`Gagal mengambil data untuk ${endpoint} dari Binance.`);
        }
    }

    async function updateHtfCompass(timeframe) {
        const resultEl = document.getElementById('htf-compass-result');
        const symbol = liveSymbolInput.value.toUpperCase();
        if (!symbol) return;

        resultEl.textContent = `Menganalisis ${timeframe}...`;
        resultEl.className = 'text-center mt-2 text-lg font-bold text-yellow-500';

        try {
            const klines = await fetchBinanceAPIData('klines', { symbol, interval: timeframe, limit: 51 }, 'futures');
            if (!klines || klines.length < 51) throw new Error("Data tidak cukup");
            
            const closes = klines.map(k => parseFloat(k[4]));
            const ema21 = calculateEMA(closes, 21).pop();
            const ema50 = calculateEMA(closes, 50).pop();

            if (ema21 > ema50) {
                resultEl.textContent = `‚ñ≤ UPTREND (${timeframe})`;
                resultEl.className = 'text-center mt-2 text-lg font-bold positive';
                htfTrend = 'UPTREND'; 
            } else {
                resultEl.textContent = `‚ñº DOWNTREND (${timeframe})`;
                resultEl.className = 'text-center mt-2 text-lg font-bold negative';
                htfTrend = 'DOWNTREND'; 
            }
        } catch (error) {
            console.error(`Gagal update kompas HTF untuk ${timeframe}:`, error);
            resultEl.textContent = `Error (${timeframe})`;
            resultEl.className = 'text-center mt-2 text-lg font-bold negative';
            htfTrend = 'NEUTRAL'; 
        }
    }

    function getChartBaseOptions(height) {
        return {
            width: document.getElementById('charts-wrapper').clientWidth - 32,
            height: height,
            layout: { background: { color: '#151414' }, textColor: '#E0E0E0' },
            grid: { vertLines: { color: 'transparent' }, horzLines: { color: 'rgba(255, 255, 255, 0.1)' } },
            timeScale: { 
                timeVisible: true, 
                borderColor: '#4B5563',
                rightOffset: 10,
            },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            rightPriceScale: { borderColor: '#4B5563' }
        };
    }

    function destroyCharts() {
        charts.forEach(chart => { if (chart) chart.remove(); });
        charts = [];
        candlestickSeries = null;
        ['main-chart-container', 'volume-chart-container', 'rsi-chart-container', 'stoch-chart-container', 'macd-chart-container'].forEach(id => {
            const container = document.getElementById(id);
            if (container) container.innerHTML = '';
        });
    }

    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if (!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (otherChart && chart !== otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                });
            });
        });
    }

    function renderAllCharts() {
        if (!liveData || liveData.length < 50) return;
        
        destroyCharts();

        const formattedKlines = liveData.map(d => ({ 
            time: d[0] / 1000, open: parseFloat(d[1]), high: parseFloat(d[2]), 
            low: parseFloat(d[3]), close: parseFloat(d[4]) 
        }));
        
        const closes = formattedKlines.map(k => k.close);

        const ema21Data = calculateEMA(closes, 21).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
        const ema50Data = calculateEMA(closes, 50).map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time);
        const bbData = calculateBollingerBands(closes);
        const formatBB = (data) => data.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d && d.time && d.value !== undefined);
        const bbUpperData = formatBB(bbData.upper);
        const bbMiddleData = formatBB(bbData.middle);
        const bbLowerData = formatBB(bbData.lower);
        const rsiValues = calculateRSI(closes, 14);
        const stochRsiData = calculateStochasticRSI(closes);
        const macdData = calculateMACD(closes);
        const volumeData = liveData.map(d => ({ 
            time: d[0] / 1000, value: parseFloat(d[5]), 
            color: parseFloat(d[4]) >= parseFloat(d[1]) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' 
        }));

        const alignData = (dataArray) => {
            const offset = formattedKlines.length - dataArray.length;
            return dataArray.map((value, index) => {
                const kline = formattedKlines[index + offset];
                if (kline && value !== undefined) {
                    return { time: kline.time, value };
                }
                return null;
            }).filter(Boolean);
        };
        const macdLineData = alignData(macdData.macdLine);
        const signalLineData = alignData(macdData.signalLine);
        const histogramData = macdData.histogram.map((item, index) => {
            const offset = formattedKlines.length - macdData.histogram.length;
            const kline = formattedKlines[index + offset];
            if (kline && item !== undefined) {
                return { time: kline.time, value: item.value, color: item.color };
            }
            return null;
        }).filter(Boolean);
    
        const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
        charts.push(mainChart);
        candlestickSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false });
        candlestickSeries.setData(formattedKlines);
        
        mainChart.addLineSeries({ color: '#2962FF', lineWidth: 1, priceLineVisible: false }).setData(ema21Data);
        mainChart.addLineSeries({ color: '#FF6D00', lineWidth: 1, priceLineVisible: false }).setData(ema50Data);
        mainChart.addLineSeries({ color: 'rgba(150, 150, 150, 0.5)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, priceLineVisible: false }).setData(bbUpperData);
        mainChart.addLineSeries({ color: 'rgba(200, 200, 200, 0.6)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, priceLineVisible: false }).setData(bbMiddleData);
        mainChart.addLineSeries({ color: 'rgba(150, 150, 150, 0.5)', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, priceLineVisible: false }).setData(bbLowerData);

        const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
        charts.push(volumeChart);
        volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } }).setData(volumeData);

        const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(120));
        charts.push(rsiChart);
        rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 }).setData(alignData(rsiValues));

        const stochChart = LightweightCharts.createChart(document.getElementById('stoch-chart-container'), getChartBaseOptions(120));
        charts.push(stochChart);
        stochChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: '%K' }).setData(alignData(stochRsiData.kLine));
        stochChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: '%D' }).setData(alignData(stochRsiData.dLine));

        const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(120));
        charts.push(macdChart);
        macdChart.addHistogramSeries({ base: 0 }).setData(histogramData);
        macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceLineVisible: false }).setData(macdLineData);
        macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceLineVisible: false }).setData(signalLineData);

        syncCharts(mainChart, volumeChart, rsiChart, stochChart, macdChart);
    }

    function updateAllCharts(newKline) {
        if (!isChartsVisible || !candlestickSeries) return;
        
        const formattedKline = { 
            time: newKline.t / 1000, open: parseFloat(newKline.o), high: parseFloat(newKline.h), 
            low: parseFloat(newKline.l), close: parseFloat(newKline.c) 
        };
        candlestickSeries.update(formattedKline);
    }

    function toggleChartsVisibility() {
        isChartsVisible = !isChartsVisible;
        const chartsWrapper = document.getElementById('charts-wrapper');
        const toggleBtn = document.getElementById('toggle-charts-btn');
        
        if (isChartsVisible) {
            chartsWrapper.style.display = 'block';
            toggleBtn.textContent = 'HIDE CHART';
            renderAllCharts();
        } else {
            chartsWrapper.style.display = 'none';
            toggleBtn.textContent = 'SHOW CHART';
            destroyCharts();
        }
    }

    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const dnaData = JSON.parse(e.target.result);
                const symbolInput = document.getElementById('live-symbol-input');
                const timeframeSelect = document.getElementById('live-timeframe-select');
                const importedSinyalPanel = document.getElementById('imported-sinyal-panel');

                // 1. Validasi struktur dasar file DNA
                if (!dnaData.metadata || !dnaData.parameters || !dnaData.weights) {
                    importedSinyalPanel.innerHTML = `<p class="text-center text-sm negative">‚ùå Format file DNA tidak valid. Pastikan file diekspor dari Genesis Engine.</p>`;
                    return;
                }

                // Tampilkan detail DNA yang berhasil dibaca (sebelum diproses lebih lanjut)
                displayImportedStrategy(dnaData);
                
                const dnaType = dnaData.metadata.dnaType;
                
                // 2. Logika untuk DNA "Specific"
                if (dnaType === 'Specific') {
                    const { sourceAsset, sourceTimeframe } = dnaData.metadata;
                    
                    if (!sourceAsset || !sourceTimeframe) {
                        importedSinyalPanel.innerHTML += `<p class="text-center text-sm negative mt-2">‚ùå Error: DNA 'Specific' tidak memiliki metadata Aset/Timeframe.</p>`;
                        return;
                    }
                    
                    // Kunci Aset, tapi biarkan Timeframe bisa diubah
                    symbolInput.value = sourceAsset.toUpperCase();
                    symbolInput.disabled = true;
                    timeframeSelect.value = sourceTimeframe;
                    timeframeSelect.disabled = false; // <-- Timeframe tidak dikunci

                    activeStrategy = dnaData; // Gunakan DNA apa adanya
                    
                    importedSinyalPanel.innerHTML += `<p class="text-center text-sm positive font-bold mt-2 p-2 bg-green-900/50 rounded-md">DNA Spesifik dimuat. Input Aset dikunci, Timeframe dapat diubah.</p>`;

                // 3. Logika untuk DNA "Generic" (dengan pemurnian)
                } else if (dnaType === 'Generic') {
                    // Pastikan input tidak terkunci
                    symbolInput.disabled = false;
                    timeframeSelect.disabled = false;

                    // Proses "pemurnian": hanya ambil parameter & bobot (Otak), buang metadata (KTP)
                    activeStrategy = {
                        parameters: dnaData.parameters,
                        weights: dnaData.weights
                    };
                    
                    importedSinyalPanel.innerHTML += `<p class="text-center text-sm text-blue-400 font-bold mt-2 p-2 bg-blue-900/50 rounded-md">DNA Generik dimuat. Silakan pilih Aset & Timeframe secara manual.</p>`;
                
                // 4. Penanganan jika tipe DNA tidak dikenal
                } else {
                    importedSinyalPanel.innerHTML += `<p class="text-center text-sm negative mt-2">‚ùå Tipe DNA tidak dikenali: ${dnaType}</p>`;
                    return;
                }
                
                // 5. Tampilkan panel input setelah impor berhasil
                document.getElementById('live-data-input-section').classList.remove('hidden');
                console.log(`Strategi DNA tipe '${dnaType}' berhasil dimuat dan diproses:`, activeStrategy);

            // 6. Penanganan jika file JSON rusak atau tidak bisa dibaca
            } catch (error) {
                importedSinyalPanel.innerHTML = `<p class="text-center text-sm negative">‚ùå Terjadi kesalahan saat membaca file. Pastikan file JSON tidak rusak.</p>`;
                console.error("Error parsing DNA JSON:", error);
            }
        };
        reader.readAsText(file);
    }

    function displayImportedStrategy(strategyData) {
        if (!strategyData) {
            importedSinyalPanel.innerHTML = `<p class="text-center text-sm text-gray-400">Gagal memuat strategi.</p>`;
            return;
        }

        importedSinyalPanel.innerHTML = `
            <div class="mt-2 text-center">
                <p class="font-bold">Metadata Strategi</p>
                <p class="font-mono text-xs">
                    Tipe DNA: ${strategyData.metadata.dnaType} |
                    Aset: ${Array.isArray(strategyData.metadata.sourceAsset) ? strategyData.metadata.sourceAsset.join(', ') : strategyData.metadata.sourceAsset} |
                    Timeframe: ${strategyData.metadata.sourceTimeframe}
                </p>
                
                <p class="font-bold mt-2">Parameter Strategi</p>
                <p class="font-mono text-xs">
                    R:R Ratio: ${strategyData.parameters.riskRewardRatio.toFixed(2)} | 
                    EMA: ${strategyData.parameters.pullbackEmaPeriod} | 
                    Bias: ${strategyData.parameters.biasThreshold} |
                    ATR Filter: ${strategyData.parameters.atrFilterThreshold}
                </p>
                
                <p class="font-bold mt-4">Bobot Indikator</p>
                <ul class="text-xs font-mono space-y-1 mt-2">
                    <li>MA: ${strategyData.weights.ma.toFixed(2)}</li>
                    <li>RSI Divergence: ${strategyData.weights.rsiDivergence.toFixed(2)}</li>
                    <li>MACD: ${strategyData.weights.macd.toFixed(2)}</li>
                    <li>Pivot: ${strategyData.weights.pivot.toFixed(2)}</li>
                    <li>VWAP: ${strategyData.weights.vwap.toFixed(2)}</li>
                    <li>Ichimoku: ${strategyData.weights.ichimoku.toFixed(2)}</li>
                    <li>Candle Pattern: ${strategyData.weights.candlePattern.toFixed(2)}</li>
                    <li>BB Squeeze: ${strategyData.weights.bbSqueeze.toFixed(2)}</li>
                    <li>PSAR: ${strategyData.weights.psar.toFixed(2)}</li>
                </ul>

                <p class="text-gray-400 text-xs mt-4">Strategi diimpor berhasil. Dasbor siap.</p>
            </div>
        `;
    }

    function connectToBinance(symbol, interval) {
        if (liveWebSocket) {
            liveWebSocket.close();
        }
        
        const wsUrl = `wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`;
        liveWebSocket = new WebSocket(wsUrl);

        liveWebSocket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            if (message.k) {
                updateLiveKlines(message.k);
            }
        };

        liveWebSocket.onclose = () => {
            console.log("Koneksi WebSocket terputus. Mencoba terhubung kembali...");
            setTimeout(() => connectToBinance(symbol, interval), 5000);
        };
    }

    function updateLiveKlines(newKline) {
        if (liveData.length > 0 && liveData[liveData.length - 1][0] === newKline.t) {
            liveData[liveData.length - 1] = [newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T];
        } else {
            liveData.push([newKline.t, newKline.o, newKline.h, newKline.l, newKline.c, newKline.v, newKline.T]);
            if (liveData.length > 500) liveData.shift();
            if (isChartsVisible) renderAllCharts(); 
        }
        
        updateAllCharts(newKline); 

        const currentPrice = parseFloat(newKline.c);
        currentMarketPrice = currentPrice;

        if(realtimeCache.main.tickerData) {
            realtimeCache.main.tickerData.lastPrice = currentPrice.toString();
        }

        const livePriceDisplay = document.getElementById('live-price-display');
        if (livePriceDisplay) {
            livePriceDisplay.textContent = formatPrice(currentPrice, realtimeCache.main.symbol);
        }

        const marketPriceInput = tsCalcElements.marketPrice;
        if (document.activeElement !== marketPriceInput) {
            marketPriceInput.value = currentPrice.toFixed(getPrecisionForAsset(currentPrice));
        }
    }
    
    function displayLiveSignal(signalData) {
        realtimeCache.main.latestScalpingSetup = signalData;
            
        const symbol = realtimeCache.main.symbol; 

        const entryPrice = signalData.entry.price !== null ? formatPrice(signalData.entry.price, symbol) : 'N/A';
        const entryPercentage = signalData.entry.percentage !== null ? `(${signalData.entry.percentage.toFixed(2)}%)` : '';
        const slPrice = signalData.sl.price !== null ? formatPrice(signalData.sl.price, symbol) : 'N/A';
        const slPercentage = signalData.sl.percentage !== null ? `(${signalData.sl.percentage.toFixed(2)}%)` : '';
        const tp1Price = signalData.tp1.price !== null ? formatPrice(signalData.tp1.price, symbol) : 'N/A';
        const tp1Percentage = signalData.tp1.percentage !== null ? `(${signalData.tp1.percentage.toFixed(2)}%)` : '';
        const tp2Price = signalData.tp2.price !== null ? formatPrice(signalData.tp2.price, symbol) : 'N/A';
        const tp2Percentage = signalData.tp2.percentage !== null ? `(${signalData.tp2.percentage.toFixed(2)}%)` : '';
        const tp3Price = signalData.tp3.price !== null ? formatPrice(signalData.tp3.price, symbol) : 'N/A';
        const tp3Percentage = signalData.tp3.percentage !== null ? `(${signalData.tp3.percentage.toFixed(2)}%)` : '';

        const biasColor = signalData.bias.status.includes('LONG') ? 'positive' : (signalData.bias.status.includes('SHORT') ? 'negative' : 'text-gray-400');
        
        document.getElementById('live-signal-content').innerHTML = `
            <div class="space-y-4">
                <div class="grid grid-cols-3 gap-2">
                    <div class="text-center">
                        <p class="font-bold text-lg ${biasColor}">${signalData.bias.status}</p>
                        <p class="text-sm text-gray-400">Contextual Bias</p>
                        <p class="text-xs ${biasColor}">(${signalData.bias.detail})</p>
                    </div>
                    <div class="text-center">
                        <p class="font-bold text-lg text-yellow-400">${entryPrice}</p>
                        <p class="text-sm text-gray-400">Entry</p>
                        <p class="text-xs text-yellow-400">${entryPercentage}</p>
                    </div>
                    <div class="text-center">
                        <p class="font-bold text-lg text-red-400">${slPrice}</p>
                        <p class="text-sm text-gray-400">Stop Loss</p>
                        <p class="text-xs text-red-400">${slPercentage}</p>
                    </div>
                </div>
                <hr class="border-gray-700"/>
                <div class="grid grid-cols-3 gap-2">
                    <div class="text-center">
                        <p class="font-bold text-lg text-green-400">${tp1Price}</p>
                        <p class="text-sm text-gray-400">TP 1 (Struktural)</p>
                        <p class="text-xs text-green-400">${tp1Percentage}</p>
                    </div>
                    <div class="text-center">
                        <p class="font-bold text-lg text-green-400">${tp2Price}</p>
                        <p class="text-sm text-gray-400">TP 2 (R:R 1:1.5)</p>
                        <p class="text-xs text-green-400">${tp2Percentage}</p>
                    </div>
                    <div class="text-center">
                        <p class="font-bold text-lg text-gray-400">${tp3Price}</p>
                        <p class="text-sm text-gray-400">TP 3 (Key Level)</p>
                        <p class="text-xs text-gray-400">${tp3Percentage}</p>
                    </div>
                </div>
            </div>
        `;
    }

    function formatPrice(price, symbol) {
        if (price === null || isNaN(price) || typeof price !== 'number') {
            return 'N/A';
        }

        // Cari presisi dari "database" kita
        const precision = precisionMap[symbol];

        if (typeof precision === 'number') {
            // Jika ditemukan, gunakan presisi dari Binance
            return `$${price.toFixed(precision)}`;
        } else {
            // Jika tidak ditemukan (fallback), gunakan aturan lama
            return price >= 1 ? `$${price.toFixed(2)}` : `$${parseFloat(price.toFixed(8))}`;
        }
    }

    function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
        const button = document.getElementById(buttonId);
        const contentWrapper = document.getElementById(contentWrapperId);
        const icon = document.getElementById(iconId);
        if (!button || !contentWrapper || !icon) return;
        
        contentWrapper.classList.add('collapsible-content');
        
        const applyState = (isVisible) => {
            if (isVisible) {
                contentWrapper.classList.add('expanded');
                icon.style.transform = 'rotate(0deg)';
            } else {
                contentWrapper.classList.remove('expanded');
                icon.style.transform = 'rotate(-90deg)';
            }
        };

        let isVisible = startVisible;
        applyState(isVisible);
        
        button.addEventListener('click', () => {
            isVisible = !isVisible;
            applyState(isVisible);
        });
    }
// ===================================================================
// BAGIAN 2: PUSTAKA FUNGSI KALKULASI MURNI 
// ===================================================================
    const tsCalc = {
        elements: tsCalcElements, 
        state: {
            marginMode: 'cross', leverage: 20, cost: 0, entryPrice: 0,
            walletBalance: 1000, tp: null, sl: null, callbackRate: null,
            activationPrice: null, positionType: 'long'
        },
        
        toggleModal: function(show) {
            if (show) this.elements.modalContainer.classList.remove('hidden');
            else this.elements.modalContainer.classList.add('hidden');
        },

        recalculate: function() {
            this.state.walletBalance = parseFloat(this.elements.walletBalance.value) || 0;
            this.state.leverage = parseFloat(this.elements.leverage.value) || 20;
            this.state.cost = parseFloat(this.elements.cost.value) || 0;
            const entry = parseFloat(this.elements.marketPrice.value) || currentMarketPrice || 0;
            if (entry === 0) return;

            const positionSize = this.state.cost * this.state.leverage;
            this.elements.resultCost.textContent = `${this.state.cost.toFixed(2)} USDT`;
            this.elements.resultPosSize.textContent = `${positionSize.toFixed(2)} USDT`;
            
            let liqPrice = 0;
            if (positionSize > 0) {
                if (this.state.marginMode === 'isolated') {
                    const priceChange = (this.state.cost / positionSize) * (1 - 0.005);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                } else {
                    const priceChange = (this.state.walletBalance / positionSize) * (1 - 0.005);
                    liqPrice = this.state.positionType === 'long' ? entry * (1 - priceChange) : entry * (1 + priceChange);
                }
            }
            this.elements.resultLiqPrice.textContent = liqPrice > 0 ? formatPrice(liqPrice) : 'N/A';
        },

        autofill: function() {
            const setup = realtimeCache.main.latestScalpingSetup;
            
            if (!setup || typeof setup.entry.price !== 'number') {
                alert("Setup sinyal belum siap atau pasar sedang sideways. Tidak bisa auto-fill.");
                return;
            }
            
            const isLong = setup.bias.status.includes('LONG');
            this.state.positionType = isLong ? 'long' : 'short';
            
            if(isLong) {
                this.elements.buyBtn.classList.remove('opacity-50');
                this.elements.sellBtn.classList.add('opacity-50');
            } else {
                this.elements.sellBtn.classList.remove('opacity-50');
                this.elements.buyBtn.classList.add('opacity-50');
            }

            const precision = getPrecisionForAsset(currentMarketPrice);

            this.elements.marketPrice.value = currentMarketPrice.toFixed(precision);
            if(typeof setup.tp1.price === 'number') this.elements.takeProfit.value = setup.tp1.price.toFixed(precision);
            if(typeof setup.sl.price === 'number') this.elements.stopLoss.value = setup.sl.price.toFixed(precision);

            this.elements.tpslToggle.checked = true;
            this.elements.tpslInputs.classList.remove('hidden');
            this.elements.cost.focus();
            this.recalculate();
            this.elements.leverage.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    };

    const calculateEMA = (data, period) => {
        if (!data || data.length < period) {
            return [];
        }

        const k = 2 / (period + 1);
        let emaArray = [];

        if (data.length > 0) {
            let sum = 0;
            for (let i = 0; i < period; i++) {
            sum += data[i] || 0;
            }
            emaArray[period - 1] = sum / period;
            for (let i = period; i < data.length; i++) {
            emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
            }
        }

        return emaArray;
    };
    
    const calculateSMA = (data, period) => {
        if (!data || data.length < period) {
            return [];
        }
        
        let sma = [];
        let sum = 0;

   
        for (let i = 0; i < period; i++) {
            sum += data[i];
        }
        sma.push(sum / period);

        for (let i = period; i < data.length; i++) {
            sum = sum - data[i - period] + data[i];
            sma.push(sum / period);
        }

        const alignedSma = [...Array(period - 1).fill(undefined), ...sma];
        
        return alignedSma;
    };

    const calculateRSI = (closes, period = 14) => {
    if (!closes || closes.length <= period) {
        return Array(closes.length).fill(undefined);
    }
    
    let gains = [];
    let losses = [];
    for (let i = 1; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        gains.push(diff > 0 ? diff : 0);
        losses.push(diff < 0 ? -diff : 0);
    }
    let rsi = Array(period).fill(undefined);
    let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
    let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
    rsi[period - 1] = (avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
        rsi.push((avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
    }
    return rsi;
};
    
    const calculateMACD = (closes, fast, slow, signal) => {
        if (fast === undefined) {
            fast = 12; slow = 26; signal = 9;
        }
        
        if (closes.length < slow) {
            return { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };
        }
        
        const emaFast = calculateEMA(closes, fast);
        const emaSlow = calculateEMA(closes, slow);
        const macdLine = emaSlow.map((slowVal, i) => {
            if (slowVal !== undefined && emaFast[i] !== undefined) {
                return emaFast[i] - slowVal;
            }
            return undefined;
        }).filter(v => v !== undefined);
        const signalLine = calculateEMA(macdLine, signal);
        const histogram = macdLine.map((macdVal, i) => {
            const sigVal = signalLine[i] !== undefined ? signalLine[i] : (signalLine.length > 0 ? signalLine.pop() : undefined);
            if (sigVal !== undefined) {
                const histValue = macdVal - sigVal;
                const prevHistValue = (i > 0 && macdLine[i - 1] !== undefined && signalLine[i - 1] !== undefined) ? (macdLine[i - 1] - signalLine[i - 1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        }).filter(v => v !== undefined);
        const lastMacd = macdLine.pop() || 0;
        const lastSig = signalLine.pop() || 0;
        const prevMacdLine = macdLine.pop() || 0;
        const prevSignalLine = signalLine.pop() || 0;
        let status = 'Netral';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) {
            status = 'Bullish Cross';
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) {
            status = 'Bearish Cross';
        }
        return { status, macdLine, signalLine, histogram };
    };

    const calculateStochasticRSI = (closes, rsiPeriod = 14, stochPeriod = 14, kSmooth = 3, dSmooth = 3) => {
        const rsiValues = calculateRSI(closes, rsiPeriod);
        const validRsi = rsiValues.filter(v => v !== undefined);
        if (validRsi.length < stochPeriod) {
            return { kLine: [], dLine: [], status: 'Netral' };
        }
        
        let stochArr = [];
        for (let i = stochPeriod - 1; i < validRsi.length; i++) {
            const window = validRsi.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((validRsi[i] - minR) / denom) * 100);
        }
        const kLineRaw = calculateSMA(stochArr, kSmooth);
        const dLineRaw = calculateSMA(kLineRaw.filter(v => v !== undefined), dSmooth);
        const kLine = kLineRaw.filter(v => v !== undefined);
        const dLine = dLineRaw.filter(v => v !== undefined);
        const lastK = kLine.pop() || 50;
        const lastD = dLine.pop() || 50;
        let status = 'Netral';
        if (lastK > 80 && lastD > 80) status = 'Overbought';
        else if (lastK < 20 && lastD < 20) status = 'Oversold';
        return { kLine, dLine, status };
    };

    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };
        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const rsiLows = findPivots(recentRSI, false), rsiHighs = findPivots(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH' };
        }
        return { status: 'NONE' };
    };

    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i-1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) obv.push(obv[i-1] + volume);
            else if (close < prevClose) obv.push(obv[i-1] - volume);
            else obv.push(obv[i-1]);
        }
        return obv;
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };

    const findCandlestickPatterns = (klines) => {
        if (!klines || klines.length < 2) return { bias: 'NETRAL' };
        const getCandle = (k) => {
            const [o, h, l, c] = k.slice(1, 5).map(parseFloat);
            return { open: o, close: c, isGreen: c > o, isRed: c < o };
        };
        const c1 = getCandle(klines[klines.length - 1]), c2 = getCandle(klines[klines.length - 2]);
        if (c2.isRed && c1.isGreen && c1.close > c2.open) return { bias: 'BULLISH' };
        if (c2.isGreen && c1.isRed && c1.close < c2.open) return { bias: 'BEARISH' };
        return { bias: 'NETRAL' };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) {
            return { upper: [], middle: [], lower: [], squeezeStatus: 'N/A' };
        }

        const middle = calculateSMA(closes, period);
        const upper = [];
        const lower = [];
        const width = [];

        let sum = 0;
        let sumOfSquares = 0;

        const initialSlice = closes.slice(0, period);
        for (const val of initialSlice) {
            sum += val;
            sumOfSquares += val * val;
        }

        const calculateAndPushBands = (currentSum, currentSumOfSquares) => {
            const mean = currentSum / period;
            const variance = (currentSumOfSquares / period) - (mean * mean);
            const stdev = Math.sqrt(Math.max(0, variance));
            upper.push(mean + (stdev * stdDev));
            lower.push(mean - (stdev * stdDev));
            width.push((stdev * stdDev * 2));
        };

        calculateAndPushBands(sum, sumOfSquares);

        for (let i = period; i < closes.length; i++) {
            const oldVal = closes[i - period];
            const newVal = closes[i];

            sum = sum - oldVal + newVal;
            sumOfSquares = sumOfSquares - (oldVal * oldVal) + (newVal * newVal);
            
            calculateAndPushBands(sum, sumOfSquares);
        }

        const lastWidth = width.filter(v => v !== undefined).pop();
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
        }

        const align = (arr) => [...Array(period - 1).fill(undefined), ...arr];

        return { 
            upper: align(upper), 
            middle: middle, 
            lower: align(lower), 
            squeezeStatus 
        };
    };

    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { value: 0, plusDI: 0, minusDI: 0 };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { value: adxValues.filter(v=>v!==undefined).pop() || 0, plusDI: plusDIs.pop() || 0, minusDI: minusDIs.pop() || 0 };
    };

    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline || prevDayKline.length < 5) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);
        if (isNaN(high) || isNaN(low) || isNaN(close)) return null;
        return { P: (high + low + close) / 3 };
    }

    function calculateVWAP(klines, period = 20) {
        if (!klines || klines.length < period) return 0;
        let sumPV = 0, sumV = 0;
        const dataSlice = klines.slice(-period);
        dataSlice.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;
    }

    function calculateIchimokuCloud(klines) {
        if (klines.length < 52) return { status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        let tenkan = [], kijun = [];
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= 8 ? getHighLow(klines.slice(i - 8, i + 1)) : {};
            tenkan.push(tenkanHighLow.high ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= 25 ? getHighLow(klines.slice(i - 25, i + 1)) : {};
            kijun.push(kijunHighLow.high ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
        }
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = tenkan[tenkan.length - 1], lastKijun = kijun[kijun.length - 1];
        if (lastTenkan > lastKijun && lastPrice > lastKijun) return { status: "BULLISH" };
        if (lastTenkan < lastKijun && lastPrice < lastKijun) return { status: "BEARISH" };
        return { status: 'Netral' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateLinearRegressionChannel(closes, period = 14) {
        if (closes.length < period) return { status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return { status: slope > 0 ? 'BULLISH' : 'BEARISH' };
    }

    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A', atrPercent: 0 };
        }
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        const rma = (data, p) => {
            let smoothed = [];
            let sum = 0;
            for(let i=0; i<data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    if (i === p - 1) smoothed.push(sum/p);
                    else smoothed.push(undefined);
                } else if (smoothed[i-1] !== undefined) {
                    smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return smoothed;
        };
        const atrValues = rma(trs, period);
        const atr = atrValues.pop() || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
        let status;
        if (atrPercent > 5) status = 'Very High';
        else if (atrPercent > 2.5) status = 'High';
        else if (atrPercent < 1) status = 'Low';
        else status = 'Normal';
        return { value: atr, status: status, atrPercent: atrPercent }; 
    }

    function getUltimateSignalScore(indicator, signalData) {
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const mapRange = (x, inMin, inMax, outMin, outMax) => {
            const t = (x - inMin) / (inMax - inMin);
            return outMin + clamp(t, 0, 1) * (outMax - outMin);
        };       
        const confidence = (typeof signalData?.confidence === 'number')
            ? clamp(signalData.confidence, 0, 1)
            : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const biasSigned = (typeof signalData?.biasSigned === 'number')
            ? Math.sign(signalData.biasSigned)
            : null;
        if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'openInterest') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('UP')) return +1 * confidence;
            if (text.includes('DOWN')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'funding' || indicator === 'fundingRate') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 0;
            const s = Math.max(-1, Math.min(1, v / 0.0025));
            return s * confidence;
            }
        if (indicator === 'lsr' || indicator === 'lsRatio') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 1;
            const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
            return s * confidence;
            }
        if (indicator === 'orderBookBias') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BID')) return +1 * confidence;
            if (text.includes('ASK')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'bbSqueeze') {
            const st = (signalData?.status || '').toString().toUpperCase();
            if (st.includes('RELEASE')) return +1 * confidence;
            if (st.includes('ON')) return 0;
            if (st.includes('OFF')) return 0.3 * confidence;
            return 0;
        }
        return 0;
    }

    function createTFAlignmentSummary(klines, timeframes, marketType) {
        const summary = {};
        
        let score = 0;
        timeframes.forEach(tf => {
            if (klines[tf] && klines[tf].length >= 50) {
                const closes = klines[tf].map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21);
                const ema50 = calculateEMA(closes, 50);
                const lastEma21 = ema21[ema21.length - 1];
                const lastEma50 = ema50[ema50.length - 1];
                summary[tf] = lastEma21 > lastEma50 ? 'UPTREND' : 'DOWNTREND';
            } else {
                summary[tf] = 'N/A';
            }
            if (summary[tf] === 'UPTREND') score++;
            else if (summary[tf] === 'DOWNTREND') score--;
        });
        return { summary, score };
    }

    function calculateConfluenceScoreForCandle(activeWeights, indicators) {
            let totalBullScore = 0, totalBearScore = 0, maxPossibleScore = 0;

            for (const indicator in activeWeights) {
                if (indicators[indicator]) {
                    const weight = activeWeights[indicator];
                    const rawScore = getUltimateSignalScore(indicator, indicators[indicator]);
                    const weightedScore = rawScore * weight;

                    if (weightedScore > 0) totalBullScore += weightedScore;
                    if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                    maxPossibleScore += Math.abs(weight);
                }
            }

            const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
            const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;

            return { bull: bullPercentage, bear: bearPercentage };
        }
    
    function calculateShortConfluenceScore(klinesSnapshot) {
            if (!klinesSnapshot || klinesSnapshot.length < 50) return { score: 0, breakdown: {} };

            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            let score = 0;
            let triggers = [];
            const rsiValues = calculateRSI(closes, 14);
            const lastRsi = rsiValues[rsiValues.length - 1];
            if (lastRsi > 72) {
                score += 3.5;
                triggers.push('RSI Overbought');
            }
            const macd = calculateMACD(closes);
            if (macd.status === 'Bearish Cross') {
                score += 2.5;
                triggers.push('MACD Cross');
            }
            const candlePattern = findCandlestickPatterns(klinesSnapshot);
            if (candlePattern.bias === 'BEARISH') {
                score += 2.0;
                triggers.push('Candle Pattern');
            }
            const lookbackPeriod = 15;
            const recentKlines = klinesSnapshot.slice(-lookbackPeriod);
            if (recentKlines.length >= 3) {
                let peakIndex = 0;
                for (let i = 1; i < recentKlines.length; i++) {
                    if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
                }
                if (peakIndex > 0 && peakIndex < lookbackPeriod - 2) {
                    const triggerCandleArr = recentKlines[peakIndex + 1];
                    if (triggerCandleArr) {
                        const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                        if (triggerCandle.Close < triggerCandle.Open) {
                            score += 3.5;
                            triggers.push('Red Candle After High');
                        }
                    }
                }
            }
            const rsiDivergence = detectRSIDivergence(closes, rsiValues);
            if (rsiDivergence.status === 'BEARISH') {
                score += 4.0;
                triggers.push('RSI Divergence');
            }
            return { score: Math.min(score, 10), triggers: triggers };
        }

    function getConfluenceAnalysis(klines) {
        if (!klines || klines.length < 50) {
            return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
        }

        let skorBullish = 0;
        let skorBearish = 0;
        const closes = klines.map(k => parseFloat(k[4]));

        const rsiValues = calculateRSI(closes);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const macd = calculateMACD(closes);
        const candlePattern = findCandlestickPatterns(klines);
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);

        if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
        if (macd.status === 'Bearish Cross') skorBearish += 2.0;
        if (lastRsi > 70) skorBearish += 1.5;
        if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

        if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
        if (macd.status === 'Bullish Cross') skorBullish += 2.0;
        if (lastRsi < 30) skorBullish += 1.5;
        if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
        
        const totalPossibleScore = 8.0;

        return { 
            skorBullish: (skorBullish / totalPossibleScore) * 10,
            skorBearish: (skorBearish / totalPossibleScore) * 10,
            detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
        };
    }
    
    function initializeNewCalculator() {
        const { elements, state } = tsCalc;
        
        elements.sellBtn.classList.add('opacity-50');
        state.positionType = 'long';

        elements.crossBtn.addEventListener('click', () => {
            state.marginMode = 'cross';
            elements.crossBtn.classList.add('active');
            elements.isolatedBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.isolatedBtn.addEventListener('click', () => {
            state.marginMode = 'isolated';
            elements.isolatedBtn.classList.add('active');
            elements.crossBtn.classList.remove('active');
            tsCalc.recalculate();
        });
        elements.buyBtn.addEventListener('click', () => {
            state.positionType = 'long';
            elements.buyBtn.classList.remove('opacity-50');
            elements.sellBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi LONG simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('long', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
            
            tsCalc.recalculate();
        });
        elements.sellBtn.addEventListener('click', () => {
            state.positionType = 'short';
            elements.sellBtn.classList.remove('opacity-50');
            elements.buyBtn.classList.add('opacity-50');
            
            if (confirm(`Buka posisi SHORT simulasi dengan modal ${tsCalc.state.cost.toFixed(2)} USDT?`)) {
                paperTrade.openPosition('short', tsCalc.state.leverage, tsCalc.state.cost, parseFloat(elements.marketPrice.value));
            }
                
            tsCalc.recalculate();
        });
        elements.tpslToggle.addEventListener('change', () => {
            elements.tpslInputs.classList.toggle('hidden', !elements.tpslToggle.checked);
        });
        elements.slider.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const percentage = parseFloat(elements.slider.value);
            const newCost = (currentWalletBalance * (percentage / 100));
            elements.cost.value = newCost.toFixed(2);
            tsCalc.recalculate();
        });
        ['cost', 'leverage', 'walletBalance', 'marketPrice'].forEach(id => {
            elements[id].addEventListener('input', () => tsCalc.recalculate());
        });
        elements.cost.addEventListener('input', () => {
            const currentWalletBalance = parseFloat(elements.walletBalance.value) || 0;
            const costValue = parseFloat(elements.cost.value) || 0;
            const percentage = currentWalletBalance > 0 ? (costValue / currentWalletBalance) * 100 : 0;
            elements.slider.value = Math.min(100, percentage);
        });
        elements.autofillBtn.addEventListener('click', () => tsCalc.autofill());

        // --- LOGIKA BARU UNTUK MODAL TS ---
        elements.tsOptionsBtn.addEventListener('click', () => tsCalc.toggleModal(true));
        elements.modalCloseBtn.addEventListener('click', () => tsCalc.toggleModal(false));
        elements.modalContainer.addEventListener('click', (e) => {
            if (e.target === elements.modalContainer) tsCalc.toggleModal(false);
        });
        elements.modalSaveBtn.addEventListener('click', () => {
            state.callbackRate = parseFloat(elements.modalCallbackRate.value);
            state.activationPrice = parseFloat(elements.modalActivationPrice.value);
            tsCalc.toggleModal(false);
            tsCalc.recalculate();
        });

        tsCalc.recalculate();
    }

    function exportHistoryToCSV() {
        const history = paperTrade.state.history;
        if (history.length === 0) {
            alert("Tidak ada riwayat trading untuk diekspor.");
            return;
        }

        const headers = ["Symbol", "Type", "EntryPrice", "ClosePrice", "PNL", "ROE", "ClosedAt", "Liquidated"];
        let csvContent = headers.join(",") + "\r\n";

        history.forEach(trade => {
            const row = [
                trade.symbol,
                trade.type,
                trade.entryPrice || 'N/A', 
                trade.closePrice || 'N/A', 
                trade.pnl,
                trade.roe,
                trade.closedAt.toISOString(),
                trade.liquidated ? 'TRUE' : 'FALSE'
            ];
            csvContent += row.join(",") + "\r\n";
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        const timestamp = new Date().toISOString().slice(0, 10);
        link.setAttribute("download", `trade_history_${timestamp}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function importHistoryFromCSV(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (lines.length <= 1) {
                alert("File CSV kosong atau hanya berisi header.");
                return;
            }

            const importedHistory = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length < 8) continue; 

                try {
                    const trade = {
                        symbol: values[0].trim(),
                        type: values[1].trim(),
                        entryPrice: parseFloat(values[2]),
                        closePrice: parseFloat(values[3]),
                        pnl: parseFloat(values[4]),
                        roe: parseFloat(values[5]),
                        closedAt: new Date(values[6].trim()),
                        liquidated: values[7].trim().toUpperCase() === 'TRUE'
                    };
                    importedHistory.push(trade);
                } catch (error) {
                    alert(`Error saat memproses baris ke-${i+1}. Cek format file Anda.`);
                    return;
                }
            }
            
            if (confirm(`Impor akan menimpa ${importedHistory.length} riwayat trading yang ada. Lanjutkan?`)) {
                paperTrade.state.history = importedHistory.reverse();
                paperTrade.saveState();
                paperTrade.render();
                alert("Impor riwayat trading berhasil!");
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    }

    function getPrecisionForAsset(price) {
        if (price === 0) return 2;
        if (price > 1000) return 2;
        if (price > 1) return 4;
        if (price > 0.001) return 9;
        return 8;
    }

    function resetLiveSession() {
        console.log("--- RESETTING LIVE SESSION ---");
        // Hentikan interval kalkulasi yang sedang berjalan
        if (liveInterval) {
            clearInterval(liveInterval);
            liveInterval = null;
        }
        // Tutup koneksi WebSocket yang ada & cegah rekoneksi otomatis
        if (liveWebSocket) {
            liveWebSocket.onclose = null; // Penting untuk mencegah logika rekoneksi
            liveWebSocket.close();
            liveWebSocket = null;
        }

        // Kosongkan semua data dan state sesi sebelumnya
        liveData = [];
        currentMarketPrice = 0;
        
        // Kembalikan UI ke kondisi awal
        document.getElementById('live-signal-content').innerHTML = '<p class="text-center text-sm text-gray-400">Tekan "START LIVE" untuk melihat sinyal.</p>';
        document.getElementById('live-price-display').textContent = '$0.00';
        document.getElementById('htf-compass-result').textContent = '-- Pilih Timeframe --';
        
        // Hapus setup sinyal sebelumnya dari cache
        if(realtimeCache.main) {
            realtimeCache.main.latestScalpingSetup = null;
        }
    }

    function setButtonState(button, isLoading, text = null) {
        const btnText = button.querySelector('span');
        const btnLoader = button.querySelector('.loader');
        
        button.disabled = isLoading;

        if (btnText) {
            btnText.classList.toggle('hidden', isLoading);
        }
        if (btnLoader) {
            btnLoader.classList.toggle('hidden', !isLoading);
        }
        if (text && btnText && !isLoading) {
            btnText.textContent = text;
        }
    }
// ===================================================================
// Event listener untuk tombol import
// ===================================================================      
document.addEventListener('DOMContentLoaded', async () => { 
    await initializePrecisionMap(); 

    setupToggle('toggle-ts-calc-btn', 'ts-calc-content-wrapper', 'toggle-ts-calc-icon', false);
    setupToggle('toggle-paper-trading-btn', 'paper-trading-content-wrapper', 'toggle-paper-trading-icon', false);setupToggle('toggle-import-btn', 'import-content-wrapper', 'toggle-import-icon', true);
    toggleChartsBtn.addEventListener('click', toggleChartsVisibility);
    
    importFile.addEventListener('change', (event) => {
       handleFileImport(event);
    });

    startLiveBtn.addEventListener('click', async () => {
        if (!activeStrategy) {
            alert("Mohon impor file DNA strategi terlebih dahulu.");
            return;
        }

        resetLiveSession();

        // Tampilkan status loading
        setButtonState(startLiveBtn, true, "Running...");

        const symbol = liveSymbolInput.value.toUpperCase();
        const timeframe = liveTimeframeSelect.value;
        realtimeCache.main.symbol = symbol;

        try {
            await fetchInitialData(symbol, timeframe);
            connectToBinance(symbol, timeframe);
            
            setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START LIVE");
            liveSignalPanel.classList.remove('hidden');
            updateHtfCompass('1h');

            document.querySelectorAll('.htf-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.htf-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    updateHtfCompass(btn.dataset.timeframe);
                });
            });

            liveInterval = setInterval(() => {
            if (liveData && liveData.length > 50) {
                const closes = liveData.map(k => parseFloat(k[4]));
                const recentKlines = liveData.slice(-activeStrategy.swingLookback);

                const confluenceScores = calculateConfluenceScoreForCandle(activeStrategy.weights, {
                    ma: { status: calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop() ? 'BULLISH' : 'BEARISH' },
                    rsi: { status: calculateRSI(closes, 14).pop() > 70 ? 'Overbought' : (calculateRSI(closes, 14).pop() < 30 ? 'Oversold' : 'Netral') },
                    stoch: calculateStochasticRSI(closes),
                    macd: calculateMACD(closes),
                    rsiDivergence: detectRSIDivergence(closes, calculateRSI(closes, 14)),
                    obvDivergence: detectOBVDivergence(closes, liveData),
                    pivot: { status: (closes[closes.length - 1] > calculatePivotPoints(liveData.slice(-2,-1)[0])?.P) ? 'BULLISH' : 'BEARISH' },
                    vwap: { status: (closes[closes.length - 1] > calculateVWAP(liveData)) ? 'BULLISH' : 'BEARISH' },
                    ichimoku: calculateIchimokuCloud(liveData),
                    candlePattern: findCandlestickPatterns(recentKlines),
                    bollingerBands: calculateBollingerBands(closes),
                    bbSqueeze: { status: calculateBollingerBands(closes).squeezeStatus },
                    psar: calculateParabolicSAR(liveData),
                    roc: calculateROC(closes),
                    linreg: calculateLinearRegressionChannel(closes)
                });

                const currentPrice = parseFloat(liveData[liveData.length - 1][4]);

                let biasStatus = 'NEUTRAL', biasDetail = '';
                let entryPrice = null, stopLoss = null, tp1 = null, tp2 = null;

                const bullScore = confluenceScores.bull;
                const bearScore = confluenceScores.bear;
                const threshold = activeStrategy.parameters.biasThreshold;
                const dominanceMultiplier = 1.75; // FAKTOR BARU untuk mengukur dominasi

                const bullAbsoluteDominance = bullScore > bearScore + threshold;
                const bullRelativeDominance = bullScore > bearScore * dominanceMultiplier && bearScore > 0;

                if (bullAbsoluteDominance || bullRelativeDominance) {
                    const emaEntry = calculateEMA(closes, activeStrategy.parameters.pullbackEmaPeriod).pop();
                    entryPrice = emaEntry;
                    
                    if (htfTrend === 'UPTREND') {
                        biasStatus = 'LONG - FOLLOW TREND';
                    } else if (htfTrend === 'DOWNTREND') {
                        biasStatus = 'LONG - COUNTER TREND';
                    } else {
                        biasStatus = 'LONG - RANGE TRADING';
                    }
                    
                    biasDetail = `Bull (${bullScore.toFixed(1)}) vs Bear (${bearScore.toFixed(1)})`;
                    const recentSwingLow = Math.min(...liveData.slice(-activeStrategy.parameters.swingLookback).map(k => parseFloat(k[3])));
                    const recentSwingHigh = Math.max(...liveData.slice(-activeStrategy.parameters.swingLookback).map(k => parseFloat(k[2])));
                    stopLoss = recentSwingLow;
                    tp1 = recentSwingHigh;
                    tp2 = entryPrice + (Math.abs(entryPrice - stopLoss) * activeStrategy.parameters.riskRewardRatio);

                // --- LOGIKA BARU: Pengecekan Bearish ---
                } else {
                    const bearAbsoluteDominance = bearScore > bullScore + threshold;
                    const bearRelativeDominance = bearScore > bullScore * dominanceMultiplier && bullScore > 0;

                    if (bearAbsoluteDominance || bearRelativeDominance) {
                        const emaEntry = calculateEMA(closes, activeStrategy.parameters.pullbackEmaPeriod).pop();
                        entryPrice = emaEntry;

                        if (htfTrend === 'DOWNTREND') {
                            biasStatus = 'SHORT - FOLLOW TREND';
                        } else if (htfTrend === 'UPTREND') {
                            biasStatus = 'SHORT - COUNTER TREND';
                        } else {
                            biasStatus = 'SHORT - RANGE TRADING';
                        }
                    
                        biasDetail = `Bull (${bullScore.toFixed(1)}) vs Bear (${bearScore.toFixed(1)})`;
                        const recentSwingHigh = Math.max(...liveData.slice(-activeStrategy.parameters.swingLookback).map(k => parseFloat(k[2])));
                        const recentSwingLow = Math.min(...liveData.slice(-activeStrategy.parameters.swingLookback).map(k => parseFloat(k[3])));
                        stopLoss = recentSwingHigh;
                        tp1 = recentSwingLow;
                        tp2 = entryPrice - (Math.abs(stopLoss - entryPrice) * activeStrategy.parameters.riskRewardRatio);
                    } else {
                        biasStatus = 'NEUTRAL';
                        biasDetail = `Bull (${bullScore.toFixed(1)}) vs Bear (${bearScore.toFixed(1)})`;
                    }
                }

                const signalData = {
                    bias: { status: biasStatus, detail: biasDetail },
                    entry: { price: entryPrice, percentage: entryPrice ? ((entryPrice - currentPrice) / currentPrice) * 100 : null },
                    sl: { price: stopLoss, percentage: stopLoss && entryPrice ? ((stopLoss - entryPrice) / entryPrice) * 100 : null },
                    tp1: { price: tp1, percentage: tp1 && entryPrice ? ((tp1 - entryPrice) / entryPrice) * 100 : null },
                    tp2: { price: tp2, percentage: tp2 && entryPrice ? ((tp2 - entryPrice) / entryPrice) * 100 : null },
                    tp3: { price: null, percentage: null }
                };
                
                displayLiveSignal(signalData);
                document.getElementById('live-price-display').textContent = formatPrice(currentPrice);
                }
            }, 5000);

        } catch (error) {
            console.error("Gagal memulai sesi live:", error);
            alert(`Gagal memulai sesi untuk ${symbol}. Cek konsol untuk detail.`);
            setButtonState(startLiveBtn, false, "‚ñ∂Ô∏è START LIVE");
            resetLiveSession();
        }
    });

    document.querySelectorAll('.chart-tf-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.chart-tf-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            const newTimeframe = btn.dataset.timeframe;
            switchChartTimeframe(newTimeframe);
        });
    });

        initializeNewCalculator();
        paperTrade.init();
});

</script>

</body>
</html>