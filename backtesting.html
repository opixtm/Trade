<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BACKTESTING ENGINE - CHART REPLAY</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #000000; color: #E0E0E0; }
        .card { background-color: #151414; border: 1px solid #333; border-radius: 0.75rem; }
        .positive { color: #4ade80; }
        .negative { color: #f87171; }
        .btn-primary { background-color: #c97c00; color: #1f2937; font-weight: 600; padding: 0.625rem 1.25rem; border-radius: 0.5rem; transition: background-color 0.3s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-primary:hover { background-color: #eb9413; }
        .btn-primary:disabled { background-color: #333333; cursor: not-allowed; }
        .btn-secondary { background-color: #374151; color: #e0e0e0; font-weight: 600; padding: 0.25rem 0.5rem; border-radius: 0.5rem; transition: background-color 0.3s; }
        .btn-secondary:hover { background-color: #4b5563; }
        .input-primary { background-color: #1c1b1b; border: 1px solid #444; border-radius: 0.5rem; padding: 0.625rem 1rem; width: 100%; color: #E0E0E0; }
        .input-primary:focus { outline: none; border-color: #f59e0b; box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3); }
        .input-primary.small-input { padding-left: 0.5rem; padding-right: 0.5rem; }
        .input-primary.small-input::-webkit-inner-spin-button, .input-primary.small-input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .loader { display: flex; justify-content: center; align-items: center; gap: 4px; }
        .dot { width: 8px; height: 8px; background-color: #e1e1e1; border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both; }
        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .collapsible-content { display: grid; grid-template-rows: 0fr; transition: grid-template-rows 0.4s ease-in-out; }
        .collapsible-content.expanded { grid-template-rows: 1fr; }
        .collapsible-content > div { overflow: hidden; }
        .regime-tag { display: inline-block; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; margin-right: 0.5rem; }
        .uptrend { background-color: #10B981; color: white; }
        .downtrend { background-color: #EF4444; color: white; }
        .ranging { background-color: #F59E0B; color: white; }
        .sideways { background-color: #6B7280; color: white; }
        .volatile { background-color: #8B5CF6; color: white; }
        .market-condition-bar { height: 8px; border-radius: 4px; margin: 0.5rem 0; }
        .time-segment { display: inline-block; height: 30px; margin-right: 2px; cursor: pointer; position: relative; }
        .time-segment:hover::after { content: attr(data-date); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #1F2937; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; white-space: nowrap; z-index: 10; }
        .recommendation-card { border-left: 4px solid #F59E0B; background-color: #1F2937; }
        #backtest-chart-container {
            min-height: 600px;
            background-color: #151414;
            border-radius: 0.5rem;
        }
        /* Style untuk tombol toggle section */
        .section-toggle-btn {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-align: left;
            margin-bottom: 1rem;
            background: none;
            border: none;
            color: #E0E0E0;
            cursor: pointer;
            padding: 0;
        }
        .section-toggle-btn:hover {
            opacity: 0.8;
        }
        .section-toggle-icon {
            transition: transform 0.3s ease;
        }
        .section-content-wrapper {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        .section-content-wrapper.collapsed {
            grid-template-rows: 0fr;
            opacity: 0;
        }
        .section-content-wrapper.expanded {
            grid-template-rows: 1fr;
            opacity: 1;
        }
        .section-content-wrapper > div {
            overflow: hidden;
        }
        .low-volatility { background-color: #8B5CF6; color: white; }
        .session-filter-label {
    cursor: pointer;
    padding: 0.25rem 0.75rem;
    border-radius: 9999px;
    font-size: 0.875rem;
    border: 1px solid #444;
    background-color: #1c1b1b;
    transition: all 0.2s ease;
}
.session-filter-label:hover {
    background-color: #333;
}
.session-filter-checkbox:checked + .session-filter-label {
    background-color: #f59e0b;
    color: #1f2937;
    border-color: #c97c00;
    font-weight: 600;
}
    </style>
</head>
<body class="antialiased">    
    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <main class="space-y-8 mt-8">
            <section id="backtesting-section" class="card p-6">
                 <button id="toggle-backtesting-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-base font-bold">🔬 Mesin Backtesting</h2>
                    <svg id="toggle-backtesting-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="backtesting-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700 space-y-4">
                        <div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2">
                                <div>
                                    <label for="backtest-symbol-input" class="block text-sm font-medium text-gray-400">Simbol Aset</label>
                                    <input type="text" id="backtest-symbol-input" value="BTCUSDT" class="input-primary uppercase mt-1">
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="backtest-timeframe-select" class="block text-sm font-medium text-gray-400">Timeframe</label>
                                        <select id="backtest-timeframe-select" class="input-primary mt-1">
                                            <option value="1m">1m</option><option value="3m">3m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option><option value="1d">1d</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label for="backtest-leverage-input" class="block text-sm font-medium text-gray-400">Leverage</label>
                                        <input type="number" id="backtest-leverage-input" value="10" class="input-primary small-input mt-1">
                                    </div>
                                </div>
                                <div>
                                    <label for="backtest-start-date" class="block text-sm font-medium text-gray-400">Mulai (Tanggal & Jam)</label>
                                    <input type="datetime-local" id="backtest-start-date" class="input-primary mt-1">
                                </div>
                                <div>
                                    <label for="backtest-end-date" class="block text-sm font-medium text-gray-400">Selesai (Tanggal & Jam)</label>
                                    <input type="datetime-local" id="backtest-end-date" class="input-primary mt-1">
                                </div>
                            </div>
                            <div class="pt-4 border-t border-gray-800">
                                <label class="block text-sm font-medium text-gray-400 mb-2">💡 Asisten Durasi Cerdas (Mengisi "Mulai" secara otomatis)</label>
                                <div class="flex flex-wrap items-center gap-2 text-sm">
                                    <span>Durasi Mundur dari "Selesai":</span>
                                    <button id="duration-btn-3d" class="btn-secondary !text-xs">3 Hari</button>
                                    <button id="duration-btn-1w" class="btn-secondary !text-xs">1 Minggu</button>
                                    <button id="duration-btn-1m" class="btn-secondary !text-xs">1 Bulan</button>
                                    <span class="border-l border-gray-600 pl-2">atau</span>
                                    <input type="number" id="duration-candle-input" placeholder="Jml. Candle" class="input-primary small-input !w-28 text-center bg-gray-900/50">
                                    <button id="duration-apply-btn" class="btn-primary !py-1 !px-3 !text-xs">Terapkan</button>
                                </div>
                            </div>
                            <div class="pt-4 border-t border-gray-800">
                                <label class="block text-sm font-medium text-gray-400 mb-2">🕒 Filter Sesi Aktif (WIB)</label>
                                <div class="flex flex-wrap gap-4 items-center">
                                    <input type="checkbox" id="filter-session-tokyo" value="tokyo" class="hidden session-filter-checkbox">
                                    <label for="filter-session-tokyo" class="session-filter-label">🇯🇵 Tokyo (07:00-15:00)</label>
                                    
                                    <input type="checkbox" id="filter-session-london" value="london" class="hidden session-filter-checkbox">
                                    <label for="filter-session-london" class="session-filter-label">🇬🇧 London (15:00-23:00)</label>

                                    <input type="checkbox" id="filter-session-newyork" value="newyork" class="hidden session-filter-checkbox">
                                    <label for="filter-session-newyork" class="session-filter-label">🇺🇸 New York (20:00-04:00)</label>
                                </div>
                            </div>
                            <div class="pt-4 flex flex-col md:flex-row gap-4 items-center">
                            <div class="w-full md:w-auto">
                                <label for="backtest-initial-balance" class="block text-sm font-medium text-gray-400 text-center md:text-left">Modal Awal ($)</label>
                                <input type="number" id="backtest-initial-balance" value="1000" class="input-primary small-input mt-1 md:w-32 text-center">
                            </div>
                            <div class="flex-grow flex items-center gap-4 w-full">
                                <button id="start-backtest-btn" class="btn-primary w-full"><span>▶️ BACKTEST</span><div class="loader w-5 h-5 hidden"></div></button>
                                <button id="stop-backtest-btn" class="btn-secondary w-auto hidden"><span>⏹️ STOP</span></button>
                            </div>
                            <div class="text-right text-xs text-gray-400 w-full md:w-auto mt-2 md:mt-0">
                                <span id="candle-estimation-display" class="font-bold text-yellow-400">Pilih rentang waktu...</span>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <div id="backtest-progress-container" class="hidden my-4">
                <p id="backtest-status-text" class="text-center text-sm text-yellow-400 mb-2">Mengambil data...</p>
                <div class="w-full bg-gray-700 rounded-full h-2.5"><div id="backtest-progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div></div>
            </div>

            <section id="strategy-lab-section" class="card p-6">
                <button id="toggle-lab-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-base font-bold">🧪 Strategy Lab & Tuning</h2>
                    <svg id="toggle-lab-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="lab-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700 space-y-6">
                        <div>
                            <h3 class="font-semibold text-lg mb-3">Preset Bobot (Otomatis berdasarkan Rezim)</h3>
                            <select id="lab-regime-preset" class="input-primary mt-1">
                                <option value="default" selected>Default (Hybrid)</option>
                                <option value="trending">Trending Market (Follow Trend)</option>
                                <option value="ranging">Ranging Market (Mean Reversion)</option>
                                <option value="lowVolatility">Low Volatility (Breakout)</option>
                                <option value="custom">Custom</option>
                            </select>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg mb-3">Parameter Eksekusi & Realitas Pasar</h3>
                            <div class="grid grid-cols-2 md:grid-cols-6 gap-4">
                                <div><label class="block text-xs text-gray-400">R:R Ratio (TP)</label><input type="number" step="0.1" id="lab-rr-ratio" value="1.5" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">EMA Entry</label><input type="number" id="lab-ema-period" value="9" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Swing Lookback (SL)</label><input type="number" id="lab-swing-lookback" value="15" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Bias Threshold</label><input type="number" id="lab-bias-threshold" value="15" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Risk per Trade (%)</label><input type="number" id="lab-risk-percent" value="10" class="input-primary small-input mt-1"></div>
                                
                                <div>
                                    <label class="block text-xs text-gray-400">ATR Filter (Nilai Min)</label>
                                    <input type="number" step="0.0001" id="lab-atr-filter-input" value="0" class="input-primary small-input mt-1">
                                </div>
                                
                                <div><label class="block text-xs text-gray-400">Taker Fee (%)</label><input type="number" step="0.01" id="lab-taker-fee" value="0.04" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Maker Fee (%)</label><input type="number" step="0.01" id="lab-maker-fee" value="0.02" class="input-primary small-input mt-1"></div>
                                <div>
                                    <label class="block text-xs text-gray-400">Model Slippage</label>
                                    <select id="lab-slippage-model" class="input-primary mt-1 text-xs">
                                        <option value="none">None</option>
                                        <option value="atrDynamic" selected>ATR Dinamis</option>
                                    </select>
                                </div>
                                <div class="md:col-span-2">
                                    <label class="block text-xs text-gray-400">Margin Mode</label>
                                    <select id="lab-margin-mode" class="input-primary mt-1">
                                        <option value="cross" selected>Cross</option>
                                        <option value="isolated">Isolated</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <details>
                            <summary class="cursor-pointer text-sm text-gray-400 hover:text-white">Tuning Bobot Konfluensi (Advanced)</summary>
                            <div id="lab-weights-tuning" class="mt-4 pt-4 border-t border-gray-600 grid grid-cols-2 md:grid-cols-4 gap-x-6 gap-y-4"></div>
                        </details>
                    </div>
                </div>
            </section>
            
            <div id="backtest-results-container" class="hidden card p-6">
                <h3 class="font-bold text-lg mb-4 text-center">📊 Dasbor Performa Kuantitatif</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-4 text-center">
                    <div>
                        <p class="text-xs text-gray-500">💰 Total Profit/Loss</p>
                        <p id="backtest-result-pnl" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">🎯 Win Rate</p>
                        <p id="backtest-result-winrate" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">📈 Profit Factor</p>
                        <p id="backtest-result-profit-factor" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Trades</p>
                        <p id="backtest-result-total-trades" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">📉 Max Drawdown</p>
                        <p id="backtest-result-max-drawdown" class="font-mono font-bold text-lg negative">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">🎲 Expectancy / Trade</p>
                        <p id="backtest-result-expectancy" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">🔥 Max Losing Streak</p>
                        <p id="backtest-result-losing-streak" class="font-mono font-bold text-lg">-</p>
                    </div>
                </div>
            </div>
            
            <section id="tuning-recommendation-section" class="card p-6 hidden">
                <button id="toggle-tuning-recommendation-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-xl font-bold">🎯 Rekomendasi Tuning (Quant V3.2)</h2>
                    <svg id="toggle-tuning-recommendation-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="tuning-recommendation-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700 grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                        
                        <div class="space-y-6">
                            <div>
                                <h3 class="font-semibold mb-2 text-yellow-400">Konfluensi yang Perlu Diperbaiki</h3>
                                <ul id="confluence-issues-list" class="text-sm space-y-2"></ul>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-blue-400">Saran Regime Pasar</h3>
                                <div id="regime-suggestion-content" class="text-sm"></div>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-green-300">📋 Action Plan</h3>
                                <ul id="action-plan-list" class="text-sm space-y-2"></ul>
                            </div>
                        </div>

                        <div class="space-y-6">
                            <div>
                                <h3 class="font-semibold mb-2 text-purple-400">Parameter Optimal (Hasil "What-If")</h3>
                                <div id="optimal-params-container" class="text-sm space-y-2"></div>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-gray-400">Saran Umum</h3>
                                <ul id="general-suggestions-list" class="text-sm space-y-2"></ul>
                            </div>
                        </div>

                        <div class="md:col-span-2 flex items-center gap-4 pt-4 mt-4 border-t border-gray-600">
                            <button id="apply-tuning-btn" class="btn-primary w-full">
                                <span>⚙️ Terapkan ke Index.HTML</span>
                            </button>
                            <button id="export-config-btn" class="btn-secondary w-full">
                                <span>📄 Ekspor Konfigurasi</span>
                            </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="market-analysis-section" class="card p-6 hidden">
                <button id="toggle-market-analysis-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-xl font-bold">📊 Analisis Kondisi Pasar</h2>
                    <svg id="toggle-market-analysis-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="market-analysis-content-wrapper" class="collapsible-content expanded">
                <div id="market-analysis-content" class="space-y-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h3 class="font-semibold mb-2">Distribusi Kondisi Pasar</h3>
                            <div id="market-condition-chart"></div>
                        </div>
                        <div class="space-y-4">
                            <h3 class="font-semibold mb-2">Ringkasan Volatilitas</h3>
                            <div class="flex items-center justify-between text-sm">
                                <span>Kondisi Pasar</span>
                                <span id="overall-volatility-text" class="font-mono">-</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-1.5 mb-2">
                                <div id="overall-volatility-bar" class="market-condition-bar" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Segmentasi Waktu Berdasarkan Kondisi</h3>
                            <div id="time-segmentation-chart" class="mt-2"></div>
                        </div>
                    </div>
                    
                    <div class="recommendation-card p-4 rounded-md">
                        <h3 class="font-semibold mb-2 text-yellow-400">💡 Rekomendasi Berdasarkan Kondisi Pasar</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 pt-4 border-t border-gray-700">
                            <div>
                            <h3 class="font-semibold mb-2">ATR Saat Ini</h3>
                            <div id="atr-value" class="text-lg font-mono">-</div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Status Volatilitas</h3>
                            <div id="volatility-status" class="text-lg font-mono">-</div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Rata-rata Perubahan Harian</h3>
                            <div id="daily-range" class="text-lg font-mono">-</div>
                        </div>
                        </div>
                        <ul id="market-recommendations" class="text-sm space-y-2"></ul>
                    </div>
                </div>
            </section>
            <section id="logbook-section" class="card p-6">
                <button id="toggle-logbook-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-lg font-bold">📖 LOGBOOK</h2>
                    <svg id="toggle-logbook-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="logbook-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700">
                        <div class="flex justify-between items-center mb-2">
                            <h4 class="font-semibold text-gray-400">Backtest History</h4>
                            <button id="clear-logbook-btn" class="btn-secondary !text-xs !py-1 !px-2">Hapus Riwayat</button>
                        </div>
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-sm text-left text-gray-400">
                                <thead class="text-xs text-gray-400 uppercase bg-gray-700/50">
                                    <tr>
                                        <th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="symbol">Aset</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="timeframe">TF</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="pnlPercent">PNL (%)</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="winRate">Win Rate</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="profitFactor">Profit Factor</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="totalTrades">Trades</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="startDate">Periode</th>
                                    </tr>
                                </thead>
                                <tbody id="logbook-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <div id="backtest-trade-log-container" class="hidden card p-4">
                <h4 class="font-semibold text-gray-400 mb-2">Trades Simulation History</h4>
                <div id="backtest-trade-log" class="space-y-2 text-xs max-h-60 overflow-y-auto p-2 bg-gray-900/50 rounded-md"></div>
            </div>

            <section id="backtest-chart-container-section" class="card p-4 hidden">
                <button id="toggle-chart-container-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-xl font-bold">Chart Replay</h2>
                    <svg id="toggle-chart-container-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="chart-container-content-wrapper" class="collapsible-content expanded">
                
                <div class="chart-container relative border-b border-gray-700 pb-2">
                    <div class="pane-title text-sm font-bold text-gray-300">REPLAY</div>
                    <div id="main-chart-container" style="height: 450px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">Volume</div>
                    <div id="volume-chart-container" style="height: 100px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">RSI (14)</div>
                    <div id="rsi-chart-container" style="height: 120px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">Stochastic RSI (14, 14, 3, 3)</div>
                    <div id="stoch-rsi-chart-container" style="height: 120px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">MACD</div>
                    <div id="macd-chart-container" style="height: 120px;"></div>
                    <div id="replay-controls" class="flex items-center justify-center gap-4 p-4 mt-4 border-t border-gray-700">
                    <button id="replay-reset-btn" class="btn-secondary">⏮️ Reset</button>
                    <button id="replay-step-btn" class="btn-secondary">⏯️ Step</button>
                    <button id="replay-play-pause-btn" class="btn-primary w-28">▶️ Play</button>
                    <div class="flex items-center gap-2">
                        <label for="replay-speed-slider" class="text-sm">Speed</label>
                        <input id="replay-speed-slider" type="range" min="1" max="20" value="5" class="w-32">
                        <span id="replay-speed-label" class="text-sm font-mono w-8">x10</span>
                    </div>
                </div>
                </div>                
            </section>
        </main>
    </div>

<script>
    // Deklarasi variabel global untuk elemen-elemen HTML
        const backtestSymbolInput = document.getElementById('backtest-symbol-input');
        const backtestStartDate = document.getElementById('backtest-start-date');
        const backtestEndDate = document.getElementById('backtest-end-date');
        const backtestTimeframeSelect = document.getElementById('backtest-timeframe-select');
        const backtestInitialBalance = document.getElementById('backtest-initial-balance');
        const backtestLeverageInput = document.getElementById('backtest-leverage-input');
        const startBacktestBtn = document.getElementById('start-backtest-btn');
        const stopBacktestBtn = document.getElementById('stop-backtest-btn');
        const backtestProgressContainer = document.getElementById('backtest-progress-container');
        const backtestStatusText = document.getElementById('backtest-status-text');
        const backtestProgressBar = document.getElementById('backtest-progress-bar');
        const backtestResultsContainer = document.getElementById('backtest-results-container');
        const backtestPnl = document.getElementById('backtest-result-pnl');
        const backtestWinrate = document.getElementById('backtest-result-winrate');
        const backtestProfitFactor = document.getElementById('backtest-result-profit-factor');
        const backtestTotalTrades = document.getElementById('backtest-result-total-trades');
        const backtestTradeLogContainer = document.getElementById('backtest-trade-log-container');
        const backtestTradeLog = document.getElementById('backtest-trade-log');
        const labRegimePreset = document.getElementById('lab-regime-preset');
        const labRrRatioInput = document.getElementById('lab-rr-ratio');
        const labEmaPeriodInput = document.getElementById('lab-ema-period');
        const labSwingLookbackInput = document.getElementById('lab-swing-lookback');
        const labBiasThresholdInput = document.getElementById('lab-bias-threshold');
        const labRiskPercentInput = document.getElementById('lab-risk-percent');
        const labMarginModeSelect = document.getElementById('lab-margin-mode');
        const labWeightsContainer = document.getElementById('lab-weights-tuning');
        const tuningRecommendationSection = document.getElementById('tuning-recommendation-section');
        const weakConfluencesList = document.getElementById('weak-confluences-list');
        const optimalParamsList = document.getElementById('optimal-params-list');
        const applyTuningBtn = document.getElementById('apply-tuning-btn');
        const exportConfigBtn = document.getElementById('export-config-btn');
        const labTakerFeeInput = document.getElementById('lab-taker-fee');
        const labMakerFeeInput = document.getElementById('lab-maker-fee');
        const labSlippageModelSelect = document.getElementById('lab-slippage-model');
        const labAtrFilterInput = document.getElementById('lab-atr-filter-input');
        const replaySpeedSlider = document.getElementById('replay-speed-slider');
        const replaySpeedLabel = document.getElementById('replay-speed-label');

        const timeframeParameterMap = {
            '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
            '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
        };

    // Deklarasi variabel global lainnya
        let logbookSortState = { key: 'id', direction: 'desc' };
        let lastRecommendations = null;

        let replayState = {
            isPlaying: false,
            currentIndex: 0,
            speed: 5,
            intervalId: null,
            candleSeries: null,
            volumeSeries: null,
            rsiSeries: null,
            stochKSeries: null, // [TAMBAHAN]
            stochDSeries: null, // [TAMBAHAN]
            macdLineSeries: null,
            signalLineSeries: null,
            histogramSeries: null,
            fullData: {},
            priceLines: []
        };

        let charts = [];
// ===================================================================
// BAGIAN BARU: FITUR REPLAY CHART
// ===================================================================
    function getChartBaseOptions(height) {
        return {
            width: document.getElementById('backtest-chart-container-section').clientWidth - 32,
            height: height,
            layout: { background: { color: '#151414' }, textColor: '#E0E0E0' },
            grid: { vertLines: { color: '#333' }, horzLines: { color: '#333' } },
            timeScale: { borderColor: '#444', timeVisible: true },
            rightPriceScale: { borderColor: '#444' },
            lockVisibleTimeRangeOnResize: true,
            rightOffset: -30, // chart offset
                barSpacing: 6,
                minBarSpacing: 3,
                horzTouchDrag: true, 
                vertTouchDrag: false, 
                mouseScroll: false, // Menonaktifkan mouse scroll zoom
                pinchToZoom: true, // Membiarkan pinch-to-zoom di mobile
                tickMarkFormatter: (time) => {
                    const date = new Date(time * 1000);
                    // Format ke jam:menit menggunakan timezone default browser pengguna
                    return date.toLocaleTimeString('id-ID', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
        };
    }

    function syncCharts(...chartsToSync) {
        chartsToSync.forEach(chart => {
            if (!chart) return;
            chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                chartsToSync.forEach(otherChart => {
                    if (chart !== otherChart && otherChart) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }
                    if (timeRange && timeRange.from && timeRange.to) {
                        otherChart.timeScale().setVisibleRange(timeRange);
                    }

                });
            });
        });
    }

    function destroyCharts() {
        charts.forEach(chart => { if (chart) chart.remove(); });
        charts = [];
        // [MODIFIKASI] Menambahkan container Stoch RSI untuk dibersihkan
        ['main-chart-container', 'volume-chart-container', 'rsi-chart-container', 'stoch-rsi-chart-container', 'macd-chart-container'].forEach(id => {
            const container = document.getElementById(id);
            if (container) container.innerHTML = '';
        });
    }

    function renderReplayWithIndicators(historicalData, trades) {
    if (!historicalData || historicalData.length < 200) {
        destroyCharts();
        return;
    }
    destroyCharts();
    const formattedKlines = historicalData.map(d => ({
        time: d[0] / 1000,
        open: parseFloat(d[1]),
        high: parseFloat(d[2]),
        low: parseFloat(d[3]),
        close: parseFloat(d[4])
    }));
    const volumeData = historicalData.map(d => ({ time: d[0] / 1000, value: parseFloat(d[5]), color: parseFloat(d[4]) >= parseFloat(d[1]) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' }));
    const closes = formattedKlines.map(k => k.close);
    const rsiIndicator = calculateRSI(closes, 14);
    const stochRsiIndicator = calculateStochasticRSI(closes);
    const macdIndicator = calculateMACD(closes);
    const rsiData = rsiIndicator.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
    const stochKData = stochRsiIndicator.kLine.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
    const stochDData = stochRsiIndicator.dLine.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
    const macdLineData = macdIndicator.macdLine.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
    const signalLineData = macdIndicator.signalLine.map((value, index) => ({ time: formattedKlines[index + 33]?.time, value })).filter(d => d.time && d.value !== undefined);
    const histogramData = macdIndicator.histogram.map((item, index) => (item && formattedKlines[index]) ? { time: formattedKlines[index].time, value: item.value, color: item.color } : null).filter(Boolean);
    const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
    const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
    const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(120));
    const stochRsiChart = LightweightCharts.createChart(document.getElementById('stoch-rsi-chart-container'), getChartBaseOptions(120));
    const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(120));
    charts = [mainChart, volumeChart, rsiChart, stochRsiChart, macdChart];
    replayState.candleSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false });
    replayState.volumeSeries = volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } });
    replayState.rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 });
    replayState.stochKSeries = stochRsiChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: '%K' });
    replayState.stochDSeries = stochRsiChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: '%D' });
    replayState.macdLineSeries = macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceLineVisible: false });
    replayState.signalLineSeries = macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceLineVisible: false });
    replayState.histogramSeries = macdChart.addHistogramSeries({ base: 0 });
    replayState.fullData = {
            formattedKlines: formattedKlines.filter(k => k.close !== undefined && !isNaN(k.close)),
            volumeData: volumeData.filter(v => v.value !== undefined && !isNaN(v.value)),
            rsiData: rsiData.filter(d => d.value !== undefined && !isNaN(d.value)),
            stochKData: stochKData.filter(d => d.value !== undefined && !isNaN(d.value)),
            stochDData: stochDData.filter(d => d.value !== undefined && !isNaN(d.value)),
            macdLineData: macdLineData.filter(d => d.value !== undefined && !isNaN(d.value)),
            signalLineData: signalLineData.filter(d => d.value !== undefined && !isNaN(d.value)),
            histogramData: histogramData.filter(d => d.value !== undefined && !isNaN(d.value)),
            trades: trades
        };
    resetReplay();
    const firstValidKline = formattedKlines.find(k => k.time);
    const lastValidKline = formattedKlines.slice().reverse().find(k => k.time);
    if (firstValidKline && lastValidKline && formattedKlines.length > 1) {
        mainChart.timeScale().setVisibleRange({
            from: firstValidKline.time,
            to: lastValidKline.time,
        });
    }
    syncCharts(...charts);
}

    function runReplayStep() {
        if (!replayState.fullData.formattedKlines || replayState.currentIndex >= replayState.fullData.formattedKlines.length) {
            pauseReplay();
            document.getElementById('replay-play-pause-btn').disabled = true;
            return;
        }

        const i = replayState.currentIndex;
        const currentKline = replayState.fullData.formattedKlines[i];
        const currentTime = currentKline.time;

        // Update series utama
        replayState.candleSeries.update(currentKline);
        replayState.volumeSeries.update(replayState.fullData.volumeData[i]);

        // Update series indikator
        const rsiPoint = replayState.fullData.rsiData.find(d => d.time === currentTime);
        if (rsiPoint) replayState.rsiSeries.update(rsiPoint);

        // [TAMBAHAN] Update Stoch RSI
        const stochKPoint = replayState.fullData.stochKData.find(d => d.time === currentTime);
        if (stochKPoint) replayState.stochKSeries.update(stochKPoint);
        const stochDPoint = replayState.fullData.stochDData.find(d => d.time === currentTime);
        if (stochDPoint) replayState.stochDSeries.update(stochDPoint);

        // Update MACD
        const macdLinePoint = replayState.fullData.macdLineData.find(d => d.time === currentTime);
        if (macdLinePoint) replayState.macdLineSeries.update(macdLinePoint);
        const signalLinePoint = replayState.fullData.signalLineData.find(d => d.time === currentTime);
        if (signalLinePoint) replayState.signalLineSeries.update(signalLinePoint);
        const histogramPoint = replayState.fullData.histogramData.find(d => d.time === currentTime);
        if (histogramPoint) replayState.histogramSeries.update(histogramPoint);

        // Logika Marker & Price Line (tidak berubah)
        const markersToAdd = [];
        replayState.fullData.trades.forEach(trade => {
            const entryTime = new Date(trade.entryDate).getTime() / 1000;
            const exitTime = new Date(trade.exitDate).getTime() / 1000;
            if (entryTime === currentTime) {
                markersToAdd.push({ time: currentTime, position: trade.type === 'LONG' ? 'belowBar' : 'aboveBar', color: trade.type === 'LONG' ? '#26a69a' : '#ef5350', shape: trade.type === 'LONG' ? 'arrowUp' : 'arrowDown', text: `Entry @ ${trade.entryPrice.toFixed(4)}` });
                trade.slLine = replayState.candleSeries.createPriceLine({ price: trade.sl, color: '#f87171', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'SL' });
                trade.tpLine = replayState.candleSeries.createPriceLine({ price: trade.tp, color: '#4ade80', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'TP' });
            }
            if (exitTime === currentTime) {
                markersToAdd.push({ time: currentTime, position: trade.type === 'LONG' ? 'aboveBar' : 'belowBar', color: '#a3a3a3', shape: 'square', text: `Exit @ ${trade.exitPrice.toFixed(4)}` });
                if(trade.slLine) replayState.candleSeries.removePriceLine(trade.slLine);
                if(trade.tpLine) replayState.candleSeries.removePriceLine(trade.tpLine);
            }
        });
        if (markersToAdd.length > 0) {
            const existingMarkers = replayState.candleSeries.markers() || [];
            replayState.candleSeries.setMarkers([...existingMarkers, ...markersToAdd]);
        }

        replayState.currentIndex++;
    }

    function playReplay() {
        if (replayState.isPlaying) return;
        replayState.isPlaying = true;
        document.getElementById('replay-play-pause-btn').innerHTML = '⏸️ Pause';
        const speedMap = { 1: 1000, 2: 800, 3: 600, 4: 400, 5: 300, 6: 200, 7: 150, 8: 100, 9: 50, 10: 25, 11: 20, 12: 18, 13: 16, 14: 14, 15: 12, 16: 10, 17: 8, 18: 5, 19: 2, 20: 1 };
        replayState.intervalId = setInterval(runReplayStep, speedMap[replayState.speed] || 300);
    }

    function pauseReplay() {
        if (!replayState.isPlaying) return;
        replayState.isPlaying = false;
        document.getElementById('replay-play-pause-btn').innerHTML = '▶️ Play';
        clearInterval(replayState.intervalId);
        replayState.intervalId = null;
    }

    function stepReplay() {
        if (replayState.isPlaying) pauseReplay();
        runReplayStep();
    }

    function resetReplay() {
        pauseReplay();
        replayState.currentIndex = 0;

        if (replayState.candleSeries) {
            replayState.priceLines.forEach(line => replayState.candleSeries.removePriceLine(line));
            replayState.candleSeries.setMarkers([]);
        }
        replayState.priceLines = [];

        if (replayState.candleSeries) replayState.candleSeries.setData([]);
        if (replayState.volumeSeries) replayState.volumeSeries.setData([]);
        if (replayState.rsiSeries) replayState.rsiSeries.setData([]);
        if (replayState.stochKSeries) replayState.stochKSeries.setData([]); // [TAMBAHAN]
        if (replayState.stochDSeries) replayState.stochDSeries.setData([]); // [TAMBAHAN]
        if (replayState.macdLineSeries) replayState.macdLineSeries.setData([]);
        if (replayState.signalLineSeries) replayState.signalLineSeries.setData([]);
        if (replayState.histogramSeries) replayState.histogramSeries.setData([]);

        document.getElementById('replay-play-pause-btn').disabled = false;
        document.getElementById('replay-step-btn').disabled = false;
    }

    function changeReplaySpeed(value) {
        const speed = parseInt(value, 10);
        replayState.speed = speed;
        replaySpeedLabel.textContent = `x${speed}`;

        if (replayState.isPlaying) {
            pauseReplay();
            playReplay();
        }
    }

    function setupReplayEventListeners() {
        if (window.replayListenersAttached) return;
        document.getElementById('replay-play-pause-btn').addEventListener('click', () => {
            if (replayState.isPlaying) pauseReplay();
            else playReplay();
        });
        document.getElementById('replay-step-btn').addEventListener('click', stepReplay);
        document.getElementById('replay-reset-btn').addEventListener('click', resetReplay);
        document.getElementById('replay-speed-slider').addEventListener('input', (e) => {
            changeReplaySpeed(parseInt(e.target.value));
        });
        window.replayListenersAttached = true;
    }

    function replayEntry(id) {
        const logbookData = JSON.parse(localStorage.getItem('backtestLogbook')) || [];
        const entry = logbookData.find(e => e.id === id);
        if (entry && entry.historicalData) {
            document.getElementById('backtest-chart-container-section').classList.remove('hidden');
            renderReplayWithIndicators(entry.historicalData, entry.trades);
            window.scrollTo({ top: document.getElementById('backtest-chart-container-section').offsetTop, behavior: 'smooth' });
        } else {
            alert("Data historis tidak tersedia untuk entri ini. Jalankan backtest lagi.");
        }
    }
    // ===================================================================
    // BAGIAN 2: PUSTAKA FUNGSI KALKULASI MURNI (VERSI LENGKAP & SINKRON)
    // ===================================================================
    let userSettings = {
        presets: {
            'default': { weights: { ma: 2, rsiDivergence: 2.5, macd: 2, pivot: 2, vwap: 2, ichimoku: 3, candlePattern: 1.5, obvDivergence: 3.0, bbSqueeze: 1.5, psar: 1, roc: 1, bollingerBands: 1, rsi: 1.5, stoch: 1, linreg: 1 } },
            'trending': { weights: { ma: 3.0, rsiDivergence: 1.0, macd: 2.5, pivot: 1.5, vwap: 2.5, ichimoku: 3.0, candlePattern: 1.5, obvDivergence: 2.0, bbSqueeze: 0.5, psar: 2.5, roc: 1.5, bollingerBands: 1, rsi: 1.0, stoch: 0.5, linreg: 2.0 } },
            'ranging': { weights: { ma: 1.0, rsiDivergence: 3.0, macd: 1.5, pivot: 2.0, vwap: 1.0, ichimoku: 1.0, candlePattern: 2.0, obvDivergence: 2.5, bbSqueeze: 1.0, psar: 0.5, roc: 1.0, bollingerBands: 2.5, rsi: 2.5, stoch: 2.0, linreg: 1.5 } },
            'lowVolatility': { weights: { ma: 1.0, rsiDivergence: 1.5, macd: 2.0, pivot: 1.0, vwap: 1.0, ichimoku: 0.5, candlePattern: 1.5, obvDivergence: 1.0, bbSqueeze: 3.5, psar: 0.5, roc: 2.0, bollingerBands: 2.0, rsi: 2.0, stoch: 1.5, linreg: 1.0 } }
        }
    };
    
    const calculateEMA = (data, period) => {
        // Pastikan data valid dan cukup panjang untuk perhitungan
        if (!data || data.length < period) {
            return [];
        }

        // Hitung faktor penghalus (smoothing factor)
        const k = 2 / (period + 1);
        let emaArray = [];

        // Hitung EMA pertama (SMA)
        if (data.length > 0) {
            let sum = 0;
            for (let i = 0; i < period; i++) {
            sum += data[i] || 0;
            }
            emaArray[period - 1] = sum / period;

            // Hitung EMA selanjutnya
            for (let i = period; i < data.length; i++) {
            // Perhitungan EMA menggunakan formula: EMA_saat_ini = (harga_saat_ini * k) + (EMA_sebelumnya * (1 - k))
            emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
            }
        }

        return emaArray;
    };
    
    const calculateSMA = (data, period) => {
        // Pastikan data valid dan cukup panjang
        if (!data || data.length < period) {
            return [];
        }

        let sma = Array(period - 1).fill(undefined);

        // Mulai perhitungan SMA dari titik di mana data mencukupi
        for (let i = period - 1; i < data.length; i++) {
            // Ambil bagian data yang relevan
            const slice = data.slice(i - period + 1, i + 1);
            
            // Hitung rata-rata dan tambahkan ke array hasil
            const sum = slice.reduce((a, b) => a + b, 0);
            sma.push(sum / period);
        }

        return sma;
    };

    const calculateRSI = (closes, period) => {
        // Jika periode tidak diberikan secara spesifik, buat menjadi adaptif
        if (period === undefined) {
            const timeframe = backtestTimeframeSelect.value;
            period = timeframeParameterMap[timeframe]?.rsi_period || 14;
        }
        
        if (!closes || closes.length <= period) {
            return Array(closes.length).fill(undefined);
        }
        // ... sisa dari fungsi calculateRSI tetap sama ...
        let gains = [];
        let losses = [];
        for (let i = 1; i < closes.length; i++) {
            const diff = closes[i] - closes[i - 1];
            gains.push(diff > 0 ? diff : 0);
            losses.push(diff < 0 ? -diff : 0);
        }
        let rsi = Array(period).fill(undefined);
        let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
        let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
        rsi[period - 1] = (avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
        for (let i = period; i < gains.length; i++) {
            avgGain = (avgGain * (period - 1) + gains[i]) / period;
            avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
            rsi.push((avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
        }
        return rsi;
    };
    
    const calculateMACD = (closes, fast, slow, signal) => {
        // Buat parameter menjadi adaptif jika tidak diisi
        if (fast === undefined) {
            const timeframe = backtestTimeframeSelect.value;
            const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];
            fast = params.macd_fast;
            slow = params.macd_slow;
            signal = params.macd_signal;
        }
        
        if (closes.length < slow) {
            return { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };
        }
        // ... sisa dari fungsi calculateMACD tetap sama ...
        const emaFast = calculateEMA(closes, fast);
        const emaSlow = calculateEMA(closes, slow);
        const macdLine = emaSlow.map((slowVal, i) => {
            if (slowVal !== undefined && emaFast[i] !== undefined) {
                return emaFast[i] - slowVal;
            }
            return undefined;
        }).filter(v => v !== undefined);
        const signalLine = calculateEMA(macdLine, signal);
        const histogram = macdLine.map((macdVal, i) => {
            const sigVal = signalLine[i] !== undefined ? signalLine[i] : (signalLine.length > 0 ? signalLine.pop() : undefined);
            if (sigVal !== undefined) {
                const histValue = macdVal - sigVal;
                const prevHistValue = (i > 0 && macdLine[i - 1] !== undefined && signalLine[i - 1] !== undefined) ? (macdLine[i - 1] - signalLine[i - 1]) : 0;
                return {
                    value: histValue,
                    color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                };
            }
            return undefined;
        }).filter(v => v !== undefined);
        const lastMacd = macdLine.pop() || 0;
        const lastSig = signalLine.pop() || 0;
        const prevMacdLine = macdLine.pop() || 0;
        const prevSignalLine = signalLine.pop() || 0;
        let status = 'Netral';
        if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) {
            status = 'Bullish Cross';
        } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) {
            status = 'Bearish Cross';
        }
        return { status, macdLine, signalLine, histogram };
    };

    const calculateStochasticRSI = (closes, rsiPeriod, stochPeriod, kSmooth, dSmooth) => {
        // Buat parameter menjadi adaptif jika tidak diisi
        if (rsiPeriod === undefined) {
            const timeframe = backtestTimeframeSelect.value;
            const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];
            rsiPeriod = params.stoch_rsi_period;
            stochPeriod = params.stoch_stoch_period;
            kSmooth = params.stoch_k_smooth;
            dSmooth = params.stoch_d_smooth;
        }

        const rsiValues = calculateRSI(closes, rsiPeriod);
        const validRsi = rsiValues.filter(v => v !== undefined);
        if (validRsi.length < stochPeriod) {
            return { kLine: [], dLine: [], status: 'Netral' };
        }
        // ... sisa dari fungsi calculateStochasticRSI tetap sama ...
        let stochArr = [];
        for (let i = stochPeriod - 1; i < validRsi.length; i++) {
            const window = validRsi.slice(i - stochPeriod + 1, i + 1);
            const minR = Math.min(...window);
            const maxR = Math.max(...window);
            const denom = maxR - minR;
            stochArr.push(denom === 0 ? 0 : ((validRsi[i] - minR) / denom) * 100);
        }
        const kLineRaw = calculateSMA(stochArr, kSmooth);
        const dLineRaw = calculateSMA(kLineRaw.filter(v => v !== undefined), dSmooth);
        const kLine = kLineRaw.filter(v => v !== undefined);
        const dLine = dLineRaw.filter(v => v !== undefined);
        const lastK = kLine.pop() || 50;
        const lastD = dLine.pop() || 50;
        let status = 'Netral';
        if (lastK > 80 && lastD > 80) status = 'Overbought';
        else if (lastK < 20 && lastD < 20) status = 'Oversold';
        return { kLine, dLine, status };
    };

    const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
        if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE' };
        const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };
        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const rsiLows = findPivots(recentRSI, false), rsiHighs = findPivots(recentRSI, true);
        if (priceLows.length >= 2 && rsiLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH' };
        }
        if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH' };
        }
        return { status: 'NONE' };
    };

    const calculateOBV = (klines) => {
        if (!klines || klines.length < 2) return [];
        let obv = [0]; 
        for (let i = 1; i < klines.length; i++) {
            const close = parseFloat(klines[i][4]);
            const prevClose = parseFloat(klines[i-1][4]);
            const volume = parseFloat(klines[i][5]);
            if (close > prevClose) obv.push(obv[i-1] + volume);
            else if (close < prevClose) obv.push(obv[i-1] - volume);
            else obv.push(obv[i-1]);
        }
        return obv;
    };

    const detectOBVDivergence = (closes, klines, lookback = 30) => {
        if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

        const obvValues = calculateOBV(klines);
        const recentCloses = closes.slice(-lookback);
        const recentOBV = obvValues.slice(-lookback);

        const findPivots = (data, isHigh) => {
            let pivots = [];
            for (let i = 1; i < data.length - 1; i++) {
                if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                    pivots.push({ index: i, value: data[i] });
                }
            }
            return pivots;
        };

        const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
        const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

        if (priceLows.length >= 2 && obvLows.length >= 2) {
            const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
            const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
            if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
        }
        if (priceHighs.length >= 2 && obvHighs.length >= 2) {
            const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
            const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
            if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
        }
        return { status: 'NONE', class: 'text-gray-500' };
    };

    const findCandlestickPatterns = (klines) => {
        if (!klines || klines.length < 2) return { bias: 'NETRAL' };
        const getCandle = (k) => {
            const [o, h, l, c] = k.slice(1, 5).map(parseFloat);
            return { open: o, close: c, isGreen: c > o, isRed: c < o };
        };
        const c1 = getCandle(klines[klines.length - 1]), c2 = getCandle(klines[klines.length - 2]);
        if (c2.isRed && c1.isGreen && c1.close > c2.open) return { bias: 'BULLISH' };
        if (c2.isGreen && c1.isRed && c1.close < c2.open) return { bias: 'BEARISH' };
        return { bias: 'NETRAL' };
    };

    const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
        if (closes.length < period) {
            return { upper: [], middle: [], lower: [], squeezeStatus: 'N/A' };
        }
        const middle = calculateSMA(closes, period);
        const upper = [];
        const lower = [];
        const width = [];

        for (let i = period - 1; i < closes.length; i++) {
            if (middle[i] === undefined) {
                upper.push(undefined);
                lower.push(undefined);
                width.push(undefined);
                continue;
            }
            const slice = closes.slice(i - period + 1, i + 1);
            const sumSquaredDiff = slice.reduce((a, b) => a + Math.pow(b - middle[i], 2), 0);
            const stdev = Math.sqrt(sumSquaredDiff / period);
            upper.push(middle[i] + (stdev * stdDev));
            lower.push(middle[i] - (stdev * stdDev));
            width.push((stdev * stdDev * 2));
        }

        const lastWidth = width.filter(v => v !== undefined).pop();
        let squeezeStatus = 'Normal';
        if (width.length > 50) {
            const recentWidths = width.slice(-50).filter(v => v !== undefined);
            if (recentWidths.length > 0) {
                const sortedWidths = [...recentWidths].sort((a, b) => a - b);
                const threshold = sortedWidths[Math.floor(sortedWidths.length * 0.20)];
                if (lastWidth < threshold) {
                    squeezeStatus = 'Squeeze!';
                }
            }
        }
        return { upper, middle, lower, squeezeStatus };
    };

    const calculateADX = (klines, period = 14) => {
        if (!klines || klines.length < period * 2) return { value: 0, plusDI: 0, minusDI: 0 };
        let highs = klines.map(k => parseFloat(k[2])), lows = klines.map(k => parseFloat(k[3])), closes = klines.map(k => parseFloat(k[4]));
        let trs = [], plusDMs = [], minusDMs = [];
        for (let i = 1; i < highs.length; i++) {
            trs.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1])));
            let upMove = highs[i] - highs[i - 1], downMove = lows[i - 1] - lows[i];
            plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
            minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
        }
        const rma = (data, p) => {
            let rma = [], sum = 0;
            for (let i = 0; i < data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    rma.push(i === p - 1 ? sum / p : undefined);
                } else if(rma[i-1] !== undefined) {
                    rma.push((rma[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return rma;
        };
        let smoothedTR = rma(trs, period), smoothedPlusDM = rma(plusDMs, period), smoothedMinusDM = rma(minusDMs, period);
        let plusDIs = [], minusDIs = [], dxs = [];
        for (let i = 0; i < smoothedTR.length; i++) {
            if (smoothedTR[i] === undefined) continue;
            let plusDI = smoothedTR[i] > 0 ? (smoothedPlusDM[i] / smoothedTR[i]) * 100 : 0;
            let minusDI = smoothedTR[i] > 0 ? (smoothedMinusDM[i] / smoothedTR[i]) * 100 : 0;
            plusDIs.push(plusDI);
            minusDIs.push(minusDI);
            let diSum = plusDI + minusDI;
            dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
        }
        let adxValues = rma(dxs, period);
        return { value: adxValues.filter(v=>v!==undefined).pop() || 0, plusDI: plusDIs.pop() || 0, minusDI: minusDIs.pop() || 0 };
    };

    function calculatePivotPoints(prevDayKline) {
        if (!prevDayKline || prevDayKline.length < 5) return null;
        const high = parseFloat(prevDayKline[2]);
        const low = parseFloat(prevDayKline[3]);
        const close = parseFloat(prevDayKline[4]);
        if (isNaN(high) || isNaN(low) || isNaN(close)) return null;
        return { P: (high + low + close) / 3 };
    }

    function calculateVWAP(klines, period = 20) {
        if (!klines || klines.length < period) return 0;
        let sumPV = 0, sumV = 0;
        const dataSlice = klines.slice(-period);
        dataSlice.forEach(k => {
            const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
            sumPV += ((high + low + close) / 3) * vol;
            sumV += vol;
        });
        return sumV > 0 ? sumPV / sumV : 0;
    }

    function calculateIchimokuCloud(klines) {
        if (klines.length < 52) return { status: 'Netral' };
        const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
        let tenkan = [], kijun = [];
        for (let i = 0; i < klines.length; i++) {
            const tenkanHighLow = i >= 8 ? getHighLow(klines.slice(i - 8, i + 1)) : {};
            tenkan.push(tenkanHighLow.high ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
            const kijunHighLow = i >= 25 ? getHighLow(klines.slice(i - 25, i + 1)) : {};
            kijun.push(kijunHighLow.high ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
        }
        const lastPrice = parseFloat(klines[klines.length - 1][4]);
        const lastTenkan = tenkan[tenkan.length - 1], lastKijun = kijun[kijun.length - 1];
        if (lastTenkan > lastKijun && lastPrice > lastKijun) return { status: "BULLISH" };
        if (lastTenkan < lastKijun && lastPrice < lastKijun) return { status: "BEARISH" };
        return { status: 'Netral' };
    }

    function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
        if (klines.length < 2) return { status: 'N/A' };
        let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
            if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
            } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
        }
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        return { status: lastClose > sar ? 'Bullish' : 'Bearish' };
    }

    function calculateROC(closes, period = 12) {
        if (closes.length < period + 1) return { status: 'N/A' };
        const currentClose = closes[closes.length - 1];
        const pastClose = closes[closes.length - 1 - period];
        if (pastClose === 0) return { status: 'N/A' };
        const roc = ((currentClose - pastClose) / pastClose) * 100;
        return { status: roc > 0 ? 'Positif' : 'Negatif' };
    }

    function calculateLinearRegressionChannel(closes, period = 14) {
        if (closes.length < period) return { status: 'N/A' };
        const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        return { status: slope > 0 ? 'BULLISH' : 'BEARISH' };
    }

    function calculateATR(klines, period = 14) {
        if (!klines || klines.length < period + 1) {
            return { value: 0, status: 'N/A', atrPercent: 0 };
        }
        let trs = [];
        for (let i = 1; i < klines.length; i++) {
            const high = parseFloat(klines[i][2]);
            const low = parseFloat(klines[i][3]);
            const prevClose = parseFloat(klines[i - 1][4]);
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        const rma = (data, p) => {
            let smoothed = [];
            let sum = 0;
            for(let i=0; i<data.length; i++) {
                if (i < p) {
                    sum += data[i];
                    if (i === p - 1) smoothed.push(sum/p);
                    else smoothed.push(undefined);
                } else if (smoothed[i-1] !== undefined) {
                    smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                }
            }
            return smoothed;
        };
        const atrValues = rma(trs, period);
        const atr = atrValues.pop() || 0;
        const lastClose = parseFloat(klines[klines.length - 1][4]);
        const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
        let status;
        if (atrPercent > 5) status = 'Very High';
        else if (atrPercent > 2.5) status = 'High';
        else if (atrPercent < 1) status = 'Low';
        else status = 'Normal';
        return { value: atr, status: status, atrPercent: atrPercent }; 
    }

    function getConfluenceAnalysis(klines) {
        if (!klines || klines.length < 50) {
            return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
        }

        let skorBullish = 0;
        let skorBearish = 0;
        const closes = klines.map(k => parseFloat(k[4]));

        const rsiValues = calculateRSI(closes);
        const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
        const macd = calculateMACD(closes);
        const candlePattern = findCandlestickPatterns(klines);
        const rsiDivergence = detectRSIDivergence(closes, rsiValues);

        if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
        if (macd.status === 'Bearish Cross') skorBearish += 2.0;
        if (lastRsi > 70) skorBearish += 1.5;
        if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;

        if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
        if (macd.status === 'Bullish Cross') skorBullish += 2.0;
        if (lastRsi < 30) skorBullish += 1.5;
        if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
        
        const totalPossibleScore = 8.0;

        return { 
            skorBullish: (skorBullish / totalPossibleScore) * 10,
            skorBearish: (skorBearish / totalPossibleScore) * 10,
            detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
        };
    }

    function detectMarketRegime(klinesSnapshot) {
        const adxData = calculateADX(klinesSnapshot, 14);
        const bbData = calculateBollingerBands(klinesSnapshot.map(k => parseFloat(k[4])));

        if (bbData.squeezeStatus === 'Squeeze!') {
            return 'lowVolatility';
        }
        if (adxData.value > 25) {
            return 'trending';
        }
        return 'ranging';
    }

    function getUltimateSignalScore(indicator, signalData) {
        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        const mapRange = (x, inMin, inMax, outMin, outMax) => {
            const t = (x - inMin) / (inMax - inMin);
            return outMin + clamp(t, 0, 1) * (outMax - outMin);
        };       
        const confidence = (typeof signalData?.confidence === 'number')
            ? clamp(signalData.confidence, 0, 1)
            : 1;
        const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
        const biasSigned = (typeof signalData?.biasSigned === 'number')
            ? Math.sign(signalData.biasSigned)
            : null;
        if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
            if (text.includes('BULL')) return +1 * confidence;
            if (text.includes('BEAR')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'openInterest') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('UP')) return +1 * confidence;
            if (text.includes('DOWN')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'funding' || indicator === 'fundingRate') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 0;
            const s = Math.max(-1, Math.min(1, v / 0.0025));
            return s * confidence;
            }
        if (indicator === 'lsr' || indicator === 'lsRatio') {
            const v = typeof signalData?.value === 'number' ? signalData.value : 1;
            const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
            return s * confidence;
            }
        if (indicator === 'orderBookBias') {
            if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
            if (text.includes('BID')) return +1 * confidence;
            if (text.includes('ASK')) return -1 * confidence;
            return 0;
        }
        if (indicator === 'bbSqueeze') {
            const st = (signalData?.status || '').toString().toUpperCase();
            if (st.includes('RELEASE')) return +1 * confidence;
            if (st.includes('ON')) return 0;
            if (st.includes('OFF')) return 0.3 * confidence;
            return 0;
        }
        return 0;
    }

    function createTFAlignmentSummary(klines, timeframes, marketType) {
        const summary = {};
        const getConfluenceAnalysis = (klines) => {
            if (!klines || klines.length < 50) return { skorBullish: 0, skorBearish: 0, detail: 'Not Enough Data' };
            let skorBullish = 0;
            let skorBearish = 0;
            const closes = klines.map(k => parseFloat(k[4]));
            const rsiValues = calculateRSI(closes);
            const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
            const macd = calculateMACD(closes);
            const candlePattern = findCandlestickPatterns(klines);
            const rsiDivergence = detectRSIDivergence(closes, rsiValues);
            if (candlePattern.bias === 'BEARISH') skorBearish += 2.0;
            if (macd.status === 'Bearish Cross') skorBearish += 2.0;
            if (lastRsi > 70) skorBearish += 1.5;
            if (rsiDivergence.status === 'BEARISH') skorBearish += 2.5;
            if (candlePattern.bias === 'BULLISH') skorBullish += 2.0;
            if (macd.status === 'Bullish Cross') skorBullish += 2.0;
            if (lastRsi < 30) skorBullish += 1.5;
            if (rsiDivergence.status === 'BULLISH') skorBullish += 2.5;
            const totalPossibleScore = 8.0;
            return {
                skorBullish: (skorBullish / totalPossibleScore) * 10,
                skorBearish: (skorBearish / totalPossibleScore) * 10,
                detail: `Bull (${skorBullish.toFixed(1)}) vs Bear (${skorBearish.toFixed(1)})`
            };
        };
        let score = 0;
        timeframes.forEach(tf => {
            if (klines[tf] && klines[tf].length >= 50) {
                const closes = klines[tf].map(k => parseFloat(k[4]));
                const ema21 = calculateEMA(closes, 21);
                const ema50 = calculateEMA(closes, 50);
                const lastEma21 = ema21[ema21.length - 1];
                const lastEma50 = ema50[ema50.length - 1];
                summary[tf] = lastEma21 > lastEma50 ? 'UPTREND' : 'DOWNTREND';
            } else {
                summary[tf] = 'N/A';
            }
            if (summary[tf] === 'UPTREND') score++;
            else if (summary[tf] === 'DOWNTREND') score--;
        });
        return { summary, score };
    }

    function calculateConfluenceScoreForCandle(klinesSnapshot, tunedWeights) {
        if (klinesSnapshot.length < 200) return { bull: 0, bear: 0 };

        const closes = klinesSnapshot.map(k => parseFloat(k[4]));
        const lastPrice = closes[closes.length - 1];
        
        const rsiValues = calculateRSI(closes);
        const indicators = {
            ma: { status: (calculateEMA(closes, 21).pop() > calculateEMA(closes, 50).pop()) ? 'BULLISH' : 'BEARISH' },
            rsi: { last: rsiValues[rsiValues.length-1], status: rsiValues[rsiValues.length-1] > 70 ? 'Overbought' : (rsiValues[rsiValues.length-1] < 30 ? 'Oversold' : 'Netral') },
            stoch: calculateStochasticRSI(closes),
            rsiDivergence: detectRSIDivergence(closes, rsiValues),
            obvDivergence: detectOBVDivergence(closes, klinesSnapshot),
            macd: calculateMACD(closes),
            pivot: { status: (lastPrice > (calculatePivotPoints(klinesSnapshot[klinesSnapshot.length - 2])?.P || lastPrice)) ? 'BULLISH' : 'BEARISH' },
            vwap: { status: (lastPrice > calculateVWAP(klinesSnapshot)) ? 'BULLISH' : 'BEARISH' },
            ichimoku: calculateIchimokuCloud(klinesSnapshot) || { status: 'Netral' },
            candlePattern: findCandlestickPatterns(klinesSnapshot) || { bias: 'NETRAL' },
            bollingerBands: calculateBollingerBands(closes),
            psar: calculateParabolicSAR(klinesSnapshot),
            roc: calculateROC(closes),
            linreg: calculateLinearRegressionChannel(closes),
            bbSqueeze: { status: calculateBollingerBands(closes).squeezeStatus }
        };

        const activeWeights = tunedWeights;
        let totalBullScore = 0, totalBearScore = 0, maxPossibleScore = 0;

        for (const indicator in activeWeights) {
            if (indicators[indicator]) {
                const weight = activeWeights[indicator];
                const rawScore = getUltimateSignalScore(indicator, indicators[indicator]);
                const weightedScore = rawScore * weight;

                if (weightedScore > 0) totalBullScore += weightedScore;
                if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                maxPossibleScore += Math.abs(weight);
            }
        }

        const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
        const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;

        return { bull: bullPercentage, bear: bearPercentage };
    }


    
    // ===================================================================
    // BAGIAN 3: FUNGSI-FUNGSI PEMBANTU (HELPERS)
    // ===================================================================
        async function fetchBinanceKlines(symbol, interval, limit, endTime) {
            const baseUrl = 'https://fapi.binance.com/fapi/v1';
            const params = new URLSearchParams({ symbol, interval, limit, endTime });
            const url = `${baseUrl}/klines?${params.toString()}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Binance API returned status ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error(`Gagal mengambil klines dari ${url}:`, error);
                throw error;
            }
        }

        function getCurrentMarketSessions() {
            const now = new Date();
            const utcHours = now.getUTCHours();
            const utcMinutes = now.getUTCMinutes();
            const utcTime = utcHours + utcMinutes / 60;
            
            // Market session hours in UTC
            const sessions = {
                tokyo: { open: 0, close: 8 },      // 00:00 - 08:00 UTC
                london: { open: 7, close: 16 },    // 07:00 - 16:00 UTC
                newyork: { open: 13, close: 22 },  // 13:00 - 22:00 UTC
                nyse: { open: 13.5, close: 20 }    // 13:30 - 20:00 UTC
            };
            
            const status = {};
            for (const [market, hours] of Object.entries(sessions)) {
                status[market] = utcTime >= hours.open && utcTime < hours.close ? 'OPEN' : 'CLOSED';
            }
            
            return status;
        }
    
        function updateMarketSessions() {
            const sessions = getCurrentMarketSessions();
            
            for (const [market, status] of Object.entries(sessions)) {
                const element = document.getElementById(`${market}-status`);
                if (element) {
                    element.textContent = status;
                    element.className = `regime-tag ${status === 'OPEN' ? 'volatile' : 'sideways'}`;
                }
            }
        }
        
        function calculateVolatilityInfo(klines) {
            if (!klines || klines.length < 20) {
                return {
                    atr: '0.000000',
                    status: 'Data tidak cukup',
                    dailyRange: '0%',
                    atrPercent: 0
                };
            }
            
            // Use the better ATR calculation from calculateATR function
            const atrData = calculateATR(klines);

            // Calculate average "daily" range (using the same logic as before, but on recent candles)
            let dailyRange = '0%';
            const recentKlines = klines.slice(-20);
            const dailyChanges = [];
            for (let i = 1; i < recentKlines.length; i++) {
                const current = parseFloat(recentKlines[i][4]);
                const previous = parseFloat(recentKlines[i - 1][4]);
                if (previous > 0) {
                    const change = Math.abs((current - previous) / previous * 100);
                    dailyChanges.push(change);
                }
            }
            if (dailyChanges.length > 0) {
                const avgChange = dailyChanges.reduce((a, b) => a + b, 0) / dailyChanges.length;
                dailyRange = avgChange.toFixed(2) + '%';
            }
            
            return {
                atr: atrData.value.toFixed(6),
                status: atrData.status,
                dailyRange,
                atrPercent: atrData.atrPercent // Return the percentage
            };
        }
        
        function analyzeMarketConditions(historicalData) {
            if (!historicalData || historicalData.length < 100) {
                return {
                    distribution: { sideways: 100 },
                    segments: [],
                    recommendations: [
                        `⚠️ Jumlah candle (${historicalData?.length || 0}) terlalu sedikit untuk hasil yang akurat.`,
                        `📊 Minimal 1000 candle direkomendasikan untuk analisis yang lebih andal.`,
                        `💡 Gunakan timeframe yang lebih tinggi atau rentang waktu lebih panjang.`
                    ],
                    volatility: {
                        atr: '0',
                        status: 'Data tidak cukup',
                        dailyRange: '0%',
                        atrPercent: 0
                    },
                    overallVolatility: { // <-- TAMBAHKAN BAGIAN INI
                        score: 0,
                        status: 'Data Tidak Cukup'
                    }
                };
            }
            
            const regimeCounts = { trending: 0, ranging: 0, lowVolatility: 0, sideways: 0 };
            const segments = [];
            const segmentSize = Math.max(100, Math.floor(historicalData.length / 12));
            
            // Calculate volatility info
            const volatilityInfo = calculateVolatilityInfo(historicalData);
            
            for (let i = 0; i < historicalData.length; i += segmentSize) {
                const chunk = historicalData.slice(i, i + segmentSize);
                if (chunk.length < 50) continue;
                
                const regime = detectMarketRegime(chunk);
                regimeCounts[regime]++;
                segments.push({ 
                    regime: regime, 
                    date: new Date(chunk[0][0]).toLocaleDateString('id-ID') 
                });
            }
            
            let total = Object.values(regimeCounts).reduce((a, b) => a + b, 0);
            if (total === 0) {
                regimeCounts.sideways = 1;
                total = 1;
            }

            const distribution = {
                trending: (regimeCounts.trending / total) * 100,
                ranging: (regimeCounts.ranging / total) * 100,
                lowVolatility: (regimeCounts.lowVolatility / total) * 100,
                sideways: (regimeCounts.sideways / total) * 100,
            };
            
            if(distribution.trending === 0 && distribution.ranging === 0 && distribution.lowVolatility === 0) {
                distribution.sideways = 100;
            }
            // **[MODIFIKASI] - Kalkulasi Volatility Score Keseluruhan**
            // Kami menggunakan bobot: Low Volatility (0.2), Ranging (0.5), Trending (0.8)
            const totalVolatilityScore = (
                (distribution.lowVolatility * 0.2) +
                (distribution.ranging * 0.5) +
                (distribution.trending * 0.8)
            );

            let volatilityStatus = 'Normal';
            if (totalVolatilityScore < 25) {
                volatilityStatus = 'Sangat Rendah';
            } else if (totalVolatilityScore < 50) {
                volatilityStatus = 'Rendah';
            } else if (totalVolatilityScore < 75) {
                volatilityStatus = 'Tinggi';
            } else {
                volatilityStatus = 'Sangat Tinggi';
            }
            const recommendations = [];
            const dominantRegime = Object.keys(distribution).reduce((a, b) => distribution[a] > distribution[b] ? a : b);

            // Enhanced recommendations based on market regime
            if (dominantRegime === 'trending') {
                recommendations.push("✅ Pasar sedang dalam kondisi trending. Gunakan strategi trend-following.");
                recommendations.push("📈 Fokus pada breakout dan pullback trading dengan preset 'trending'.");
                recommendations.push("🎯 Gunakan trailing stop untuk maximize profit selama trend berlangsung.");
            } else if (dominantRegime === 'ranging' || dominantRegime === 'sideways') {
                recommendations.push("✅ Pasar sedang sideways/ranging. Gunakan strategi mean-reversion.");
                recommendations.push("📊 Fokus pada support/resistance dengan preset 'ranging'.");
                recommendations.push("🔄 Buy di support, sell di resistance dengan tight stop loss.");
            } else if (dominantRegime === 'lowVolatility') {
                recommendations.push("✅ Volatilitas rendah - pertimbangkan strategi breakout.");
                recommendations.push("⚡ Gunakan preset 'lowVolatility' dan siap untuk volatility expansion.");
                recommendations.push("📉 Watch for consolidation patterns (triangle, rectangle) for breakout signals.");
            }
            
            // Add volatility-based recommendations
            if (volatilityInfo.status === 'Tinggi') {
                recommendations.push("🌪️ Volatilitas TINGGI - Pertimbangkan mengurangi size position atau menggunakan wider stop.");
            } else if (volatilityInfo.status === 'Rendah') {
                recommendations.push("🍃 Volatilitas RENDAH - Pertimbangkan strategy yang cocok untuk low volatility seperti strangles atau iron condors.");
            }
            
            // Add recommendations based on market sessions
            const sessions = getCurrentMarketSessions();
            const openSessions = Object.entries(sessions)
                .filter(([_, status]) => status === 'OPEN')
                .map(([market, _]) => market);
                
            if (openSessions.length > 0) {
                recommendations.push(`🌐 Sesi pasar aktif: ${openSessions.map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(', ')}`);
                
                if (openSessions.includes('london') && openSessions.includes('newyork')) {
                    recommendations.push("🔄 Overlap sesi London-New York: Likuiditas tinggi, volatilitas mungkin meningkat.");
                }
            } else {
                recommendations.push("🌙 Semua sesi pasar tutup - pasar mungkin lebih tidak likuid dan rentan slippage.");
            }
            
            return { 
                distribution, 
                segments, 
                recommendations,
                volatility: volatilityInfo,
                overallVolatility: { // <-- TAMBAHKAN BAGIAN INI
                    score: totalVolatilityScore,
                    status: volatilityStatus
                }
            };
        }
        
        function displayMarketAnalysis(analysis) {
            const section = document.getElementById('market-analysis-section');
            if (!section || !analysis) return;

            section.classList.remove('hidden');
            
            // Display distribution chart
            const distributionChart = document.getElementById('market-condition-chart');
            const colorMap = {
                trending: 'uptrend', // Ganti 'trending' menjadi 'uptrend'
                ranging: 'ranging',
                lowVolatility: 'low-volatility', // Ganti 'lowVolatility' menjadi 'low-volatility'
                sideways: 'sideways'
            };
            distributionChart.innerHTML = Object.entries(analysis.distribution)
                .filter(([, value]) => value > 0)
                .map(([key, value]) => `
                    <div class="flex items-center justify-between text-sm">
                        <span class="capitalize">${key.replace(/([A-Z])/g, ' $1')}</span>
                        <span class="font-mono">${value.toFixed(1)}%</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-1.5 mb-2">
                        <div class="market-condition-bar ${colorMap[key] || key}" style="width: ${value}%"></div>
                    </div>
                `).join('');
            
            // Display time segmentation chart
            const segmentationChart = document.getElementById('time-segmentation-chart');
            segmentationChart.innerHTML = analysis.segments.map(segment => {
                 const colorClass = {
                    trending: 'bg-green-500',
                    ranging: 'bg-yellow-500',
                    lowVolatility: 'bg-purple-500',
                    sideways: 'bg-gray-500'
                }[segment.regime];
                return `<div class="time-segment ${colorClass}" style="width: ${100 / analysis.segments.length}%;" data-date="${segment.date}" title="${segment.regime} starting ${segment.date}"></div>`;
            }).join('');
            
            // Display volatility information
            const atrValueEl = document.getElementById('atr-value');
            if (analysis.volatility && typeof analysis.volatility.atrPercent === 'number') {
                atrValueEl.innerHTML = `${analysis.volatility.atr} <span class="text-xs text-gray-400 font-normal">(${analysis.volatility.atrPercent.toFixed(2)}%)</span>`;
            } else if (analysis.volatility) {
                atrValueEl.textContent = analysis.volatility.atr;
            }
            document.getElementById('volatility-status').textContent = analysis.volatility.status;
            document.getElementById('volatility-status').className = `font-mono ${
                analysis.volatility.status === 'Tinggi' ? 'text-red-400' : 
                analysis.volatility.status === 'Rendah' ? 'text-blue-400' : 'text-yellow-400'
            }`;
            document.getElementById('daily-range').textContent = analysis.volatility.dailyRange;
            
            // Update market sessions
            updateMarketSessions();
            
            // Display recommendations
            const overallVolatilityBar = document.getElementById('overall-volatility-bar');
            const overallVolatilityText = document.getElementById('overall-volatility-text');
            const overallVolatility = analysis.overallVolatility;

            if (overallVolatility && overallVolatilityBar && overallVolatilityText) {
                overallVolatilityBar.style.width = `${overallVolatility.score}%`;
                overallVolatilityText.textContent = `${overallVolatility.status} (${overallVolatility.score.toFixed(1)}%)`;
                
                // Atur warna bar berdasarkan status
                if (overallVolatility.status === 'Sangat Rendah' || overallVolatility.status === 'Rendah') {
                    overallVolatilityBar.style.backgroundColor = '#6B7280'; // abu-abu
                } else if (overallVolatility.status === 'Normal') {
                    overallVolatilityBar.style.backgroundColor = '#F59E0B'; // oranye
                } else {
                    overallVolatilityBar.style.backgroundColor = '#EF4444'; // merah
                }
            }
            
            const recommendationsList = document.getElementById('market-recommendations');
            recommendationsList.innerHTML = analysis.recommendations.map(rec => {
                const icon = rec.startsWith('✅') ? '✅' : 
                            rec.startsWith('⚠️') ? '⚠️' :
                            rec.startsWith('📊') ? '📊' :
                            rec.startsWith('📈') ? '📈' :
                            rec.startsWith('🎯') ? '🎯' :
                            rec.startsWith('🔄') ? '🔄' :
                            rec.startsWith('⚡') ? '⚡' :
                            rec.startsWith('📉') ? '📉' :
                            rec.startsWith('🌪️') ? '🌪️' :
                            rec.startsWith('🍃') ? '🍃' :
                            rec.startsWith('🌐') ? '🌐' :
                            rec.startsWith('🌙') ? '🌙' : '💡';
                
                return `<li class="flex items-start"><span class="mr-2">${icon}</span><span>${rec.substring(2)}</span></li>`;
            }).join('');
        }
        
        function applyRegimePreset(presetName) {
            if (presetName === 'custom') return;
            const weights = userSettings.presets[presetName].weights;
            labWeightsContainer.querySelectorAll('input').forEach(input => {
                const key = input.dataset.weightKey;
                if (weights[key] !== undefined) {
                    input.value = weights[key];
                }
            });
        }

        function populateWeightsTuningPanel() {
            const allPossibleWeights = userSettings.presets.default.weights;
            if (!labWeightsContainer) return;
            labWeightsContainer.innerHTML = '';
            for (const key in allPossibleWeights) {
                const defaultValue = allPossibleWeights[key];
                const div = document.createElement('div');
                div.innerHTML = `
                    <label class="block text-xs text-gray-400 capitalize">
                        ${key.replace(/([A-Z])/g, ' $1')}
                    </label>
                    <input type="number" step="0.1" data-weight-key="${key}" value="${defaultValue}" class="input-primary small-input mt-1">
                `;
                labWeightsContainer.appendChild(div);
            }
            labWeightsContainer.addEventListener('input', () => {
                labRegimePreset.value = 'custom';
            });
        }

        function attachLogbookRowListeners() {
            document.querySelectorAll('.logbook-entry-row').forEach(row => {
                row.addEventListener('click', () => {
                    const entryId = row.dataset.entryId;
                    toggleLogbookDetails(entryId);
                });
            });
        }

        function setButtonState(button, isLoading, text = null) {
            const btnText = button.querySelector('span');
            const btnLoader = button.querySelector('.loader');
            button.disabled = isLoading;
            if (btnText) btnText.classList.toggle('hidden', isLoading);
            if (btnLoader) btnLoader.classList.toggle('hidden', !isLoading);
            if (text && btnText && !isLoading) btnText.textContent = text;
        }

        function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
            const button = document.getElementById(buttonId);
            const contentWrapper = document.getElementById(contentWrapperId);
            const icon = document.getElementById(iconId);
            if (!button || !contentWrapper || !icon) return;
            contentWrapper.classList.add('collapsible-content');
            const applyState = (isVisible) => {
                if (isVisible) {
                    contentWrapper.classList.add('expanded');
                    icon.style.transform = 'rotate(0deg)';
                } else {
                    contentWrapper.classList.remove('expanded');
                    icon.style.transform = 'rotate(-90deg)';
                }
            };
            let isVisible = startVisible;
            applyState(isVisible);
            button.addEventListener('click', () => {
                isVisible = !isVisible;
                applyState(isVisible);
            });
        }

        function calculateShortConfluenceScore(klinesSnapshot) {
            if (!klinesSnapshot || klinesSnapshot.length < 50) return { score: 0, breakdown: {} };

            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            let score = 0;
            let triggers = [];
            const rsiValues = calculateRSI(closes, 14);
            const lastRsi = rsiValues[rsiValues.length - 1];
            if (lastRsi > 72) {
                score += 3.5;
                triggers.push('RSI Overbought');
            }
            const macd = calculateMACD(closes);
            if (macd.status === 'Bearish Cross') {
                score += 2.5;
                triggers.push('MACD Cross');
            }
            const candlePattern = findCandlestickPatterns(klinesSnapshot);
            if (candlePattern.bias === 'BEARISH') {
                score += 2.0;
                triggers.push('Candle Pattern');
            }
            const lookbackPeriod = 15;
            const recentKlines = klinesSnapshot.slice(-lookbackPeriod);
            if (recentKlines.length >= 3) {
                let peakIndex = 0;
                for (let i = 1; i < recentKlines.length; i++) {
                    if (parseFloat(recentKlines[i][2]) > parseFloat(recentKlines[peakIndex][2])) peakIndex = i;
                }
                if (peakIndex > 0 && peakIndex < lookbackPeriod - 2) {
                    const triggerCandleArr = recentKlines[peakIndex + 1];
                    if (triggerCandleArr) {
                        const triggerCandle = { Open: parseFloat(triggerCandleArr[1]), Close: parseFloat(triggerCandleArr[4]) };
                        if (triggerCandle.Close < triggerCandle.Open) {
                            score += 3.5;
                            triggers.push('Red Candle After High');
                        }
                    }
                }
            }
            const rsiDivergence = detectRSIDivergence(closes, rsiValues);
            if (rsiDivergence.status === 'BEARISH') {
                score += 4.0;
                triggers.push('RSI Divergence');
            }
            return { score: Math.min(score, 10), triggers: triggers };
        }

        function formatDateTimeLocal(date) {
            const pad = (num) => num.toString().padStart(2, '0');
            const yyyy = date.getFullYear();
            const mm = pad(date.getMonth() + 1);
            const dd = pad(date.getDate());
            const hh = pad(date.getHours());
            const min = pad(date.getMinutes());
            return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
        }

        function calculateAndDisplayCandleCount() {
    try {
        const displayEl = document.getElementById('candle-estimation-display');
        if (!backtestStartDate.value || !backtestEndDate.value) {
            displayEl.textContent = 'Pilih rentang waktu...';
            return;
        }
        const startDate = new Date(backtestStartDate.value);
        const endDate = new Date(backtestEndDate.value);
        const timeframe = backtestTimeframeSelect.value;
        
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime()) || endDate < startDate) {
            displayEl.textContent = 'Rentang waktu tidak valid';
            return;
        }

        const timeframeMapMs = {
            '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
            '1h': 3600000, '4h': 14400000, '1d': 86400000
        };
        const timeframeMs = timeframeMapMs[timeframe];
        const durationMs = endDate.getTime() - startDate.getTime();
        const totalCandles = Math.floor(durationMs / timeframeMs);

        const activeFilters = Array.from(document.querySelectorAll('.session-filter-checkbox:checked')).map(cb => cb.value);

        if (activeFilters.length === 0) {
            displayEl.textContent = `Estimasi: ${totalCandles.toLocaleString('id-ID')} candle`;
            return;
        }

        // Estimasi kasar berdasarkan jam aktif
        const sessionHours = {
            tokyo: { start: 0, end: 8 },   // 00:00 - 08:00 UTC
            london: { start: 7, end: 16 },  // 07:00 - 16:00 UTC
            newyork: { start: 13, end: 22 } // 13:00 - 22:00 UTC
        };
        
        let activeHours = new Set();
        activeFilters.forEach(filter => {
            for (let h = sessionHours[filter].start; h < sessionHours[filter].end; h++) {
                activeHours.add(h);
            }
        });

        const activeHourCount = activeHours.size;
        const estimatedFilteredCandles = Math.round(totalCandles * (activeHourCount / 24));
        
        displayEl.innerHTML = `Estimasi: <span class="text-white">~${estimatedFilteredCandles.toLocaleString('id-ID')}</span> dari ${totalCandles.toLocaleString('id-ID')} candle akan diuji`;

    } catch (e) {
        document.getElementById('candle-estimation-display').textContent = 'Error menghitung candle';
    }
}

    function updateDateRangeFromCandleCount() {
        const candleCount = parseInt(candleCountInput.value);
        let endDate = backtestEndDate.value ? new Date(backtestEndDate.value) : new Date();
        
        if (isNaN(endDate.getTime())) {
            endDate = new Date();
        }
        backtestEndDate.value = formatDateTimeLocal(endDate);
        
        const timeframe = backtestTimeframeSelect.value;
        if (isNaN(candleCount) || candleCount <= 0) return;
        const timeframeMapMs = {
            '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
            '1h': 3600000, '4h': 14400000, '1d': 86400000
        };
        const timeframeMs = timeframeMapMs[timeframe];
        if (!timeframeMs) return;
        const durationMs = candleCount * timeframeMs;
        const newStartDate = new Date(endDate.getTime() - durationMs);
        backtestStartDate.value = formatDateTimeLocal(newStartDate);
        calculateAndDisplayCandleCount();
    }
        
    function saveResultToLogbook(settings, metrics, marketAnalysis, historicalData, trades) {
    let logbookData = JSON.parse(localStorage.getItem('backtestLogbook')) || [];
    const sessionDistribution = analyzeSessionDistribution(historicalData); // ANALISIS SESI
    const newEntry = {
        id: Date.now(),
        symbol: settings.symbol,
        timeframe: settings.timeframe,
        leverage: settings.leverage,
        pnlPercent: (metrics.totalPnl / settings.initialBalance) * 100,
        winRate: metrics.winRate,
        profitFactor: metrics.profitFactor,
        totalTrades: metrics.totalTrades,
        // SIMPAN TIMESTAMP LENGKAP
        startTimestamp: settings.startDate,
        endTimestamp: settings.endDate,
        params: {
            strategy: settings.strategyMode,
            rrRatio: settings.riskRewardRatio,
            emaPeriod: settings.pullbackEmaPeriod,
            swingLookback: settings.swingLookback,
            biasThreshold: settings.biasThreshold,
            riskPerTrade: (settings.riskPerTrade * 100),
            marginMode: settings.marginMode,
            atrFilterThreshold: settings.atrFilterThreshold,
            marketAnalysis: {
                distribution: marketAnalysis.distribution,
                overallVolatility: marketAnalysis.overallVolatility,
                sessionDistribution: sessionDistribution // SIMPAN DATA SESI
            }
        },
        historicalData: historicalData,
        trades: trades
    };
    logbookData.unshift(newEntry);
    if (logbookData.length > 100) logbookData.pop();
    localStorage.setItem('backtestLogbook', JSON.stringify(logbookData));
}

    function loadAndRenderLogbook(dataToRender) {
    const logbookBody = document.getElementById('logbook-body');
    const logbookSection = document.getElementById('logbook-section');
    const logbookData = dataToRender || JSON.parse(localStorage.getItem('backtestLogbook')) || [];

    // Helper untuk format periode
    const formatPeriod = (start, end) => {
        if (!start || !end) return 'N/A';
        const startDate = new Date(start);
        const endDate = new Date(end);
        const options = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
        
        const diffMs = endDate - startDate;
        const diffDays = Math.floor(diffMs / 86400000);
        const diffHrs = Math.floor((diffMs % 86400000) / 3600000);
        const diffMins = Math.round(((diffMs % 86400000) % 3600000) / 60000);

        let duration = '';
        if (diffDays > 0) duration += `${diffDays}h `;
        if (diffHrs > 0) duration += `${diffHrs}j `;
        if (diffMins > 0) duration += `${diffMins}m`;
        
        return `${startDate.toLocaleDateString('id-ID', options)} - ${endDate.toLocaleDateString('id-ID', options)} <br> <span class="text-xs text-gray-500 font-normal">(Durasi: ${duration.trim()})</span>`;
    };

    if (logbookData.length > 0) {
        logbookBody.innerHTML = logbookData.map(entry => {
            const params = entry.params || {};
            const marketAnalysis = params.marketAnalysis || {};
            const sessionDist = marketAnalysis.sessionDistribution || { Tokyo: 'N/A', London: 'N/A', NewYork: 'N/A' };
            
            const pnlText = (typeof entry.pnlPercent === 'number') ? entry.pnlPercent.toFixed(2) : '0.00';
            const winRateText = (typeof entry.winRate === 'number') ? entry.winRate.toFixed(2) : '0.00';
            const profitFactorText = (entry.profitFactor === Infinity) ? '∞' : (typeof entry.profitFactor === 'number' ? entry.profitFactor.toFixed(2) : '0.00');
            
            // Format periode baru
            const periodText = formatPeriod(entry.startTimestamp, entry.endTimestamp);

            return `
            <tr class="logbook-entry-row cursor-pointer hover:bg-gray-800" data-entry-id="${entry.id}">
                <td class="px-4 py-2">${entry.symbol}</td>
                <td class="px-4 py-2">${entry.timeframe}</td>
                <td class="px-4 py-2 ${entry.pnlPercent >= 0 ? 'positive' : 'negative'}">${pnlText}%</td>
                <td class="px-4 py-2">${winRateText}%</td>
                <td class="px-4 py-2">${profitFactorText}</td>
                <td class="px-4 py-2">${entry.totalTrades}</td>
                <td class="px-4 py-2 leading-tight">${periodText}</td>
            </tr>
            <tr id="details-${entry.id}" class="hidden">
                <td colspan="7" class="p-4 bg-gray-900/50 text-xs">
                    <div class="font-mono text-yellow-400 grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4">
                        <span>R:R Ratio: <strong>${params.rrRatio || 'N/A'}</strong></span>
                        <span>EMA Entry: <strong>${params.emaPeriod || 'N/A'}</strong></span>
                        <span>Swing Lookback: <strong>${params.swingLookback || 'N/A'}</strong></span>
                        <span>Bias Threshold: <strong>${params.biasThreshold || 'N/A'}</strong></span>
                        <span>Risk/Trade: <strong>${params.riskPerTrade || 'N/A'}%</strong></span>
                        <span>ATR Filter: <strong>${(params.atrFilterThreshold || 0).toFixed(4)}</strong></span>
                    </div>
                    
                    ${marketAnalysis.distribution ? `
                    <div class="mt-4 pt-4 border-t border-gray-700">
                        <h4 class="font-bold text-lg mb-2 text-white">Analisis Pasar</h4>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div>
                                <h5 class="font-semibold mb-1">Distribusi Kondisi Pasar</h5>
                                ${Object.entries(marketAnalysis.distribution).filter(([, value]) => value > 0).map(([key, value]) => `
                                    <div class="flex items-center justify-between text-sm mt-1">
                                        <span class="capitalize">${key.replace(/([A-Z])/g, ' $1')}</span>
                                        <span class="font-mono">${value.toFixed(1)}%</span>
                                    </div>
                                `).join('')}
                            </div>
                            <div>
                                <h5 class="font-semibold mb-1">Ringkasan Volatilitas</h5>
                                <div class="flex items-center justify-between text-sm">
                                    <span>Kondisi Pasar</span>
                                    <span class="font-mono">${marketAnalysis.overallVolatility?.status || 'N/A'} (${(marketAnalysis.overallVolatility?.score || 0).toFixed(1)}%)</span>
                                </div>
                            </div>
                            <div>
                                <h5 class="font-semibold mb-1">Distribusi Sesi Pasar</h5>
                                <div class="text-sm mt-1 space-y-1">
                                    <div class="flex justify-between"><span>Tokyo (Asia)</span><span class="font-mono">${sessionDist.Tokyo}%</span></div>
                                    <div class="flex justify-between"><span>London (Eropa)</span><span class="font-mono">${sessionDist.London}%</span></div>
                                    <div class="flex justify-between"><span>New York (AS)</span><span class="font-mono">${sessionDist.NewYork}%</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </td>
            </tr>
        `;
        }).join('');
        logbookSection.classList.remove('hidden');
        attachLogbookRowListeners();
    } else { 
        logbookSection.classList.add('hidden'); 
    }
}

// FUNGSI BARU UNTUK ASISTEN DURASI
function applyDuration(type, value) {
    let endDate = backtestEndDate.value ? new Date(backtestEndDate.value) : new Date();
    if (isNaN(endDate.getTime())) {
        endDate = new Date();
        backtestEndDate.value = formatDateTimeLocal(endDate);
    }

    let durationMs = 0;
    const timeframe = backtestTimeframeSelect.value;
    
    if (type === 'days') {
        durationMs = value * 24 * 60 * 60 * 1000;
    } else if (type === 'weeks') {
        durationMs = value * 7 * 24 * 60 * 60 * 1000;
    } else if (type === 'months') {
        durationMs = value * 30 * 24 * 60 * 60 * 1000; // Aproksimasi
    } else if (type === 'candles') {
        const timeframeMapMs = {
            '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
            '1h': 3600000, '4h': 14400000, '1d': 86400000
        };
        const timeframeMs = timeframeMapMs[timeframe];
        durationMs = value * timeframeMs;
    }

    if (durationMs > 0) {
        const newStartDate = new Date(endDate.getTime() - durationMs);
        backtestStartDate.value = formatDateTimeLocal(newStartDate);
    }
    
    // Perbarui estimasi setelah tanggal diatur
    calculateAndDisplayCandleCount();
}

function analyzeSessionDistribution(historicalData) {
    if (!historicalData || historicalData.length === 0) {
        return { Tokyo: 0, London: 0, NewYork: 0 };
    }
    const sessionCounts = { Tokyo: 0, London: 0, NewYork: 0 };
    let totalCandles = 0;

    historicalData.forEach(candle => {
        const timestamp = candle[0];
        const date = new Date(timestamp);
        const utcHour = date.getUTCHours();
        totalCandles++;

        // Sesi Tokyo: 00:00 - 08:00 UTC
        if (utcHour >= 0 && utcHour < 8) {
            sessionCounts.Tokyo++;
        }
        // Sesi London: 07:00 - 16:00 UTC (Overlap dengan Tokyo & NY)
        if (utcHour >= 7 && utcHour < 16) {
            sessionCounts.London++;
        }
        // Sesi New York: 13:00 - 22:00 UTC (Overlap dengan London)
        if (utcHour >= 13 && utcHour < 22) {
            sessionCounts.NewYork++;
        }
    });

    if (totalCandles === 0) return { Tokyo: 0, London: 0, NewYork: 0 };

    return {
        Tokyo: ((sessionCounts.Tokyo / totalCandles) * 100).toFixed(1),
        London: ((sessionCounts.London / totalCandles) * 100).toFixed(1),
        NewYork: ((sessionCounts.NewYork / totalCandles) * 100).toFixed(1)
    };
}

    function sortAndRenderLogbook() {
        const logbookData = JSON.parse(localStorage.getItem('backtestLogbook')) || [];
        const { key, direction } = logbookSortState;
        const sortedData = [...logbookData].sort((a, b) => {
            const valA = a[key]; const valB = b[key];
            let comparison = (typeof valA === 'string') ? valA.localeCompare(valB) : valA - valB;
            return direction === 'asc' ? comparison : -comparison;
        });
        loadAndRenderLogbook(sortedData);
    }

    function toggleLogbookDetails(id) {
        const detailRow = document.getElementById(`details-${id}`);
        if (detailRow) detailRow.classList.toggle('hidden');
    }

    function clearLogbook() {
        if (confirm("Hapus seluruh riwayat pengujian?")) {
            localStorage.removeItem('backtestLogbook');
            loadAndRenderLogbook([]);
        }
    }

    function runWhatIfSimulation(trades, historicalData, baseSettings, analysisCache) {
        if (trades.length === 0 || !analysisCache || analysisCache.length === 0) return {};

        const optimalParams = {};
        const calculateProfitFactor = (hypotheticalTrades) => {
            if (hypotheticalTrades.length === 0) return 0;
            const grossProfit = hypotheticalTrades.filter(t => t.pnl > 0).reduce((sum, t) => sum + t.pnl, 0);
            const grossLoss = Math.abs(hypotheticalTrades.filter(t => t.pnl <= 0).reduce((sum, t) => sum + t.pnl, 0));
            return grossLoss > 0 ? grossProfit / grossLoss : Infinity;
        };
        const basePf = calculateProfitFactor(trades);

        // --- 1. Uji Optimasi R:R Ratio (LENGKAP) ---
        let bestRr = { value: baseSettings.riskRewardRatio, pf: basePf };
        for (let rr = 1.2; rr <= 3.0; rr += 0.3) {
            if (Math.abs(rr - baseSettings.riskRewardRatio) < 0.01) continue;
            const hypotheticalTrades = trades.map(trade => {
                const risk = Math.abs(trade.entryPrice - trade.sl);
                const newTp = trade.type === 'LONG' ? trade.entryPrice + (risk * rr) : trade.entryPrice - (risk * rr);
                const entryIndex = historicalData.findIndex(k => new Date(k[0]).getTime() === new Date(trade.entryDate).getTime());
                if (entryIndex === -1) return { ...trade, pnl: -risk };
                let exitPrice = trade.sl;
                for (let i = entryIndex + 1; i < historicalData.length; i++) {
                    const high = parseFloat(historicalData[i][2]);
                    const low = parseFloat(historicalData[i][3]);
                    if ((trade.type === 'LONG' && low <= trade.sl) || (trade.type === 'SHORT' && high >= trade.sl)) { break; }
                    if ((trade.type === 'LONG' && high >= newTp) || (trade.type === 'SHORT' && low <= newTp)) { exitPrice = newTp; break; }
                }
                const rawPnl = trade.type === 'LONG' ? (exitPrice - trade.entryPrice) * trade.size : (trade.entryPrice - exitPrice) * trade.size;
                const exitValue = exitPrice * trade.size;
                const newTotalFee = (trade.entryPrice * trade.size * baseSettings.takerFee) + (exitValue * baseSettings.makerFee);
                return { ...trade, pnl: rawPnl - newTotalFee };
            });
            const newPf = calculateProfitFactor(hypotheticalTrades);
            if (newPf > bestRr.pf) bestRr = { value: rr, pf: newPf };
        }
        optimalParams.riskRewardRatio = bestRr;

        // --- 2. Uji Optimasi Bias Threshold (LENGKAP) ---
        let bestThreshold = { value: baseSettings.biasThreshold, pf: basePf };
        for (let th = 5; th <= 25; th += 3) {
            if (th === baseSettings.biasThreshold) continue;
            const hypotheticalTrades = trades.filter(trade => {
                const entryIndex = analysisCache.findIndex(c => new Date(c.time).getTime() === new Date(trade.entryDate).getTime());
                if (entryIndex === -1) return false;
                const cache = analysisCache[entryIndex];
                if (!cache) return false;
                if (trade.type === 'LONG') return cache.bullScore > cache.bearScore + th;
                if (trade.type === 'SHORT') return cache.bearScore > cache.bullScore + th;
                return false;
            });
            const newPf = calculateProfitFactor(hypotheticalTrades);
            if (newPf > bestThreshold.pf) bestThreshold = { value: th, pf: newPf };
        }
        optimalParams.biasThreshold = bestThreshold;
        
        // --- 3. Uji Optimasi Swing Lookback (LENGKAP) ---
        let bestLookback = { value: baseSettings.swingLookback, pf: basePf };
        for (let lookback = 10; lookback <= 30; lookback += 5) {
            if (lookback === baseSettings.swingLookback) continue;
            const hypotheticalTrades = trades.map(trade => {
                const entryIndex = historicalData.findIndex(k => new Date(k[0]).getTime() === new Date(trade.entryDate).getTime());
                if (entryIndex === -1) return trade;
                const recentKlines = historicalData.slice(Math.max(0, entryIndex - lookback), entryIndex);
                if(recentKlines.length === 0) return trade;
                const newSl = trade.type === 'LONG' 
                    ? Math.min(...recentKlines.map(k => parseFloat(k[3]))) * 0.999 
                    : Math.max(...recentKlines.map(k => parseFloat(k[2]))) * 1.001;
                
                let exitPrice = newSl;
                for (let i = entryIndex + 1; i < historicalData.length; i++) {
                    const high = parseFloat(historicalData[i][2]);
                    const low = parseFloat(historicalData[i][3]);
                    if ((trade.type === 'LONG' && high >= trade.tp) || (trade.type === 'SHORT' && low <= trade.tp)) {
                        exitPrice = trade.tp; break;
                    }
                    if ((trade.type === 'LONG' && low <= newSl) || (trade.type === 'SHORT' && high >= newSl)) {
                        exitPrice = newSl; break;
                    }
                }
                const rawPnl = trade.type === 'LONG' ? (exitPrice - trade.entryPrice) * trade.size : (trade.entryPrice - exitPrice) * trade.size;
                const exitValue = exitPrice * trade.size;
                const newTotalFee = (trade.entryPrice * trade.size * baseSettings.takerFee) + (exitValue * baseSettings.makerFee);
                return { ...trade, pnl: rawPnl - newTotalFee };
            });
            const newPf = calculateProfitFactor(hypotheticalTrades);
            if (newPf > bestLookback.pf) bestLookback = { value: lookback, pf: newPf };
        }
        optimalParams.swingLookback = bestLookback;

        // --- 4. Uji Optimasi ATR Filter (LENGKAP) ---
        let bestAtrFilter = { value: baseSettings.atrFilterThreshold, pf: basePf };
        if (analysisCache.length > 0) {
            const avgAtr = analysisCache.reduce((sum, c) => sum + c.atrValue, 0) / analysisCache.length;
            if (avgAtr > 0) {
                for (let filter = 0; filter < avgAtr * 1.5; filter += avgAtr * 0.25) {
                    if (Math.abs(filter - baseSettings.atrFilterThreshold) < 0.00001) continue;
                    const hypotheticalTrades = trades.filter(trade => {
                        const entryIndex = analysisCache.findIndex(c => new Date(c.time).getTime() === new Date(trade.entryDate).getTime());
                        if (entryIndex === -1) return false;
                        return analysisCache[entryIndex].atrValue > filter;
                    });
                    const newPf = calculateProfitFactor(hypotheticalTrades);
                    if (newPf > bestAtrFilter.pf) bestAtrFilter = { value: filter, pf: newPf };
                }
            }
        }
        optimalParams.atrFilterThreshold = bestAtrFilter;

        return optimalParams;
    }

    function generateAdvancedTuningRecommendations(metrics, trades, settings, optimalParams, marketAnalysis) {
        const rec = {
            stats: {},
            confluenceToImprove: [],
            optimalParams: optimalParams,
            regimeSuggestion: null,
            generalSuggestions: [],
            actionPlan: [],
            microInsights: [],
            basePf: metrics.profitFactor
        };

        // --- Lapis 1 & 2: Kalkulasi Statistik & Mikro ---
        let equityCurve = [settings.initialBalance];
        let peakEquity = settings.initialBalance;
        let maxDrawdown = 0;
        trades.forEach(trade => {
            const newBalance = equityCurve[equityCurve.length - 1] + trade.pnl;
            equityCurve.push(newBalance);
            if (newBalance > peakEquity) peakEquity = newBalance;
            const drawdown = ((peakEquity - newBalance) / peakEquity) * 100;
            if (drawdown > maxDrawdown) maxDrawdown = drawdown;
        });
        rec.stats.maxDrawdown = maxDrawdown;
        const winRate = metrics.winRate / 100;
        const lossRate = 1 - winRate;
        const winningTrades = trades.filter(t => t.pnl > 0);
        const losingTrades = trades.filter(t => t.pnl <= 0);
        const avgWin = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnl, 0) / winningTrades.length : 0;
        const avgLoss = losingTrades.length > 0 ? Math.abs(losingTrades.reduce((sum, t) => sum + t.pnl, 0) / losingTrades.length) : 0;
        rec.stats.expectancy = (winRate * avgWin) - (lossRate * avgLoss);
        let maxLosingStreak = 0;
        let currentLosingStreak = 0;
        trades.forEach(trade => {
            if (trade.pnl <= 0) currentLosingStreak++;
            else {
                if (currentLosingStreak > maxLosingStreak) maxLosingStreak = currentLosingStreak;
                currentLosingStreak = 0;
            }
        });
        if (currentLosingStreak > maxLosingStreak) maxLosingStreak = currentLosingStreak;
        rec.stats.maxLosingStreak = maxLosingStreak;

        // --- Logika Heuristik untuk Rekomendasi Presisi (Struktur Lama) ---
        if (metrics.winRate < 45) rec.confluenceToImprove.push("⚠️ Win rate rendah (<45%) - pertimbangkan meningkatkan `Bias Threshold` atau menambah filter.");
        if (metrics.profitFactor < 1.2) rec.confluenceToImprove.push("⚠️ Profit factor rendah - pertimbangkan mengatur ulang `Risk/Reward Ratio`.");
        if (rec.confluenceToImprove.length === 0) rec.confluenceToImprove.push("✅ Tidak ada masalah konfluensi kritis.");
        
        // --- Saran Regime Pasar (BARU & AKTIF) ---
        const dominantRegime = marketAnalysis ? Object.keys(marketAnalysis.distribution).reduce((a, b) => marketAnalysis.distribution[a] > marketAnalysis.distribution[b] ? a : b) : null;
        if (dominantRegime && metrics.profitFactor < 1.0) {
            rec.regimeSuggestion = `🔄 Strategi tidak performa baik di regime dominan '${dominantRegime}'. Pertimbangkan preset '${dominantRegime}' atau ubah timeframe.`;
        } else {
            rec.regimeSuggestion = `✅ Strategi cukup robust di kondisi pasar saat ini.`;
        }

        // --- Saran Umum & Action Plan (LENGKAP) ---
        rec.generalSuggestions.push("💡 Kurangi leverage atau risk per trade untuk mengurangi drawdown.");
        rec.generalSuggestions.push("💡 Coba backtest di timeframe lain (15m, 4h, 1d) untuk membandingkan performa.");
        rec.actionPlan.push("📋 Coba backtest dengan preset 'trending' jika pasar sedang trending, atau 'ranging' jika pasar sideways.");
        rec.actionPlan.push("📋 Backtest dengan parameter baru di 3 periode berbeda untuk memvalidasi hasil.");
        rec.actionPlan.push("📋 Analisis trades yang gagal untuk mengidentifikasi pola kerugian yang konsisten.");
        
        // --- LOGIKA HEURISTIK KHUSUS UNTUK EMA PERIOD (METODE LAMA) ---
        let suggestedEma = settings.pullbackEmaPeriod;
        if (metrics.profitFactor < 1.2 && metrics.totalTrades < 15) {
            suggestedEma = Math.max(5, settings.pullbackEmaPeriod - 2);
        } else if (metrics.winRate < 45) {
            suggestedEma = settings.pullbackEmaPeriod + 4;
        }
        rec.optimalParams.pullbackEmaPeriod = { value: suggestedEma, pf: null, note: '(Heuristik)' };

        return rec;
    }

    function displayTuningRecommendations(recommendations) {
        const section = document.getElementById('tuning-recommendation-section');
        section.classList.remove('hidden');

        const confluenceList = document.getElementById('confluence-issues-list');
        const optimalContainer = document.getElementById('optimal-params-container');
        const regimeSuggestion = document.getElementById('regime-suggestion-content');
        const generalList = document.getElementById('general-suggestions-list');
        const actionList = document.getElementById('action-plan-list');

        confluenceList.innerHTML = recommendations.confluenceToImprove.map(item => `<li>${item}</li>`).join('');
        
        optimalContainer.innerHTML = '';
        if (recommendations.optimalParams && Object.keys(recommendations.optimalParams).length > 0) {
            for (const [key, value] of Object.entries(recommendations.optimalParams)) {
                if (value && (typeof value.pf !== 'undefined' || value.note)) {
                    const paramName = formatParamName(key);
                    const userValue = backtester.state.settings[key];
                    let optimalText;
                    if (value.note === '(Heuristik)') {
                        optimalText = `<span class="font-mono font-bold text-blue-400">${value.value} ${value.note}</span><span class="text-xs text-gray-500"> vs. ${userValue} (Anda)</span>`;
                    } else {
                        const isBetter = value.pf > recommendations.basePf;
                        optimalText = `<span class="font-mono font-bold ${isBetter ? 'positive' : 'text-white'}">${(value.value || 0).toFixed(4)} (PF: ${value.pf.toFixed(2)})</span>
                                    <span class="text-xs text-gray-500"> vs. ${userValue} (Anda)</span>`;
                    }
                    optimalContainer.innerHTML += `
                        <div class="flex justify-between items-center text-sm py-1">
                            <span class="text-gray-400">${paramName}:</span>
                            <div class="text-right">${optimalText}</div>
                        </div>`;
                }
            }
            if (optimalContainer.innerHTML === '') {
                optimalContainer.innerHTML = '<p class="text-xs text-gray-500 italic">Tidak ditemukan setelan parameter yang lebih optimal.</p>';
            }
        } else {
            optimalContainer.innerHTML = '<p class="text-xs text-gray-500 italic">Simulasi "What-If" tidak dijalankan.</p>';
        }
        
        generalList.innerHTML = recommendations.generalSuggestions.map(item => `<li>${item}</li>`).join('');
        actionList.innerHTML = recommendations.actionPlan.map(item => `<li>${item}</li>`).join('');
        regimeSuggestion.innerHTML = recommendations.regimeSuggestion || '<p class="text-sm text-gray-500 italic">Analisis rezim belum memberikan saran spesifik.</p>';
    }

    function formatParamName(key) {
        const nameMap = {
            riskRewardRatio: 'R:R Ratio',
            biasThreshold: 'Bias Threshold',
            swingLookback: 'Swing Lookback (SL)',
            atrFilterThreshold: 'ATR Filter',
            pullbackEmaPeriod: 'EMA Period' 
        };
        return nameMap[key] || key;
    }

    function applyTuningToIndexHTML(recommendations) {
        localStorage.setItem('tuningRecommendations', JSON.stringify({
            ...recommendations,
            appliedAt: new Date().toISOString()
        }));
            
        alert("Rekomendasi tuning telah disimpan. Buka index.html untuk menerapkan perubahan.");
    }

        function exportConfiguration(settings) {
            const dataStr = JSON.stringify(settings, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `backtest-config-${new Date().toISOString().slice(0,10)}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }
    // ===================================================================
    // BAGIAN 4: OBJEK UTAMA MESIN BACKTESTING
    // ===================================================================
    const backtester = {
            state: {
                isRunning: false,
                isStopped: false,
                settings: {}
            },

            stop() {
                this.state.isStopped = true;
            },

        async run() {
            if (this.state.isRunning) return;
            this.state.isRunning = true;
            this.state.isStopped = false;
            setButtonState(startBacktestBtn, true, "Running...");
            stopBacktestBtn.classList.remove('hidden');
            this.resetUI();
            
            let historicalData = [];
            let trades = [];
            let marketAnalysis = null; // Deklarasikan di sini agar bisa diakses di 'finally'

            try {
                this.gatherSettings();
                historicalData = await this.fetchHistoricalData();
                if (this.state.isStopped) {
                    backtestStatusText.textContent = "Pengambilan data dihentikan.";
                    return;
                }
                if (historicalData.length < 200) throw new Error("Data historis tidak cukup (min. 200 candle).");
                
                // --- PERBAIKAN ALUR KERJA DIMULAI DI SINI ---
                
                // 1. Lakukan SEMUA kalkulasi terlebih dahulu
                const { trades: simTrades, analysisCache } = await this.runSimulation_unifiedContextual(historicalData);
                trades = simTrades;

                if (this.state.isStopped) {
                    backtestStatusText.textContent = "Simulasi dihentikan oleh pengguna.";
                    return;
                }
                
                const metrics = this.calculateMetrics(trades, this.state.settings.initialBalance);
                const optimalParams = runWhatIfSimulation(trades, historicalData, this.state.settings, analysisCache);
                
                // Lakukan analisis pasar SEBELUM menampilkan hasil
                marketAnalysis = analyzeMarketConditions(historicalData);
                
                // 2. BARU tampilkan semua hasil setelah semua data siap
                this.displayResults(metrics, optimalParams, marketAnalysis, historicalData, trades);
                
                // --- AKHIR PERBAIKAN ALUR KERJA ---

            } catch (error) {
                console.error("Backtest Gagal:", error);
                backtestStatusText.textContent = `Error: ${error.message}`;
                backtestProgressBar.style.backgroundColor = '#ef4444';
            } finally {
                this.state.isRunning = false;
                setButtonState(startBacktestBtn, false, "▶️ BACKTEST");
                stopBacktestBtn.classList.add('hidden');

                // Pindahkan tampilan panel analisis dan chart ke sini
                if (marketAnalysis) {
                    displayMarketAnalysis(marketAnalysis);
                }
                if (historicalData && historicalData.length > 0) {
                    try {
                        document.getElementById('backtest-chart-container-section').classList.remove('hidden');
                        renderReplayWithIndicators(historicalData, trades); 
                    } catch (chartError) {
                        console.error("Error saat merender chart replay:", chartError);
                    }
                }
            }
        },

            resetUI() {
                backtestResultsContainer.classList.add('hidden');
                backtestTradeLogContainer.classList.add('hidden');
                document.getElementById('backtest-chart-container-section').classList.add('hidden');
                tuningRecommendationSection.classList.add('hidden');
                document.getElementById('market-analysis-section').classList.add('hidden');
                backtestProgressContainer.classList.remove('hidden');
                backtestProgressBar.style.backgroundColor = '#3b82f6';
                backtestStatusText.textContent = "Mempersiapkan...";
                backtestProgressBar.style.width = "0%";
            },

        gatherSettings() {
            const tunedWeights = {};
            labWeightsContainer.querySelectorAll('input').forEach(input => {
                tunedWeights[input.dataset.weightKey] = parseFloat(input.value) || 0;
            });
            this.state.settings = {
                symbol: backtestSymbolInput.value.toUpperCase().trim(),
                timeframe: backtestTimeframeSelect.value,
                startDate: new Date(backtestStartDate.value).getTime(),
                endDate: new Date(backtestEndDate.value).getTime(),
                initialBalance: parseFloat(backtestInitialBalance.value),
                leverage: parseInt(backtestLeverageInput.value) || 1,
                riskRewardRatio: parseFloat(labRrRatioInput.value) || 1.5,
                pullbackEmaPeriod: parseInt(labEmaPeriodInput.value) || 9,
                swingLookback: parseInt(labSwingLookbackInput.value) || 15,
                biasThreshold: parseInt(labBiasThresholdInput.value) || 15,
                atrFilterThreshold: parseFloat(labAtrFilterInput.value) || 0,
                weights: { ...userSettings.presets.default.weights, ...tunedWeights },
                riskPerTrade: (parseFloat(labRiskPercentInput.value) / 100) || 0.05,
                marginMode: labMarginModeSelect.value,
                // --- BARIS YANG DIPERBAIKI & DITAMBAHKAN ---
                takerFee: (parseFloat(labTakerFeeInput.value) / 100) || 0,
                makerFee: (parseFloat(labMakerFeeInput.value) / 100) || 0,
                slippageModel: labSlippageModelSelect.value,
                slippageFactor: 0.5 // Anda bisa membuat ini bisa di-tuning juga nanti
            };
            if (!this.state.settings.symbol || !this.state.settings.startDate || !this.state.settings.endDate) {
                throw new Error("Simbol, Tanggal Mulai, dan Tanggal Selesai harus diisi.");
            }
        },

        async fetchHistoricalData() {
    const { symbol, timeframe, startDate, endDate } = this.state.settings;
    let allKlines = [];
    let currentEndTime = endDate;
    const limit = 1000;

    // --- BLOK YANG DIPERBAIKI ---
    // Menghitung total candle langsung dari rentang waktu, tidak lagi dari input
    const timeframeMapMs = {
        '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
        '1h': 3600000, '4h': 14400000, '1d': 86400000
    };
    const timeframeMs = timeframeMapMs[timeframe];
    const durationMs = endDate - startDate;
    const totalCandleCount = timeframeMs > 0 ? Math.floor(durationMs / timeframeMs) : 0;
    const totalCalls = Math.ceil(totalCandleCount / limit);
    let callsMade = 0;
    // --- AKHIR BLOK YANG DIPERBAIKI ---

    while (currentEndTime > startDate && !this.state.isStopped) {
        const fetchedKlines = await fetchBinanceKlines(symbol, timeframe, limit, currentEndTime);
        if (fetchedKlines.length === 0) break;
        
        allKlines = fetchedKlines.concat(allKlines);
        
        currentEndTime = fetchedKlines[0][0] - 1; 
        callsMade++;

        const progress = Math.min(100, (callsMade / totalCalls) * 100);
        backtestProgressBar.style.width = `${progress}%`;
        backtestStatusText.textContent = `Mengambil data (${callsMade}/${totalCalls}) dari ${new Date(currentEndTime).toLocaleDateString('id-ID')}...`;
        
        await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    return allKlines.filter(k => k[0] >= startDate && k[0] <= endDate).sort((a, b) => a[0] - b[0]);
},

        async runSimulation_unifiedContextual(historicalData) {
            const activeFilters = Array.from(document.querySelectorAll('.session-filter-checkbox:checked')).map(cb => cb.value);
    let filteredData = historicalData;

    if (activeFilters.length > 0) {
        const sessionHours = {
            tokyo: { start: 0, end: 8 },   // 00:00 - 08:00 UTC
            london: { start: 7, end: 16 },  // 07:00 - 16:00 UTC
            newyork: { start: 13, end: 22 } // 13:00 - 22:00 UTC
        };

        filteredData = historicalData.filter(candle => {
            const date = new Date(candle[0]);
            const utcHour = date.getUTCHours();
            
            for (const filter of activeFilters) {
                if (utcHour >= sessionHours[filter].start && utcHour < sessionHours[filter].end) {
                    return true;
                }
            }
            return false;
        });
        console.log(`Data difilter untuk sesi: ${activeFilters.join(', ')}. Jumlah candle: ${filteredData.length} dari ${historicalData.length}.`);
        
        if (filteredData.length < 200) {
            throw new Error(`Data setelah difilter tidak cukup (hanya ${filteredData.length} candle). Coba rentang waktu yang lebih panjang.`);
        }
    }
    // ====================================================================

    const settings = this.state.settings;
    let balance = settings.initialBalance;
    let position = null;
    const trades = [];
    const analysisCache = [];

    // PASTIKAN SEMUA REFERENSI MENGGUNAKAN 'filteredData'
    for (let i = 200; i < filteredData.length; i++) {
        if (this.state.isStopped) break;

        const klinesSnapshot = filteredData.slice(0, i + 1);
        const closes = klinesSnapshot.map(k => parseFloat(k[4]));
        const currentCandle = filteredData[i];
        const currentLow = parseFloat(currentCandle[3]);
        const currentHigh = parseFloat(currentCandle[2]);

        const score = calculateConfluenceScoreForCandle(klinesSnapshot, settings.weights);
        const atrData = calculateATR(klinesSnapshot, 14);
        analysisCache.push({
            time: filteredData[i][0],
            bullScore: score.bull,
            bearScore: score.bear,
            atrValue: atrData.value
        });

        if (position) {
            let exitReason = null, exitPrice = 0;
            if (position.type === 'LONG') {
                if (currentLow <= position.sl) { exitReason = 'Stop Loss'; exitPrice = position.sl; }
                else if (currentHigh >= position.tp) { exitReason = 'Take Profit'; exitPrice = position.tp; }
            } else {
                if (currentHigh >= position.sl) { exitReason = 'Stop Loss'; exitPrice = position.sl; }
                else if (currentLow <= position.tp) { exitReason = 'Take Profit'; exitPrice = position.tp; }
            }

            if (exitReason) {
                const rawPnl = position.type === 'LONG' ? (exitPrice - position.entryPrice) * position.size : (position.entryPrice - exitPrice) * position.size;
                const entryValue = position.entryPrice * position.size;
                const exitValue = exitPrice * position.size;
                const entryFee = entryValue * settings.takerFee;
                const exitFee = exitValue * settings.makerFee;
                const totalFee = entryFee + exitFee;
                const netPnl = rawPnl - totalFee;

                balance += netPnl;
                trades.push({ ...position, exitPrice, pnl: netPnl, fee: totalFee, exitDate: new Date(currentCandle[0]), reason: exitReason });
                position = null;
                if (balance <= 0) { console.error("MODAL HABIS!"); break; }
            }
        }

        if (!position) {
            const currentRegime = detectMarketRegime(klinesSnapshot);
            let entrySignal = false;
            let detectedBias = 'NETRAL';
            let entryPrice = 0;
            const recentKlines = klinesSnapshot.slice(-settings.swingLookback);
            const recentSwingHigh = Math.max(...recentKlines.map(k => parseFloat(k[2])));
            const recentSwingLow = Math.min(...recentKlines.map(k => parseFloat(k[3])));

            if (currentRegime === 'trending') {
                const bias = (score.bull > score.bear + settings.biasThreshold) ? 'LONG' : (score.bear > score.bull + settings.biasThreshold) ? 'SHORT' : 'NETRAL';
                const emaEntry = calculateEMA(closes, settings.pullbackEmaPeriod).pop();
                if (bias !== 'NETRAL' && emaEntry && currentLow <= emaEntry && currentHigh >= emaEntry) {
                    entrySignal = true; detectedBias = bias; entryPrice = emaEntry;
                }
            } else if (currentRegime === 'ranging') {
                const bollingerBands = calculateBollingerBands(closes);
                const lastUpperBand = bollingerBands.upper ? bollingerBands.upper[bollingerBands.upper.length - 1] : 0;
                const lastLowerBand = bollingerBands.lower ? bollingerBands.lower[bollingerBands.length - 1] : 0;
                if (lastLowerBand > 0 && currentLow <= lastLowerBand) {
                    entrySignal = true; detectedBias = 'LONG'; entryPrice = currentLow;
                } else if (lastUpperBand > 0 && currentHigh >= lastUpperBand) {
                    entrySignal = true; detectedBias = 'SHORT'; entryPrice = currentHigh;
                }
            } else if (currentRegime === 'lowVolatility') {
                if (currentHigh > recentSwingHigh) {
                    entrySignal = true; detectedBias = 'LONG'; entryPrice = recentSwingHigh;
                } else if (currentLow < recentSwingLow) {
                    entrySignal = true; detectedBias = 'SHORT'; entryPrice = recentSwingLow;
                }
            }

            if (entrySignal) {
                let isVolatilitySufficient = true;
                if (settings.atrFilterThreshold > 0) {
                    isVolatilitySufficient = atrData.value > settings.atrFilterThreshold;
                }
                if (isVolatilitySufficient) {
                    if (settings.slippageModel === 'atrDynamic') {
                        const slippageAmount = atrData.value * settings.slippageFactor;
                        if (detectedBias === 'LONG') entryPrice += slippageAmount;
                        else entryPrice -= slippageAmount;
                    }
                    let stopLoss, takeProfit;
                    if (detectedBias === 'LONG') {
                        stopLoss = recentSwingLow * 0.999;
                        takeProfit = entryPrice + (Math.abs(entryPrice - stopLoss) * settings.riskRewardRatio);
                    } else {
                        stopLoss = recentSwingHigh * 1.001;
                        takeProfit = entryPrice - (Math.abs(stopLoss - entryPrice) * settings.riskRewardRatio);
                    }
                    const cost = balance * settings.riskPerTrade;
                    const sizeInAsset = (cost * settings.leverage) / entryPrice;
                    position = { type: detectedBias, entryPrice, cost, size: sizeInAsset, sl: stopLoss, tp: takeProfit, leverage: settings.leverage, entryDate: new Date(currentCandle[0]) };
                }
            }
        }
        
        const progress = (i / filteredData.length) * 100;
        backtestProgressBar.style.width = `${progress}%`;
        backtestStatusText.textContent = `Simulasi: ${(progress).toFixed(2)}% | Candle: ${i}/${filteredData.length}`;
        await new Promise(resolve => setTimeout(resolve, 0));
    }
    return { trades, analysisCache };
},

        calculateMetrics(trades, initialBalance) {
            let totalPnl = 0, grossProfit = 0, grossLoss = 0, wins = 0;
            trades.forEach(trade => {
                totalPnl += trade.pnl;
                if (trade.pnl > 0) {
                    grossProfit += trade.pnl;
                    wins++;
                } else {
                    grossLoss += Math.abs(trade.pnl);
                }
            });
            const winRate = trades.length > 0 ? (wins / trades.length) * 100 : 0;
            const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : Infinity;
            return {
                totalPnl,
                winRate,
                profitFactor,
                totalTrades: trades.length,
                finalBalance: initialBalance + totalPnl,
                trades
            };
        },
        
        displayResults(metrics, optimalParams, marketAnalysis, historicalData, trades) {
            // Mengisi Dasbor Performa Kuantitatif yang baru
            document.getElementById('backtest-result-pnl').textContent = `${metrics.totalPnl.toFixed(2)} USD (${((metrics.totalPnl / this.state.settings.initialBalance) * 100).toFixed(2)}%)`;
            document.getElementById('backtest-result-pnl').className = `font-mono font-bold text-lg ${metrics.totalPnl >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('backtest-result-winrate').textContent = `${metrics.winRate.toFixed(2)}%`;
            document.getElementById('backtest-result-profit-factor').textContent = (metrics.profitFactor === Infinity) ? '∞' : metrics.profitFactor.toFixed(2);
            document.getElementById('backtest-result-total-trades').textContent = `${metrics.totalTrades} Trades`;

            const recommendations = generateAdvancedTuningRecommendations(metrics, metrics.trades, this.state.settings, optimalParams, marketAnalysis);

            // Mengisi sisa metrik canggih dari hasil rekomendasi
            document.getElementById('backtest-result-max-drawdown').textContent = `${recommendations.stats.maxDrawdown.toFixed(2)}%`;
            const expectancyEl = document.getElementById('backtest-result-expectancy');
            expectancyEl.textContent = `${recommendations.stats.expectancy.toFixed(2)} USD`;
            expectancyEl.className = `font-mono font-bold text-lg ${recommendations.stats.expectancy >= 0 ? 'positive' : 'negative'}`;
            document.getElementById('backtest-result-losing-streak').textContent = `${recommendations.stats.maxLosingStreak} Trades`;

            // Menampilkan log trade
            backtestTradeLog.innerHTML = metrics.trades.map(trade => {
                return `
                <div class="p-1.5 rounded-md ${trade.pnl >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'}">
                    <div class="flex justify-between items-center font-mono">
                        <span>${trade.type} @ ${trade.entryPrice.toFixed(4)} -> ${trade.exitPrice.toFixed(4)}</span>
                        <span class="${trade.pnl >= 0 ? 'positive' : 'negative'}">${trade.pnl.toFixed(2)}</span>
                    </div>
                    <div class="text-gray-500 text-[10px]">${new Date(trade.entryDate).toLocaleString('id-ID')} -> ${new Date(trade.exitDate).toLocaleString('id-ID')}</div>
                </div>`
            }).join('');

            backtestResultsContainer.classList.remove('hidden');
            backtestTradeLogContainer.classList.remove('hidden');
            backtestProgressContainer.classList.add('hidden');
            
            saveResultToLogbook(this.state.settings, metrics, marketAnalysis, historicalData, trades);
            sortAndRenderLogbook();
            displayTuningRecommendations(recommendations);
            window.lastRecommendations = recommendations;
        },
    };
    
    // ===================================================================
    // BAGIAN 5: INISIALISASI & PENGHUBUNGAN EVENT
    // ===================================================================
// GANTI SELURUH BLOK document.addEventListener('DOMContentLoaded', ...) DENGAN INI
document.addEventListener('DOMContentLoaded', () => {
    // ... (fungsi setupToggle tetap sama) ...
    setupToggle('toggle-backtesting-btn', 'backtesting-content-wrapper', 'toggle-backtesting-icon', true);
    setupToggle('toggle-lab-btn', 'lab-content-wrapper', 'toggle-lab-icon', false);
    setupToggle('toggle-logbook-btn', 'logbook-content-wrapper', 'toggle-logbook-icon', false);
    setupToggle('toggle-tuning-recommendation-btn', 'tuning-recommendation-content-wrapper', 'toggle-tuning-recommendation-icon', true);
    setupToggle('toggle-market-analysis-btn', 'market-analysis-content-wrapper', 'toggle-market-analysis-icon', true);
    setupToggle('toggle-chart-container-btn', 'chart-container-content-wrapper', 'toggle-chart-container-icon', false);
    
    // === BLOK EVENT LISTENER BARU & LAMA ===
    startBacktestBtn.addEventListener('click', () => backtester.run());
    stopBacktestBtn.addEventListener('click', () => backtester.stop());
    
    const clearBtn = document.getElementById('clear-logbook-btn');
    if (clearBtn) clearBtn.addEventListener('click', clearLogbook);
    
    labRegimePreset.addEventListener('change', () => {
        applyRegimePreset(labRegimePreset.value);
    });    
    
    document.querySelectorAll('#logbook-section thead th').forEach(header => {
        header.addEventListener('click', () => {
            const sortKey = header.dataset.sortKey;
            if (!sortKey) return;
            if (logbookSortState.key === sortKey) {
                logbookSortState.direction = logbookSortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                logbookSortState.key = sortKey;
                logbookSortState.direction = 'desc';
            }
            sortAndRenderLogbook();
        });
    });

    // Event listener untuk tombol "Terapkan" dan "Ekspor"
    document.getElementById('apply-tuning-btn')?.addEventListener('click', function() {
        if (window.lastRecommendations) {
            applyTuningToIndexHTML(window.lastRecommendations);
        } else {
            alert("Tidak ada rekomendasi tuning yang tersedia. Jalankan backtest terlebih dahulu.");
        }
    });
    
    document.getElementById('export-config-btn')?.addEventListener('click', function() {
        backtester.gatherSettings();
        exportConfiguration(backtester.state.settings);
    });

    // Event listener untuk Chart Replay
    replaySpeedSlider.addEventListener('input', (e) => {
        changeReplaySpeed(e.target.value);
    });

    // Listener untuk update estimasi otomatis
    const filterCheckboxes = document.querySelectorAll('.session-filter-checkbox');
    backtestStartDate.addEventListener('change', calculateAndDisplayCandleCount);
    backtestEndDate.addEventListener('change', calculateAndDisplayCandleCount);
    backtestTimeframeSelect.addEventListener('change', calculateAndDisplayCandleCount);
    filterCheckboxes.forEach(cb => cb.addEventListener('change', calculateAndDisplayCandleCount));

    // === Logika untuk Asisten Durasi Cerdas (BARU) ===
    document.getElementById('duration-btn-3d').addEventListener('click', () => applyDuration('days', 3));
    document.getElementById('duration-btn-1w').addEventListener('click', () => applyDuration('weeks', 1));
    document.getElementById('duration-btn-1m').addEventListener('click', () => applyDuration('months', 1));
    document.getElementById('duration-apply-btn').addEventListener('click', () => {
        const candleValue = parseInt(document.getElementById('duration-candle-input').value);
        if (candleValue > 0) {
            applyDuration('candles', candleValue);
        }
    });

    // Set nilai default dan panggil fungsi awal
    backtestEndDate.value = formatDateTimeLocal(new Date()); // Set default ke waktu sekarang
    populateWeightsTuningPanel();
    calculateAndDisplayCandleCount();
    sortAndRenderLogbook();
    setupReplayEventListeners();
    updateMarketSessions();
    setInterval(updateMarketSessions, 60000);
});
</script>

</body>
</html>