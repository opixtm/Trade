<!DOCTYPE html>
<html lang="id" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BACKTESTING ENGINE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/lightweight-charts@4.2.3/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
<style>body{font-family:'Inter',sans-serif;background-color:#000000;color:#E0E0E0;}.card{background-color:#151414;border:1px solid #333;border-radius:.75rem;}.positive{color:#4ade80;}.negative{color:#f87171;}.btn-primary{background-color:#c97c00;color:#1f2937;font-weight:600;padding:.625rem 1.25rem;border-radius:.5rem;transition:background-color .3s;display:flex;align-items:center;justify-content:center;gap:.5rem;}.btn-primary:hover{background-color:#eb9413;}.btn-primary:disabled{background-color:#333333;cursor:not-allowed;}.btn-secondary{background-color:#374151;color:#e0e0e0;font-weight:600;padding:.25rem .5rem;border-radius:.5rem;transition:background-color .3s;}.btn-secondary:hover{background-color:#4b5563;}.input-primary{background-color:#1c1b1b;border:1px solid #444;border-radius:.5rem;padding:.625rem 1rem;width:100%;color:#E0E0E0;}.input-primary:focus{outline:none;border-color:#f59e0b;box-shadow:0 0 0 2px rgba(245,158,11,.3);}.input-primary.small-input{padding-left:.5rem;padding-right:.5rem;}.input-primary.small-input::-webkit-inner-spin-button,.input-primary.small-input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0;}.loader{display:flex;justify-content:center;align-items:center;gap:4px;}.dot{width:8px;height:8px;background-color:#e1e1e1;border-radius:50%;animation:bounce 1.4s infinite ease-in-out both;}.dot:nth-child(1){animation-delay:-.32s;}.dot:nth-child(2){animation-delay:-.16s;}@keyframes bounce{0%,80%,100%{transform:scale(0);}40%{transform:scale(1.0);}}.collapsible-content{display:grid;grid-template-rows:0fr;transition:grid-template-rows .4s ease-in-out;}.collapsible-content.expanded{grid-template-rows:1fr;}.collapsible-content>div{overflow:hidden;}.regime-tag{display:inline-block;padding:.25rem .5rem;border-radius:.25rem;font-size:.75rem;font-weight:600;margin-right:.5rem;}.uptrend{background-color:#10B981;color:white;}.downtrend{background-color:#EF4444;color:white;}.ranging{background-color:#F59E0B;color:white;}.sideways{background-color:#6B7280;color:white;}.volatile{background-color:#8B5CF6;color:white;}.market-condition-bar{height:8px;border-radius:4px;margin:.5rem 0;}.time-segment{display:inline-block;height:30px;margin-right:2px;cursor:pointer;position:relative;}.time-segment:hover::after{content:attr(data-date);position:absolute;bottom:100%;left:50%;transform:translateX(-50%);background:#1F2937;color:white;padding:4px 8px;border-radius:4px;font-size:12px;white-space:nowrap;z-index:10;}.recommendation-card{border-left:4px solid #F59E0B;background-color:#1F2937;}#backtest-chart-container{min-height:600px;background-color:#151414;border-radius:.5rem;}.section-toggle-btn{width:100%;display:flex;justify-content:space-between;align-items:center;text-align:left;margin-bottom:1rem;background:none;border:none;color:#E0E0E0;cursor:pointer;padding:0;}.section-toggle-btn:hover{opacity:.8;}.section-toggle-icon{transition:transform .3s ease;}.section-content-wrapper{transition:all .3s ease;overflow:hidden;}.section-content-wrapper.collapsed{grid-template-rows:0fr;opacity:0;}.section-content-wrapper.expanded{grid-template-rows:1fr;opacity:1;}.section-content-wrapper>div{overflow:hidden;}.low-volatility{background-color:#8B5CF6;color:white;}.session-filter-label{cursor:pointer;padding:.25rem .75rem;border-radius:9999px;font-size:.875rem;border:1px solid #444;background-color:#1c1b1b;transition:all .2s ease;}.session-filter-label:hover{background-color:#333;}.session-filter-checkbox:checked+.session-filter-label{background-color:#f59e0b;color:#1f2937;border-color:#c97c00;font-weight:600;}.regime-filter-label{cursor:pointer;padding:.25rem .75rem;border-radius:9999px;font-size:.875rem;border:1px solid #444;background-color:#1c1b1b;transition:all .2s ease;}.regime-filter-label:hover{background-color:#333;}.regime-filter-checkbox:checked+.regime-filter-label{background-color:#f59e0b;color:#1f2937;border-color:#c97c00;font-weight:600;}.btn-red{background-color:#ef4444;color:white;}.btn-red:hover{background-color:#dc2626;}.dark .btn-red{background-color:#ef4444;color:white;}.dark .btn-red:hover{background-color:#dc2626;}.input-primary{background-color:#2c2c2c;border:1px solid #444;color:#E0E0E0;padding:.5rem .75rem;border-radius:.375rem;width:100%;transition:all .2s ease;}.input-primary:focus{outline:none;border-color:#f59e0b;box-shadow:0 0 0 2px rgba(245,158,11,.3);}.input-primary.small-input{padding-left:.5rem;padding-right:.5rem;}.btn-success{background-color:#10B981;color:white;}.btn-success:hover:not(:disabled){background-color:#059669;}.btn-special{background-color:#8B5CF6;color:white;}.btn-special:hover:not(:disabled){background-color:#7c3aed;}.progress-bar-container{width:100%;background-color:#374151;border-radius:9999px;overflow:hidden;height:.75rem;}.progress-bar{height:100%;width:0%;transition:width .5s ease-in-out;}.session-filter-label{cursor:pointer;padding:.25rem .75rem;border-radius:9999px;font-size:.875rem;border:1px solid #444;background-color:#2c2c2c;transition:all .2s ease;}.session-filter-label:hover{background-color:#374151;}.session-filter-checkbox:checked+.session-filter-label{background-color:#f59e0b;color:#1f2937;border-color:#c97c00;font-weight:600;}.btn{padding:.6rem 1.25rem;border-radius:.375rem;font-weight:600;cursor:pointer;transition:all .2s ease;text-align:center;display:inline-flex;align-items:center;justify-content:center;gap:.5rem;}
</style>
</head>
<body class="antialiased">

    <div id="main-content-container" class="px-4 pb-8 sm:px-6 lg:px-8">
        <main class="space-y-8 mt-8">
            <section id="backtesting-section" class="card p-6">
                 <button id="toggle-backtesting-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-base font-bold">🔬 Mesin Backtesting</h2>
                    <svg id="toggle-backtesting-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="backtesting-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700 space-y-4">
                        <div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2">
                                <div>
                                    <label for="asset-category-select" class="block text-sm font-medium text-gray-400">Asisten Kategori Aset</label>
                                    <select id="asset-category-select" class="input-primary mt-1">
                                        <option value="">-- Pilih Kategori --</option>
                                        </select>
                                </div>
                                <div>
                                    <label for="backtest-symbol-input" class="block text-sm font-medium text-gray-400">Simbol Aset (Pisahkan dengan koma untuk Generic DNA)</label>
                                    <textarea id="backtest-symbol-input" rows="3" class="input-primary uppercase mt-1" placeholder="Contoh: BTCUSDT, ETHUSDT, SOLUSDT..."></textarea>
                                </div>
                                <div class="grid grid-cols-2 gap-4">
                                    <div>
                                        <label for="backtest-timeframe-select" class="block text-sm font-medium text-gray-400">Timeframe</label>
                                        <select id="backtest-timeframe-select" class="input-primary mt-1">
                                            <option value="1m">1m</option><option value="3m">3m</option><option value="5m">5m</option><option value="15m" selected>15m</option><option value="1h">1h</option><option value="4h">4h</option><option value="1d">1d</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label for="backtest-leverage-input" class="block text-sm font-medium text-gray-400">Leverage</label>
                                        <input type="number" id="backtest-leverage-input" value="10" class="input-primary small-input mt-1">
                                    </div>
                                </div>
                                <div>
                                    <label for="backtest-start-date" class="block text-sm font-medium text-gray-400">Mulai (Tanggal & Jam)</label>
                                    <input type="datetime-local" id="backtest-start-date" class="input-primary mt-1">
                                </div>
                                <div>
                                    <label for="backtest-end-date" class="block text-sm font-medium text-gray-400">Selesai (Tanggal & Jam)</label>
                                    <input type="datetime-local" id="backtest-end-date" class="input-primary mt-1">
                                </div>
                            </div>
                            <div class="pt-4 border-t border-gray-800">
                                <label class="block text-sm font-medium text-gray-400 mb-2">💡 Asisten Durasi Cerdas (Mengisi "Mulai" secara otomatis)</label>
                                <div class="flex flex-wrap items-center gap-2 text-sm">
                                    <span>Durasi Mundur dari "Selesai":</span>
                                    <button id="duration-btn-3d" class="btn-secondary !text-xs">3 Hari</button>
                                    <button id="duration-btn-1w" class="btn-secondary !text-xs">1 Minggu</button>
                                    <button id="duration-btn-1m" class="btn-secondary !text-xs">1 Bulan</button>
                                    <span class="border-l border-gray-600 pl-2">atau</span>
                                    <input type="number" id="duration-candle-input" placeholder="Jml. Candle" class="input-primary small-input !w-28 text-center bg-gray-900/50">
                                    <button id="duration-apply-btn" class="btn-primary !py-1 !px-3 !text-xs">Terapkan</button>
                                </div>
                            </div>
                            <div class="pt-4 border-t border-gray-800">
                            <label class="block text-sm font-medium text-gray-400 mb-2">🕒 Filter Sesi Aktif (WIB)</label>
                            <div class="flex flex-wrap gap-4 items-center">
                                <input type="checkbox" id="filter-session-tokyo" value="tokyo" class="hidden session-filter-checkbox">
                                <label for="filter-session-tokyo" class="session-filter-label">🇯🇵 Tokyo (07:00-15:00)</label>
                                
                                <input type="checkbox" id="filter-session-london" value="london" class="hidden session-filter-checkbox">
                                <label for="filter-session-london" class="session-filter-label">🇬🇧 London (15:00-23:00)</label>

                                <input type="checkbox" id="filter-session-newyork" value="newyork" class="hidden session-filter-checkbox">
                                <label for="filter-session-newyork" class="session-filter-label">🇺🇸 New York (20:00-04:00)</label>

                                <div class="flex items-center gap-2 p-2 rounded-lg bg-gray-900/50 border border-gray-700">
                                    <input type="checkbox" id="filter-session-custom" value="custom" class="hidden session-filter-checkbox">
                                    <label for="filter-session-custom" class="session-filter-label">⚙️ Custom</label>
                                    <input type="time" id="custom-session-start" class="input-primary small-input !w-24 bg-gray-800 text-center">
                                    <span>-</span>
                                    <input type="time" id="custom-session-end" class="input-primary small-input !w-24 bg-gray-800 text-center">
                                    </div>
                                </div>
                            </div>
                            <div class="pt-4 border-t border-gray-800">
                                <label class="block text-sm font-medium text-gray-400 mb-2">🔎 Filter Berdasarkan Rezim Pasar (Pilih satu atau lebih)</label>
                                <div class="flex flex-wrap gap-4 items-center">
                                    
                                    <input type="checkbox" id="filter-regime-bull" value="bullTrend" class="hidden session-filter-checkbox" checked>
                                    <label for="filter-regime-bull" class="session-filter-label">🐂 Bull Trend</label>
                                    
                                    <input type="checkbox" id="filter-regime-bear" value="bearTrend" class="hidden session-filter-checkbox" checked>
                                    <label for="filter-regime-bear" class="session-filter-label">🐻 Bear Trend</label>
                                    
                                    <input type="checkbox" id="filter-regime-ranging" value="ranging" class="hidden session-filter-checkbox" checked>
                                    <label for="filter-regime-ranging" class="session-filter-label">🐒 Ranging</label>
                                    
                                    <input type="checkbox" id="filter-regime-lowvol" value="lowVolatility" class="hidden session-filter-checkbox" checked>
                                    <label for="filter-regime-lowvol" class="session-filter-label">🪫 Low Volatility</label>

                                </div>
                            </div>
                            <div class="pt-4 flex flex-col md:flex-row gap-4 items-center">
                            <div class="w-full md:w-auto">
                                <label for="backtest-initial-balance" class="block text-sm font-medium text-gray-400 text-center md:text-left">Modal Awal ($)</label>
                                <input type="number" id="backtest-initial-balance" value="1000" class="input-primary small-input mt-1 md:w-32 text-center">
                            </div>
                            <div class="flex-grow flex items-center gap-4 w-full">
                                <button id="start-backtest-btn" class="btn-primary w-full"><span>▶️ BACKTEST</span><div class="loader w-5 h-5 hidden"></div></button>
                                <button id="stop-backtest-btn" class="btn-secondary w-auto hidden"><span>⏹️ STOP</span></button>
                            </div>
                            <div class="text-right text-xs text-gray-400 w-full md:w-auto mt-2 md:mt-0">
                                <span id="candle-estimation-display" class="font-bold text-yellow-400">Pilih rentang waktu...</span>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <div id="data-lake-progress-container" class="hidden card p-4 my-4">
                <p id="data-lake-status-text" class="text-center text-sm text-yellow-400 mb-2">Mempersiapkan sinkronisasi Data Lake...</p>
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="data-lake-progress-bar" class="bg-green-500 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>

            <div id="backtest-progress-container" class="hidden my-4">
                <p id="backtest-status-text" class="text-center text-sm text-yellow-400 mb-2">Mengambil data...</p>
                <div class="w-full bg-gray-700 rounded-full h-2.5"><div id="backtest-progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%"></div></div>
            </div>

            <section id="strategy-lab-section" class="card p-3">
                <button id="toggle-lab-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-base font-bold">🧪 Strategy Lab & Tuning</h2>
                    <svg id="toggle-lab-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="lab-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700 space-y-6">
                        <div>
                            <h3 class="font-semibold text-lg mb-3">Preset Bobot (Otomatis berdasarkan Rezim)</h3>
                            <select id="lab-regime-preset" class="input-primary mt-1">
                                <option value="default" selected>ꂒ Default (Hybrid)</option>
                                <option value="bullTrend">🐂 Bull Trend Market (Follow Trend)</option>
                                <option value="bearTrend">🐻 Bear Trend Market (Follow Trend)</option>
                                <option value="ranging">🐒 Ranging Market (Mean Reversion)</option>
                                <option value="lowVolatility">🪫 Low Volatility (Breakout)</option>
                                <option value="custom">🦽 ⑉ Custom</option>
                            </select>
                        </div>
                        <div>
                            <h3 class="font-semibold text-lg mb-3">Parameter Eksekusi & Realitas Pasar</h3>
                            <div class="grid grid-cols-2 md:grid-cols-6 gap-4">
                                <div><label class="block text-xs text-gray-400">R:R Ratio (TP)</label><input type="number" step="0.1" id="lab-rr-ratio" value="1.8" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">EMA Entry</label><input type="number" id="lab-ema-period" value="13" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Swing Lookback (SL)</label><input type="number" id="lab-swing-lookback" value="15" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Bias Threshold</label><input type="number" id="lab-bias-threshold" value="15" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Risk per Trade (%)</label><input type="number" id="lab-risk-percent" value="10" class="input-primary small-input mt-1"></div>
                                
                                <div>
                                    <label class="block text-xs text-gray-400">ATR Filter (Nilai Min)</label>
                                    <input type="number" step="0.0001" id="lab-atr-filter-input" value="0" class="input-primary small-input mt-1">
                                </div>
                                
                                <div><label class="block text-xs text-gray-400">Taker Fee (%)</label><input type="number" step="0.01" id="lab-taker-fee" value="0.04" class="input-primary small-input mt-1"></div>
                                <div><label class="block text-xs text-gray-400">Maker Fee (%)</label><input type="number" step="0.01" id="lab-maker-fee" value="0.02" class="input-primary small-input mt-1"></div>
                                <div>
                                    <label class="block text-xs text-gray-400">Model Slippage</label>
                                    <select id="lab-slippage-model" class="input-primary mt-1 text-xs">
                                        <option value="none">None</option>
                                        <option value="atrDynamic">ATR Dinamis (Lama)</option>
                                        <option value="atrAdvanced" selected>ATR Lanjutan (Realistis)</option> </select>
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400">Slippage ATR (%)</label>
                                    <input type="number" step="1" id="lab-atr-slippage-percent" value="10" class="input-primary small-input mt-1">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-400">Slippage Acak (%)</label>
                                    <input type="number" step="0.001" id="lab-random-slippage-percent" value="0.005" class="input-primary small-input mt-1">
                                </div>
                                <div class="md:col-span-2">
                                    <label class="block text-xs text-gray-400">Margin Mode</label>
                                    <select id="lab-margin-mode" class="input-primary mt-1">
                                        <option value="cross" selected>Cross</option>
                                        <option value="isolated">Isolated</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <details>
                            <summary class="cursor-pointer text-sm text-gray-400 hover:text-white">Tuning Bobot Konfluensi (Advanced)</summary>
                            <div id="lab-weights-tuning" class="mt-4 pt-4 border-t border-gray-600 grid grid-cols-2 md:grid-cols-4 gap-x-6 gap-y-4"></div>
                        </details>
                    </div>
                </div>
            </section>
            
            <div id="backtest-results-container" class="hidden card p-3">
                <h3 class="font-bold text-lg mb-4 text-center">📊 Dasbor Performa Kuantitatif</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-4 text-center">
                    <div>
                        <p class="text-xs text-gray-500">💰 Total Profit/Loss</p>
                        <p id="backtest-result-pnl" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">🎯 Win Rate</p>
                        <p id="backtest-result-winrate" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">📈 Profit Factor</p>
                        <p id="backtest-result-profit-factor" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Trades</p>
                        <p id="backtest-result-total-trades" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">📉 Max Drawdown</p>
                        <p id="backtest-result-max-drawdown" class="font-mono font-bold text-lg negative">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">🎲 Expectancy / Trade</p>
                        <p id="backtest-result-expectancy" class="font-mono font-bold text-lg">-</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">🔥 Max Losing Streak</p>
                        <p id="backtest-result-losing-streak" class="font-mono font-bold text-lg">-</p>
                    </div>
                </div>
            </div>
            
            <section id="tuning-recommendation-section" class="card p-3 hidden">
                <button id="toggle-tuning-recommendation-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-xl font-bold">🎯 Rekomendasi Tuning (Quant V3.2)</h2>
                    <svg id="toggle-tuning-recommendation-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
                </button>
                <div id="tuning-recommendation-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700 grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
                        
                        <div class="space-y-6">
                            <div>
                                <h3 class="font-semibold mb-2 text-yellow-400">Konfluensi yang Perlu Diperbaiki</h3>
                                <ul id="confluence-issues-list" class="text-sm space-y-2"></ul>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-blue-400">Saran Regime Pasar</h3>
                                <div id="regime-suggestion-content" class="text-sm"></div>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-green-300">📋 Action Plan</h3>
                                <ul id="action-plan-list" class="text-sm space-y-2"></ul>
                            </div>
                        </div>

                        <div class="space-y-6">
                            <div>
                                <h3 class="font-semibold mb-2 text-purple-400">Parameter Optimal (Hasil "What-If")</h3>
                                <div id="optimal-params-container" class="text-sm space-y-2"></div>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-gray-400">Saran Umum</h3>
                                <ul id="general-suggestions-list" class="text-sm space-y-2"></ul>
                            </div>
                        </div>

                        <div class="md:col-span-2 flex items-center gap-4 pt-4 mt-4 border-t border-gray-600">
                            <button id="apply-tuning-btn" class="btn-primary w-full">
                                <span>⚙️ Terapkan ke Index.HTML</span>
                            </button>
                            <button id="export-config-btn" class="btn-secondary w-full">
                                <span>📄 Ekspor Konfigurasi</span>
                            </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="market-analysis-section" class="card p-3 hidden">
                <button id="toggle-market-analysis-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-xl font-bold">📊 Analisis Kondisi Pasar</h2>
                    <svg id="toggle-market-analysis-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="market-analysis-content-wrapper" class="collapsible-content expanded">
                <div id="market-analysis-content" class="space-y-4">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h3 class="font-semibold mb-2">Distribusi Kondisi Pasar</h3>
                            <div id="market-condition-chart"></div>
                        </div>
                        <div class="space-y-4">
                            <h3 class="font-semibold mb-2">Ringkasan Volatilitas</h3>
                            <div class="flex items-center justify-between text-sm">
                                <span>Kondisi Pasar</span>
                                <span id="overall-volatility-text" class="font-mono">-</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-1.5 mb-2">
                                <div id="overall-volatility-bar" class="market-condition-bar" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Segmentasi Waktu Berdasarkan Kondisi</h3>
                            <div id="time-segmentation-chart" class="mt-2"></div>
                        </div>
                    </div>
                    
                    <div class="recommendation-card p-4 rounded-md">
                        <h3 class="font-semibold mb-2 text-yellow-400">💡 Rekomendasi Berdasarkan Kondisi Pasar</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 pt-4 border-t border-gray-700">
                            <div>
                            <h3 class="font-semibold mb-2">ATR Saat Ini</h3>
                            <div id="atr-value" class="text-lg font-mono">-</div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Status Volatilitas</h3>
                            <div id="volatility-status" class="text-lg font-mono">-</div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2">Rata-rata Perubahan Harian</h3>
                            <div id="daily-range" class="text-lg font-mono">-</div>
                        </div>
                        </div>
                        <ul id="market-recommendations" class="text-sm space-y-2"></ul>
                    </div>
                </div>
            </section>
            <section id="logbook-section" class="card p-3">
                <button id="toggle-logbook-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-lg font-bold">📖 LOGBOOK</h2>
                    <svg id="toggle-logbook-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="logbook-content-wrapper" class="collapsible-content expanded">
                    <div class="pt-4 mt-4 border-t border-gray-700">
                        <div class="flex justify-between items-center mb-2">
                            <h4 class="font-semibold text-gray-400">Backtest History</h4>
                            <div class="flex gap-2"> <button id="clear-cache-btn" class="btn-secondary !bg-blue-800 hover:!bg-blue-700 !text-xs !py-1 !px-2">Hapus Cache Indikator</button>
                                <button id="clear-logbook-btn" class="btn-secondary !text-xs !py-1 !px-2">Hapus Riwayat</button>
                            </div>
                        </div>
                        <div class="overflow-x-auto">
                            <table class="min-w-full text-sm text-left text-gray-400">
                                <thead class="text-xs text-gray-400 uppercase bg-gray-700/50">
                                    <tr>
                                        <th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="symbol">Aset</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="timeframe">TF</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="pnlPercent">PNL (%)</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="winRate">Win Rate</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="profitFactor">Profit Factor</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="totalTrades">Trades</th><th scope="col" class="px-4 py-2 cursor-pointer hover:bg-gray-600" data-sort-key="startDate">Periode</th>
                                    </tr>
                                </thead>
                                <tbody id="logbook-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <div id="backtest-trade-log-container" class="hidden card p-3">
                <h4 class="font-semibold text-gray-400 mb-2">Trades Simulation History</h4>
                <div id="backtest-trade-log" class="space-y-2 text-xs max-h-60 overflow-y-auto p-2 bg-gray-900/50 rounded-md"></div>
            </div>

            <section id="backtest-chart-container-section" class="card p-4 hidden">
                <button id="toggle-chart-container-btn" class="w-full flex justify-between items-center text-left mb-4">
                    <h2 class="text-xl font-bold">Chart Replay</h2>
                    <svg id="toggle-chart-container-icon" class="w-6 h-6 transition-transform" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                    </svg>
                </button>
                <div id="chart-container-content-wrapper" class="collapsible-content expanded">
                
                <div class="chart-container relative border-b border-gray-700 pb-2">
                    <div class="pane-title text-sm font-bold text-gray-300">REPLAY</div>
                    <div id="main-chart-container" style="height: 450px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">Volume</div>
                    <div id="volume-chart-container" style="height: 100px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">RSI (14)</div>
                    <div id="rsi-chart-container" style="height: 120px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">Stochastic RSI (14, 14, 3, 3)</div>
                    <div id="stoch-rsi-chart-container" style="height: 120px;"></div>
                    <div class="pane-title text-sm font-bold text-gray-300">MACD</div>
                    <div id="macd-chart-container" style="height: 120px;"></div>
                    <div id="replay-controls" class="flex items-center justify-center gap-4 p-4 mt-4 border-t border-gray-700">
                    <button id="replay-reset-btn" class="btn-secondary">⏮️ Reset</button>
                    <button id="replay-step-btn" class="btn-secondary">⏯️ Step</button>
                    <button id="replay-play-pause-btn" class="btn-primary w-28">▶️ Play</button>
                    <div class="flex items-center gap-2">
                        <label for="replay-speed-slider" class="text-sm">Speed</label>
                        <input id="replay-speed-slider" type="range" min="1" max="20" value="5" class="w-32">
                        <span id="replay-speed-label" class="text-sm font-mono w-8">x10</span>
                    </div>
                </div>
                </div>                
            </section>


            <div class="card p-3">
                <h2 class="text-xl font-bold mb-4 text-green-400 border-b border-gray-700 pb-2">🚀 Genesis Engine - Machine Learning Backtest</h2>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                    <div><label class="block text-sm text-gray-400">Population Size</label><input type="number" id="population-size" value="50" class="input-primary mt-1" /></div>
                    <div><label class="block text-sm text-gray-400">Generation Count</label><input type="number" id="generation-count" value="200" class="input-primary mt-1" /></div>
                    <div><label class="block text-sm text-gray-400">Mutated Degree (%)</label><input type="number" id="mutation-rate" value="5" class="input-primary mt-1" /></div><div><label class="block text-sm text-gray-400">Optimasi Berdasarkan</label>
                        <select id="optimization-metric-select" class="input-primary mt-1"><option selected>Profit Factor</option><option>Win Rate</option><option>Sharpe Ratio</option></select>
                    </div>
                </div>
                <div class="flex items-center space-x-4 mt-4">
                    <button id="start-genesis-btn" class="btn-primary w-1/2">▶️ Start Evolution</button>
                    <button id="stop-genesis-btn" class="btn btn-red w-1/2">⏹️ Stop Evolution</button>
                </div>
            </div>

            <div class="card p-3">
                <h2 class="text-xl font-bold mb-4 text-purple-400 border-b border-gray-700 pb-2">📈 Monitoring Evolusi & Kinerja</h2>
                <div id="genesis-progress-container" class="my-4 space-y-2 hidden">
                    <div class="flex items-center justify-center gap-2">
                        <svg class="animate-spin h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <span id="genome-eval-text" class="text-sm font-semibold text-white">Mengevaluasi Genom...</span>
                    </div>
                    <div id="population-progress-container" class="w-full bg-gray-700 rounded-full h-2.5">
                        <div id="genome-progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%;"></div>                    
                    </div>
                </div>
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-1"><span class="text-sm font-medium text-gray-300">Progres Generasi</span><span id="progress-text" class="text-sm font-mono text-gray-400">Generasi 0 dari 200</span></div>
                    <div class="progress-bar-container"><div id="progress-bar" class="progress-bar !bg-purple-500"></div></div>
                </div>
                <div id="resource-monitor" class="text-center text-xs text-gray-500 font-mono bg-gray-900/50 p-2 rounded-md mb-4">
                    <span>Kinerja: <span id="performance-metric">0 Gen/detik</span> (<span id="trade-speed">0 Trade/detik</span>)</span>
                </div>
                <div class="bg-gray-900/50 p-2 rounded-lg mb-4">
                    <canvas id="fitness-chart"></canvas>
                </div>
                <h3 class="font-bold text-gray-300 mb-2">🏆 DNA Strategi Juara Saat Ini:</h3>
                <div class="bg-gray-900 p-3 rounded text-sm overflow-x-auto">
                    <pre id="champion-dna" class="text-yellow-200">Menunggu generasi pertama selesai...</pre>
                    
                  
                    <div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <button id="run-monte-carlo-btn" class="btn btn-secondary !bg-blue-600 hover:!bg-blue-700 w-full">
                            📊 Jalankan Simulasi Monte Carlo
                        </button>
                        <button id="export-dna-btn" class="btn btn-special w-full">
                            🚀 EKSPOR DNA STRATEGI
                        </button>
                        <button id="export-autodna-btn" class="btn btn-success w-full sm:col-span-2">
                            <span>✨ Buat & Ekspor DNA Auto-Switch</span>
                        </button>
                    </div>

                </div>
            </div>
            <div id="genesis-results-container" class="hidden card p-6">
            </div>
        </main>
    </div>

    <div id="monte-carlo-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50 hidden">
        <div id="monte-carlo-content" class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-blue-400">📊 Proyeksi Probabilistik (Monte Carlo)</h3>
                <button id="monte-carlo-close-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>
            
            <div id="monte-carlo-summary" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center mb-4 p-3 bg-gray-900/50 rounded-lg">
                <div>
                    <p class="text-xs text-gray-400">Jumlah Simulasi</p>
                    <p id="mc-summary-sims" class="font-mono font-bold text-lg text-white">-</p>
                </div>
                <div>
                    <p class="text-xs text-gray-400">Jumlah Trade per Simulasi</p>
                    <p id="mc-summary-trades" class="font-mono font-bold text-lg text-white">-</p>
                </div>
                <div>
                    <p class="text-xs text-gray-400">Rata-rata PNL Final</p>
                    <p id="mc-summary-avg-pnl" class="font-mono font-bold text-lg text-green-400">-</p>
                </div>
                <div>
                    <p class="text-xs text-gray-400">Probabilitas Loss</p>
                    <p id="mc-summary-loss-prob" class="font-mono font-bold text-lg text-red-400">-</p>
                </div>
            </div>
            
            <div class="flex-grow min-h-0">
                <canvas id="monte-carlo-chart"></canvas>
            </div>
            
            <div class="text-center mt-2">
                <p class="text-xs text-gray-500">Garis tebal biru adalah jalur ekuitas historis. Kerucut abu-abu menunjukkan rentang probabilitas 25%-75% dari hasil simulasi.</p>
            </div>
        </div>
    </div>
<script>
// ===================================================================
// DEKLARASI VARIABEL GLOBAL & KONFIGURASI
// ===================================================================
    let binanceFuturesSymbolsCache = null; 
    let logbookSortState = { key: 'id', direction: 'desc' };
    let lastRecommendations = null;
    let replayState = {
        isPlaying: false, currentIndex: 0, speed: 5, intervalId: null,
        candleSeries: null, volumeSeries: null, rsiSeries: null,
        stochKSeries: null, stochDSeries: null, macdLineSeries: null,
        signalLineSeries: null, histogramSeries: null, fullData: {}, priceLines: []
    };
    let charts = [];
    let userSettings = {
        presets: {
            'default': { weights: { ma: 2, rsiDivergence: 2.5, macd: 2, pivot: 2, vwap: 2, ichimoku: 3, candlePattern: 1.5, obvDivergence: 3.0, bbSqueeze: 1.5, psar: 1, roc: 1, bollingerBands: 1, rsi: 1.5, stoch: 1, linreg: 1 } },
            'bullTrend': { weights: { ma: 3.0, rsiDivergence: 1.5, macd: 2.5, pivot: 1.5, vwap: 2.5, ichimoku: 3.0, candlePattern: 1.5, obvDivergence: 2.0, bbSqueeze: 0.5, psar: 2.5, roc: 1.5, bollingerBands: 1, rsi: 1.0, stoch: 0.5, linreg: 2.0 } },
            'bearTrend': { weights: { ma: 3.0, rsiDivergence: 1.0, macd: 3.0, pivot: 1.5, vwap: 2.5, ichimoku: 3.0, candlePattern: 1.5, obvDivergence: 2.0, bbSqueeze: 0.5, psar: 2.5, roc: 1.5, bollingerBands: 1, rsi: 1.0, stoch: 0.5, linreg: 2.0 } },
            'ranging': { weights: { ma: 1.0, rsiDivergence: 3.0, macd: 1.5, pivot: 2.0, vwap: 1.0, ichimoku: 1.0, candlePattern: 2.0, obvDivergence: 2.5, bbSqueeze: 1.0, psar: 0.5, roc: 1.0, bollingerBands: 2.5, rsi: 2.5, stoch: 2.0, linreg: 1.5 } },
            'lowVolatility': { weights: { ma: 1.0, rsiDivergence: 1.5, macd: 2.0, pivot: 1.0, vwap: 1.0, ichimoku: 0.5, candlePattern: 1.5, obvDivergence: 1.0, bbSqueeze: 3.5, psar: 0.5, roc: 2.0, bollingerBands: 2.0, rsi: 2.0, stoch: 1.5, linreg: 1.0 } }
        }
    };
    let evolutionState = {
        isRunning: false, currentGeneration: 0, populationSize: 50, maxGenerations: 200,
        mutationRate: 0.05, population: [], champion: null, fitnessChart: null,
        logbook: [], historicalData: []
    };
    let lastMonteCarloResult = null;
    let performanceMonitor = {
        startTime: null,
        lastGenerationCount: 0,
        lastTime: null
    };
    let regimeSensorModel = null;
    let predictionModel;
    let isTfModelReady = false;
    let monteCarloChartInstance = null;
    let runMonteCarloBtn, monteCarloModal, monteCarloCloseBtn;

    const REGIME_LABELS = ['BULL_TREND', 'BEAR_TREND', 'RANGING', 'LOW_VOLATILITY'];
    const TIMEFRAME_MAP_MS = {
        '1m': 60000, '3m': 180000, '5m': 300000, '15m': 900000,
        '1h': 3600000, '4h': 14400000, '1d': 86400000
    };    
    const timeframeParameterMap = {
        '1m': { rsi_period: 7, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '3m': { rsi_period: 9, macd_fast: 5, macd_slow: 13, macd_signal: 5, stoch_rsi_period: 9, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '5m': { rsi_period: 9, macd_fast: 8, macd_slow: 21, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '15m': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1h': { rsi_period: 14, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 14, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '4h': { rsi_period: 21, macd_fast: 12, macd_slow: 26, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 },
        '1d': { rsi_period: 21, macd_fast: 21, macd_slow: 55, macd_signal: 9, stoch_rsi_period: 21, stoch_stoch_period: 14, stoch_k_smooth: 3, stoch_d_smooth: 3 }
    };
    const MAINTENANCE_MARGIN_RATE = 0.005;
    const MAX_API_LIMIT = 1000; 
    const MODEL_ARTIFACTS_JSON_STRING = `
    {
        "format": "layers-model",
        "generatedBy": "TensorFlow.js tfjs-layers v4.2.0",
        "convertedBy": null,
        "modelTopology": {
            "class_name": "Sequential",
            "config": {
                "name": "sequential_1",
                "layers": [
                    {
                        "class_name": "Dense",
                        "config": {
                            "units": 64, "activation": "relu", "use_bias": true, "kernel_initializer": {"class_name": "VarianceScaling", "config": {"scale": 1, "mode": "fan_avg", "distribution": "normal", "seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "name": "dense_Dense1", "batch_input_shape": [null, 12], "dtype": "float32"
                        }
                    },
                    {"class_name": "Dropout", "config": {"rate": 0.2, "name": "dropout_Dropout1"}},
                    {
                        "class_name": "Dense",
                        "config": {"units": 32, "activation": "relu", "use_bias": true, "kernel_initializer": {"class_name": "VarianceScaling", "config": {"scale": 1, "mode": "fan_avg", "distribution": "normal", "seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "name": "dense_Dense2"}
                    },
                    {
                        "class_name": "Dense",
                        "config": {"units": 4, "activation": "softmax", "use_bias": true, "kernel_initializer": {"class_name": "VarianceScaling", "config": {"scale": 1, "mode": "fan_avg", "distribution": "normal", "seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "name": "dense_Dense3"}
                    }
                ]
            },
            "keras_version": "tfjs-layers 4.2.0",
            "backend": "tensor_flow.js"
        },
        "weightsManifest": [
            {
                "paths": ["weights.bin"],
                "weights": [
                    {"name": "dense_Dense1/kernel", "shape": [12, 64], "dtype": "float32"},
                    {"name": "dense_Dense1/bias", "shape": [64], "dtype": "float32"},
                    {"name": "dense_Dense2/kernel", "shape": [64, 32], "dtype": "float32"},
                    {"name": "dense_Dense2/bias", "shape": [32], "dtype": "float32"},
                    {"name": "dense_Dense3/kernel", "shape": [32, 4], "dtype": "float32"},
                    {"name": "dense_Dense3/bias", "shape": [4], "dtype": "float32"}
                ]
            }
        ]
    }
    `;
    const WEIGHTS_BASE64_STRING = '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';
// ===============================================================
// LOGIKA MESIN PREDIKSI TENSORFLOW.JS
// ===============================================================
    async function loadRegimeSensorModel() {
        console.log("🧠 Memuat Model Sensor Rezim (vFinal)...");
        try {
            const base64Handler = {
                load: async () => {
                    const modelArtifacts = JSON.parse(MODEL_ARTIFACTS_JSON_STRING);
                    const binaryString = window.atob(WEIGHTS_BASE64_STRING);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const weightData = bytes.buffer;

                    return {
                        modelTopology: modelArtifacts.modelTopology, 
                        weightSpecs: modelArtifacts.weightsManifest[0].weights, 
                        weightData: weightData
                    };
                }
            };

            regimeSensorModel = await tf.loadLayersModel(base64Handler);
            console.log('✅ Model Sensor Rezim berhasil dimuat dan siap bekerja!');

        } catch (error) {
            console.error("❌ GAGAL memuat Model Sensor Rezim:", error);
            alert("Terjadi kesalahan fatal saat memuat model AI. Periksa konsol untuk detail.");
            regimeSensorModel = null;
        }
    }

    async function predictMarketRegime(featureArray) {
        if (!regimeSensorModel || !featureArray) {
            return 'RANGING'; 
        }

        return tf.tidy(() => {
            const inputTensor = tf.tensor2d(featureArray, [1, 12]);
            const prediction = regimeSensorModel.predict(inputTensor);
            const predictedClassIndex = prediction.argMax(-1).dataSync()[0];

            return REGIME_LABELS[predictedClassIndex];
        });
    }

// ===================================================================
// BAGIAN BARU: LOGIKA SIMULASI MONTE CARLO
// ===================================================================
    function toggleMonteCarloModal(show) {
            monteCarloModal.classList.toggle('hidden', !show);
    }

    function calculateTradeStats(trades) {
        const pnlList = trades.map(t => t.pnl);
        if (pnlList.length === 0) return { mean: 0, stdDev: 0 };

        const mean = pnlList.reduce((sum, val) => sum + val, 0) / pnlList.length;
        
        const variance = pnlList.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / pnlList.length;
        const stdDev = Math.sqrt(variance);

        return { mean, stdDev };
    }

    function generateRandomNormal(mean, stdDev) {
        let u1 = Math.random();
        let u2 = Math.random();
        let z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        return z0 * stdDev + mean;
    }

    function runMonteCarloSimulation(backtesterInstance, historicalTrades, historicalEquityCurve) {
        const tradeStats = calculateTradeStats(historicalTrades);
        const initialBalance = parseFloat(backtesterInstance.state.settings.initialBalance) || 1000; 
        const NUM_SIMULATIONS = 1000;
        const NUM_TRADES_PER_SIM = historicalTrades.length;

        let allSimulatedCurves = [];
        let finalPnlValues = [];

        for (let i = 0; i < NUM_SIMULATIONS; i++) {
            let currentEquity = initialBalance;
            let equityCurve = [initialBalance];

            for (let j = 0; j < NUM_TRADES_PER_SIM; j++) {
                const randomPnl = generateRandomNormal(tradeStats.mean, tradeStats.stdDev);
                if (isFinite(randomPnl)) {
                    currentEquity += randomPnl;
                }
                equityCurve.push(currentEquity);
            }
            const finalPnl = currentEquity - initialBalance;
            if (isFinite(finalPnl)) {
                finalPnlValues.push(finalPnl);
            }

            allSimulatedCurves.push(equityCurve); 

        }

        const validFinalPnls = finalPnlValues.filter(pnl => isFinite(pnl));
        const averageFinalPnl = validFinalPnls.length > 0 
            ? validFinalPnls.reduce((sum, pnl) => sum + pnl, 0) / validFinalPnls.length 
            : 0; 
        const lossCount = finalPnlValues.filter(pnl => pnl < 0).length;
        const lossProbability = (finalPnlValues.length > 0) ? (lossCount / finalPnlValues.length) * 100 : 0;

        document.getElementById('mc-summary-sims').textContent = NUM_SIMULATIONS.toLocaleString('id-ID');
        document.getElementById('mc-summary-trades').textContent = NUM_TRADES_PER_SIM;
        document.getElementById('mc-summary-avg-pnl').textContent = `${averageFinalPnl.toFixed(2)} USD`;
        document.getElementById('mc-summary-loss-prob').textContent = `${lossProbability.toFixed(1)}%`;

        lastMonteCarloResult = {
            status: "Validated",
            simulations_run: NUM_SIMULATIONS,
            avg_final_pnl_usd: averageFinalPnl,
            loss_probability_percent: lossProbability,
            avgPnl_per_trade: tradeStats.mean,
            stdDevPnl_per_trade: tradeStats.stdDev
        };

        renderMonteCarloChart(allSimulatedCurves, historicalEquityCurve);
    }

    function renderMonteCarloChart(simulatedCurves, historicalEquityCurve) {
        if (!simulatedCurves || simulatedCurves.length === 0 || !historicalEquityCurve || historicalEquityCurve.length === 0) {
            console.error("Gagal merender Monte Carlo: Tidak ada kurva simulasi atau data historis yang valid.");
            return;
        }

        if (simulatedCurves[0].length === 0) {
            console.error("Gagal merender Monte Carlo: Kurva simulasi memiliki panjang nol.");
            return;
        }

        const ctx = document.getElementById('monte-carlo-chart').getContext('2d');

        if (monteCarloChartInstance) {
            monteCarloChartInstance.destroy();
        }

        const numTrades = simulatedCurves[0].length;
        const labels = Array.from({ length: numTrades }, (_, i) => `Trade ${i}`);
      
        let percentile25 = [];
        let percentile75 = [];
        
        for (let i = 0; i < numTrades; i++) {
            let valuesAtStep = simulatedCurves.map(curve => curve[i]).sort((a, b) => a - b);

            if (valuesAtStep.length > 0) {
                percentile25.push(valuesAtStep[Math.floor(0.25 * valuesAtStep.length)]);
                percentile75.push(valuesAtStep[Math.floor(0.75 * valuesAtStep.length)]);
            } else {
                percentile25.push(NaN);
                percentile75.push(NaN);
            }
        }

        const sampleCurves = [];
        for (let i = 0; i < 20; i++) {
            sampleCurves.push(simulatedCurves[Math.floor(Math.random() * simulatedCurves.length)]);
        }

        const datasets = [
            {
                label: 'Rentang Probabilitas 25%-75%',
                data: percentile75,
                fill: '+1', 
                backgroundColor: 'rgba(100, 100, 100, 0.2)',
                borderColor: 'transparent',
                pointRadius: 0,
            },
            {
                label: 'Batas Bawah (25%)',
                data: percentile25,
                borderColor: 'transparent',
                pointRadius: 0,
            },
            {
                label: 'Kinerja Historis',
                data: historicalEquityCurve,
                borderColor: '#3b82f6', 
                borderWidth: 3,
                tension: 0.1,
                pointRadius: 0,
            }
        ];

        sampleCurves.forEach((curve, index) => {
            datasets.push({
                label: `Simulasi #${index + 1}`,
                data: curve,
                borderColor: 'rgba(255, 255, 255, 0.1)',
                borderWidth: 1,
                pointRadius: 0,
                tension: 0.1,
            });
        });

        monteCarloChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets,
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false 
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                    }
                },
                scales: {
                    y: {
                        title: {
                            display: true,
                            text: 'Equity (USD)',
                            color: '#9ca3af'
                        },
                        ticks: { color: '#9ca3af' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Jumlah Trade',
                            color: '#9ca3af'
                        },
                        ticks: { color: '#9ca3af' },
                        grid: { display: false }
                    }
                }
            }
        });
    }
// ===================================================================

// ===================================================================    
// FUNGSI HELPERS UMUM
// ===================================================================
    function normalize(value, min, max) {
        if (max === min) return 1; 
        const normalized = (value - min) / (max - min);
        return Math.max(0, Math.min(1, normalized));
    }

    function calculateSharpeRatio(equityCurve, riskFreeRate = 0.02) {
        if (!equityCurve || equityCurve.length < 10) {
            return 0;
        }

        const returns = [];
        for (let i = 1; i < equityCurve.length; i++) {
            const prevEquity = equityCurve[i - 1];
            const currentEquity = equityCurve[i];
            if (isFinite(prevEquity) && prevEquity > 0 && isFinite(currentEquity) && currentEquity > 0) {
                returns.push(Math.log(currentEquity / prevEquity));
            }
        }
        
        if (returns.length < 2) {
            return 0;
        }
        
        const sumReturns = returns.reduce((sum, r) => sum + r, 0);
        const avgReturnPerTrade = parseFloat(sumReturns.toFixed(15)) / returns.length; 
        
        const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturnPerTrade, 2), 0) / (returns.length - 1);
        const stdDev = Math.sqrt(Math.max(0, variance));
        
        const MIN_STD_DEV = 1e-9; 
        const finalStdDev = Math.max(MIN_STD_DEV, stdDev); 
        
        const finalSharpe = (avgReturnPerTrade - 0) / finalStdDev;
        
        return isFinite(finalSharpe) ? finalSharpe : 0;
    }

    async function fetchBinanceFuturesSymbols() {
        if (binanceFuturesSymbolsCache) {
            return; 
        }
        try {
            const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
            const data = await response.json();
            binanceFuturesSymbolsCache = data.symbols
                .filter(s => s.contractType === 'PERPETUAL' && s.status === 'TRADING' && s.quoteAsset === 'USDT')
                .map(s => s.symbol);
        } catch (error) {
            console.error("Gagal mengambil daftar simbol Binance Futures:", error);
            alert("Tidak dapat memuat daftar aset dari Binance. Periksa koneksi internet Anda.");
            binanceFuturesSymbolsCache = []; 
        }
    }

    async function fetchBinanceKlines(symbol, interval, limit, endTime) {
            const baseUrl = 'https://fapi.binance.com/fapi/v1';
            const params = new URLSearchParams({ symbol, interval, limit, endTime });
            const url = `${baseUrl}/klines?${params.toString()}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Cek Asset Symbol! Binance API${response.status}`);
                return await response.json();
            } catch (error) {
                console.error(`Nama Koin Salah or Server Down ${url}:`, error);
                throw error;
            }
        }
 
    function getCurrentMarketSessions() {
        const now = new Date();
        const utcHours = now.getUTCHours();
        const utcMinutes = now.getUTCMinutes();
        const utcTime = utcHours + utcMinutes / 60;
        const sessions = {
            tokyo: { open: 0, close: 8 },      
            london: { open: 7, close: 16 },   
            newyork: { open: 13, close: 22 },  
            nyse: { open: 13.5, close: 20 }    
        };
            
        const status = {};
        for (const [market, hours] of Object.entries(sessions)) {
            status[market] = utcTime >= hours.open && utcTime < hours.close ? 'OPEN' : 'CLOSED';
        }
            
        return status;
    }
    
    function generateIndicatorCacheKey(settings) {
        const timeframeParams = timeframeParameterMap[settings.timeframe] || timeframeParameterMap['15m'];
        const relevantParams = {
            symbol: settings.symbol,
            timeframe: settings.timeframe,
            startDate: settings.startDate,
            endDate: settings.endDate,
            rsi_period: timeframeParams.rsi_period,
            macd_fast: timeframeParams.macd_fast,
            macd_slow: timeframeParams.macd_slow,
            macd_signal: timeframeParams.macd_signal,
            stoch_rsi_period: timeframeParams.stoch_rsi_period,
            stoch_stoch_period: timeframeParams.stoch_stoch_period,
            stoch_k_smooth: timeframeParams.stoch_k_smooth,
            stoch_d_smooth: timeframeParams.stoch_d_smooth
        };
            
        return 'indicatorCache_' + JSON.stringify(relevantParams);
    }
// ===================================================================    
// OBJEK UTAMA MESIN EVOLUSI GENOME
// ===================================================================
    function gaussianRandom(mean = 0, stdev = 1) {
        const u = 1 - Math.random(); 
        const v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return z * stdev + mean;
    }

    function createStrategyGenome() {
        const emaPeriods = [9, 13, 21];
        const lookbacks = [10, 15, 25];
        const emaChoice = emaPeriods[Math.floor(Math.random() * emaPeriods.length)];
        const lookbackChoice = (emaChoice === 9) ? lookbacks[Math.floor(Math.random()*2)] : lookbacks[1 + Math.floor(Math.random()*2)];
        const riskRewardRatio = Math.max(1.2, Math.min(3.0, gaussianRandom(1.8, 0.3))); // Rata-rata 1.8
        const archetypes = ['trend', 'reversal', 'breakout'];
        const chosenArchetype = archetypes[Math.floor(Math.random() * archetypes.length)];
        let weights = {};
        const allIndicators = ['ma', 'rsiDivergence', 'macd', 'pivot', 'vwap', 'ichimoku', 'candlePattern', 'obvDivergence', 'bbSqueeze', 'psar', 'roc', 'bollingerBands', 'rsi', 'stoch', 'linreg'];

        allIndicators.forEach(indicator => {
            weights[indicator] = (Math.random() * 1.0) + 0.5; 
        });

        if (chosenArchetype === 'trend') {
            ['ma', 'psar', 'ichimoku', 'macd'].forEach(k => weights[k] = (Math.random() * 1.5) + 2.0);
        } else if (chosenArchetype === 'reversal') {
            ['rsiDivergence', 'bollingerBands', 'stoch'].forEach(k => weights[k] = (Math.random() * 1.5) + 2.0);
        } else if (chosenArchetype === 'breakout') {
            ['bbSqueeze', 'roc', 'obvDivergence'].forEach(k => { if(weights[k]) weights[k] = (Math.random() * 1.5) + 2.0; });
        }

        return {
            riskRewardRatio: riskRewardRatio,
            pullbackEmaPeriod: emaChoice,
            swingLookback: lookbackChoice,
            biasThreshold: Math.floor(Math.max(5, Math.min(25, gaussianRandom(15, 4)))), // Rata-rata 15
            atrFilterThreshold: (Math.random() * 0.0015),
            weights: weights,
            fitness: 0,
            metrics: {}
        };
    }
    
    function createInitialPopulation(size) {
        return Array.from({ length: size }, () => createStrategyGenome());
    }

    function createNextGeneration(evaluatedPopulation) {
        const sortedPopulation = [...evaluatedPopulation].sort((a, b) => b.fitness - a.fitness);
        const newPopulation = [];

        newPopulation.push(sortedPopulation[0], sortedPopulation[1]);

        while (newPopulation.length < evolutionState.populationSize) {
            const parent1 = selectParent(sortedPopulation);
            const parent2 = selectParent(sortedPopulation);
            const child = crossover(parent1, parent2);

            mutate(child);

            newPopulation.push(child);
        }

        return newPopulation;
    }

    function findChampion(population) {
        return population.reduce((best, current) => current.fitness > best.fitness ? current : best, population[0]);
    }

    function selectParent(population) {
        const tournamentSize = 5;
        let tournament = [];
        for(let i=0; i<tournamentSize; i++) {
            tournament.push(population[Math.floor(Math.random() * population.length)]);
        }
        return findChampion(tournament);
    }

    function crossover(parent1, parent2) {
        const child = {
            weights: {} 
        };
        const params = ['riskRewardRatio', 'pullbackEmaPeriod', 'swingLookback', 'biasThreshold', 'atrFilterThreshold'];
        params.forEach(key => {
            child[key] = Math.random() > 0.5 ? parent1[key] : parent2[key];
        });

        for (const key in parent1.weights) {
            child.weights[key] = Math.random() > 0.5 ? parent1.weights[key] : parent2.weights[key];
        }
 
        child.fitness = 0;
        child.metrics = {};

        return child;
    }

    function mutate(genome) {
        const mutationRate = evolutionState.mutationRate; 

        if (Math.random() < mutationRate) {
            genome.riskRewardRatio += gaussianRandom(0, 0.1); // Guncangan rata-rata 0, std dev 0.1
            genome.riskRewardRatio = Math.max(1.2, Math.min(3.0, genome.riskRewardRatio)); // Jaga dalam rentang
        }
        
        // Mutasi Swing Lookback dengan memilih tetangga terdekat
        if (Math.random() < mutationRate) {
            const options = [10, 15, 25];
            const currentIndex = options.indexOf(genome.swingLookback);
            const move = Math.random() < 0.5 ? -1 : 1;
            const newIndex = (currentIndex + move + options.length) % options.length;
            genome.swingLookback = options[newIndex];
        }

        // Mutasi Bias Threshold dengan guncangan kecil
        if (Math.random() < mutationRate) { // <-- BUG diperbaiki di sini
            genome.biasThreshold += gaussianRandom(0, 1); // Guncangan rata-rata 0, std dev 1
            genome.biasThreshold = Math.round(Math.max(5, Math.min(25, genome.biasThreshold)));
        }

        // Mutasi EMA Period (sama seperti Swing Lookback)
        if (Math.random() < mutationRate) {
            const options = [9, 13, 21];
            const currentIndex = options.indexOf(genome.pullbackEmaPeriod);
            const move = Math.random() < 0.5 ? -1 : 1;
            const newIndex = (currentIndex + move + options.length) % options.length;
            genome.pullbackEmaPeriod = options[newIndex];
        }

        // Mutasi ATR Filter
        if (Math.random() < mutationRate) {
            const atrMutation = gaussianRandom(0, 0.0001);
            genome.atrFilterThreshold = Math.max(0, genome.atrFilterThreshold + atrMutation);        }
        
        // Mutasi bobot indikator
        for(const key in genome.weights) {
            if (Math.random() < mutationRate) {
                const mutationAmount = gaussianRandom(0, 0.2); // Guncangan kecil yang lebih terkontrol
                genome.weights[key] = Math.max(0.5, Math.min(3.5, genome.weights[key] + mutationAmount));
            }
        }
    }
// ==========================================================
// FUNGSI UTAMA (MAIN)
// ========================================================== 
    async function main() {
        const backtestSymbolInput = document.getElementById('backtest-symbol-input');
        const backtestStartDate = document.getElementById('backtest-start-date');
        const backtestEndDate = document.getElementById('backtest-end-date');
        const backtestTimeframeSelect = document.getElementById('backtest-timeframe-select');
        const backtestInitialBalance = document.getElementById('backtest-initial-balance');
        const backtestLeverageInput = document.getElementById('backtest-leverage-input');
        const startBacktestBtn = document.getElementById('start-backtest-btn');
        const stopBacktestBtn = document.getElementById('stop-backtest-btn');
        const backtestProgressContainer = document.getElementById('backtest-progress-container');
        const backtestStatusText = document.getElementById('backtest-status-text');
        const backtestProgressBar = document.getElementById('backtest-progress-bar');
        const backtestResultsContainer = document.getElementById('backtest-results-container');
        const backtestPnl = document.getElementById('backtest-result-pnl');
        const backtestWinrate = document.getElementById('backtest-result-winrate');
        const backtestProfitFactor = document.getElementById('backtest-result-profit-factor');
        const backtestTotalTrades = document.getElementById('backtest-result-total-trades');
        const backtestTradeLogContainer = document.getElementById('backtest-trade-log-container');
        const backtestTradeLog = document.getElementById('backtest-trade-log');
        const labRegimePreset = document.getElementById('lab-regime-preset');
        const labRrRatioInput = document.getElementById('lab-rr-ratio');
        const labEmaPeriodInput = document.getElementById('lab-ema-period');
        const labSwingLookbackInput = document.getElementById('lab-swing-lookback');
        const labBiasThresholdInput = document.getElementById('lab-bias-threshold');
        const labRiskPercentInput = document.getElementById('lab-risk-percent');
        const labMarginModeSelect = document.getElementById('lab-margin-mode');
        const labWeightsContainer = document.getElementById('lab-weights-tuning');
        const tuningRecommendationSection = document.getElementById('tuning-recommendation-section');
        const exportConfigBtn = document.getElementById('export-config-btn');
        const labTakerFeeInput = document.getElementById('lab-taker-fee');
        const labMakerFeeInput = document.getElementById('lab-maker-fee');
        const labSlippageModelSelect = document.getElementById('lab-slippage-model');
        const labAtrFilterInput = document.getElementById('lab-atr-filter-input');
        const startGenesisBtn = document.getElementById('start-genesis-btn');
        const stopGenesisBtn = document.getElementById('stop-genesis-btn'); 
        const candleCountInput = document.getElementById('duration-candle-input');
        const applyDurationBtn = document.getElementById('duration-apply-btn');
        const replaySpeedSlider = document.getElementById('replay-speed-slider');
        const replaySpeedLabel = document.getElementById('replay-speed-label');
        const exportDnaBtn = document.getElementById('export-dna-btn');
        runMonteCarloBtn = document.getElementById('run-monte-carlo-btn');
        monteCarloModal = document.getElementById('monte-carlo-modal');
        monteCarloCloseBtn = document.getElementById('monte-carlo-close-btn');
// ===================================================================
// PUSTAKA FUNGSI KALKULASI MURNI (VERSI LENGKAP & SINKRON)
// ===================================================================
        const calculateEMA = (data, period) => {
            if (!data || data.length < period) {
                return [];
            }

            const k = 2 / (period + 1);
            let emaArray = [];

            if (data.length > 0) {
                let sum = 0;
                for (let i = 0; i < period; i++) {
                sum += data[i] || 0;
                }
                emaArray[period - 1] = sum / period;
                for (let i = period; i < data.length; i++) {
                emaArray[i] = (data[i] * k) + (emaArray[i - 1] * (1 - k));
                }
            }

            return emaArray;
        };
        
        const calculateSMA = (data, period) => {
            if (!data || data.length < period) {
                return [];
            }
            
            let sma = [];
            let sum = 0;

            for (let i = 0; i < period; i++) {
                sum += data[i];
            }
            sma.push(sum / period);

            for (let i = period; i < data.length; i++) {
                sum = sum - data[i - period] + data[i];
                sma.push(sum / period);
            }

            const alignedSma = [...Array(period - 1).fill(undefined), ...sma];
            
            return alignedSma;
        };

        const calculateRSI = (closes, period) => {
            if (period === undefined) {
                const timeframe = backtestTimeframeSelect.value;
                period = timeframeParameterMap[timeframe]?.rsi_period || 14;
            }
            
            if (!closes || closes.length <= period) {
                return Array(closes.length).fill(undefined);
            }
            
            let gains = [];
            let losses = [];
            for (let i = 1; i < closes.length; i++) {
                const diff = closes[i] - closes[i - 1];
                gains.push(diff > 0 ? diff : 0);
                losses.push(diff < 0 ? -diff : 0);
            }
            let rsi = Array(period).fill(undefined);
            let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;
            rsi[period - 1] = (avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss)));
            for (let i = period; i < gains.length; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
                rsi.push((avgLoss === 0) ? 100 : 100 - (100 / (1 + (avgGain / avgLoss))));
            }
            return rsi;
        };
        
        const calculateMACD = (closes, fast, slow, signal) => {
            if (fast === undefined) {
                const timeframe = backtestTimeframeSelect.value;
                const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];
                fast = params.macd_fast;
                slow = params.macd_slow;
                signal = params.macd_signal;
            }
            
            if (closes.length < slow) {
                return { status: 'Netral', macdLine: [], signalLine: [], histogram: [] };
            }
            
            const emaFast = calculateEMA(closes, fast);
            const emaSlow = calculateEMA(closes, slow);
            const macdLine = emaSlow.map((slowVal, i) => {
                if (slowVal !== undefined && emaFast[i] !== undefined) {
                    return emaFast[i] - slowVal;
                }
                return undefined;
            }).filter(v => v !== undefined);
            const signalLine = calculateEMA(macdLine, signal);
            const histogram = macdLine.map((macdVal, i) => {
                const sigVal = signalLine[i] !== undefined ? signalLine[i] : (signalLine.length > 0 ? signalLine.pop() : undefined);
                if (sigVal !== undefined) {
                    const histValue = macdVal - sigVal;
                    const prevHistValue = (i > 0 && macdLine[i - 1] !== undefined && signalLine[i - 1] !== undefined) ? (macdLine[i - 1] - signalLine[i - 1]) : 0;
                    return {
                        value: histValue,
                        color: histValue >= 0 ? (histValue >= prevHistValue ? '#26a69a' : '#80cbc4') : (histValue < prevHistValue ? '#ef5350' : '#e57373')
                    };
                }
                return undefined;
            }).filter(v => v !== undefined);
            const lastMacd = macdLine.pop() || 0;
            const lastSig = signalLine.pop() || 0;
            const prevMacdLine = macdLine.pop() || 0;
            const prevSignalLine = signalLine.pop() || 0;
            let status = 'Netral';
            if (prevMacdLine <= prevSignalLine && lastMacd > lastSig) {
                status = 'Bullish Cross';
            } else if (prevMacdLine >= prevSignalLine && lastMacd < lastSig) {
                status = 'Bearish Cross';
            }
            return { status, macdLine, signalLine, histogram };
        };

        const calculateStochasticRSI = (closes, rsiPeriod, stochPeriod, kSmooth, dSmooth) => {
            if (rsiPeriod === undefined) {
                const timeframe = backtestTimeframeSelect.value;
                const params = timeframeParameterMap[timeframe] || timeframeParameterMap['15m'];
                rsiPeriod = params.stoch_rsi_period;
                stochPeriod = params.stoch_stoch_period;
                kSmooth = params.stoch_k_smooth;
                dSmooth = params.stoch_d_smooth;
            }

            const rsiValues = calculateRSI(closes, rsiPeriod);
            const validRsi = rsiValues.filter(v => v !== undefined);
            if (validRsi.length < stochPeriod) {
                return { kLine: [], dLine: [], status: 'Netral' };
            }
            
            let stochArr = [];
            for (let i = stochPeriod - 1; i < validRsi.length; i++) {
                const window = validRsi.slice(i - stochPeriod + 1, i + 1);
                const minR = Math.min(...window);
                const maxR = Math.max(...window);
                const denom = maxR - minR;
                stochArr.push(denom === 0 ? 0 : ((validRsi[i] - minR) / denom) * 100);
            }
            const kLineRaw = calculateSMA(stochArr, kSmooth);
            const dLineRaw = calculateSMA(kLineRaw.filter(v => v !== undefined), dSmooth);
            const kLine = kLineRaw.filter(v => v !== undefined);
            const dLine = dLineRaw.filter(v => v !== undefined);
            const lastK = kLine.pop() || 50;
            const lastD = dLine.pop() || 50;
            let status = 'Netral';
            if (lastK > 80 && lastD > 80) status = 'Overbought';
            else if (lastK < 20 && lastD < 20) status = 'Oversold';
            return { kLine, dLine, status };
        };

        const detectRSIDivergence = (closes, rsiValues, lookback = 30) => {
            if (!closes || closes.length < lookback || !rsiValues || rsiValues.length < lookback) return { status: 'NONE' };
            const recentCloses = closes.slice(-lookback), recentRSI = rsiValues.slice(-lookback);
            const findPivots = (data, isHigh) => {
                let pivots = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                        pivots.push({ index: i, value: data[i] });
                    }
                }
                return pivots;
            };
            const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
            const rsiLows = findPivots(recentRSI, false), rsiHighs = findPivots(recentRSI, true);
            if (priceLows.length >= 2 && rsiLows.length >= 2) {
                const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
                const lastRsiLow = rsiLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevRsiLow = rsiLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
                if (lastPriceLow && prevPriceLow && lastRsiLow && prevRsiLow && lastPriceLow.value < prevPriceLow.value && lastRsiLow.value > prevRsiLow.value) return { status: 'BULLISH' };
            }
            if (priceHighs.length >= 2 && rsiHighs.length >= 2) {
                const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
                const lastRsiHigh = rsiHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevRsiHigh = rsiHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
                if (lastPriceHigh && prevPriceHigh && lastRsiHigh && prevRsiHigh && lastPriceHigh.value > prevPriceHigh.value && lastRsiHigh.value < prevRsiHigh.value) return { status: 'BEARISH' };
            }
            return { status: 'NONE' };
        };

        const calculateOBV = (klines) => {
            if (!klines || klines.length < 2) return [];
            let obv = [0]; 
            for (let i = 1; i < klines.length; i++) {
                const close = parseFloat(klines[i][4]);
                const prevClose = parseFloat(klines[i-1][4]);
                const volume = parseFloat(klines[i][5]);
                if (close > prevClose) obv.push(obv[i-1] + volume);
                else if (close < prevClose) obv.push(obv[i-1] - volume);
                else obv.push(obv[i-1]);
            }
            return obv;
        };

        const detectOBVDivergence = (closes, klines, lookback = 30) => {
            if (!closes || closes.length < lookback || !klines || klines.length < lookback) return { status: 'NONE', class: 'text-gray-500' };

            const obvValues = calculateOBV(klines);
            const recentCloses = closes.slice(-lookback);
            const recentOBV = obvValues.slice(-lookback);

            const findPivots = (data, isHigh) => {
                let pivots = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if ((isHigh && data[i] > data[i - 1] && data[i] > data[i + 1]) || (!isHigh && data[i] < data[i - 1] && data[i] < data[i + 1])) {
                        pivots.push({ index: i, value: data[i] });
                    }
                }
                return pivots;
            };

            const priceLows = findPivots(recentCloses, false), priceHighs = findPivots(recentCloses, true);
            const obvLows = findPivots(recentOBV, false), obvHighs = findPivots(recentOBV, true);

            if (priceLows.length >= 2 && obvLows.length >= 2) {
                const lastPriceLow = priceLows[priceLows.length - 1], prevPriceLow = priceLows[priceLows.length - 2];
                const lastObvLow = obvLows.find(l => Math.abs(l.index - lastPriceLow.index) < 3), prevObvLow = obvLows.find(l => Math.abs(l.index - prevPriceLow.index) < 3);
                if (lastPriceLow && prevPriceLow && lastObvLow && prevObvLow && lastPriceLow.value < prevPriceLow.value && lastObvLow.value > prevObvLow.value) return { status: 'BULLISH', class: 'positive blinking-text-animation' };
            }
            if (priceHighs.length >= 2 && obvHighs.length >= 2) {
                const lastPriceHigh = priceHighs[priceHighs.length - 1], prevPriceHigh = priceHighs[priceHighs.length - 2];
                const lastObvHigh = obvHighs.find(h => Math.abs(h.index - lastPriceHigh.index) < 3), prevObvHigh = obvHighs.find(h => Math.abs(h.index - prevPriceHigh.index) < 3);
                if (lastPriceHigh && prevPriceHigh && lastObvHigh && prevObvHigh && lastPriceHigh.value > prevPriceHigh.value && lastObvHigh.value < prevObvHigh.value) return { status: 'BEARISH', class: 'negative blinking-text-animation' };
            }
            return { status: 'NONE', class: 'text-gray-500' };
        };

        const findCandlestickPatterns = (klines) => {
            if (!klines || klines.length < 2) return { bias: 'NETRAL' };
            const getCandle = (k) => {
                const [o, h, l, c] = k.slice(1, 5).map(parseFloat);
                return { open: o, close: c, isGreen: c > o, isRed: c < o };
            };
            const c1 = getCandle(klines[klines.length - 1]), c2 = getCandle(klines[klines.length - 2]);
            if (c2.isRed && c1.isGreen && c1.close > c2.open) return { bias: 'BULLISH' };
            if (c2.isGreen && c1.isRed && c1.close < c2.open) return { bias: 'BEARISH' };
            return { bias: 'NETRAL' };
        };

        const calculateBollingerBands = (closes, period = 20, stdDev = 2) => {
            if (closes.length < period) {
                return { upper: [], middle: [], lower: [], squeezeStatus: 'N/A' };
            }

            const middle = calculateSMA(closes, period);
            const upper = [];
            const lower = [];
            const width = [];

            let sum = 0;
            let sumOfSquares = 0;

            const initialSlice = closes.slice(0, period);
            for (const val of initialSlice) {
                sum += val;
                sumOfSquares += val * val;
            }

            const calculateAndPushBands = (currentSum, currentSumOfSquares) => {
                const mean = currentSum / period;
                const variance = (currentSumOfSquares / period) - (mean * mean);
                const stdev = Math.sqrt(Math.max(0, variance)); 

                upper.push(mean + (stdev * stdDev));
                lower.push(mean - (stdev * stdDev));
                width.push((stdev * stdDev * 2));
            };

            calculateAndPushBands(sum, sumOfSquares);

            for (let i = period; i < closes.length; i++) {
                const oldVal = closes[i - period];
                const newVal = closes[i];

                sum = sum - oldVal + newVal;
                sumOfSquares = sumOfSquares - (oldVal * oldVal) + (newVal * newVal);
                
                calculateAndPushBands(sum, sumOfSquares);
            }
            
            const lastWidth = width.filter(v => v !== undefined).pop();
            let squeezeStatus = 'Normal';
            if (width.length > 50) {
            }

            const align = (arr) => [...Array(period - 1).fill(undefined), ...arr];

            return { 
                upper: align(upper), 
                middle: middle, 
                lower: align(lower), 
                squeezeStatus 
            };
        };

        function calculatePredictionInput(klinesSnapshot) {
            if (klinesSnapshot.length < 50) return null;
            const closes = klinesSnapshot.map(k => parseFloat(k[4]));
            const rsiValues = calculateRSI(closes, 14);
            const stochRsiData = calculateStochasticRSI(closes);
            const macdData = calculateMACD(closes);
            const bbData = calculateBollingerBands(closes);
            const vwap = calculateVWAP(klinesSnapshot, 20);
            const atrData = calculateATR(klinesSnapshot);
            const currentClose = closes[closes.length - 1];
            const lastRsi = rsiValues.filter(v => v !== undefined).pop() || 50;
            const lastK = stochRsiData.kLine.filter(v => v !== undefined).pop() || 50;
            const lastD = stochRsiData.dLine.filter(v => v !== undefined).pop() || 50;
            const prevK = stochRsiData.kLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
            const prevD = stochRsiData.dLine.filter(v => v !== undefined).slice(-2, -1)[0] || 50;
            const macdLine = macdData.macdLine.filter(v => v !== undefined).pop() || 0;
            const signalLine = macdData.signalLine.filter(v => v !== undefined).pop() || 0;
            const macdHist = macdData.histogram.filter(v => v !== undefined).pop()?.value || 0;
            const ema50 = calculateEMA(closes, 50).pop() || currentClose;
            const bbUpper = bbData.upper.filter(v => v !== undefined).pop() || currentClose;
            const bbMiddle = bbData.middle.filter(v => v !== undefined).pop() || currentClose;
            const bbLower = bbData.lower.filter(v => v !== undefined).pop() || currentClose;
            const features = {
                rsi: lastRsi,
                macd_cross: macdLine > signalLine ? 1 : -1,
                macd_hist: macdHist,
                ema_dist: (currentClose - ema50) / ema50,
                bb_width: (bbUpper - bbLower) / bbMiddle,
                bb_pos: (currentClose - bbLower) / (bbUpper - bbLower),
                vwap_dist: (currentClose - vwap) / vwap,
                atr_percent: atrData.atrPercent,
                stoch_rsi_k: lastK,
                stoch_rsi_d: lastD,
                stoch_rsi_cross: (prevK <= prevD && lastK > lastD) ? 1 : ((prevK >= prevD && lastK < lastD) ? -1 : 0),
                stoch_rsi_state: (lastK > 80 && lastD > 80) ? 1 : ((lastK < 20 && lastD < 20) ? -1 : 0)
            };
            const featureOrder = ['rsi','macd_cross','macd_hist','ema_dist','bb_width','bb_pos','vwap_dist','atr_percent','stoch_rsi_k','stoch_rsi_d','stoch_rsi_cross','stoch_rsi_state'];
            const inputArray = featureOrder.map(key => features[key] || 0);
            if (inputArray.some(val => !isFinite(val))) {
                console.warn("Input tidak valid terdeteksi, dilewati.", inputArray);
                return null;
            }
            return inputArray;
        }

        const calculateADX = (klines, period = 14) => {
            if (!klines || klines.length < period * 2) {
                return { value: 0, plusDI: 0, minusDI: 0 };
            }

            const trs = [];
            const plusDMs = [];
            const minusDMs = [];
            
            for (let i = 1; i < klines.length; i++) {
                const high = parseFloat(klines[i][2]);
                const low = parseFloat(klines[i][3]);
                const prevHigh = parseFloat(klines[i - 1][2]);
                const prevLow = parseFloat(klines[i - 1][3]);
                const prevClose = parseFloat(klines[i-1][4]);
                
                const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));
                trs.push(tr);

                const upMove = high - prevHigh;
                const downMove = prevLow - low;
                
                plusDMs.push(upMove > downMove && upMove > 0 ? upMove : 0);
                minusDMs.push(downMove > upMove && downMove > 0 ? downMove : 0);
            }

            const rma = (data, p) => {
                let result = [];
                if (data.length < p) return data.map(() => undefined);

                let sum = data.slice(0, p).reduce((acc, val) => acc + val, 0);
                result.push(sum / p);

                for (let i = p; i < data.length; i++) {
                    const prevRma = result[result.length - 1]; 
                    const nextRma = (prevRma * (p - 1) + data[i]) / p;
                    result.push(nextRma);
                }
                
                return [...Array(p - 1).fill(undefined), ...result];
            };
            
            const smoothedTRs = rma(trs, period);
            const smoothedPlusDMs = rma(plusDMs, period);
            const smoothedMinusDMs = rma(minusDMs, period);

            const dxs = [];
            const plusDIs = [];
            const minusDIs = [];

            for (let i = period -1; i < klines.length -1; i++) {
                const smoothedTR = smoothedTRs[i];
                if (smoothedTR === undefined || smoothedTR === 0) {
                    dxs.push(dxs.length > 0 ? dxs[dxs.length-1] : 0); 
                    plusDIs.push(0);
                    minusDIs.push(0);
                    continue;
                }
                const plusDI = Math.max(0, (smoothedPlusDMs[i] / smoothedTR) * 100);
                const minusDI = Math.max(0, (smoothedMinusDMs[i] / smoothedTR) * 100);
                plusDIs.push(plusDI);
                minusDIs.push(minusDI);

                const diSum = plusDI + minusDI;
                dxs.push(diSum > 0 ? (Math.abs(plusDI - minusDI) / diSum) * 100 : 0);
            }
            
            const adxValues = rma(dxs.filter(v => !isNaN(v)), period);
            const lastADX = adxValues[adxValues.length - 1] || 0;
            const lastPlusDI = plusDIs[plusDIs.length-1] || 0;
            const lastMinusDI = minusDIs[minusDIs.length-1] || 0;
            
            return {
                value: lastADX,
                plusDI: lastPlusDI,
                minusDI: lastMinusDI
            };
        };

        function calculatePivotPoints(prevDayKline) {
            if (!prevDayKline || prevDayKline.length < 5) return null;
            const high = parseFloat(prevDayKline[2]);
            const low = parseFloat(prevDayKline[3]);
            const close = parseFloat(prevDayKline[4]);
            if (isNaN(high) || isNaN(low) || isNaN(close)) return null;
            return { P: (high + low + close) / 3 };
        }

        function calculateVWAP(klines, period = 20) {
            if (!klines || klines.length < period) return 0;
            let sumPV = 0, sumV = 0;
            const dataSlice = klines.slice(-period);
            dataSlice.forEach(k => {
                const high = parseFloat(k[2]), low = parseFloat(k[3]), close = parseFloat(k[4]), vol = parseFloat(k[5]);
                sumPV += ((high + low + close) / 3) * vol;
                sumV += vol;
            });
            return sumV > 0 ? sumPV / sumV : 0;
        }

        function calculateIchimokuCloud(klines) {
            if (klines.length < 52) return { status: 'Netral' };
            const getHighLow = (slice) => ({ high: Math.max(...slice.map(k => parseFloat(k[2]))), low: Math.min(...slice.map(k => parseFloat(k[3]))) });
            let tenkan = [], kijun = [];
            for (let i = 0; i < klines.length; i++) {
                const tenkanHighLow = i >= 8 ? getHighLow(klines.slice(i - 8, i + 1)) : {};
                tenkan.push(tenkanHighLow.high ? (tenkanHighLow.high + tenkanHighLow.low) / 2 : undefined);
                const kijunHighLow = i >= 25 ? getHighLow(klines.slice(i - 25, i + 1)) : {};
                kijun.push(kijunHighLow.high ? (kijunHighLow.high + kijunHighLow.low) / 2 : undefined);
            }
            const lastPrice = parseFloat(klines[klines.length - 1][4]);
            const lastTenkan = tenkan[tenkan.length - 1], lastKijun = kijun[kijun.length - 1];
            if (lastTenkan > lastKijun && lastPrice > lastKijun) return { status: "BULLISH" };
            if (lastTenkan < lastKijun && lastPrice < lastKijun) return { status: "BEARISH" };
            return { status: 'Netral' };
        }

        function calculateParabolicSAR(klines, step = 0.02, max = 0.2) {
            if (klines.length < 2) return { status: 'N/A' };
            let sar = parseFloat(klines[0][3]); let ep = parseFloat(klines[0][2]); let af = step; let isUptrend = true;
            for (let i = 1; i < klines.length; i++) {
                const high = parseFloat(klines[i][2]); const low = parseFloat(klines[i][3]); const prevSar = sar;
                if (isUptrend) { sar = prevSar + af * (ep - prevSar); if (low < sar) { isUptrend = false; sar = ep; ep = low; af = step; } else { if (high > ep) { ep = high; af = Math.min(max, af + step); } }
                } else { sar = prevSar - af * (prevSar - ep); if (high > sar) { isUptrend = true; sar = ep; ep = high; af = step; } else { if (low < ep) { ep = low; af = Math.min(max, af + step); } } }
            }
            const lastClose = parseFloat(klines[klines.length - 1][4]);
            return { status: lastClose > sar ? 'Bullish' : 'Bearish' };
        }

        function calculateROC(closes, period = 12) {
            if (closes.length < period + 1) return { status: 'N/A' };
            const currentClose = closes[closes.length - 1];
            const pastClose = closes[closes.length - 1 - period];
            if (pastClose === 0) return { status: 'N/A' };
            const roc = ((currentClose - pastClose) / pastClose) * 100;
            return { status: roc > 0 ? 'Positif' : 'Negatif' };
        }

        function calculateLinearRegressionChannel(closes, period = 14) {
            if (closes.length < period) return { status: 'N/A' };
            const y = closes.slice(-period); const n = period; const sumX = (n * (n - 1)) / 2; const sumY = y.reduce((a, b) => a + b, 0); const sumXY = y.reduce((acc, val, i) => acc + val * i, 0); const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            return { status: slope > 0 ? 'BULLISH' : 'BEARISH' };
        }

        function calculateATR(klines, period = 14) {
            if (!klines || klines.length < period + 1) {
                return { value: 0, status: 'N/A', atrPercent: 0 };
            }
            let trs = [];
            for (let i = 1; i < klines.length; i++) {
                const high = parseFloat(klines[i][2]);
                const low = parseFloat(klines[i][3]);
                const prevClose = parseFloat(klines[i - 1][4]);
                trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
            }
            const rma = (data, p) => {
                let smoothed = [];
                let sum = 0;
                for(let i=0; i<data.length; i++) {
                    if (i < p) {
                        sum += data[i];
                        if (i === p - 1) smoothed.push(sum/p);
                        else smoothed.push(undefined);
                    } else if (smoothed[i-1] !== undefined) {
                        smoothed.push((smoothed[i - 1] * (p - 1) + data[i]) / p);
                    }
                }
                return smoothed;
            };
            const atrValues = rma(trs, period);
            const atr = atrValues.pop() || 0;
            const lastClose = parseFloat(klines[klines.length - 1][4]);
            const atrPercent = lastClose > 0 ? (atr / lastClose) * 100 : 0;
            let status;
            if (atrPercent > 5) status = 'Very High';
            else if (atrPercent > 2.5) status = 'High';
            else if (atrPercent < 1) status = 'Low';
            else status = 'Normal';
            return { value: atr, status: status, atrPercent: atrPercent }; 
        }

        function getUltimateSignalScore(indicator, signalData) {
            const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
            const mapRange = (x, inMin, inMax, outMin, outMax) => {
                const t = (x - inMin) / (inMax - inMin);
                return outMin + clamp(t, 0, 1) * (outMax - outMin);
            };       
            const confidence = (typeof signalData?.confidence === 'number')
                ? clamp(signalData.confidence, 0, 1)
                : 1;
            const text = (signalData?.status || signalData?.bias || signalData?.signal || '').toString().toUpperCase();
            const biasSigned = (typeof signalData?.biasSigned === 'number')
                ? Math.sign(signalData.biasSigned)
                : null;
            if (['ma','macd','rsi','stoch','psar','linreg','roc','pivot','vwap','ichimoku','candlePattern','bollingerBands'].includes(indicator)) {
                if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
                if (text.includes('BULL')) return +1 * confidence;
                if (text.includes('BEAR')) return -1 * confidence;
                return 0;
            }
            if (indicator === 'rsiDivergence' || indicator === 'obvDivergence') {
                if (text.includes('BULL')) return +1 * confidence;
                if (text.includes('BEAR')) return -1 * confidence;
                return 0;
            }
            if (indicator === 'openInterest') {
                if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
                if (text.includes('UP')) return +1 * confidence;
                if (text.includes('DOWN')) return -1 * confidence;
                return 0;
            }
            if (indicator === 'funding' || indicator === 'fundingRate') {
                const v = typeof signalData?.value === 'number' ? signalData.value : 0;
                const s = Math.max(-1, Math.min(1, v / 0.0025));
                return s * confidence;
                }
            if (indicator === 'lsr' || indicator === 'lsRatio') {
                const v = typeof signalData?.value === 'number' ? signalData.value : 1;
                const s = Math.max(-1, Math.min(1, (v - 1) / 0.3));
                return s * confidence;
                }
            if (indicator === 'orderBookBias') {
                if (biasSigned !== null) return clamp(biasSigned, -1, 1) * confidence;
                if (text.includes('BID')) return +1 * confidence;
                if (text.includes('ASK')) return -1 * confidence;
                return 0;
            }
            if (indicator === 'bbSqueeze') {
                const st = (signalData?.status || '').toString().toUpperCase();
                if (st.includes('RELEASE')) return +1 * confidence;
                if (st.includes('ON')) return 0;
                if (st.includes('OFF')) return 0.3 * confidence;
                return 0;
            }
            return 0;
        }

        function createTFAlignmentSummary(klines, timeframes, marketType) {
            const summary = {};
            
            let score = 0;
            timeframes.forEach(tf => {
                if (klines[tf] && klines[tf].length >= 50) {
                    const closes = klines[tf].map(k => parseFloat(k[4]));
                    const ema21 = calculateEMA(closes, 21);
                    const ema50 = calculateEMA(closes, 50);
                    const lastEma21 = ema21[ema21.length - 1];
                    const lastEma50 = ema50[ema50.length - 1];
                    summary[tf] = lastEma21 > lastEma50 ? 'UPTREND' : 'DOWNTREND';
                } else {
                    summary[tf] = 'N/A';
                }
                if (summary[tf] === 'UPTREND') score++;
                else if (summary[tf] === 'DOWNTREND') score--;
            });
            return { summary, score };
        }

        function calculateConfluenceScoreForCandle(activeWeights, indicators) {
                let totalBullScore = 0, totalBearScore = 0, maxPossibleScore = 0;

                for (const indicator in activeWeights) {
                    if (indicators[indicator]) {
                        const weight = activeWeights[indicator];
                        const rawScore = getUltimateSignalScore(indicator, indicators[indicator]);
                        const weightedScore = rawScore * weight;

                        if (weightedScore > 0) totalBullScore += weightedScore;
                        if (weightedScore < 0) totalBearScore += Math.abs(weightedScore);
                        maxPossibleScore += Math.abs(weight);
                    }
                }

                const bullPercentage = maxPossibleScore > 0 ? (totalBullScore / maxPossibleScore) * 100 : 0;
                const bearPercentage = maxPossibleScore > 0 ? (totalBearScore / maxPossibleScore) * 100 : 0;

                return { bull: bullPercentage, bear: bearPercentage };
            }
        
        function calculateVolatilityInfo(klines) {
            if (!klines || klines.length < 20) {
                return {
                    atr: '0.000000',
                    status: 'Data tidak cukup',
                    dailyRange: '0%',
                    atrPercent: 0
                };
            }
            
            const atrData = calculateATR(klines);

            let dailyRange = '0%';
            const recentKlines = klines.slice(-20);
            const dailyChanges = [];
            for (let i = 1; i < recentKlines.length; i++) {
                const current = parseFloat(recentKlines[i][4]);
                const previous = parseFloat(recentKlines[i - 1][4]);
                if (previous > 0) {
                    const change = Math.abs((current - previous) / previous * 100);
                    dailyChanges.push(change);
                }
            }
            if (dailyChanges.length > 0) {
                const avgChange = dailyChanges.reduce((a, b) => a + b, 0) / dailyChanges.length;
                dailyRange = avgChange.toFixed(2) + '%';
            }
            
            return {
                atr: atrData.value.toFixed(6),
                status: atrData.status,
                dailyRange,
                atrPercent: atrData.atrPercent 
            };
        }

        function calculateAndDisplayCandleCount() {
                try {
                    const displayEl = document.getElementById('candle-estimation-display');
                    if (!backtestStartDate.value || !backtestEndDate.value) {
                        displayEl.textContent = 'Pilih rentang waktu...';
                        return;
                    }
                    const startDate = new Date(backtestStartDate.value);
                    const endDate = new Date(backtestEndDate.value);
                    const timeframe = backtestTimeframeSelect.value;
                    
                    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime()) || endDate < startDate) {
                        displayEl.textContent = 'Rentang waktu tidak valid';
                        return;
                    }

                    const timeframeMs = TIMEFRAME_MAP_MS[timeframe];
                    const durationMs = endDate.getTime() - startDate.getTime();
                    const totalCandles = Math.floor(durationMs / timeframeMs);
                    const activeFilters = Array.from(document.querySelectorAll('input[id^="filter-session-"]:checked')).map(cb => cb.value);

                    if (activeFilters.length === 0) {
                        displayEl.textContent = `Estimasi: ${totalCandles.toLocaleString('id-ID')} candle`;
                        return;
                    }

                    const sessionHours = {
                        tokyo: { start: 0, end: 8 },
                        london: { start: 7, end: 16 },
                        newyork: { start: 13, end: 22 }
                    };

                    const customSessionCheckbox = document.getElementById('filter-session-custom');
                    if (customSessionCheckbox.checked) {
                        const startTimeWIB = document.getElementById('custom-session-start').value;
                        const endTimeWIB = document.getElementById('custom-session-end').value;
                        if (startTimeWIB && endTimeWIB) {
                            const [startH, startM] = startTimeWIB.split(':').map(Number);
                            const [endH, endM] = endTimeWIB.split(':').map(Number);
                            sessionHours.custom = {
                                start: (startH - 7 + 24) % 24 + (startM / 60),
                                end: (endH - 7 + 24) % 24 + (endM / 60)
                            };
                        }
                    }
                    
                    let activeHours = new Set();
                    activeFilters.forEach(filter => {
                        const session = sessionHours[filter];
                        if (session) {
                            if (session.end < session.start) { // Handle overnight
                                for (let h = session.start; h < 24; h++) activeHours.add(Math.floor(h));
                                for (let h = 0; h < session.end; h++) activeHours.add(Math.floor(h));
                            } else {
                                for (let h = session.start; h < session.end; h++) activeHours.add(Math.floor(h));
                            }
                        }
                    });

                    const activeHourCount = activeHours.size;
                    const estimatedFilteredCandles = Math.round(totalCandles * (activeHourCount / 24));
                    
                    displayEl.innerHTML = `Estimasi: <span class="text-white">~${estimatedFilteredCandles.toLocaleString('id-ID')}</span> dari ${totalCandles.toLocaleString('id-ID')} candle akan diuji`;

                } catch (e) {
                    console.error("Error in calculateAndDisplayCandleCount:", e);
                    document.getElementById('candle-estimation-display').textContent = 'Error menghitung candle';
                }
            }
// ===================================================================        
        async function startAutoSwitchDNAExport() {
            const exportBtn = document.getElementById('export-autodna-btn');
            const originalText = exportBtn.querySelector('span').textContent;
            setButtonState(exportBtn, true, "Memulai Backtest Adaptif...");

            try {
                // LANGKAH 1: Jalankan backtest adaptif secara penuh menggunakan setelan saat ini.
                await backtester.run();

                // Cek apakah backtest menghasilkan cukup trade untuk dianalisis.
                if (!backtester.state.lastRunMetrics || backtester.state.lastRunMetrics.totalTrades < 2) {
                    alert("Backtest tidak menghasilkan cukup data (minimal 2 trade) untuk simulasi Monte Carlo.");
                    throw new Error("Backtest tidak menghasilkan trade.");
                }
                
                setButtonState(exportBtn, true, "Menjalankan Simulasi Monte Carlo...");
                await new Promise(resolve => setTimeout(resolve, 500)); // Jeda singkat untuk feedback UI

                // LANGKAH 2: Jalankan Monte Carlo secara otomatis pada hasil backtest.
                const simBacktester = { state: { settings: { initialBalance: backtester.state.settings.initialBalance } } };
                runMonteCarloSimulation(simBacktester, backtester.state.lastRunMetrics.trades, backtester.state.lastRunMetrics.equityCurve);
                
                // Cek apakah hasil Monte Carlo valid.
                if (!lastMonteCarloResult) {
                    throw new Error("Simulasi Monte Carlo gagal dijalankan.");
                }

                setButtonState(exportBtn, true, "Merakit DNA Final...");
                await new Promise(resolve => setTimeout(resolve, 500));

                // LANGKAH 3: Rakit objek DNA final, gabungkan preset bobot dengan hasil QC Validation.
                const settings = backtester.state.settings;
                const dnaObject = {
                    metadata: {
                        dnaType: "AutoSwitch_v1_QC", // Penanda bahwa ini adalah versi yang sudah tervalidasi QC.
                        sourceAsset: settings.symbol,
                        sourceTimeframe: settings.timeframe,
                        exportedAt: new Date().toISOString(),
                        qc_validation: lastMonteCarloResult // INI BAGIAN PENTINGNYA: Hasil QC dimasukkan di sini.
                    },
                    parameters: settings.parameters, // Ambil parameter dari setelan backtest terakhir.
                    weights: userSettings.presets // Kita tetap ekspor semua preset bobot (Bull, Bear, dll.) sebagai referensi.
                };

                // LANGKAH 4: Buat file JSON dan picu download.
                const jsonString = JSON.stringify(dnaObject, null, 2);
                const filename = `dna_autoswitch_qc_${settings.symbol}_${settings.timeframe}.json`;
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert(`File DNA Auto-Switch Tervalidasi '${filename}' telah berhasil diekspor!`);

            } catch (error) {
                console.error("Error saat ekspor DNA Auto-Switch otomatis:", error);
                // Jangan tampilkan alert error jika sudah ada alert spesifik sebelumnya (misal, 0 trade).
                if (!error.message.includes("Backtest tidak menghasilkan trade")) {
                    alert(`Proses ekspor otomatis gagal: ${error.message}`);
                }
            } finally {
                // Kembalikan tombol ke keadaan semula.
                setButtonState(exportBtn, false, originalText);
            }
        }

        function updateMarketSessions() {
            const sessions = getCurrentMarketSessions();
                
            for (const [market, status] of Object.entries(sessions)) {
                const element = document.getElementById(`${market}-status`);
                if (element) {
                    element.textContent = status;
                    element.className = `regime-tag ${status === 'OPEN' ? 'volatile' : 'sideways'}`;
                }
            }
        }
            
        async function analyzeMarketConditions(historicalData) {
            if (!historicalData || historicalData.length < 200) {
                return {
                    distribution: { ranging: 100 },
                    recommendations: [`⚠️ Data tidak cukup (${historicalData?.length || 0} candle). Minimal 200.`],
                    volatility: { atr: '0', status: 'N/A', dailyRange: '0%', atrPercent: 0 },
                    overallVolatility: { score: 0, status: 'N/A' },
                    segments: [] 
                };
            }

            const regimeCounts = { BULL_TREND: 0, BEAR_TREND: 0, RANGING: 0, LOW_VOLATILITY: 0, trending: 0 };            let segmentsAnalyzed = 0;
            const stepSize = 50;
            const lookbackPeriod = 200;
            const segments = [];
            let lastRegime = null;
            let segmentStartTime = historicalData[lookbackPeriod][0]; 

            for (let i = lookbackPeriod; i < historicalData.length; i += stepSize) {
                const snapshot = historicalData.slice(i - lookbackPeriod, i + 1);
                const inputValues = calculatePredictionInput(snapshot);
                const currentRegime = await predictMarketRegime(inputValues); 

                if (regimeCounts[currentRegime] !== undefined) {
                    regimeCounts[currentRegime]++;
                }
                segmentsAnalyzed++;

                if (lastRegime !== currentRegime) {
                    if (lastRegime) { 
                        segments.push({
                            regime: lastRegime,
                            startTime: segmentStartTime,
                            endTime: historicalData[i][0] 
                        });
                    }
                    
                    lastRegime = currentRegime;
                    segmentStartTime = historicalData[i][0];
                }
            }
            
            if (lastRegime) {
                segments.push({
                    regime: lastRegime,
                    startTime: segmentStartTime,
                    endTime: historicalData[historicalData.length - 1][0]
                });
            }

            const distribution = {};
            if (segmentsAnalyzed > 0) {
                for (const key in regimeCounts) {
                    distribution[key] = (regimeCounts[key] / segmentsAnalyzed) * 100;
                }
            } else {
                const finalRegime = detectMarketRegime_Unified(historicalData);
                distribution[finalRegime] = 100;
            }
            
            const volatilityInfo = calculateVolatilityInfo(historicalData);
            const overallVolatility = { score: volatilityInfo.atrPercent, status: volatilityInfo.status };
            const recommendations = [];
            let dominantRegime = Object.keys(distribution).reduce((a, b) => distribution[a] > distribution[b] ? a : b);
            if (dominantRegime === 'bullTrend' || dominantRegime === 'bearTrend' || dominantRegime === 'trending') {
                recommendations.push("✅ Pasar dominan trending. Gunakan strategi trend-following.");
                recommendations.push("📈 Fokus pada breakout dan pullback.");
            } else if (dominantRegime === 'ranging') {
                recommendations.push("✅ Pasar dominan sideways/ranging. Gunakan strategi mean-reversion.");
                recommendations.push("📊 Fokus pada support/resistance dan pembalikan arah.");
            } else if (dominantRegime === 'lowVolatility') {
                recommendations.push("✅ Volatilitas rendah (squeeze). Waspada potensi breakout.");
            }

            return {
                distribution,
                recommendations,
                volatility: volatilityInfo,
                overallVolatility: overallVolatility,
                segments: segments 
            };
        }
                
        function displayMarketAnalysis(analysis) {
            const section = document.getElementById('market-analysis-section');
            if (!section || !analysis) return;
            section.classList.remove('hidden');

            const contentWrapper = document.getElementById('market-analysis-content');
            if (!contentWrapper) return;

            const colorMap = {
                BULL_TREND: 'uptrend', BEAR_TREND: 'downtrend', RANGING: 'ranging',
                LOW_VOLATILITY: 'low-volatility', trending: 'uptrend'
            };

            let leftColumnHtml = `
                <div>
                    <h3 class="font-semibold mb-2">Distribusi Kondisi Pasar</h3>
                    <div id="market-condition-chart">
            `;
            const sortedRegimes = Object.keys(analysis.distribution).sort((a, b) => analysis.distribution[b] - analysis.distribution[a]);
            for (const key of sortedRegimes) {
                const value = analysis.distribution[key];
                if (value > 0.1) {
                    const formattedKey = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                    leftColumnHtml += `
                        <div class="flex items-center justify-between text-sm mt-2">
                            <span class="capitalize">${formattedKey}</span>
                            <span class="font-mono">${value.toFixed(1)}%</span>
                        </div>
                        <div class="w-full bg-gray-700 rounded-full h-1.5">
                            <div class="market-condition-bar ${colorMap[key] || key}" style="width: ${value}%"></div>
                        </div>`;
                }
            }
            leftColumnHtml += `</div></div>`; 

            leftColumnHtml += `<div class="mt-4">
                <h3 class="font-semibold mb-2">Segmentasi Waktu Berdasarkan Kondisi</h3>
                <div id="time-segmentation-chart">
            `;
            if (analysis.segments) {
                const groupedSegments = {};
                analysis.segments.forEach(segment => {
                    if (!groupedSegments[segment.regime]) { groupedSegments[segment.regime] = []; }
                    groupedSegments[segment.regime].push(segment);
                });

                const formatDate = (timestamp) => new Date(timestamp).toLocaleDateString('id-ID', { day: 'numeric', month: 'short' });
                const sortedGroups = Object.keys(groupedSegments).sort((a,b) => groupedSegments[b].length - groupedSegments[a].length);

                for (const regime of sortedGroups) {
                    if (regime === 'trending') continue;
                    const segmentsInGroup = groupedSegments[regime];
                    const formattedKey = regime.charAt(0).toUpperCase() + regime.slice(1).replace(/([A-Z])/g, ' $1');
                    const colorClass = colorMap[regime] || 'ranging';
                    leftColumnHtml += `<details class="mt-2 bg-gray-900/50 p-2 rounded-md">
                        <summary class="cursor-pointer font-bold text-gray-300 hover:text-white flex items-center">
                            <span class="w-3 h-3 rounded-full ${colorClass} mr-2"></span>
                            ${formattedKey} (${segmentsInGroup.length} Fase Terdeteksi)
                        </summary>
                        <ul class="text-xs space-y-1 mt-2 pt-2 pl-4 border-l border-gray-700">`;
                    segmentsInGroup.forEach(segment => {
                        leftColumnHtml += `
                            <li class="text-gray-400">
                                <span class="font-mono">${formatDate(segment.startTime)}</span> -> <span class="font-mono">${formatDate(segment.endTime)}</span>
                            </li>`;
                    });
                    leftColumnHtml += `</ul></details>`;
                }
            }
            leftColumnHtml += `</div></div>`; 

            const overallVolatility = analysis.overallVolatility;
            const barWidth = Math.min(100, (overallVolatility.score / 10) * 100);
            let barColor = '#6B7280';
            if (overallVolatility.status === 'Normal') barColor = '#F59E0B';
            else if (overallVolatility.status === 'High' || overallVolatility.status === 'Very High') barColor = '#EF4444';

            let rightColumnHtml = `
                <div class="space-y-4">
                    <div>
                        <h3 class="font-semibold mb-2">Ringkasan Volatilitas</h3>
                        <div class="flex items-center justify-between text-sm">
                            <span>Kondisi Pasar</span>
                            <span class="font-mono">${overallVolatility.status} (${overallVolatility.score.toFixed(1)}%)</span>
                        </div>
                        <div class="w-full bg-gray-700 rounded-full h-1.5 mb-2">
                            <div class="market-condition-bar" style="width: ${barWidth}%; background-color: ${barColor};"></div>
                        </div>
                    </div>
                    <div class="recommendation-card p-4 rounded-md">
                        <h3 class="font-semibold mb-2 text-yellow-400">💡 Rekomendasi Berdasarkan Kondisi Pasar</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 pt-4 border-t border-gray-700">
                            <div>
                                <h4 class="font-semibold mb-2 text-sm">ATR Saat Ini</h4>
                                <div class="text-lg font-mono">${analysis.volatility.atr} <span class="text-xs text-gray-400 font-normal">(${analysis.volatility.atrPercent.toFixed(2)}%)</span></div>
                            </div>
                            <div>
                                <h4 class="font-semibold mb-2 text-sm">Status Volatilitas</h4>
                                <div class="text-lg font-mono">${analysis.volatility.status}</div>
                            </div>
                            <div>
                                <h4 class="font-semibold mb-2 text-sm">Rata-rata Perubahan Harian</h4>
                                <div class="text-lg font-mono">${analysis.volatility.dailyRange}</div>
                            </div>
                        </div>
                        <ul class="text-sm space-y-2 mt-4">`;

            analysis.recommendations.forEach(rec => {
                const icon = rec.match(/✅|⚠️|📊|📈|🎯|🔄|⚡|📉|🌪️|🍃|🌐|🌙|💡/)?.[0] || '💡';
                rightColumnHtml += `<li class="flex items-start"><span class="mr-2">${icon}</span><span>${rec.substring(2)}</span></li>`;
            });

            rightColumnHtml += `</ul></div></div>`;
            contentWrapper.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8">
                    ${leftColumnHtml}
                    ${rightColumnHtml}
                </div>
            `;
        }
        
        function applyRegimePreset(presetName) {
            if (presetName === 'custom') return;
            const weights = userSettings.presets[presetName].weights;
            labWeightsContainer.querySelectorAll('input').forEach(input => {
                const key = input.dataset.weightKey;
                if (weights[key] !== undefined) {
                    input.value = weights[key];
                }
            });
        }

        function populateWeightsTuningPanel() {
            const allPossibleWeights = userSettings.presets.default.weights;
            if (!labWeightsContainer) return;
            labWeightsContainer.innerHTML = '';
            for (const key in allPossibleWeights) {
                const defaultValue = allPossibleWeights[key];
                const div = document.createElement('div');
                div.innerHTML = `
                    <label class="block text-xs text-gray-400 capitalize">
                        ${key.replace(/([A-Z])/g, ' $1')}
                    </label>
                    <input type="number" step="0.1" data-weight-key="${key}" value="${defaultValue}" class="input-primary small-input mt-1">
                `;
                labWeightsContainer.appendChild(div);
            }
            labWeightsContainer.addEventListener('input', () => {
                labRegimePreset.value = 'custom';
            });
        }

        function attachLogbookRowListeners() {
            document.querySelectorAll('.logbook-entry-row').forEach(row => {
                row.addEventListener('click', () => {
                    const entryId = row.dataset.entryId;
                    toggleLogbookDetails(entryId);
                });
            });
        }

        function setButtonState(button, isLoading, text = null) {
            const btnText = button.querySelector('span');
            const btnLoader = button.querySelector('.loader');
            button.disabled = isLoading;
            if (btnText) btnText.classList.toggle('hidden', isLoading);
            if (btnLoader) btnLoader.classList.toggle('hidden', !isLoading);
            if (text && btnText && !isLoading) btnText.textContent = text;
        }

        function setupToggle(buttonId, contentWrapperId, iconId, startVisible = false) {
            const button = document.getElementById(buttonId);
            const contentWrapper = document.getElementById(contentWrapperId);
            const icon = document.getElementById(iconId);
            if (!button || !contentWrapper || !icon) return;
            contentWrapper.classList.add('collapsible-content');
            const applyState = (isVisible) => {
                if (isVisible) {
                    contentWrapper.classList.add('expanded');
                    icon.style.transform = 'rotate(0deg)';
                } else {
                    contentWrapper.classList.remove('expanded');
                    icon.style.transform = 'rotate(-90deg)';
                }
            };
            let isVisible = startVisible;
            applyState(isVisible);
            button.addEventListener('click', () => {
                isVisible = !isVisible;
                applyState(isVisible);
            });
        }

        function formatDateTimeLocal(date) {
            const pad = (num) => num.toString().padStart(2, '0');
            const yyyy = date.getFullYear();
            const mm = pad(date.getMonth() + 1);
            const dd = pad(date.getDate());
            const hh = pad(date.getHours());
            const min = pad(date.getMinutes());
            return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
        }

        function updateDateRangeFromCandleCount() {
            const candleCount = parseInt(candleCountInput.value);
            let endDate = backtestEndDate.value ? new Date(backtestEndDate.value) : new Date();
            
            if (isNaN(endDate.getTime())) {
                endDate = new Date();
            }
            backtestEndDate.value = formatDateTimeLocal(endDate);
            
            const timeframe = backtestTimeframeSelect.value;
            if (isNaN(candleCount) || candleCount <= 0) return;
            const timeframeMs = TIMEFRAME_MAP_MS[timeframe];
            if (!timeframeMs) return;
            const durationMs = candleCount * timeframeMs;
            const newStartDate = new Date(endDate.getTime() - durationMs);
            backtestStartDate.value = formatDateTimeLocal(newStartDate);
            calculateAndDisplayCandleCount();
        }
        
        function saveResultToLogbook(settings, metrics, marketAnalysis, historicalData, trades, optimalParams, sharpeRatio) {
            let logbookData = JSON.parse(localStorage.getItem('backtestLogbook')) || [];
            const sessionDistribution = analyzeSessionDistribution(historicalData);
            
            const newEntry = {
                id: Date.now(),
                symbol: settings.symbol,
                timeframe: settings.timeframe,
                leverage: settings.leverage,
                pnlPercent: (metrics.totalPnl / settings.initialBalance) * 100,
                winRate: metrics.winRate,
                profitFactor: metrics.profitFactor,
                totalTrades: metrics.totalTrades,
                startTimestamp: settings.startDate,
                endTimestamp: settings.endDate,
                hasReplayData: true,
                maxDrawdown: metrics.maxDrawdown,
                expectancy: metrics.expectancy,
                maxLosingStreak: metrics.maxLosingStreak,
                quantScore: optimalParams?.bestParams?.quantScore || null, 
                sharpeRatio: sharpeRatio, 
                params: {
                    strategy: settings.strategyMode,
                    rrRatio: settings.riskRewardRatio,
                    emaPeriod: settings.pullbackEmaPeriod,
                    swingLookback: settings.swingLookback,
                    biasThreshold: settings.biasThreshold,
                    riskPerTrade: (settings.riskPerTrade * 100),
                    marginMode: settings.marginMode,
                    atrFilterThreshold: settings.atrFilterThreshold,
                    marketAnalysis: {
                        distribution: marketAnalysis.distribution,
                        overallVolatility: marketAnalysis.overallVolatility,
                        sessionDistribution: sessionDistribution
                    }
                }
            };
            
            if (logbookData.length > 0) {
                logbookData[0].hasReplayData = false;
            }

            logbookData.unshift(newEntry);
            if (logbookData.length > 100) logbookData.pop();
            localStorage.setItem('backtestLogbook', JSON.stringify(logbookData));
        }

        function loadAndRenderLogbook(dataToRender) {
            const logbookBody = document.getElementById('logbook-body');
            const logbookSection = document.getElementById('logbook-section');
            const logbookData = dataToRender || JSON.parse(localStorage.getItem('backtestLogbook')) || [];

            const formatPeriod = (start, end) => {
                if (!start || !end) return 'N/A';
                const startDate = new Date(start);
                const endDate = new Date(end);
                const options = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                const diffMs = endDate - startDate;
                const diffDays = Math.floor(diffMs / 86400000);
                const diffHrs = Math.floor((diffMs % 86400000) / 3600000);
                let duration = '';
                if (diffDays > 0) duration += `${diffDays}h `;
                if (diffHrs > 0) duration += `${diffHrs}j `;
                return `${startDate.toLocaleDateString('id-ID', options)} - ${endDate.toLocaleDateString('id-ID', options)} <br> <span class="text-xs text-gray-500 font-normal">(Durasi: ${duration.trim()})</span>`;
            };

            if (logbookData.length > 0) {
                logbookBody.innerHTML = logbookData.map(entry => {
                    const params = entry.params || {};
                    const marketAnalysis = params.marketAnalysis || {};
                    const sessionDist = marketAnalysis.sessionDistribution || { Tokyo: 'N/A', London: 'N/A', NewYork: 'N/A' };
                    const pnlText = (typeof entry.pnlPercent === 'number') ? entry.pnlPercent.toFixed(2) : '0.00';
                    const winRateText = (typeof entry.winRate === 'number') ? entry.winRate.toFixed(2) : '0.00';
                    const profitFactorText = (entry.profitFactor === Infinity) ? '∞' : (typeof entry.profitFactor === 'number' ? entry.profitFactor.toFixed(2) : '0.00');
                    const periodText = formatPeriod(entry.startTimestamp, entry.endTimestamp);
                    const replayButtonHtml = entry.hasReplayData 
                        ? `<button onclick="replayLastEntry()" class="btn-primary !py-1 !px-3 !text-xs">Replay Hasil Ini</button>`
                        : `<button class="btn-secondary !py-1 !px-3 !text-xs" disabled>Replay (Kadaluarsa)</button>`;

                    return `
                    <tr class="logbook-entry-row cursor-pointer hover:bg-gray-800" data-entry-id="${entry.id}">
                        <td class="px-4 py-2">${entry.symbol}</td>
                        <td class="px-4 py-2">${entry.timeframe}</td>
                        <td class="px-4 py-2 ${entry.pnlPercent >= 0 ? 'positive' : 'negative'}">${pnlText}%</td>
                        <td class="px-4 py-2">${winRateText}%</td>
                        <td class="px-4 py-2">${profitFactorText}</td>
                        <td class="px-4 py-2">${entry.totalTrades}</td>
                        <td class="px-4 py-2 leading-tight">${periodText}</td>
                    </tr>
                    <tr id="details-${entry.id}" class="hidden">
                        <td colspan="7" class="p-4 bg-gray-900/50 text-xs">
                            <div class="space-y-3">
                                <div class="font-mono text-yellow-400 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-x-6 gap-y-2">
                                    <span>R:R Ratio: <strong>${params.rrRatio || 'N/A'}</strong></span>
                                    <span>EMA Entry: <strong>${params.emaPeriod || 'N/A'}</strong></span>
                                    <span>Swing Lookback: <strong>${params.swingLookback || 'N/A'}</strong></span>
                                    <span>Bias Threshold: <strong>${params.biasThreshold || 'N/A'}</strong></span>
                                    <span>Risk/Trade: <strong>${params.riskPerTrade || 'N/A'}%</strong></span>
                                    <span>ATR Filter: <strong>${(params.atrFilterThreshold || 0).toFixed(4)}</strong></span>
                                    <span>Slippage Model: <strong>${params.slippageModel || 'N/A'}</strong></span>
                                </div>

                                <div class="border-t border-gray-700/50"></div>

                                <div class="font-mono grid grid-cols-2 md:grid-cols-3 gap-x-6 gap-y-2">
                                    <span>Max Drawdown: <strong class="text-red-400">${(entry.maxDrawdown || 0).toFixed(2)}%</strong></span>
                                    <span>Expect/Trade: <strong class="${(entry.expectancy || 0) >= 0 ? 'text-green-400' : 'text-red-400'}">${(entry.expectancy || 0).toFixed(2)} USD</strong></span>
                                    <span>Max Losing Streak: <strong>${entry.maxLosingStreak || 0}</strong></span>
                                    <span>Quant Score: <strong>${entry.quantScore ? entry.quantScore.toFixed(3) : 'N/A'}</strong></span>
                                    <span>Sharpe Ratio: <strong class="${(entry.sharpeRatio || 0) >= 1 ? 'text-green-400' : (entry.sharpeRatio || 0) > 0 ? 'text-yellow-400' : 'text-red-400'}">${entry.sharpeRatio ? entry.sharpeRatio.toFixed(3) : 'N/A'}</strong></span>
                                </div>
                            </div>
                        </td>
                    </tr>
                `;
                }).join('');
                logbookSection.classList.remove('hidden');
                attachLogbookRowListeners();
            } else { 
                logbookSection.classList.add('hidden'); 
            }
        }

        function applyDuration(type, value) {
            let endDate = backtestEndDate.value ? new Date(backtestEndDate.value) : new Date();
            if (isNaN(endDate.getTime())) {
                endDate = new Date();
                backtestEndDate.value = formatDateTimeLocal(endDate);
            }

            let durationMs = 0;
            const timeframe = backtestTimeframeSelect.value;
            
            if (type === 'days') {
                durationMs = value * 24 * 60 * 60 * 1000;
            } else if (type === 'weeks') {
                durationMs = value * 7 * 24 * 60 * 60 * 1000;
            } else if (type === 'months') {
                durationMs = value * 30 * 24 * 60 * 60 * 1000; 
            } else if (type === 'candles') {
                const timeframeMs = TIMEFRAME_MAP_MS[timeframe];
                durationMs = value * timeframeMs;
            }

            if (durationMs > 0) {
                const newStartDate = new Date(endDate.getTime() - durationMs);
                backtestStartDate.value = formatDateTimeLocal(newStartDate);
            }
            
            calculateAndDisplayCandleCount();
        }

        function analyzeSessionDistribution(historicalData) {
            if (!historicalData || historicalData.length === 0) {
                return { Tokyo: 0, London: 0, NewYork: 0 };
            }
            const sessionCounts = { Tokyo: 0, London: 0, NewYork: 0 };
            let totalCandles = 0;

            historicalData.forEach(candle => {
                const timestamp = candle[0];
                const date = new Date(timestamp);
                const utcHour = date.getUTCHours();
                totalCandles++;

                // Sesi Tokyo: 00:00 - 08:00 UTC
                if (utcHour >= 0 && utcHour < 8) {
                    sessionCounts.Tokyo++;
                }
                // Sesi London: 07:00 - 16:00 UTC (Overlap dengan Tokyo & NY)
                if (utcHour >= 7 && utcHour < 16) {
                    sessionCounts.London++;
                }
                // Sesi New York: 13:00 - 22:00 UTC (Overlap dengan London)
                if (utcHour >= 13 && utcHour < 22) {
                    sessionCounts.NewYork++;
                }
            });

            if (totalCandles === 0) return { Tokyo: 0, London: 0, NewYork: 0 };

            return {
                Tokyo: ((sessionCounts.Tokyo / totalCandles) * 100).toFixed(1),
                London: ((sessionCounts.London / totalCandles) * 100).toFixed(1),
                NewYork: ((sessionCounts.NewYork / totalCandles) * 100).toFixed(1)
            };
        }

        function sortAndRenderLogbook() {
            const logbookData = JSON.parse(localStorage.getItem('backtestLogbook')) || [];
            const { key, direction } = logbookSortState;
            const sortedData = [...logbookData].sort((a, b) => {
                const valA = a[key]; const valB = b[key];
                let comparison = (typeof valA === 'string') ? valA.localeCompare(valB) : valA - valB;
                return direction === 'asc' ? comparison : -comparison;
            });
            loadAndRenderLogbook(sortedData);
        }

        function toggleLogbookDetails(id) {
            const detailRow = document.getElementById(`details-${id}`);
            if (detailRow) detailRow.classList.toggle('hidden');
        }

        function clearLogbook() {
            if (confirm("Hapus seluruh riwayat pengujian?")) {
                localStorage.removeItem('backtestLogbook');
                loadAndRenderLogbook([]);
            }
        }

        function runWhatIfSimulation(trades, historicalData, baseSettings, analysisCache) {
            if (trades.length < 5) return { bestParams: null, baseMetrics: {} };

            // --- LANGKAH 1: EKSTRAK SINYAL MASUK ASLI DARI BACKTEST ---
            const entrySignals = trades.map(trade => {
                const entryIndex = historicalData.findIndex(k => new Date(k[0]).toISOString() === trade.entryDate.toISOString());
                return {
                    index: entryIndex,
                    bias: trade.type,
                    originalEntryPrice: trade.entryPrice
                };
            }).filter(s => s.index !== -1);

            if (entrySignals.length < 5) return { bestParams: null, baseMetrics: {} };

            const paramGrid = {
                riskRewardRatio: [1.5, 2.0, 2.5],
                biasThreshold: [10, 15, 20],
                swingLookback: [10, 15, 25]
            };

            let paramCombinations = [{}];
            for (const key in paramGrid) {
                const newCombinations = [];
                for (const combination of paramCombinations) {
                    for (const value of paramGrid[key]) {
                        newCombinations.push({ ...combination, [key]: value });
                    }
                }
                paramCombinations = newCombinations;
            }

            let bestResult = { quantScore: -Infinity, params: null, metrics: null };
            const baseMetrics = backtester.calculateMetrics(trades, baseSettings.initialBalance);

            // --- LANGKAH 2: JALANKAN SIMULASI MINI UNTUK SETIAP KOMBINASI ---
            paramCombinations.forEach(params => {
                const tempSettings = { ...baseSettings, ...params };
                const hypotheticalTrades = [];
                
                entrySignals.forEach(signal => {
                    const entryPrice = signal.originalEntryPrice;
                    const recentKlines = historicalData.slice(Math.max(0, signal.index - tempSettings.swingLookback), signal.index);
                    
                    if (recentKlines.length === 0) return;

                    const recentSwingHigh = Math.max(...recentKlines.map(k => parseFloat(k[2])));
                    const recentSwingLow = Math.min(...recentKlines.map(k => parseFloat(k[3])));

                    let sl, tp;
                    if (signal.bias === 'LONG') {
                        sl = recentSwingLow * 0.999;
                        tp = entryPrice + (Math.abs(entryPrice - sl) * tempSettings.riskRewardRatio);
                    } else { // SHORT
                        sl = recentSwingHigh * 1.001;
                        tp = entryPrice - (Math.abs(sl - entryPrice) * tempSettings.riskRewardRatio);
                    }
                    
                    let exitPrice = tp;
                    let exitReason = 'Take Profit';
                    
                    // Simulasi exit sederhana
                    for (let k = signal.index + 1; k < historicalData.length; k++) {
                        const candleLow = parseFloat(historicalData[k][3]);
                        const candleHigh = parseFloat(historicalData[k][2]);
                        if (signal.bias === 'LONG') {
                            if (candleLow <= sl) { exitPrice = sl; exitReason = 'Stop Loss'; break; }
                            if (candleHigh >= tp) { exitPrice = tp; exitReason = 'Take Profit'; break; }
                        } else {
                            if (candleHigh >= sl) { exitPrice = sl; exitReason = 'Stop Loss'; break; }
                            if (candleLow <= tp) { exitPrice = tp; exitReason = 'Take Profit'; break; }
                        }
                    }

                    const size = (1000 * 0.01 * tempSettings.leverage) / entryPrice;
                    const pnl = signal.bias === 'LONG' ? (exitPrice - entryPrice) * size : (entryPrice - exitPrice) * size;
                    hypotheticalTrades.push({ pnl: pnl });
                });

                const hypotheticalMetrics = backtester.calculateMetrics(hypotheticalTrades, tempSettings.initialBalance);
                const pf = hypotheticalMetrics.profitFactor === Infinity ? 5 : hypotheticalMetrics.profitFactor;
                const wr = hypotheticalMetrics.winRate;
                const mdd = hypotheticalMetrics.maxDrawdown;
                const normalize = (val, min, max) => (val - min) / (max - min) || 0;
                const pfNorm = normalize(pf, 0.5, 3.0);
                const wrNorm = normalize(wr, 30, 70);
                const mddNorm = 1 - normalize(mdd, 5, 50);
                const quantScore = (0.5 * pfNorm) + (0.3 * wrNorm) - (0.2 * mddNorm);

                if (quantScore > bestResult.quantScore) {
                    bestResult = { quantScore, params, metrics: hypotheticalMetrics };
                }
            });

            return { bestParams: bestResult, baseMetrics: baseMetrics };
        }

        function generateAdvancedTuningRecommendations(metrics, trades, settings, whatIfResults, sharpeRatio) {
            const section = document.getElementById('tuning-recommendation-section');
            section.classList.remove('hidden');
            const confluenceList = document.getElementById('confluence-issues-list');
            const optimalContainer = document.getElementById('optimal-params-container');
            const regimeSuggestion = document.getElementById('regime-suggestion-content');
            const actionList = document.getElementById('action-plan-list');
            const generalList = document.getElementById('general-suggestions-list');
            
            let actionPlanItems = [];

            optimalContainer.innerHTML = '';
            if (whatIfResults && whatIfResults.bestParams && whatIfResults.bestParams.params) {
                const best = whatIfResults.bestParams;
                
                // Membangun daftar parameter secara dinamis
                let paramsHtml = '<ul class="space-y-1 text-sm">';
                for (const key in best.params) {
                    const userValue = settings[key] || 'N/A';
                    const bestValue = best.params[key];
                    const displayName = formatParamName(key); 
                    
                    paramsHtml += `<li>${displayName}: <strong class="font-mono text-white">${bestValue}</strong> (Anda: ${userValue})</li>`;
                }
                paramsHtml += '</ul>';

                // Menampilkan hasil ke UI
                optimalContainer.innerHTML = `<div class="p-3 bg-gray-900/50 rounded-md">
                    <h4 class="font-semibold text-lg text-green-400 mb-2">🏆 Setelan Paling Optimal (Quant Score: ${best.quantScore.toFixed(3)})</h4>
                    ${paramsHtml}
                </div>`;

                actionPlanItems.push("📋 Terapkan setelan paling optimal dan jalankan kembali backtest untuk validasi.");
            } else {
                optimalContainer.innerHTML = '<p class="text-xs text-gray-500 italic">Simulasi "What-If" tidak menemukan kombinasi yang lebih baik.</p>';
            }

            let confluenceIssues = [];
            if (metrics.profitFactor < 1.2) {
                confluenceIssues.push("⚠️ Profit factor rendah (<1.2). Ini menandakan rasio profit terhadap loss kurang ideal. Pertimbangkan untuk meningkatkan R:R Ratio.");
            }
            if (metrics.winRate < 45) {
                confluenceIssues.push("⚠️ Win rate rendah (<45%). Terlalu banyak sinyal palsu. Pertimbangkan meningkatkan `Bias Threshold` atau memperketat filter entri.");
            }
            if (metrics.maxDrawdown > 25) {
                confluenceIssues.push("🔥 Max drawdown tinggi (>25%). Risiko kehancuran akun besar. Pertimbangkan mengurangi `Leverage` atau `Risk per Trade`.");
            }
            if (confluenceIssues.length === 0) confluenceIssues.push("✅ Metrik inti (PF, WR, MDD) berada dalam rentang yang sehat.");
            confluenceList.innerHTML = confluenceIssues.map(item => `<li>${item}</li>`).join('');

            generalList.innerHTML = `<li><strong class="text-purple-400">Sharpe Ratio: ${sharpeRatio.toFixed(3)}</strong> — Mengukur return per unit risiko. Semakin tinggi (>1), semakin baik.</li>`;
            generalList.innerHTML += "<li>💡 Coba backtest di timeframe lain (15m, 4h, 1d) untuk melihat di mana strategi paling unggul.</li>";

            actionList.innerHTML = actionPlanItems.map(item => `<li>${item}</li>`).join('');
            regimeSuggestion.innerHTML = `<p>🔄 Analisis lebih lanjut diperlukan untuk saran rezim spesifik.</p>`;
        }
    
        function displayTuningRecommendations(recommendations) {
            const section = document.getElementById('tuning-recommendation-section');
            section.classList.remove('hidden');

            const confluenceList = document.getElementById('confluence-issues-list');
            const optimalContainer = document.getElementById('optimal-params-container');
            const regimeSuggestion = document.getElementById('regime-suggestion-content');
            const generalList = document.getElementById('general-suggestions-list');
            const actionList = document.getElementById('action-plan-list');

            confluenceList.innerHTML = recommendations.confluenceToImprove.map(item => `<li>${item}</li>`).join('');
            
            optimalContainer.innerHTML = '';
            if (recommendations.optimalParams && Object.keys(recommendations.optimalParams).length > 0) {
                for (const [key, value] of Object.entries(recommendations.optimalParams)) {
                    if (value && (typeof value.pf !== 'undefined' || value.note)) {
                        const paramName = formatParamName(key);
                        const userValue = backtester.state.settings[key];
                        let optimalText;
                        if (value.note === '(Heuristik)') {
                            optimalText = `<span class="font-mono font-bold text-blue-400">${value.value} ${value.note}</span><span class="text-xs text-gray-500"> vs. ${userValue} (Anda)</span>`;
                        } else {
                            const isBetter = value.pf > recommendations.basePf;
                            optimalText = `<span class="font-mono font-bold ${isBetter ? 'positive' : 'text-white'}">${(value.value || 0).toFixed(4)} (PF: ${value.pf.toFixed(2)})</span>
                                        <span class="text-xs text-gray-500"> vs. ${userValue} (Anda)</span>`;
                        }
                        optimalContainer.innerHTML += `
                            <div class="flex justify-between items-center text-sm py-1">
                                <span class="text-gray-400">${paramName}:</span>
                                <div class="text-right">${optimalText}</div>
                            </div>`;
                    }
                }
                if (optimalContainer.innerHTML === '') {
                    optimalContainer.innerHTML = '<p class="text-xs text-gray-500 italic">Tidak ditemukan setelan parameter yang lebih optimal.</p>';
                }
            } else {
                optimalContainer.innerHTML = '<p class="text-xs text-gray-500 italic">Simulasi "What-If" tidak dijalankan.</p>';
            }
            
            generalList.innerHTML = recommendations.generalSuggestions.map(item => `<li>${item}</li>`).join('');
            actionList.innerHTML = recommendations.actionPlan.map(item => `<li>${item}</li>`).join('');
            regimeSuggestion.innerHTML = recommendations.regimeSuggestion || '<p class="text-sm text-gray-500 italic">Analisis rezim belum memberikan saran spesifik.</p>';
            // --- BAGIAN BARU UNTUK MENAMPILKAN SARAN HEURISTIK ---
            if (recommendations.heuristicSuggestions && recommendations.heuristicSuggestions.length > 0) {
                let heuristicHtml = `<div class="mt-4 pt-4 border-t border-gray-600">
                    <h4 class="font-semibold mb-2 text-blue-300">Saran Heuristik Tambahan</h4>
                    <ul class="text-sm space-y-3">`;
                
                recommendations.heuristicSuggestions.forEach(saran => {
                    heuristicHtml += `<li>
                        <p class="font-bold">${saran.suggestion}</p>
                        <p class="text-xs text-gray-400 italic">Alasan: ${saran.reason}</p>
                    </li>`;
                });

                heuristicHtml += `</ul></div>`;
                // Sisipkan HTML ini ke dalam panel Parameter Optimal
                optimalContainer.innerHTML += heuristicHtml;
            }
        }

        function formatParamName(key) {
            const nameMap = {
                riskRewardRatio: 'R:R Ratio',
                biasThreshold: 'Bias Threshold',
                swingLookback: 'Swing Lookback (SL)',
                atrFilterThreshold: 'ATR Filter',
                pullbackEmaPeriod: 'EMA Period' 
            };
            return nameMap[key] || key;
        }

        function applyTuningToIndexHTML(recommendations) {
            localStorage.setItem('tuningRecommendations', JSON.stringify({
                ...recommendations,
                appliedAt: new Date().toISOString()
            }));
                
            alert("Rekomendasi tuning telah disimpan. Buka index.html untuk menerapkan perubahan.");
        }

        function exportConfiguration(settings) {
            const dataStr = JSON.stringify(settings, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const exportFileDefaultName = `backtest-config-${new Date().toISOString().slice(0,10)}.json`;
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }
// ===================================================================
// OBJEK UTAMA MESIN BACKTESTING
// ===================================================================
        const backtester = {
            state: {
                isRunning: false,
                isStopped: false,
                settings: {}
            },

            stop() {
                this.state.isStopped = true;
            },

            async run() {
                lastMonteCarloResult = null;
                if (this.state.isRunning) return;
                this.state.isRunning = true;
                this.state.isStopped = false;
                setButtonState(startBacktestBtn, true, "Running...");
                stopBacktestBtn.classList.remove('hidden');
                this.resetUI();
                
                let historicalData = [];
                let trades = [];
                let marketAnalysis = null; 

                try {
                    this.gatherSettings();
                    
                    const timeframeMs = TIMEFRAME_MAP_MS[this.state.settings.timeframe];
                    const durationMs = this.state.settings.endDate - this.state.settings.startDate;
                    const totalCandleCount = timeframeMs > 0 ? Math.floor(durationMs / timeframeMs) : 0;
                    const MAX_API_LIMIT = 1000; 
                    const totalCandlesToFetch = Math.ceil(totalCandleCount / MAX_API_LIMIT) * MAX_API_LIMIT;
                    const onHistoricalProgress = (percentage) => {
                        backtestProgressBar.style.width = `${percentage * 0.5}%`; // Mengambil 50% dari total progres
                        backtestStatusText.textContent = `Mengambil data... ${percentage.toFixed(0)}%`;
                    };
                  
                    historicalData = await this.fetchHistoricalData(
                        this.state.settings, 
                        onHistoricalProgress, 
                        totalCandlesToFetch
                    );
                    
                    backtestStatusText.textContent = `✅ Data ${historicalData.length.toLocaleString('id-ID')} candle dimuat. Mempersiapkan kalkulasi indikator...`;
                    await new Promise(resolve => setTimeout(resolve, 500)); 
                    backtestProgressBar.style.width = `50%`; // Progress bar diset ke 50% sebelum kalkulasi CPU berat
                    backtestProgressBar.style.backgroundColor = '#f59e0b';
                    // ===========================================


                    if (this.state.isStopped) {
                        backtestStatusText.textContent = "Pengambilan data dihentikan.";
                        return;
                    }
                    
                    if (historicalData.length < 200) throw new Error("Data historis tidak cukup (min. 200 candle).");

                    // Tambahkan parameter currentCandle dan totalCandles
                    const onSimulationProgress = (percentage, currentCandle, totalCandles) => {
                        const finalProgress = 50 + (percentage * 0.5);
                        backtestProgressBar.style.width = `${finalProgress}%`;
                        
                        // Logika tampilan yang lebih rinci
                        if (currentCandle && totalCandles) {
                            backtestStatusText.textContent = `Simulasi berjalan: ${percentage.toFixed(0)}% (${currentCandle.toLocaleString('id-ID')} dari ${totalCandles.toLocaleString('id-ID')} candle)`;
                        } else {
                            backtestStatusText.textContent = `Simulasi berjalan: ${percentage.toFixed(0)}%`;
                        }
                    };

                    const { trades: simTrades, analysisCache } = await this.runSimulation_unifiedContextual(
                        historicalData, 
                        this.state.settings, 
                        onSimulationProgress
                    );

                    trades = simTrades;

                    if (this.state.isStopped) {
                        backtestStatusText.textContent = "Simulasi dihentikan oleh pengguna.";
                        return;
                    }
                    
                    const metrics = this.calculateMetrics(trades, this.state.settings.initialBalance);
                    const optimalParams = runWhatIfSimulation(trades, historicalData, this.state.settings, analysisCache);
                    marketAnalysis = await analyzeMarketConditions(historicalData);
                    this.displayResults(metrics, optimalParams, marketAnalysis, historicalData, trades);
                    
                } catch (error) {
                    console.error("Backtest Gagal:", error);
                    backtestStatusText.textContent = `Error: ${error.message}`;
                    backtestProgressBar.style.backgroundColor = '#ef4444';
                } finally {
                    this.state.isRunning = false;
                    setButtonState(startBacktestBtn, false, "▶️ BACKTEST");
                    stopBacktestBtn.classList.add('hidden');

                    if (marketAnalysis) {
                        displayMarketAnalysis(marketAnalysis);
                    }
                    if (historicalData && historicalData.length > 0) {
                        try {
                            document.getElementById('backtest-chart-container-section').classList.remove('hidden');
                            renderReplayWithIndicators(historicalData, trades); 
                        } catch (chartError) {
                            console.error("Error saat merender chart replay:", chartError);
                        }
                    }
                }
            },

            resetUI() {
                backtestResultsContainer.classList.add('hidden');
                backtestTradeLogContainer.classList.add('hidden');
                document.getElementById('backtest-chart-container-section').classList.add('hidden');
                tuningRecommendationSection.classList.add('hidden');
                document.getElementById('market-analysis-section').classList.add('hidden');
                backtestProgressContainer.classList.remove('hidden');
                backtestProgressBar.style.backgroundColor = '#3b82f6';
                backtestStatusText.textContent = "Mempersiapkan...";
                backtestProgressBar.style.width = "0%";
            },

            gatherSettings() {
                const tunedWeights = {};
                labWeightsContainer.querySelectorAll('input').forEach(input => {
                    tunedWeights[input.dataset.weightKey] = parseFloat(input.value) || 0;
                });
                this.state.settings = {
                    symbol: backtestSymbolInput.value.toUpperCase().trim(),
                    timeframe: backtestTimeframeSelect.value,
                    startDate: new Date(backtestStartDate.value).getTime(),
                    endDate: new Date(backtestEndDate.value).getTime(),
                    initialBalance: parseFloat(backtestInitialBalance.value),
                    leverage: parseInt(backtestLeverageInput.value) || 1,
                    riskRewardRatio: parseFloat(labRrRatioInput.value) || 1.5,
                    pullbackEmaPeriod: parseInt(labEmaPeriodInput.value) || 9,
                    swingLookback: parseInt(labSwingLookbackInput.value) || 15,
                    biasThreshold: parseInt(labBiasThresholdInput.value) || 15,
                    atrFilterThreshold: parseFloat(labAtrFilterInput.value) || 0,
                    weights: { ...userSettings.presets.default.weights, ...tunedWeights },
                    riskPerTrade: (parseFloat(labRiskPercentInput.value) / 100) || 0.05,
                    marginMode: labMarginModeSelect.value,
                    takerFee: (parseFloat(labTakerFeeInput.value) / 100) || 0,
                    makerFee: (parseFloat(labMakerFeeInput.value) / 100) || 0,
                    slippageModel: labSlippageModelSelect.value,
                    slippageFactor: 0.5, // Anda bisa membuat ini bisa di-tuning juga nanti
                    atrSlippagePercent: parseFloat(document.getElementById('lab-atr-slippage-percent').value) || 0,
                    randomSlippagePercent: parseFloat(document.getElementById('lab-random-slippage-percent').value) || 0,
                    filterRegime: Array.from(document.querySelectorAll('.regime-filter-checkbox:checked')).map(cb => cb.value),
                    parameters: {
                        riskRewardRatio: parseFloat(labRrRatioInput.value) || 1.5,
                        pullbackEmaPeriod: parseInt(labEmaPeriodInput.value) || 9,
                        swingLookback: parseInt(labSwingLookbackInput.value) || 15,
                        biasThreshold: parseInt(labBiasThresholdInput.value) || 15,
                        atrFilterThreshold: parseFloat(labAtrFilterInput.value) || 0,
                    },
                };
                if (!this.state.settings.symbol || !this.state.settings.startDate || !this.state.settings.endDate) {
                    throw new Error("Simbol, Tanggal Mulai, dan Tanggal Selesai harus diisi.");
                }
            },

            async fetchHistoricalData(settings, onProgress = () => {}, totalCandlesToFetch = 0) {
                const { symbol, timeframe, startDate, endDate } = settings;
                let allKlines = [];
                let currentEndTime = endDate;
                const limit = 1000; 

                if (totalCandlesToFetch === 0) {
                    const timeframeMs = TIMEFRAME_MAP_MS[timeframe];
                    const durationMs = endDate - startDate;
                    const totalCandleCountEstimate = timeframeMs > 0 ? Math.floor(durationMs / timeframeMs) : 0;
                    totalCandlesToFetch = Math.ceil(totalCandleCountEstimate / limit) * limit; 
                    totalCandlesToFetch = Math.max(limit, totalCandlesToFetch); // Pastikan minimal 1000
                }
    
                let candlesCollected = 0; 

                while (currentEndTime > startDate && !this.state.isStopped) {
                    const fetchedKlines = await fetchBinanceKlines(symbol, timeframe, limit, currentEndTime);
                    if (fetchedKlines.length === 0) break;
      
                    const newKlines = fetchedKlines.filter(k => k[0] >= startDate); 
                    
                    allKlines = newKlines.concat(allKlines);
                    currentEndTime = fetchedKlines[0][0] - 1; 
                    candlesCollected = allKlines.length; 
                    
                    const progress = Math.min(99, (candlesCollected / totalCandlesToFetch) * 100); 

                    onProgress(progress);
                    
                    const statusText = `Mengambil data: ${candlesCollected.toLocaleString('id-ID')} dari ~${totalCandlesToFetch.toLocaleString('id-ID')} candle...`;
                    const dataLakeStatusText = document.getElementById('data-lake-status-text');
                    if (dataLakeStatusText) {
                        dataLakeStatusText.textContent = statusText;
                    }

                    await new Promise(resolve => setTimeout(resolve, 300));
                }
    
                onProgress(100); 

                return allKlines.filter(k => k[0] >= startDate && k[0] <= endDate).sort((a, b) => a[0] - b[0]);
            },

            async processIndicatorCacheInChunks(filteredData, settings, onProgress = () => {}) { 
                return new Promise((resolve, reject) => {
                    const cacheKey = generateIndicatorCacheKey(settings);
                    try {
                        const cachedData = localStorage.getItem(cacheKey);
                        if (cachedData) {
                            setTimeout(() => resolve(JSON.parse(cachedData)), 50);
                            return;
                        }
                    } catch (e) {
                        console.error("Gagal membaca cache, akan melakukan kalkulasi ulang.", e);
                        localStorage.removeItem(cacheKey);
                    }

                    const fullCloses = filteredData.map(k => parseFloat(k[4]));
                    const allEma21 = calculateEMA(fullCloses, 21);
                    const allEma50 = calculateEMA(fullCloses, 50);
                    const allRsiValues = calculateRSI(fullCloses);
                    const allMacdData = calculateMACD(fullCloses);
                    const allStochRsiData = calculateStochasticRSI(fullCloses);
                    const allAtrValues = [];
                    for (let i = 0; i < filteredData.length; i++) {
                        allAtrValues.push(calculateATR(filteredData.slice(0, i + 1)).value);
                    }
                    
                    let analysisCache = [];
                    let currentIndex = 0;
                    const totalCandles = filteredData.length;
                    const chunkSize = 200;

                    const processChunk = () => {
                        if (this.state.isStopped) {
                            reject(new Error("Proses dihentikan oleh pengguna"));
                            return;
                        }

                        const chunkEnd = Math.min(currentIndex + chunkSize, totalCandles);
                        
                        for (let i = currentIndex; i < chunkEnd; i++) {
                            if (i < 200) {
                                analysisCache.push(null);
                                continue;
                            }
                            const klinesSnapshot = filteredData.slice(0, i + 1);
                            const closesSnapshot = fullCloses.slice(0, i + 1);
                            
                            const lastMacd = allMacdData.macdLine[i];
                            const lastSig = allMacdData.signalLine[i];
                            const prevMacd = allMacdData.macdLine[i - 1];
                            const prevSig = allMacdData.signalLine[i - 1];
                            let macdStatus = 'Netral';
                            if (prevMacd <= prevSig && lastMacd > lastSig) macdStatus = 'Bullish Cross';
                            else if (prevMacd >= prevSig && lastMacd < lastSig) macdStatus = 'Bearish Cross';
                            
                            const lastK = allStochRsiData.kLine[i];
                            const lastD = allStochRsiData.dLine[i];
                            let stochStatus = 'Netral';
                            if (lastK > 80 && lastD > 80) stochStatus = 'Overbought';
                            else if (lastK < 20 && lastD < 20) stochStatus = 'Oversold';

                            const indicators = {
                                ma: { status: (allEma21[i] > allEma50[i]) ? 'BULLISH' : 'BEARISH' },
                                rsi: { status: allRsiValues[i] > 70 ? 'Overbought' : (allRsiValues[i] < 30 ? 'Oversold' : 'Netral') },
                                stoch: { status: stochStatus },
                                macd: { status: macdStatus },
                                rsiDivergence: detectRSIDivergence(closesSnapshot, allRsiValues.slice(0, i + 1)),
                                obvDivergence: detectOBVDivergence(closesSnapshot, klinesSnapshot),
                                pivot: { status: (fullCloses[i] > (calculatePivotPoints(filteredData[i - 1])?.P || fullCloses[i])) ? 'BULLISH' : 'BEARISH' },
                                vwap: { status: (fullCloses[i] > calculateVWAP(klinesSnapshot)) ? 'BULLISH' : 'BEARISH' },
                                ichimoku: calculateIchimokuCloud(klinesSnapshot) || { status: 'Netral' },
                                candlePattern: findCandlestickPatterns(klinesSnapshot) || { bias: 'NETRAL' },
                                bollingerBands: calculateBollingerBands(closesSnapshot),
                                psar: calculateParabolicSAR(klinesSnapshot),
                                roc: calculateROC(closesSnapshot),
                                linreg: calculateLinearRegressionChannel(closesSnapshot)
                            };
                            
                            //const score = calculateConfluenceScoreForCandle(activeWeights, indicators);
                            //analysisCache.push({ bullScore: score.bull, bearScore: score.bear, atrValue: allAtrValues[i] });
                            analysisCache.push({ indicators: indicators, atrValue: allAtrValues[i] });
                        }

                        currentIndex = chunkEnd;

                        if (currentIndex < totalCandles) {
                            // Hitung persentase untuk kalkulasi indikator
                            const percentage = (currentIndex / totalCandles) * 100;
                            onProgress(percentage); // <--- BARIS INI DITAMBAHKAN
                            setTimeout(processChunk, 0);
                        } else {
                            onProgress(100); // Pastikan 100% saat selesai <--- BARIS INI DITAMBAHKAN
                            try {
                                localStorage.setItem(cacheKey, JSON.stringify(analysisCache));
                            } catch (e) {
                                console.error("Gagal menyimpan ke cache (localStorage penuh).", e);
                            }
                            resolve(analysisCache);
                        }
                    };

                    processChunk();
                });
            },

            async runSimulation_unifiedContextual(historicalData, settings, onProgress = () => {}) {
                const customSessionCheckbox = document.getElementById('filter-session-custom');
                const customSessionEnabled = customSessionCheckbox.checked;
                let customStartHourUTC = 0;
                let customEndHourUTC = 0;

                if (customSessionEnabled) {
                    const startTimeWIB = document.getElementById('custom-session-start').value;
                    const endTimeWIB = document.getElementById('custom-session-end').value;

                    if (startTimeWIB && endTimeWIB) {
                        const [startH, startM] = startTimeWIB.split(':').map(Number);
                        const [endH, endM] = endTimeWIB.split(':').map(Number);
                        customStartHourUTC = (startH - 7 + 24) % 24 + (startM / 60);
                        customEndHourUTC = (endH - 7 + 24) % 24 + (endM / 60);
                    }
                }
                
                const activeFilters = Array.from(document.querySelectorAll('input[id^="filter-session-"]:checked')).map(cb => cb.value);
                let filteredData = historicalData;

                if (activeFilters.length > 0) {
                    const sessionHours = {
                        tokyo: { start: 0, end: 8 },
                        london: { start: 7, end: 16 },
                        newyork: { start: 13, end: 22 }
                    };

                    if (customSessionEnabled && document.getElementById('custom-session-start').value) {
                        sessionHours.custom = { start: customStartHourUTC, end: customEndHourUTC };
                    }

                    filteredData = historicalData.filter(candle => {
                        const candleDate = new Date(candle[0]);
                        const candleUTCHour = candleDate.getUTCHours() + (candleDate.getUTCMinutes() / 60);

                        for (const filter of activeFilters) {
                            const session = sessionHours[filter];
                            if (session) {
                                if (session.end < session.start) { // Handle overnight sessions
                                    if (candleUTCHour >= session.start || candleUTCHour < session.end) return true;
                                } else {
                                    if (candleUTCHour >= session.start && candleUTCHour < session.end) return true;
                                }
                            }
                        }
                        return false;
                    });

                    if (filteredData.length < 200) {
                        throw new Error(`Data setelah difilter tidak cukup (hanya ${filteredData.length} candle). Coba rentang waktu yang lebih panjang.`);
                    }
                }
                
                const onIndicatorProgress = (percentage) => { 
                    // Progress dari 50% hingga 75% total bar
                    const finalProgress = 50 + (percentage * 0.25); 
                    backtestProgressBar.style.width = `${finalProgress}%`; 
                    backtestStatusText.textContent = `⚙️ Menghitung Indikator: ${percentage.toFixed(0)}% Selesai...`; 
                }; 
                const analysisCache = await this.processIndicatorCacheInChunks(
                    filteredData, 
                    this.state.settings, 
                    onIndicatorProgress // <--- BARIS BARU: Teruskan callback 
                ); 
                // Progress bar diset ke 75% setelah kalkulasi indikator selesai 
                backtestProgressBar.style.width = `75%`; 
                backtestProgressBar.style.backgroundColor = '#4ade80'; // Ubah warna untuk transisi yang jelas
                backtestStatusText.textContent = `✅ Indikator siap. Memulai simulasi perdagangan...`; 
                await new Promise(resolve => setTimeout(resolve, 500)); 
                backtestProgressBar.style.backgroundColor = '#3b82f6'; // Kembalikan warna ke biru untuk fase simulasi
                
                const fullCloses = filteredData.map(k => parseFloat(k[4]));
                
                await new Promise(resolve => setTimeout(resolve, 0));

                let balance = settings.initialBalance;
                let position = null;
                const trades = [];
                
                const totalCandles = filteredData.length;
                let candlesProcessedInChunk = 0;
                // Jika callback progres disediakan (dipanggil dari Backtest Manual/Evolusi), gunakan CHUNK_SIZE lebih kecil.
                // Jika tidak, gunakan CHUNK_SIZE default yang besar (misal 1000) untuk performa cepat.
                const EVOLUTION_CHUNK_SIZE = 50; 
                const CHUNK_SIZE = onProgress !== undefined ? EVOLUTION_CHUNK_SIZE : 1000;

                for (let i = 200; i < totalCandles; i++) {
                    if (this.state.isStopped) break;
 if (i % 1000 === 0) {
                        console.log(`[PROGRESS CHECK] Candle ke-${i} sedang diproses. Total Candle: ${totalCandles}`);
                    }
                    const currentCandle = filteredData[i];
                    const cacheEntry = analysisCache[i];
                    const currentLow = parseFloat(currentCandle[3]);
                    const currentHigh = parseFloat(currentCandle[2]);
                    
                    const klinesSnapshot = filteredData.slice(0, i + 1);
                    const featureInputs = calculatePredictionInput(klinesSnapshot);

                    if (!featureInputs) {
                        continue; 
                    }

                    const currentRegime = await predictMarketRegime(featureInputs); 
                    //console.log(`Candle #${i}: Rezim terdeteksi -> ${currentRegime}`);
                    // =================== BLOK KODE BARU UNTUK SWITCHING STRATEGI ===================
                    let activeWeights; // Variabel baru untuk menampung bobot (strategi) yang aktif
                    let dnaAutoSwitch = userSettings.presets; // Asumsi dna_autoswitch dimuat di sini, kita akan perbaiki ini nanti jika perlu

                    // Logika "JIKA-MAKA" untuk memilih strategi berdasarkan deteksi AI
                    switch (currentRegime) {
                    case 'BULL_TREND':
                        // Jika BULL_TREND terdeteksi
                        activeWeights = dnaAutoSwitch.bullTrend.weights;
                        break;
                    case 'BEAR_TREND':
                        // Jika BEAR_TREND terdeteksi
                        activeWeights = dnaAutoSwitch.bearTrend.weights;
                        break;
                    case 'RANGING':
                        // Jika RANGING terdeteksi
                        activeWeights = dnaAutoSwitch.ranging.weights;
                        break;
                    case 'LOW_VOLATILITY':
                        // Jika LOW_VOLATILITY terdeteksi
                        activeWeights = dnaAutoSwitch.lowVolatility.weights;
                        break;
                    default:
                        // Jika karena suatu hal prediksinya aneh, pakai strategi RANGING sebagai cadangan
                        activeWeights = dnaAutoSwitch.ranging.weights; 
                        break;
                    }
                    // =============================== AKHIR BLOK KODE BARU ===============================
                    // Hitung skor secara real-time menggunakan strategi yang tepat (activeWeights)
                    const score = calculateConfluenceScoreForCandle(activeWeights, cacheEntry.indicators);
                    if (settings.filterRegime && settings.filterRegime.length > 0) {
                        const checkboxFormatRegime = currentRegime.charAt(0).toLowerCase() + currentRegime.slice(1).replace(/_([a-z])/g, g => g[1].toUpperCase());

                        if (!settings.filterRegime.includes(checkboxFormatRegime)) {
                            continue;
                        }
                    }

                    if (position) {
                        const markPrice = position.type === 'LONG' ? currentLow : currentHigh;
                        const unrealizedPnl = position.type === 'LONG' ? (markPrice - position.entryPrice) * position.size : (position.entryPrice - markPrice) * position.size;
                        const positionValue = position.entryPrice * position.size;
                        const maintenanceMargin = positionValue * MAINTENANCE_MARGIN_RATE;
                        let availableEquity = (settings.marginMode === 'isolated') ? position.cost + unrealizedPnl : balance + unrealizedPnl;

                        if (availableEquity <= maintenanceMargin) {
                            balance += unrealizedPnl;
                            trades.push({ ...position, exitPrice: markPrice, pnl: unrealizedPnl, fee: 0, exitDate: new Date(currentCandle[0]), reason: 'LIQUIDATION' });
                            position = null;
                            break;
                        }

                        let exitReason = null, exitPrice = 0;
                        if (position.type === 'LONG') {
                            if (currentLow <= position.sl) { exitReason = 'Stop Loss'; exitPrice = position.sl; }
                            else if (currentHigh >= position.tp) { exitReason = 'Take Profit'; exitPrice = position.tp; }
                        } else {
                            if (currentHigh >= position.sl) { exitReason = 'Stop Loss'; exitPrice = position.sl; }
                            else if (currentLow <= position.tp) { exitReason = 'Take Profit'; exitPrice = position.tp; }
                        }

                        if (exitReason) {
                            const rawPnl = position.type === 'LONG' ? (exitPrice - position.entryPrice) * position.size : (position.entryPrice - exitPrice) * position.size;
                            const entryValue = position.entryPrice * position.size;
                            const exitValue = exitPrice * position.size;
                            const entryFee = entryValue * settings.takerFee;
                            const exitFee = exitValue * settings.makerFee;
                            const totalFee = entryFee + exitFee;
                            const netPnl = rawPnl - totalFee;
                            balance += netPnl;
                            trades.push({ ...position, exitPrice, pnl: netPnl, fee: totalFee, exitDate: new Date(currentCandle[0]), reason: exitReason });
                            position = null;
                            if (balance <= 0) { break; }
                        }
                    }

                    if (!position && cacheEntry) {
                        let entrySignal = false, detectedBias = 'NETRAL', entryPrice = 0;
                        const recentKlines = filteredData.slice(Math.max(0, i - settings.swingLookback), i);
                        const recentSwingHigh = Math.max(...recentKlines.map(k => parseFloat(k[2])));
                        const recentSwingLow = Math.min(...recentKlines.map(k => parseFloat(k[3])));
                        const closes = fullCloses.slice(0, i + 1);

                        if (currentRegime === 'BULL_TREND' || currentRegime === 'BEAR_TREND') {
                            //const bias = (score.bull > score.bear + settings.biasThreshold) ? 'LONG' : (score.bear > score.bull + settings.biasThreshold) ? 'SHORT' : 'NETRAL';
                            const bias = (score.bull > score.bear + settings.biasThreshold) ? 'LONG' : (score.bear > score.bull + settings.biasThreshold) ? 'SHORT' : 'NETRAL';
                            const emaEntry = calculateEMA(closes, settings.pullbackEmaPeriod).pop();
                            if (bias !== 'NETRAL' && emaEntry && currentLow <= emaEntry && currentHigh >= emaEntry) {
                                entrySignal = true; detectedBias = bias; entryPrice = emaEntry;
                            }
                        } else if (currentRegime === 'RANGING') {
                            const bollingerBands = calculateBollingerBands(closes); 
                            const lastUpperBand = bollingerBands.upper.pop();
                            const lastLowerBand = bollingerBands.lower.pop();
                            if (lastLowerBand > 0 && currentLow <= lastLowerBand) {
                                entrySignal = true; detectedBias = 'LONG'; entryPrice = currentLow;
                            } else if (lastUpperBand > 0 && currentHigh >= lastUpperBand) {
                                entrySignal = true; detectedBias = 'SHORT'; entryPrice = currentHigh;
                            }
                        } else if (currentRegime === 'LOW_VOLATILITY') {
                            if (currentHigh > recentSwingHigh) {
                                entrySignal = true; detectedBias = 'LONG'; entryPrice = recentSwingHigh;
                            } else if (currentLow < recentSwingLow) {
                                entrySignal = true; detectedBias = 'SHORT'; entryPrice = recentSwingLow;
                            }
                        }
                        
                        if (entrySignal && isFinite(entryPrice) && entryPrice > 0) {
                            if (settings.atrFilterThreshold <= 0 || (cacheEntry.atrValue > settings.atrFilterThreshold)) {
                                if (settings.slippageModel === 'atrAdvanced') {
                                    const atrComponent = cacheEntry.atrValue * (settings.atrSlippagePercent / 100);
                                    const randomComponent = entryPrice * (settings.randomSlippagePercent / 100) * Math.random();
                                    const totalSlippage = atrComponent + randomComponent;
                                    if (detectedBias === 'LONG') entryPrice += totalSlippage; else entryPrice -= totalSlippage;
                                } else if (settings.slippageModel === 'atrDynamic') {
                                    const slippageAmount = cacheEntry.atrValue * 0.5;
                                    if (detectedBias === 'LONG') entryPrice += slippageAmount; else entryPrice -= slippageAmount;
                                }
                                let stopLoss, takeProfit;
                                if (detectedBias === 'LONG') {
                                    stopLoss = recentSwingLow * 0.999;
                                    takeProfit = entryPrice + (Math.abs(entryPrice - stopLoss) * settings.riskRewardRatio);
                                } else {
                                    stopLoss = recentSwingHigh * 1.001;
                                    takeProfit = entryPrice - (Math.abs(stopLoss - entryPrice) * settings.riskRewardRatio);
                                }
                                const cost = balance * settings.riskPerTrade;
                                const sizeInAsset = (cost * settings.leverage) / entryPrice;
                                if (isFinite(sizeInAsset) && sizeInAsset > 0) {
                                    position = { type: detectedBias, entryPrice, cost, size: sizeInAsset, sl: stopLoss, tp: takeProfit, leverage: settings.leverage, entryDate: new Date(currentCandle[0]) };
                                }
                            }
                        }
                    }
                    
                    candlesProcessedInChunk++;
                    if (candlesProcessedInChunk >= CHUNK_SIZE) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                        candlesProcessedInChunk = 0;
                        
                        const percentage = ((i + 1) / totalCandles) * 100;
                        // Meneruskan jumlah candle yang diproses saat ini
                        if (onProgress) onProgress(percentage, i + 1, totalCandles);
                    }
                }
                
                const finalPercentage = 100;
                // Meneruskan total candle saat selesai
                if (onProgress) onProgress(finalPercentage, totalCandles, totalCandles); 

                return { trades, analysisCache };
            },

            calculateMetrics(trades, initialBalance) {
                if (trades.length === 0) {
                    return {
                        totalPnl: 0, winRate: 0, profitFactor: 0, totalTrades: 0,
                        finalBalance: initialBalance, trades: [], maxDrawdown: 0,
                        expectancy: 0, maxLosingStreak: 0,
                        equityCurve: [initialBalance] 
                    };
                }

                let totalPnl = 0, grossProfit = 0, grossLoss = 0, wins = 0;
                let equityCurve = [initialBalance];
                let peakEquity = initialBalance;
                let maxDrawdown = 0;
                let losingStreak = 0, maxLosingStreak = 0;

                trades.forEach(trade => {
                    totalPnl += trade.pnl;
                    equityCurve.push(initialBalance + totalPnl);
                    peakEquity = Math.max(peakEquity, equityCurve[equityCurve.length - 1]);
                    const drawdown = ((peakEquity - equityCurve[equityCurve.length - 1]) / peakEquity) * 100;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);

                    if (trade.pnl > 0) {
                        grossProfit += trade.pnl;
                        wins++;
                        losingStreak = 0; 
                    } else {
                        grossLoss += Math.abs(trade.pnl);
                        losingStreak++;
                        maxLosingStreak = Math.max(maxLosingStreak, losingStreak);
                    }
                });

                const winRate = (wins / trades.length) * 100;
                const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : Infinity;
                const expectancy = totalPnl / trades.length;

                return {
                    totalPnl, winRate, profitFactor, totalTrades: trades.length,
                    finalBalance: initialBalance + totalPnl, trades, maxDrawdown,
                    expectancy, maxLosingStreak, equityCurve
                };
            },
        
            displayResults(metrics, optimalParams, marketAnalysis, historicalData, trades) {
                this.state.lastRunMetrics = metrics;
                document.getElementById('backtest-result-pnl').textContent = `${metrics.totalPnl.toFixed(2)} USD (${((metrics.totalPnl / this.state.settings.initialBalance) * 100).toFixed(2)}%)`;
                document.getElementById('backtest-result-pnl').className = `font-mono font-bold text-lg ${metrics.totalPnl >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('backtest-result-winrate').textContent = `${metrics.winRate.toFixed(2)}%`;
                document.getElementById('backtest-result-profit-factor').textContent = (metrics.profitFactor === Infinity) ? '∞' : metrics.profitFactor.toFixed(2);
                document.getElementById('backtest-result-total-trades').textContent = `${metrics.totalTrades} Trades`;
                const sharpeRatio = calculateSharpeRatio(metrics.equityCurve);

                document.getElementById('backtest-result-max-drawdown').textContent = `${metrics.maxDrawdown.toFixed(2)}%`;
                const expectancyEl = document.getElementById('backtest-result-expectancy');
                expectancyEl.textContent = `${metrics.expectancy.toFixed(2)} USD`;
                expectancyEl.className = `font-mono font-bold text-lg ${metrics.expectancy >= 0 ? 'positive' : 'negative'}`;
                document.getElementById('backtest-result-losing-streak').textContent = `${metrics.maxLosingStreak} Trades`;

                backtestTradeLog.innerHTML = metrics.trades.map(trade => {
                    return `
                    <div class="p-1.5 rounded-md ${trade.pnl >= 0 ? 'bg-green-900/40' : 'bg-red-900/40'}">
                        <div class="flex justify-between items-center font-mono">
                            <span>${trade.type} @ ${trade.entryPrice.toFixed(4)} -> ${trade.exitPrice.toFixed(4)}</span>
                            <span class="${trade.pnl >= 0 ? 'positive' : 'negative'}">${trade.pnl.toFixed(2)}</span>
                        </div>
                        <div class="text-gray-500 text-[10px]">${new Date(trade.entryDate).toLocaleString('id-ID')} -> ${new Date(trade.exitDate).toLocaleString('id-ID')}</div>
                    </div>`
                }).join('');

                backtestResultsContainer.classList.remove('hidden');
                backtestTradeLogContainer.classList.remove('hidden');
                backtestProgressContainer.classList.add('hidden');

                generateAdvancedTuningRecommendations(metrics, trades, this.state.settings, optimalParams, sharpeRatio);
                saveResultToLogbook(this.state.settings, metrics, marketAnalysis, historicalData, trades, optimalParams, sharpeRatio);
                sortAndRenderLogbook();

                window.lastRecommendations = { settings: this.state.settings, whatIf: optimalParams };
            },
        };
// ===================================================================
        async function syncDataLake() {
            const symbolTextarea = document.getElementById('backtest-symbol-input');
            const progressContainer = document.getElementById('data-lake-progress-container');
            const statusBar = document.getElementById('data-lake-progress-bar');
            const statusText = document.getElementById('data-lake-status-text');
            const symbols = symbolTextarea.value.split(',').map(s => s.trim().toUpperCase()).filter(s => s);

            if (symbols.length === 0) {
                alert("Silakan masukkan minimal satu simbol aset di area teks untuk memulai evolusi.");
                return false;
            }

            progressContainer.classList.remove('hidden');
            statusBar.style.backgroundColor = '#3b82f6';
            statusBar.style.width = '0%';
            statusText.textContent = "Mempersiapkan sinkronisasi...";

            const settings = {
                timeframe: document.getElementById('backtest-timeframe-select').value,
                startDate: new Date(document.getElementById('backtest-start-date').value).getTime(),
                endDate: new Date(document.getElementById('backtest-end-date').value).getTime(),
            };
            
            const totalAssets = symbols.length;
            let currentAssetIndex = 0;

            evolutionState.historicalData = {}; 

            for (const symbol of symbols) {
                const startProgress = (currentAssetIndex / totalAssets) * 100;
                
                // --- FUNGSI PROGRES PER ASSET YANG TEPAT ---
                const onAssetProgress = (singleAssetProgress) => {
                    // Kalkulasi persentase total: (Progres Aset Selesai) + (Progres Aset Sekarang / Total Aset)
                    const overallProgress = startProgress + (singleAssetProgress / totalAssets);
                    
                    // Batasi total progres Data Lake maksimal 99% hingga selesai
                    const visualProgress = Math.min(99, overallProgress); 
                    statusBar.style.width = `${visualProgress}%`; 
                    
                    // Perbarui teks status
                    statusText.textContent = `(${currentAssetIndex + 1}/${totalAssets}) Sinkronisasi data untuk ${symbol}... (${singleAssetProgress.toFixed(0)}%)`;
                };
                // --- END FUNGSI PROGRES PER ASSET ---

                try {
                    const klineData = await backtester.fetchHistoricalData({ ...settings, symbol: symbol }, onAssetProgress);
                    if (klineData.length < 200) {
                        throw new Error(`Data tidak cukup (hanya ${klineData.length} candle)`);
                    }
                    evolutionState.historicalData[symbol] = klineData;
                    currentAssetIndex++; // Pindah ke aset berikutnya

                } catch (error) {
                    statusText.textContent = `Error saat mengambil data ${symbol}: ${error.message}`;
                    statusBar.style.backgroundColor = '#ef4444'; // Merah jika error
                    return false; // Gagal
                }
            }

            statusText.textContent = "Sinkronisasi Data Lake Selesai! Siap untuk memulai evolusi.";
            statusBar.style.backgroundColor = '#10B981'; // Hijau jika sukses
            statusBar.style.width = '100%'; // Pastikan penuh di akhir
            return true; // Sukses
        }

        async function initializeAssetCategorization() {
            await fetchBinanceFuturesSymbols();

            const categorySelect = document.getElementById('asset-category-select');
            const symbolTextarea = document.getElementById('backtest-symbol-input');
            const assetCategories = {
                'BTC': ['BTC'],
                'Major Coins': ['BTC', 'ETH', 'BNB', 'SOL', 'XRP'],
                'DeFi Tokens': ['UNI', 'LINK', 'AAVE', 'MKR', 'SNX', 'COMP'],
                'Meme Coins': ['DOGE', 'SHIB', 'PEPE', 'FLOKI', 'MEME', 'WIF'],
                'AI Tokens': ['RNDR', 'FET', 'AGIX', 'OCEAN']
            };

            for (const category in assetCategories) {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelect.appendChild(option);
            }

            categorySelect.addEventListener('change', () => {
                const selectedCategory = categorySelect.value;
                if (!assetCategories[selectedCategory]) {
                    symbolTextarea.value = '';
                    return;
                }

                const rawSymbols = assetCategories[selectedCategory];
                const validatedSymbols = [];

                rawSymbols.forEach(baseSymbol => {
                    const directMatch = baseSymbol.toUpperCase() + 'USDT';
                    const variantMatch = '1000' + baseSymbol.toUpperCase() + 'USDT';

                    if (binanceFuturesSymbolsCache.includes(directMatch)) {
                        validatedSymbols.push(directMatch);
                    } else if (binanceFuturesSymbolsCache.includes(variantMatch)) {
                        // Ini adalah logika untuk menangani kasus seperti 1000PEPEUSDT
                        validatedSymbols.push(variantMatch);
                    } else {
                        console.warn(`Simbol ${baseSymbol} dari kategori tidak ditemukan di Binance Futures, akan dilewati.`);
                    }
                });

                symbolTextarea.value = validatedSymbols.join(', ');
            });
        }

        async function startEvolution() {
            evolutionState.isRunning = true;
            evolutionState.currentGeneration = 0;
            evolutionState.population = createInitialPopulation(evolutionState.populationSize);
            const symbols = Object.keys(evolutionState.historicalData);

            if (symbols.length === 0) {
                alert("Data historis tidak ditemukan. Mohon jalankan sinkronisasi terlebih dahulu.");
                evolutionState.isRunning = false;
                return;
            }

            const optimizationMetric = document.getElementById('optimization-metric-select').value;
            const ctx = document.getElementById('fitness-chart').getContext('2d');
            
            if (evolutionState.fitnessChart) {
                evolutionState.fitnessChart.destroy();
            }
            
            evolutionState.fitnessChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: `Skor Kualitas Tertinggi`,
                            data: [],
                            borderColor: '#4ade80',
                            yAxisID: 'y',
                            fill: false
                        },
                        {
                            label: `Juara (${optimizationMetric})`,
                            data: [],
                            borderColor: '#3b82f6',
                            yAxisID: 'y1',
                            fill: false,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            title: { display: true, text: 'Skor Kualitas Genom (0-1)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            title: { display: true, text: `Metrik Pilihan (${optimizationMetric})` },
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });

            performanceMonitor.startTime = performance.now();
            performanceMonitor.lastTime = performance.now();
            performanceMonitor.lastGenerationCount = 0;
            const monitorInterval = setInterval(updatePerformanceMetrics, 1000);

            while (evolutionState.currentGeneration < evolutionState.maxGenerations && evolutionState.isRunning) {
                const evaluatedPopulation = await evaluateFitness(evolutionState.population, evolutionState.historicalData);

                const currentChampion = findChampion(evaluatedPopulation);
                if (!evolutionState.champion || currentChampion.fitness > evolutionState.champion.fitness) {
                    evolutionState.champion = currentChampion;
                    updateChampionDNA(evolutionState.champion);
                }

                updateEvolutionProgress(currentChampion);

                evolutionState.population = createNextGeneration(evaluatedPopulation);
                evolutionState.currentGeneration++;

                if (!evolutionState.isRunning) break;
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            evolutionState.isRunning = false;
            clearInterval(monitorInterval);
            updatePerformanceMetrics(); 
            alert("Proses evolusi selesai! Strategi terbaik telah ditemukan.");
        }

        async function evaluateFitness(population, multiAssetHistoricalData) {
            const evaluatedPopulation = [];
            const symbols = Object.keys(multiAssetHistoricalData);
            const genomeEvalText = document.getElementById('genome-eval-text');
            const genomeProgressBar = document.getElementById('genome-progress-bar');
            document.getElementById('genesis-progress-container').classList.remove('hidden');

            const totalGenomes = population.length;
            const totalSymbols = symbols.length;
            let completedWorkUnits = 0;
           
            if (genomeEvalText) {
                // Atur pesan awal yang segera menunjukkan apa yang sedang diuji
                const firstSymbol = symbols[0] || 'N/A';
                genomeEvalText.textContent = `⚙️ Gen ${evolutionState.currentGeneration}: Mempersiapkan Genom #1 (${firstSymbol})...`;
            }

            for (let i = 0; i < population.length; i++) {
                if (!evolutionState.isRunning) break;
                const genome = population[i];
                let allTradesForGenome = [];

                // Atur progress bar awal untuk genom yang sedang diuji
                const initialProgress = (i / totalGenomes) * 100;
                genomeProgressBar.style.width = `${initialProgress}%`;

                for (let j = 0; j < totalSymbols; j++) {
                    if (!evolutionState.isRunning) break; // Cek status stop di setiap aset
                    
                    const symbol = symbols[j];
                    const singleAssetData = multiAssetHistoricalData[symbol];
                    console.log(`[EVALUASI GENOM] Memulai backtest untuk ${symbol} dengan ${singleAssetData.length} candle.`);
                    if (!singleAssetData) continue; // Lewati jika data aset kosong
                    
                    // --- FUNGSI PROGRESS BAR GENOM (GRANULAR) ---
                    // Callback ini menerima currentCandle dan totalCandles dari runSimulation_unifiedContextual
                    const onSimulationProgress = (simulationPercentage, currentCandle, totalCandles) => {
                        // Variabel 'j' dan 'totalSymbols' harus tersedia dari loop luar.
                        const currentAssetWeight = 1 / totalSymbols; 
                        
                        // 'totalAssetProgress' adalah progres aset saat ini (misal 1/3 aset sudah 50% selesai).
                        const totalAssetProgress = (j / totalSymbols) + (simulationPercentage / 100 * currentAssetWeight);
                        
                        // 'genomeProgress' adalah total progres Genom saat ini terhadap seluruh populasi.
                        const genomeProgress = (i / totalGenomes * 100) + (totalAssetProgress / totalGenomes * 100);
                        
                        // Visualisasi (Bar kecil)
                        genomeProgressBar.style.width = `${genomeProgress}%`;
                        
                        // Visualisasi (Text) - PESAN UTAMA GRANULAR (TAMBAHKAN DETAIL CANDLE)
                        if (currentCandle && totalCandles) {
                            genomeEvalText.textContent = `Gen ${evolutionState.currentGeneration}: Genom #${i + 1} (${symbol}) - ${currentCandle.toLocaleString('id-ID')} dari ${totalCandles.toLocaleString('id-ID')} candle... (${simulationPercentage.toFixed(0)}%)`;
                        } else {
                            genomeEvalText.textContent = `Gen ${evolutionState.currentGeneration}: Genom #${i + 1} (${symbol}) - Mempersiapkan... (${simulationPercentage.toFixed(0)}%)`;
                        }
                    };
                    // --- END FUNGSI PROGRESS BAR GENOM ---

                    // Panggil backtest dengan callback progress
                    const { trades } = await runBacktestWithGenome(genome, singleAssetData, symbol, onSimulationProgress);
                    allTradesForGenome = allTradesForGenome.concat(trades);
                    
                    completedWorkUnits++;
                    
                    await new Promise(resolve => setTimeout(resolve, 0)); 
                }
                
                // --- KALKULASI FITNESS MULTI-ASET ---
                const multiAssetMetrics = backtester.calculateMetrics(allTradesForGenome, 1000); 
                let finalFitnessScore = 0;
                const MINIMUM_TRADES = 10;
                const sharpe = calculateSharpeRatio(multiAssetMetrics.equityCurve);

                if (multiAssetMetrics.totalTrades >= MINIMUM_TRADES) {
                    const pf = (multiAssetMetrics.profitFactor === Infinity) ? 20 : (multiAssetMetrics.profitFactor || 0);
                    const mdd = multiAssetMetrics.maxDrawdown || 100;

                    const pfNorm = normalize(pf, 1.2, 5);
                    const sharpeNorm = normalize(sharpe, 0.5, 3);
                    const mddNorm = 1 - normalize(mdd, 5, 40);

                    const qualityScore = (0.5 * pfNorm) + (0.3 * sharpeNorm) + (0.2 * mddNorm);
                    finalFitnessScore = qualityScore;
                }
                
                evaluatedPopulation.push({
                    ...genome,
                    fitness: finalFitnessScore,
                    metrics: { 
                        ...multiAssetMetrics, 
                        "SharpeIndex": sharpe.toFixed(4),
                        allMultiAssetTrades: allTradesForGenome, 
                        allMultiAssetEquity: multiAssetMetrics.equityCurve,
                        initialBalance: 1000, 
                    }
                });
                
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            
            // Finalisasi: Pastikan bar progress menunjukkan 100%
            if (evolutionState.isRunning) {
                genomeProgressBar.style.width = '100%';
            }

            document.getElementById('genesis-progress-container').classList.add('hidden');
            return evaluatedPopulation;
        }

        async function runBacktestWithGenome(genome, historicalData, symbol, onProgress = () => {}) {
            const settings = {
                timeframe: document.getElementById('backtest-timeframe-select').value,
                startDate: new Date(document.getElementById('backtest-start-date').value).getTime(),
                endDate: new Date(document.getElementById('backtest-end-date').value).getTime(),
                initialBalance: 1000, // Standarkan modal untuk perbandingan yang adil
                leverage: parseInt(document.getElementById('backtest-leverage-input').value) || 10,
                riskPerTrade: 0.01, // Standarkan risiko untuk perbandingan yang adil
                marginMode: document.getElementById('lab-margin-mode').value,
                takerFee: (parseFloat(document.getElementById('lab-taker-fee').value) / 100) || 0,
                makerFee: (parseFloat(document.getElementById('lab-maker-fee').value) / 100) || 0,
                slippageModel: document.getElementById('lab-slippage-model').value,
                atrSlippagePercent: parseFloat(document.getElementById('lab-atr-slippage-percent').value) || 0,
                randomSlippagePercent: parseFloat(document.getElementById('lab-random-slippage-percent').value) || 0,
                filterRegime: Array.from(document.querySelectorAll('.regime-filter-checkbox:checked')).map(cb => cb.value),
                
                riskRewardRatio: genome.riskRewardRatio,
                pullbackEmaPeriod: genome.pullbackEmaPeriod,
                swingLookback: genome.swingLookback,
                biasThreshold: genome.biasThreshold,
                atrFilterThreshold: genome.atrFilterThreshold,
                weights: genome.weights,
            
                symbol: symbol
            };

            const { trades } = await backtester.runSimulation_unifiedContextual(historicalData, settings, onProgress);

            const metrics = backtester.calculateMetrics(trades, settings.initialBalance);
            const sharpeRatio = calculateSharpeRatio(metrics.equityCurve);

            return { metrics: { ...metrics, sharpeRatio }, trades: trades };
        }

        function updateFitnessChart(generation, fitness) {
            if (!evolutionState.fitnessChart) {
                const ctx = document.getElementById('fitness-chart').getContext('2d');
                evolutionState.fitnessChart = new Chart(ctx, {
                    type: 'line',
                    data: { 
                        labels: [], 
                        datasets: [
                            { label: 'Profit Factor Terbaik', data: [], borderColor: '#4ade80', fill: false },
                            { label: 'Rata-rata Profit Factor', data: [], borderColor: '#F59E0B', fill: false }
                        ] 
                    },
                    options: { scales: { y: { beginAtZero: false } } }
                });
            }
            evolutionState.fitnessChart.data.labels.push(generation);
            evolutionState.fitnessChart.data.datasets[0].data.push(fitness);
            // TODO: Tambahkan rata-rata profit factor
            evolutionState.fitnessChart.update();
        }

function exportStrategyDNA() {
    let strategyData = null;
    let sourceAsset = document.getElementById('backtest-symbol-input').value.toUpperCase().trim();
    let sourceTimeframe = document.getElementById('backtest-timeframe-select').value;
    let dnaType;

    let symbolsArray = sourceAsset.split(',').map(s => s.trim()).filter(s => s);
    let isMultiAsset = symbolsArray.length > 1;
    let exportAutoSwitch = document.getElementById('export-autodna-btn')?.textContent.includes('Auto-Switch');

    // --- 1. PENENTUAN TIPE DNA & SOURCE ASSET YANG AMAN ---
    if (isMultiAsset) {
        sourceAsset = 'GENERIC_MULTI_ASSET'; 
        dnaType = exportAutoSwitch ? "AutoSwitch_V1" : "Generic_V1";
    } else {
        dnaType = exportAutoSwitch ? "AutoSwitch_V1" : "Specific_V1";
    }

    // --- 2. AMBIL DATA DARI CHAMPION / LAST BACKTEST ---
    let isValidChampion = evolutionState.champion && evolutionState.champion.metrics && evolutionState.champion.metrics.totalTrades > 0;
    let isValidBacktest = backtester.state.lastRunMetrics && backtester.state.lastRunMetrics.totalTrades > 0;

    if (isValidChampion) {
        // AMBIL DARI CHAMPION EVOLUSI V1
        strategyData = {
            parameters: { 
                riskRewardRatio: evolutionState.champion.riskRewardRatio, 
                pullbackEmaPeriod: evolutionState.champion.pullbackEmaPeriod, 
                swingLookback: evolutionState.champion.swingLookback, 
                biasThreshold: evolutionState.champion.biasThreshold, 
                atrFilterThreshold: parseFloat(evolutionState.champion.atrFilterThreshold) 
            },
            // KRITIS: Untuk AutoSwitch, kita ambil SEMUA presets (BULL_TREND, BEAR_TREND, etc.)
            weights: (dnaType.includes('AutoSwitch')) ? userSettings.presets : evolutionState.champion.weights
        };
        sourceAsset = isMultiAsset ? 'GENERIC_MULTI_ASSET' : symbolsArray[0]; 
        
    } else if (isValidBacktest) {
        // AMBIL DARI BACKTEST MANUAL TERAKHIR
        const settings = backtester.state.settings;
        strategyData = {
            parameters: settings.parameters,
            weights: (dnaType.includes('AutoSwitch')) ? userSettings.presets : settings.weights
        };
        sourceAsset = settings.symbol;
    } else if (exportAutoSwitch) {
        // 🔥 JALUR DARURAT: Jika Champion GAGAL, FORCE EXPORT PRESET AMAN 🔥
        strategyData = {
            parameters: { 
                riskRewardRatio: 1.8, pullbackEmaPeriod: 13, swingLookback: 15, biasThreshold: 15, atrFilterThreshold: 0.0
            },
            weights: userSettings.presets
        };
        sourceAsset = 'FALLBACK_PRESET';
        dnaType = "AutoSwitch_V1_Fallback";
    }
    else { 
        alert("Tidak ada hasil backtest yang valid (total trades > 0) untuk diekspor. Jalankan Evolution V1 terlebih dahulu."); 
        return; 
    }

    // --- 3. RAKIT FINAL DNA OBJECT ---
    const dnaObject = { 
        metadata: { dnaType, sourceAsset, sourceTimeframe, exportedAt: new Date().toISOString() }, 
        parameters: strategyData.parameters, 
        weights: strategyData.weights 
    };

    if (lastMonteCarloResult && isFinite(lastMonteCarloResult.avg_final_pnl_usd)) { 
        dnaObject.metadata.qc_validation = lastMonteCarloResult; 
    }
    
    // --- 4. EKSPOR FILE DENGAN NAMA YANG AMAN ---
    const jsonString = JSON.stringify(dnaObject, null, 2);
    const safeAssetName = sourceAsset.replace(/,/g, '-'); 
    const filename = `dna_${dnaObject.metadata.dnaType.toLowerCase()}_${safeAssetName}_${dnaObject.metadata.sourceTimeframe}.json`;
    
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; 
    a.download = filename;
    document.body.appendChild(a); 
    a.click(); 
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    alert(`File DNA '${filename}' telah berhasil diekspor!`);
}

        function updateChampionDNA(champion) {
            const dnaElement = document.getElementById('champion-dna');
            if (dnaElement && champion && champion.metrics) {
                const metrics = champion.metrics;
                const rawSharpe = (metrics.SharpeIndex || metrics.sharpeRatio || "0.0000"); 
                const params = {
                    "R:R Ratio": (champion.riskRewardRatio || 0).toFixed(2),
                    "EMA Period": champion.pullbackEmaPeriod, 
                    "Swing Lookback": champion.swingLookback,
                    "Bias Threshold": champion.biasThreshold,
                    "ATR Filter": (champion.atrFilterThreshold || 0).toString(),
                    "Profit Factor": (metrics.profitFactor === Infinity ? "Infinity" : (metrics.profitFactor || 0).toFixed(2)),
                    "Win Rate": (metrics.winRate || 0).toFixed(2) + '%',
                    "Sharpe Ratio": rawSharpe.toString(), 
                    "Total Trades": metrics.totalTrades || 0,
                    "Weights": champion.weights
                };
                dnaElement.textContent = JSON.stringify(params, null, 2);
            } else {
                dnaElement.textContent = "Menunggu generasi pertama selesai...";
            }
        }

        function updateEvolutionProgress(champion) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            const progress = (evolutionState.currentGeneration / evolutionState.maxGenerations) * 100;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `Generasi ${evolutionState.currentGeneration} dari ${evolutionState.maxGenerations}`;

            if (evolutionState.fitnessChart && champion) {
                const optimizationMetric = document.getElementById('optimization-metric-select').value;
                
                let secondaryMetricValue = 0;
                switch (optimizationMetric) {
                    case 'Win Rate':
                        secondaryMetricValue = parseFloat(champion.metrics.winRate) || 0;
                        break;
                    case 'Sharpe Ratio':
                        secondaryMetricValue = parseFloat(champion.metrics.SharpeIndex) || 0;
                        break;
                    default: 
                        secondaryMetricValue = (champion.metrics.profitFactor === Infinity) ? 20 : (champion.metrics.profitFactor || 0);
                        break;
                }
                
                evolutionState.fitnessChart.data.labels.push(evolutionState.currentGeneration);
                evolutionState.fitnessChart.data.datasets[0].data.push(champion.fitness);
                evolutionState.fitnessChart.data.datasets[1].data.push(secondaryMetricValue);
                
                evolutionState.fitnessChart.data.datasets[1].label = `Juara (${optimizationMetric})`;
                evolutionState.fitnessChart.options.scales.y1.title.text = `Metrik Pilihan (${optimizationMetric})`;

                evolutionState.fitnessChart.update();
            }
        }

        function updatePerformanceMetrics() {
            const performanceMetric = document.getElementById('performance-metric');
            const tradeSpeed = document.getElementById('trade-speed');

            if (!evolutionState.isRunning) {
                performanceMetric.textContent = "0 Gen/detik";
                tradeSpeed.textContent = "0 Trade/detik";
                return;
            }

            const currentTime = performance.now();
            const generationsProcessed = evolutionState.currentGeneration - performanceMonitor.lastGenerationCount;
            const elapsedTime = (currentTime - performanceMonitor.lastTime) / 1000;

            let genPerSecond = 0;
            if (elapsedTime > 0) {
                genPerSecond = generationsProcessed / elapsedTime;
            }

            performanceMetric.textContent = `${genPerSecond.toFixed(1)} Gen/detik`;

            performanceMonitor.lastTime = currentTime;
            performanceMonitor.lastGenerationCount = evolutionState.currentGeneration;

            const totalTrades = evolutionState.champion ? evolutionState.champion.metrics.totalTrades : 0;
            const totalElapsedTime = (currentTime - performanceMonitor.startTime) / 1000;
            let tradesPerSecond = 0;
            if (totalElapsedTime > 0) {
                tradesPerSecond = totalTrades / totalElapsedTime;
            }
            tradeSpeed.textContent = `${tradesPerSecond.toFixed(1)} Trade/detik`;
        }
// ===================================================================
// ADD-ONS: FITUR REPLAY CHART
// ===================================================================
        function getChartBaseOptions(height) {
            return {
                width: document.getElementById('backtest-chart-container-section').clientWidth - 32,
                height: height,
                layout: { background: { color: '#151414' }, textColor: '#E0E0E0' },
                grid: { vertLines: { color: '#333' }, horzLines: { color: '#333' } },
                timeScale: { borderColor: '#444', timeVisible: true },
                rightPriceScale: { borderColor: '#444' },
                lockVisibleTimeRangeOnResize: true,
                rightOffset: -30, // chart offset
                    barSpacing: 6,
                    minBarSpacing: 3,
                    horzTouchDrag: true, 
                    vertTouchDrag: false, 
                    mouseScroll: false, // Menonaktifkan mouse scroll zoom
                    pinchToZoom: true, // Membiarkan pinch-to-zoom di mobile
                    tickMarkFormatter: (time) => {
                        const date = new Date(time * 1000);
                        return date.toLocaleTimeString('id-ID', {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }
            };
        }

        function syncCharts(...chartsToSync) {
            chartsToSync.forEach(chart => {
                if (!chart) return;
                chart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                    chartsToSync.forEach(otherChart => {
                        if (chart !== otherChart && otherChart) {
                            otherChart.timeScale().setVisibleRange(timeRange);
                        }
                        if (timeRange && timeRange.from && timeRange.to) {
                            otherChart.timeScale().setVisibleRange(timeRange);
                        }

                    });
                });
            });
        }

        function destroyCharts() {
            charts.forEach(chart => { if (chart) chart.remove(); });
            charts = [];
            ['main-chart-container', 'volume-chart-container', 'rsi-chart-container', 'stoch-rsi-chart-container', 'macd-chart-container'].forEach(id => {
                const container = document.getElementById(id);
                if (container) container.innerHTML = '';
            });
        }

        function renderReplayWithIndicators(historicalData, trades) {
            if (!historicalData || historicalData.length < 200) {
                destroyCharts();
                return;
            }
            destroyCharts();
            const formattedKlines = historicalData.map(d => ({
                time: d[0] / 1000,
                open: parseFloat(d[1]),
                high: parseFloat(d[2]),
                low: parseFloat(d[3]),
                close: parseFloat(d[4])
            }));
            const volumeData = historicalData.map(d => ({ time: d[0] / 1000, value: parseFloat(d[5]), color: parseFloat(d[4]) >= parseFloat(d[1]) ? 'rgba(76, 175, 80, 0.5)' : 'rgba(244, 67, 54, 0.5)' }));
            const closes = formattedKlines.map(k => k.close);
            const rsiIndicator = calculateRSI(closes, 14);
            const stochRsiIndicator = calculateStochasticRSI(closes);
            const macdIndicator = calculateMACD(closes);
            const rsiData = rsiIndicator.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
            const stochKData = stochRsiIndicator.kLine.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
            const stochDData = stochRsiIndicator.dLine.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
            const macdLineData = macdIndicator.macdLine.map((value, index) => ({ time: formattedKlines[index]?.time, value })).filter(d => d.time && d.value !== undefined);
            const signalLineData = macdIndicator.signalLine.map((value, index) => ({ time: formattedKlines[index + 33]?.time, value })).filter(d => d.time && d.value !== undefined);
            const histogramData = macdIndicator.histogram.map((item, index) => (item && formattedKlines[index]) ? { time: formattedKlines[index].time, value: item.value, color: item.color } : null).filter(Boolean);
            const mainChart = LightweightCharts.createChart(document.getElementById('main-chart-container'), getChartBaseOptions(450));
            const volumeChart = LightweightCharts.createChart(document.getElementById('volume-chart-container'), getChartBaseOptions(100));
            const rsiChart = LightweightCharts.createChart(document.getElementById('rsi-chart-container'), getChartBaseOptions(120));
            const stochRsiChart = LightweightCharts.createChart(document.getElementById('stoch-rsi-chart-container'), getChartBaseOptions(120));
            const macdChart = LightweightCharts.createChart(document.getElementById('macd-chart-container'), getChartBaseOptions(120));
            charts = [mainChart, volumeChart, rsiChart, stochRsiChart, macdChart];
            replayState.candleSeries = mainChart.addCandlestickSeries({ upColor: '#26a69a', downColor: '#ef5350', borderVisible: false });
            replayState.volumeSeries = volumeChart.addHistogramSeries({ priceFormat: { type: 'volume' } });
            replayState.rsiSeries = rsiChart.addLineSeries({ color: '#c792ea', lineWidth: 2 });
            replayState.stochKSeries = stochRsiChart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: '%K' });
            replayState.stochDSeries = stochRsiChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, title: '%D' });
            replayState.macdLineSeries = macdChart.addLineSeries({ color: '#2962FF', lineWidth: 2, priceLineVisible: false });
            replayState.signalLineSeries = macdChart.addLineSeries({ color: '#FF6D00', lineWidth: 2, priceLineVisible: false });
            replayState.histogramSeries = macdChart.addHistogramSeries({ base: 0 });
            replayState.fullData = {
                    formattedKlines: formattedKlines.filter(k => k.close !== undefined && !isNaN(k.close)),
                    volumeData: volumeData.filter(v => v.value !== undefined && !isNaN(v.value)),
                    rsiData: rsiData.filter(d => d.value !== undefined && !isNaN(d.value)),
                    stochKData: stochKData.filter(d => d.value !== undefined && !isNaN(d.value)),
                    stochDData: stochDData.filter(d => d.value !== undefined && !isNaN(d.value)),
                    macdLineData: macdLineData.filter(d => d.value !== undefined && !isNaN(d.value)),
                    signalLineData: signalLineData.filter(d => d.value !== undefined && !isNaN(d.value)),
                    histogramData: histogramData.filter(d => d.value !== undefined && !isNaN(d.value)),
                    trades: trades
                };
            resetReplay();
            const firstValidKline = formattedKlines.find(k => k.time);
            const lastValidKline = formattedKlines.slice().reverse().find(k => k.time);
            if (firstValidKline && lastValidKline && formattedKlines.length > 1) {
                mainChart.timeScale().setVisibleRange({
                    from: firstValidKline.time,
                    to: lastValidKline.time,
                });
            }
            syncCharts(...charts);
        }

        function runReplayStep() {
            if (!replayState.fullData.formattedKlines || replayState.currentIndex >= replayState.fullData.formattedKlines.length) {
                pauseReplay(); document.getElementById('replay-play-pause-btn').disabled = true; return;
            }

            const i = replayState.currentIndex;
            const currentKline = replayState.fullData.formattedKlines[i];
            if (!currentKline) { replayState.currentIndex++; return; } 
            
            const currentTime = currentKline.time;

            replayState.candleSeries.update(currentKline);
            if (replayState.fullData.volumeData[i]) replayState.volumeSeries.update(replayState.fullData.volumeData[i]);
            if (replayState.fullData.rsiData[i]) replayState.rsiSeries.update(replayState.fullData.rsiData[i]);
            if (replayState.fullData.stochKData[i]) replayState.stochKSeries.update(replayState.fullData.stochKData[i]);
            if (replayState.fullData.stochDData[i]) replayState.stochDSeries.update(replayState.fullData.stochDData[i]);
            if (replayState.fullData.macdLineData[i]) replayState.macdLineSeries.update(replayState.fullData.macdLineData[i]);
            if (replayState.fullData.signalLineData[i]) replayState.signalLineSeries.update(replayState.fullData.signalLineData[i]);
            if (replayState.fullData.histogramData[i]) replayState.histogramSeries.update(replayState.fullData.histogramData[i]);
            
            const markersToAdd = [];
            replayState.fullData.trades.forEach(trade => {
                const entryTime = new Date(trade.entryDate).getTime() / 1000;
                const exitTime = new Date(trade.exitDate).getTime() / 1000;
                if (entryTime === currentTime) {
                    markersToAdd.push({ time: currentTime, position: trade.type === 'LONG' ? 'belowBar' : 'aboveBar', color: trade.type === 'LONG' ? '#26a69a' : '#ef5350', shape: trade.type === 'LONG' ? 'arrowUp' : 'arrowDown', text: `Entry @ ${trade.entryPrice.toFixed(4)}` });
                    trade.slLine = replayState.candleSeries.createPriceLine({ price: trade.sl, color: '#f87171', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'SL' });
                    trade.tpLine = replayState.candleSeries.createPriceLine({ price: trade.tp, color: '#4ade80', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'TP' });
                }
                if (exitTime === currentTime) {
                    markersToAdd.push({ time: currentTime, position: trade.type === 'LONG' ? 'aboveBar' : 'belowBar', color: '#a3a3a3', shape: 'square', text: `Exit @ ${trade.exitPrice.toFixed(4)}` });
                    if(trade.slLine) replayState.candleSeries.removePriceLine(trade.slLine);
                    if(trade.tpLine) replayState.candleSeries.removePriceLine(trade.tpLine);
                }
            });
            if (markersToAdd.length > 0) {
                const existingMarkers = replayState.candleSeries.markers() || [];
                replayState.candleSeries.setMarkers([...existingMarkers, ...markersToAdd]);
            }
            replayState.currentIndex++;
        }

        function playReplay() {
            if (replayState.isPlaying) return;
            replayState.isPlaying = true;
            document.getElementById('replay-play-pause-btn').innerHTML = '⏸️ Pause';
            const speedMap = { 1: 1000, 2: 800, 3: 600, 4: 400, 5: 300, 6: 200, 7: 150, 8: 100, 9: 50, 10: 25, 11: 20, 12: 18, 13: 16, 14: 14, 15: 12, 16: 10, 17: 8, 18: 5, 19: 2, 20: 1 };
            replayState.intervalId = setInterval(runReplayStep, speedMap[replayState.speed] || 300);
        }

        function pauseReplay() {
            if (!replayState.isPlaying) return;
            replayState.isPlaying = false;
            document.getElementById('replay-play-pause-btn').innerHTML = '▶️ Play';
            clearInterval(replayState.intervalId);
            replayState.intervalId = null;
        }

        function stepReplay() {
            if (replayState.isPlaying) pauseReplay();
            runReplayStep();
        }

        function resetReplay() {
            pauseReplay();
            replayState.currentIndex = 0;

            if (replayState.candleSeries) {
                replayState.priceLines.forEach(line => replayState.candleSeries.removePriceLine(line));
                replayState.candleSeries.setMarkers([]);
            }
            replayState.priceLines = [];

            if (replayState.candleSeries) replayState.candleSeries.setData([]);
            if (replayState.volumeSeries) replayState.volumeSeries.setData([]);
            if (replayState.rsiSeries) replayState.rsiSeries.setData([]);
            if (replayState.stochKSeries) replayState.stochKSeries.setData([]); 
            if (replayState.stochDSeries) replayState.stochDSeries.setData([]); 
            if (replayState.macdLineSeries) replayState.macdLineSeries.setData([]);
            if (replayState.signalLineSeries) replayState.signalLineSeries.setData([]);
            if (replayState.histogramSeries) replayState.histogramSeries.setData([]);

            document.getElementById('replay-play-pause-btn').disabled = false;
            document.getElementById('replay-step-btn').disabled = false;
        }

        function changeReplaySpeed(value) {
            const speed = parseInt(value, 10);
            replayState.speed = speed;
            replaySpeedLabel.textContent = `x${speed}`;

            if (replayState.isPlaying) {
                pauseReplay();
                playReplay();
            }
        }

        function setupReplayEventListeners() {
            if (window.replayListenersAttached) return;
            document.getElementById('replay-play-pause-btn').addEventListener('click', () => {
                if (replayState.isPlaying) pauseReplay();
                else playReplay();
            });
            document.getElementById('replay-step-btn').addEventListener('click', stepReplay);
            document.getElementById('replay-reset-btn').addEventListener('click', resetReplay);
            document.getElementById('replay-speed-slider').addEventListener('input', (e) => {
                changeReplaySpeed(parseInt(e.target.value));
            });
            window.replayListenersAttached = true;
        }

        function replayEntry(id) {
            const logbookData = JSON.parse(localStorage.getItem('backtestLogbook')) || [];
            const entry = logbookData.find(e => e.id === id);
            if (entry && entry.historicalData) {
                document.getElementById('backtest-chart-container-section').classList.remove('hidden');
                renderReplayWithIndicators(entry.historicalData, entry.trades);
                window.scrollTo({ top: document.getElementById('backtest-chart-container-section').offsetTop, behavior: 'smooth' });
            } else {
                alert("Data historis tidak tersedia untuk entri ini. Jalankan backtest lagi.");
            }
        }
// ===================================================================           
// BAGIAN A: INISIALISASI TOGGLE DAN EVENT LISTENER UNTUK BACKTESTING
// ===================================================================
        await initializeAssetCategorization();
        await loadRegimeSensorModel();

        setupToggle('toggle-backtesting-btn', 'backtesting-content-wrapper', 'toggle-backtesting-icon', true);
        setupToggle('toggle-lab-btn', 'lab-content-wrapper', 'toggle-lab-icon', false);
        setupToggle('toggle-logbook-btn', 'logbook-content-wrapper', 'toggle-logbook-icon', false);
        setupToggle('toggle-tuning-recommendation-btn', 'tuning-recommendation-content-wrapper', 'toggle-tuning-recommendation-icon', false);
        setupToggle('toggle-market-analysis-btn', 'market-analysis-content-wrapper', 'toggle-market-analysis-icon', true);
        setupToggle('toggle-chart-container-btn', 'chart-container-content-wrapper', 'toggle-chart-container-icon', false);
        
        startBacktestBtn.addEventListener('click', async () => {
            const symbols = document.getElementById('backtest-symbol-input').value.split(',').map(s => s.trim()).filter(s => s);

            if (symbols.length > 1) {
                alert("Mode Backtest Manual hanya mendukung satu aset. Untuk multi-aset, gunakan 'Mulai Evolusi Strategi'.");
                return;
            }

            await backtester.run();
            evolutionState.historicalData[symbols[0]] = backtester.state.historicalData;
        });

        stopBacktestBtn.addEventListener('click', () => backtester.stop());
        
        const clearBtn = document.getElementById('clear-logbook-btn');
        if (clearBtn) clearBtn.addEventListener('click', clearLogbook);
        
        labRegimePreset.addEventListener('change', () => {
            applyRegimePreset(labRegimePreset.value);
        });

        candleCountInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); 
                applyDurationBtn.click(); 
                startBacktestBtn.focus(); 
            }
        });
        
        document.querySelectorAll('#logbook-section thead th').forEach(header => {
            header.addEventListener('click', () => {
                const sortKey = header.dataset.sortKey;
                if (!sortKey) return;
                if (logbookSortState.key === sortKey) {
                    logbookSortState.direction = logbookSortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    logbookSortState.key = sortKey;
                    logbookSortState.direction = 'desc';
                }
                sortAndRenderLogbook();
            });
        });

        document.getElementById('apply-tuning-btn')?.addEventListener('click', function() {
            if (window.lastRecommendations) {
                applyTuningToIndexHTML(window.lastRecommendations);
            } else {
                alert("Tidak ada rekomendasi tuning yang tersedia. Jalankan backtest terlebih dahulu.");
            }
        });
        
        document.getElementById('export-config-btn')?.addEventListener('click', function() {
            backtester.gatherSettings();
            exportConfiguration(backtester.state.settings);
        });

        document.getElementById('clear-cache-btn').addEventListener('click', () => {
            if (confirm("Hapus seluruh cache hasil kalkulasi indikator? Ini akan membuat backtest berikutnya berjalan lebih lambat (kalkulasi ulang).")) {
                let itemsRemoved = 0;
                Object.keys(localStorage)
                    .filter(key => key.startsWith('indicatorCache_'))
                    .forEach(key => {
                        localStorage.removeItem(key);
                        itemsRemoved++;
                    });
                alert(`${itemsRemoved} cache telah dihapus.`);
            }
        });
        
        replaySpeedSlider.addEventListener('input', (e) => {
            changeReplaySpeed(e.target.value);
        });

        const filterCheckboxes = document.querySelectorAll('.session-filter-checkbox');
        backtestStartDate.addEventListener('change', calculateAndDisplayCandleCount);
        backtestEndDate.addEventListener('change', calculateAndDisplayCandleCount);
        backtestTimeframeSelect.addEventListener('change', calculateAndDisplayCandleCount);
        filterCheckboxes.forEach(cb => cb.addEventListener('change', calculateAndDisplayCandleCount));

        document.getElementById('export-autodna-btn').addEventListener('click', exportStrategyDNA);
        document.getElementById('duration-btn-3d').addEventListener('click', () => applyDuration('days', 3));
        document.getElementById('duration-btn-1w').addEventListener('click', () => applyDuration('weeks', 1));
        document.getElementById('duration-btn-1m').addEventListener('click', () => applyDuration('months', 1));
        document.getElementById('duration-apply-btn').addEventListener('click', () => {
            const candleValue = parseInt(document.getElementById('duration-candle-input').value);
            if (candleValue > 0) {
                applyDuration('candles', candleValue);
            }
        });

        backtestEndDate.value = formatDateTimeLocal(new Date());
        populateWeightsTuningPanel();
        calculateAndDisplayCandleCount();
        sortAndRenderLogbook();
        setupReplayEventListeners();

        startGenesisBtn.addEventListener('click', async () => {
            const syncSuccess = await syncDataLake();

            if (syncSuccess) {
                evolutionState.populationSize = parseInt(document.getElementById('population-size').value) || 50;
                evolutionState.maxGenerations = parseInt(document.getElementById('generation-count').value) || 200;
                evolutionState.mutationRate = parseFloat(document.getElementById('mutation-rate').value) / 100 || 0.05;

                startEvolution();
            } else {
                console.error("Sinkronisasi gagal, proses evolusi dibatalkan.");
            }
        });

        stopGenesisBtn.addEventListener('click', () => {
            evolutionState.isRunning = false;
            alert("Proses evolusi dihentikan.");
        });

        runMonteCarloBtn.addEventListener('click', () => {
            let tradesForSim = null;
            let equityCurveForSim = null;
            let initialBalanceForSim = 1000; 

            if (evolutionState.champion && evolutionState.champion.metrics.allMultiAssetTrades && evolutionState.champion.metrics.allMultiAssetTrades.length >= 2) {
                tradesForSim = evolutionState.champion.metrics.allMultiAssetTrades;
                equityCurveForSim = evolutionState.champion.metrics.allMultiAssetEquity;
                initialBalanceForSim = evolutionState.champion.metrics.initialBalance;
            } 

            else if (backtester.state.lastRunMetrics?.trades && backtester.state.lastRunMetrics.trades.length >= 2) {
                tradesForSim = backtester.state.lastRunMetrics.trades;
                equityCurveForSim = backtester.state.lastRunMetrics.equityCurve;
                initialBalanceForSim = backtester.state.settings.initialBalance;
            }

            if (!tradesForSim) {
                alert("Tidak ada data backtest yang cukup (minimal 2 trade) dari Evolusi atau Backtest Manual untuk simulasi.");
                return;
            }

            toggleMonteCarloModal(true);
            const simBacktester = { state: { settings: { initialBalance: initialBalanceForSim } } };
            runMonteCarloSimulation(simBacktester, tradesForSim, equityCurveForSim);
        });

        monteCarloCloseBtn.addEventListener('click', () => toggleMonteCarloModal(false));
        monteCarloModal.addEventListener('click', (e) => {
            if (e.target === monteCarloModal) {
                toggleMonteCarloModal(false);
            }
        });
        
        exportDnaBtn.addEventListener('click', exportStrategyDNA);

        updateMarketSessions();
        setInterval(updateMarketSessions, 60000);
    }


    document.addEventListener('DOMContentLoaded', main);
</script>
</body>
</html>